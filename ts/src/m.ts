/*!            
    C+edition for Desktop, Community Edition.
    Copyright (C) 2021 Cplusedition Limited.  All rights reserved.
    
    The author licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
import { IpcRenderer } from "./common/consts";

/// Core utility classes.

type Int = number;
type IntX = number | null;
type Long = number;
type LongX = number | null;
type Double = number;
type DoubleX = number | null;

type booleanX = boolean | null;
type numberX = number | null;
type numberXX = number | null | undefined;
type stringX = string | null;
type stringXX = string | null | undefined;
type ArrayX<T> = Array<T> | null;
type ArrayXX<T> = Array<T> | null | undefined;
type StringMapX<T> = StringMap<T> | null;
type StringMapXX<T> = StringMap<T> | null | undefined;
type SStringMap = StringMap<string>;
type JSONObject = StringMap<any>;
type JSONObjectX = StringMap<any> | null;
type JSONObjectXX = StringMap<any> | null | undefined;
type JSONArray = Array<any>;
type JSONArrayX = Array<any> | null;
type StringId = string;

type Fun00 = () => void;
type Fun01<R> = () => R;
type Fun10<T> = (arg1: T) => void;
type Fun11<T, R> = (arg1: T) => R;
type Fun20<T1, T2> = (arg1: T1, arg2: T2) => void;
type Fun21<T1, T2, R> = (arg1: T1, arg2: T2) => R;
type Fun30<T1, T2, T3> = (arg1: T1, arg2: T2, arg3: T3) => void;
type Fun31<T1, T2, T3, R> = (arg1: T1, arg2: T2, arg3: T3) => R;
type Fun40<T1, T2, T3, T4> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => void;

type Fun00X = Fun00 | null;
type Fun10X<T> = Fun10<T> | null;
type Fun11X<T, R> = Fun11<T, R> | null;
type Fun20X<T1, T2> = Fun20<T1, T2> | null;
type Fun30X<T1, T2, T3> = Fun30<T1, T2, T3> | null;

type Opt10<T> = (arg?: T) => void;
type BotResultCallback<R, E> = Fun10<IBotResult<R, E>>;
type CopyInfo = [boolean, boolean, Long, Long];
type DeleteInfo = [boolean, Long, Long];
type StrFileInfo = [string, FileInfo];

const FS = "/";

/// A IBotResult object contains either a OK result or a failure.
/// There are two ways to handle the result. Either handle individually:
///     result.onFail_(errorCallback).onOK_(okCallback);
/// Or nesting several calls and handle a failure at the end. The nested call
/// process the OK result and returns another result.
///     result.ifOK_((ok)=>{ ...; return result; }).onFail_(errorCallback).onOK_(okCallback);
export abstract class IBotResult<R, E> {
    abstract isOK_(): boolean;
    abstract isFail_(): boolean;
    /// @return null if failed, otherwise self.
    abstract onFail_(callback: Fun20<E, IBotOKResult<R, E>>): IBotOKResult<R, E> | null;
    abstract onResult_<S>(failcallback: Fun11<E, S>, okcallback: Fun11<R, S>): S;
    /// @return If OK return result of the callback, otherwise self (which is a failure).
    abstract ifOK_<S>(callback: Fun11<R, IBotResult<S, E>>): IBotResult<S, E>;
    abstract ifFail_<S>(callback: Fun11<E, IBotResult<R, S>>): IBotResult<R, S>;
    abstract mapOK_<S>(result: S): IBotResult<S, E>;
    abstract mapFail_<S>(failure: S): IBotResult<R, S>;
}

export abstract class IBotOKResult<R, E> extends IBotResult<R, E> {
    abstract onOK_<S>(callback: Fun11<R, S>): S | null;
    abstract result_(): R;
}

export class BotResult<R, E> implements IBotOKResult<R, E>{
    private constructor(
        private _result: R | null,
        private _failure: E | null,
    ) { }

    static ok_<R, E>(result: R): IBotResult<R, E> {
        return new BotResult<R, E>(result, null);
    }

    static fail_<R, E>(error: E): IBotResult<R, E> {
        if (error === null || error === undefined) throw new Error("Failure value must not be null or undefined");
        return new BotResult<R, E>(null, error);
    }

    static failKey_<R>(stringid: string): IBotResult<R, string> {
        return this.fail_(MSG.string_(stringid));
    }

    static failKey1_<R>(stringid: string, arg: string): IBotResult<R, string> {
        return this.fail_(MSG.string1_(stringid, arg));
    }

    static failKey2_<R>(stringid: string, arg1: string, arg2: string): IBotResult<R, string> {
        return this.fail_(MSG.string2_(stringid, arg1, arg2));
    }

    static failArrayKey_<R>(stringid: string, ...args: string[]): IBotResult<R, string[]> {
        return this.fail_([MSG.string_(stringid), ...args]);
    }

    isOK_(): boolean {
        return this._failure === null;
    }

    isFail_(): boolean {
        return this._failure !== null;
    }

    /// Replace OK result with the given result, ie. convert IBotResult<R, E> to IBotResult<S, E>.
    mapOK_<S>(result: S): IBotResult<S, E> {
        return (this._failure !== null) ? BotResult.fail_(this.failure_()) : BotResult.ok_(result);
    }

    /// Replace fail result with the given failure, ie. convert IBotResult<R, E> to IBotResult<R, S>.
    mapFail_<S>(failure: S): IBotResult<R, S> {
        return (this._failure = null) ? BotResult.ok_(this.result_()) : BotResult.fail_(failure);
    }

    fail_<S>(): IBotResult<S, E> {
        return BotResult.fail_(this.failure_());
    }

    ok_<S>(): IBotResult<R, S> {
        return BotResult.ok_(this.result_());
    }

    failure_(): E {
        return this._failure!!;
    }

    /// If result is OK, call the callback otherwise return the fail result.
    ifOK_<S>(callback: Fun11<R, IBotResult<S, E>>): IBotResult<S, E> {
        return (this._failure === null) ? callback(this.result_()) : this.fail_();
    }

    /// If result is fail, call the callback otherwise return the ok result.
    ifFail_<S>(callback: Fun11<E, IBotResult<R, S>>): IBotResult<R, S> {
        return (this._failure !== null) ? callback(this.failure_()) : this.ok_();
    }

    onFail_(callback: Fun20<E, IBotOKResult<R, E>>): IBotOKResult<R, E> | null {
        if (callback != null && this._failure !== null) {
            callback(this.failure_(), this);
            return null;
        }
        return this;
    }

    onOK_<S>(callback: Fun11<R, S>): S | null {
        return (this._failure === null) ? callback(this.result_()) : null;
    }

    onResult_<S>(failcallback: Fun11<E, S>, okcallback: Fun11<R, S>): S {
        if (this._result != null) return okcallback(this._result);
        return failcallback(this._failure!);
    }

    result_(): R {
        return this._result as R;
    }
}

class Ut {

    /// @return true If any of the args is NaN.
    static nan_(...args: number[]): boolean {
        return args.some((value) => Number.isNaN(value));
    }

    /// @return value if it is not NaN, otherwise def.
    static num_(value: number, def: number): number {
        return (Number.isNaN(value) ? def : value);
    }

    /// Basically Number.parseInt() but optionally return def instead of NaN.
    /// Note that radix comes after def.
    static parseInt_(value: string | null | undefined, def: number = NaN, radix: number = 10): number {
        if (value === null || value === undefined) return def;
        const ret = parseInt(value, radix);
        return Number.isNaN(ret) ? def : ret;
    }

    /// Call callback if result is an integer and not NaN.
    static parseInt2_(value: string | null | undefined, callback: Fun10<number>, radix: number = 10) {
        if (value === null || value === undefined) return;
        const ret = parseInt(value, radix);
        if (!Number.isNaN(ret)) callback(ret);
    }

    /// Basically Number.parseFloat() but return def instead of NaN.
    static parseDouble_(value: string | null | undefined, def: number = NaN): number {
        if (value === null || value === undefined) return def;
        try {
            const ret = parseFloat(value);
            return Number.isNaN(ret) ? def : ret;
        } catch (e) {
            return def;
        }
    }

    static parseDoublePx_(value: string | null | undefined, def: number = NaN): number {
        if (value == null || value === undefined || value.lastIndexOf("px") != value.length - 2) {
            return def;
        }
        return Ut.parseDouble_(value.substring(0, value.length - 2), def);
    }

    static padStart_(s: string, len: number, padchar = " "): string {
        if (padchar.length == 0) return s;
        while (s.length < len) {
            s = padchar + s;
        }
        return s;
    }

    static timeString_(ms: number, width: number = 6): string {
        if (ms >= 100 * 1000) {
            return Ut.padStart_(`${(ms / 1000).toFixed(0)}s`, width);
        } else if (ms >= 1000) {
            return Ut.padStart_(`${(ms / 1000).toFixed(2)}s`, width);
        }
        return Ut.padStart_(`${ms.toFixed(0)}ms`, width);
    }

    /// Polyfill for ES5.
    static spliceString_(s: string, start: number, length: number): string {
        if (length == 0) return s;
        if (start == 0 && length == s.length) return "";
        const prefix = (start == 0 ? "" : s.slice(0, start));
        const suffix = (start + length >= s.length ? "" : s.slice(start + length));
        return prefix.length == 0 ? suffix : suffix.length == 0 ? prefix : prefix + suffix;
    }

    static isEmpty_(s: string | null | undefined): boolean {
        return s === null || s === undefined || s.length == 0;
    }

    static isNotEmpty_(s: string | null | undefined): boolean {
        return !this.isEmpty_(s);
    }

    /// Polyfill for ES5.
    static repeatString_(s: string, count: number): string {
        let ret = "";
        while (--count >= 0) ret += s;
        return ret;
    }

    /// @return The UTF-16 char codes of the given string, undefined for invalid charcode.
    static charcodes_(s: string): Array<number | undefined> {
        const len = s.length;
        let ret = Array<number | undefined>();
        for (let index = 0; index < len; ++index) {
            const c = s.charCodeAt(index);
            ret.push((isNaN(c) ? undefined : c));
        }
        return ret;
    }

    /// @return The UTF-16 char codes of the given string.
    /// @throws Error on invalid charcode.
    static charcodesOrFail_(s: string): Array<number> {
        let ret = Array<number>();
        this.charcodesOf_(s, (c, index) => {
            if (c === undefined) throw new Error(`${s}@${index}`);
            ret.push(c);
        });
        return ret;
    }

    /// @callback(charcode, index, s) The UTF-16 char codes for the given string,
    /// undefined for invalid char code, the index and the given string itself.
    static charcodesOf_(s: string, callback: Fun30<number | undefined, number, string>) {
        let len = s.length;
        for (let index = 0; index < len; ++index) {
            const c = s.charCodeAt(index);
            callback((isNaN(c) ? undefined : c), index, s);
        }
    }

    static isHighSurrogate_(charcode: number): boolean {
        return (0xD800 <= charcode && charcode <= 0xDBFF);
    }

    static isLowSurrogate_(charcode: number): boolean {
        return (0xDC00 <= charcode && charcode <= 0xDFFF);
    }

    static isSurrogatePair_(s: string, index: Int): boolean {
        return index + 1 < s.length
            && this.isHighSurrogate_(s.charCodeAt(index))
            && this.isLowSurrogate_(s.charCodeAt(index + 1));
    }

    /// @return The Unicode 21 bits code points for the given string, undefined for invalid codepoint.
    static codepoints_(s: string): Array<number | undefined> {
        let ret = Array<number | undefined>();
        for (let index = 0, len = s.length; index < len; ++index) {
            ret.push(s.codePointAt(index));
            if (this.isSurrogatePair_(s, index)) ++index;
        }
        return ret;
    }

    /// @return The Unicode 21 bits code points of the given string.
    /// @throws Error on invalid code point.
    static codepointsOrFail_(s: string): Array<number> {
        let ret = Array<number>();
        this.codepointsOf_(s, (c, index) => {
            if (c === undefined) throw new Error(`${s}@${index}`);
            ret.push(c);
        });
        return ret;
    }

    /// @callback(codepoint, index, s) The Unicode 21 bits code points for the given string,
    /// undefined for invalid codepoint, the index and the input string itself.
    static codepointsOf_(s: string, callback: Fun30<number | undefined, number, string>) {
        let len = s.length;
        for (let index = 0; index < len; ++index) {
            callback(s.codePointAt(index), index, s);
            if (this.isSurrogatePair_(s, index)) ++index;
        }
    }

    /// @callback(string, index, string) Call callback on each char of the given string,
    static chars_(s: string): string[] {
        let len = s.length;
        const ret: string[] = [];
        for (let index = 0; index < len; ++index) {
            ret.push(s.charAt(index));
        }
        return ret;
    }

    /// @callback(string, index, string) Call callback on each char of the given string,
    static charsOf_(s: string, callback: Fun30<string, number, string>) {
        let len = s.length;
        for (let index = 0; index < len; ++index) {
            callback(s.charAt(index), index, s);
        }
    }

    /// Create a shadow copy of given Map as an object.
    static mapToObject_<V>(map: Map<string, V>): object {
        let ret: { [key: string]: V; } = {};
        for (let [k, v] of map) {
            ret[k] = v;
        }
        return ret;
    }

    /// Create a shadow copy of properties of given object to a Map.
    static objectToMap_<V>(obj: object): Map<string, V> {
        let ret = new Map<string, V>();
        for (let k of Object.keys(obj)) {
            ret.set(k, Object.getOwnPropertyDescriptor(obj, k)?.value);
        }
        return ret;
    }

    /// @returns whether the provided parameter is of type object but not
    ///	null, an array, a regexp, nor a date.
    static isObject_(o: any): o is Object {
        return typeof o === "object"
            && o !== null
            && !Array.isArray(o)
            && !(o instanceof RegExp)
            && !(o instanceof Date);
    }

    static asyncIterate_<T>(array: T[], callback: Fun30<T, Int, Opt10<boolean>>, done: Fun10X<Int> = null): void {
        this._asyncIterate(array, 0, callback, done);
    }

    static _asyncIterate<T>(array: T[], index: Int, callback: Fun30<T, Int, Opt10<boolean>>, done: Fun10X<Int> = null): void {
        callback(array[index], index, (terminate?: boolean) => {
            ++index;
            if (terminate === true || index >= array.length) {
                done?.(index);
                return;
            };
            this._asyncIterate(array, index, callback, done);
        });
    }
}

class TextUt {
    static readonly lineSep$ = "\n";

    static splitAt_(value: string, start: Int, end: Int = start): [string, string] {
        if (start < 0) return [value, ""];
        return [value.substring(0, start), value.substring(end)];
    }
}

function map_<K, V>(...args: [K, V][]): Map<K, V> {
    return new Map<K, V>(args);
}

function mapFromStringMap_<V>(from: StringMap<V>): Map<string, V> {
    return new Map<string, V>(Object.entries(from));
}

function map1_<K, V>(key: K, value: V): Map<K, V> {
    return new Map<K, V>().set(key, value);
}

function smap_<V>(...args: [string, V][]): StringMap<V> {
    return StringMap.from_(...args);
}

function smap1_<V>(key: string, value: V): StringMap<V> {
    return StringMap.from1_(key, value);
}

function ssmap_(...args: [string, string][]): StringMap<string> {
    return StringMap.from_(...args);
}

function ssmap1_(key: string, value: string): StringMap<string> {
    return StringMap.from1_(key, value);
}

function sarray_(): string[] {
    return new Array<string>();
}

function jsonOf_(key: string, value: any): JSONObject {
    return StringMap.of_(key, value);
}

function json_(...args: [string, any][]): JSONObject {
    return StringMap.from_(...args);
}

function json1_(key: string, value: any): JSONObject {
    return StringMap.from1_(key, value);
}

function stringify_(...args: [string, any][]): string {
    return JSON.stringify(StringMap.from_(...args));
}

function stringify1_(key: string, value: any): string {
    return JSON.stringify(StringMap.from1_(key, value));
}

function replaceAll_(haystack: string, needle: string, replacement: string): string {
    return haystack.split(needle).join(replacement);
}

function let_<T, R>(value: T, callback: Fun11<T, R>): R {
    return callback(value);
}

class StringMap<V> {
    static of_<V>(key: string, value: V): StringMap<V> {
        let ret = new StringMap<V>();
        ret[key] = value;
        return ret;
    }
    static from1_<V>(key: string, value: V): StringMap<V> {
        let ret = new StringMap<V>();
        ret[key] = value;
        return ret;
    }
    static from_<V>(...args: [string, V][]): StringMap<V> {
        let ret = new StringMap<V>();
        for (let arg of args) {
            ret[arg[0]] = arg[1];
        }
        return ret;
    }
    /// Shadow copy of given StringMap.
    static copyOf_<V>(src: StringMap<V>): StringMap<V> {
        return this.from_(...Object.entries(src));
    }
    static invertStringMap_(src: StringMap<string>): StringMap<string> {
        return this.from_(...(Object.entries(src).map<[string, string]>((e) => [e[1], e[0]])));
    }
    static putAll_<V>(src: StringMap<V>, ...pairs: [string, V][]): StringMap<V> {
        for (const pair of pairs) {
            src[pair[0]] = pair[1];
        }
        return src;
    }
    static filter_<V>(src: StringMap<V>, predicate: Fun11<[string, V], boolean>): StringMap<V> {
        return this.from_(...(Object.entries(src).filter(predicate)));
    }
    static d_<V>(map: StringMap<V>): string {
        return "{ " + Object.entries(map).map(([k, v]) => `${k}: ${v}`).join(", ") + " }";
    }
    [key: string]: V;
}

class With {
    static exceptionOrNull_(code: Fun00): any | null {
        try {
            code();
            return null;
        } catch (e: any) {
            return e;
        }
    }

    static exceptionOrFail_(code: Fun00) {
        try {
            code();
        } catch (e: any) {
            return;
        }
        throw new Error();
    }

    static range_(start: number, end: number, code: Fun10<number>) {
        for (let index = start; index < end!; ++index) {
            code(index);
        }
    }

    static lines_(input: string, code: Fun11<string, string | null>): string[] {
        let ret: string[] = [];
        input.split(TextUt.lineSep$).map((line) => {
            let output = code(line);
            if (output != null) {
                ret.push(output);
            }
        });
        return ret;
    }

    static map_<T, R>(value: T, code: Fun11<T, R>): R {
        return code(value);
    }

    static optionalOrFalse_<T>(value: T | null | undefined, code: Fun10<T>): boolean {
        if (value === null || value === undefined) return false;
        code(value);
        return true;
    }

    static optional_<T>(value: T | null | undefined, code: Fun10<T>): T | null {
        if (value === null || value === undefined) return null;
        code(value);
        return value;
    }

    static optional0_<T>(value: T | null | undefined, code: Fun10<T>): T | null {
        if (value === null || value === undefined) return null;
        setTimeout(() => code(value), 0);
        return value;
    }

    static null_<T>(value: T | null | undefined, code: Fun01<T>): T {
        return (value === null || value === undefined) ? code() : value;
    }

    static notnull_<T, R>(value: T | null | undefined, code: Fun11<T, R>): R | null {
        if (value === null || value === undefined) return null;
        return code(value);
    }

    static notnullOrFail_<T, R>(value: T | null | undefined, code: Fun11<T, R>): R {
        if (value === null || value === undefined) throw new Error();
        return code(value);
    }

    static attribute_<T>(target: HTMLElement, name: string, value: string, callback: Fun01<T>): T {
        const ovalue = target.getAttribute(name);
        target.setAttribute(name, value);
        try {
            return callback();
        } finally {
            if (ovalue == null) target.removeAttribute(name);
            else target.setAttribute(name, ovalue);
        }
    }
}

class ArrayUt {
    static first_<T>(array: T[] | Iterator<T> | null | undefined): T | undefined {
        if (array == null) {
            return undefined;
        } else if (array instanceof Array) {
            let len = array.length;
            return len == 0 ? undefined : array[0];
        } else {
            let ret = array.next();
            if (ret.done === true) return undefined;
            return ret.value;
        }
    }

    static last_<T>(array: T[] | Iterator<T> | null | undefined): T | undefined {
        if (array === null || array === undefined) {
            return undefined;
        } else if (array instanceof Array) {
            let len = array.length;
            return (len == 0) ? undefined : array[len - 1];
        } else {
            let ret = undefined;
            while (true) {
                let result = array.next();
                if (result.done !== true) {
                    ret = result.value;
                    continue;
                }
                return ret;
            }
        }
    }

    static delete_<T>(array: T[], value: T): boolean {
        let index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }

    static insert_<T>(array: T[], index: number, value: T): T[] {
        array.splice(index, 0, value);
        return array;
    }

    static addAll_<T>(to: T[], ...from: T[]): T[] {
        for (const e of from) {
            to.push(e);
        }
        return to;
    }

    static any_<T>(array: T[], predicate: Fun11<T, boolean>): boolean {
        for (const elm of array) {
            if (predicate(elm)) return true;
        }
        return false;
    }

    static unique_<T>(array: T[]): T[] {
        return Array.from(new Set<T>(array).values());
    }

    /// Polyfill of findIndex() for ES5.
    /// @return The index in array that the predicate returns true, otherwise -1.
    static findIndex_<T>(array: T[], predicate: Fun11<T, boolean>): number {
        let index = 0;
        for (const value of array) {
            if (predicate(value)) return index;
            ++index;
        }
        return -1;
    }

    /// Polyfill of Array.fill() for ES5.
    /// @return The index in array that the predicate returns true, otherwise -1.
    static fill_<T>(array: T[], value: T): T[] {
        for (let index = 0, len = array.length; index < len; ++index) {
            array[index] = value;
        }
        return array;
    }

    static strictEqual_<T>(arr1: T[], arr2: T[]): boolean {
        const len = arr1.length;
        if (arr2.length !== len) return false;
        return arr1.every((value, index) => {
            return arr2[index] === value;
        });
    }

    static equal_<T>(arr1: T[], arr2: T[]): boolean {
        const len = arr1.length;
        if (arr2.length !== len) return false;
        return arr1.every((value, index) => {
            return arr2[index] == value;
        });
    }
}

class Stack<T> {
    private x_array: T[] = [];
    length_(): Int {
        return this.x_array.length;
    }
    clear_(): this {
        this.x_array.length = 0;
        return this;
    }
    push_(...a: T[]): this {
        this.x_array.push(...a);
        return this;
    }
    pop_(): T | undefined {
        return this.x_array.pop();
    }
    peek_(): T | undefined {
        const len = this.x_array.length;
        return len > 0 ? this.x_array[len - 1] : undefined;
    }
}

/// Utilities that works in browser.

type NodeX = Node | null;
type HTMLElementX = HTMLElement | null;
type RangeX = Range | null;

abstract class DomUt {

    static stopEvent_(event: Event) {
        try {
            event.stopPropagation();
            event.preventDefault();
        } catch (e: any) {
            /// Ignore errors.
        }
    }

    static queryAll_<E extends HTMLElement = HTMLElement>(elm: ParentNode | null, selector: string): E[] {
        return elm ? Array.from(elm.querySelectorAll<E>(selector)) : [];
    }

    static query_<E extends HTMLElement = HTMLElement>(elm: ParentNode, selector: string): E | null {
        return elm.querySelector<E>(selector);
    }

    static asHTMLDocument_(doc: any): HTMLDocument | null {
        return doc !== null
            && doc !== undefined
            && (doc instanceof HTMLDocument || Object.prototype.toString.call(doc) == "[object HTMLDocument]")
            ? doc as HTMLDocument
            : null;
    }

    private static _ELMPAT = new RegExp("^\\[object HTML\\w*Element\\]\$");

    static asHTMLElement_(elm: any): HTMLElementX {
        return elm !== null
            && elm !== undefined
            && (elm instanceof HTMLElement || this._ELMPAT.test(Object.prototype.toString.call(elm)))
            ? elm as HTMLElement
            : null;
    }

    static matchingTarget_(event: Event, selector: string): HTMLElementX {
        if (selector == null) return null;
        let target = this.asHTMLElement_(event.target);
        let currentTarget = this.asHTMLElement_(event.currentTarget);
        if (target != null && currentTarget != null) {
            const top = currentTarget.parentElement;
            do {
                if (target != null && target.matches(selector)) return target;
                target = target.parentElement;
            } while (target != null && target != top);
        }
        return null;
    }
}

interface IndexedItems<V> {
    readonly length: number;
    item(index: number): V | null;
}

class NullableItemsIterable<V> implements IterableIterator<V | null> {
    private index$ = 0;
    private length$: number;
    constructor(private items$: IndexedItems<V>) {
        this.length$ = items$.length;
    }
    [Symbol.iterator](): IterableIterator<V | null> {
        return this;
    }
    next(): IteratorResult<V | null> {
        if (this.index$ < this.length$) {
            return {
                value: this.items$.item(this.index$++),
                done: false,
            };
        } else {
            return {
                value: undefined,
                done: true,
            };
        }
    }
}

class ItemsIterable<V> implements IterableIterator<V> {
    private index$ = 0;
    private length$: number;
    constructor(private items$: IndexedItems<V | null>) {
        this.length$ = items$.length;
    }
    [Symbol.iterator](): IterableIterator<V> {
        return this;
    }
    next(): IteratorResult<V> {
        while (this.index$ < this.length$) {
            let item = this.items$.item(this.index$);
            ++this.index$;
            if (item == null) continue;
            return {
                value: item,
                done: false,
            };
        }
        return {
            value: undefined,
            done: true,
        };
    }
}

abstract class JSONUt {
    static stringArray(json: JSONObject, key: string): ArrayX<string> {
        const value = json[key];
        if (!(value instanceof Array)) return null;
        return value.filter((v) => { typeof (v) === "string"; });
    }
    static string<T>(json: JSONObject, key: string, def: T): string | T {
        const value = json[key];
        if (value != null && typeof (value) === "string") return value;
        return def;
    }
}

////////////////////////////////////////////////////////////////////////

type _DomAttrs = [key: string, value: string] | StringMap<stringX>;

class DomBuilder {
    private static attr1_(elm: HTMLElement, key: string, value: stringX): HTMLElement {
        if (value == null) {
            elm.removeAttribute(key);
        } else {
            elm.setAttribute(key, value);
        }
        return elm;
    }
    private static attrs1_(elm: HTMLElement, attrs: StringMap<stringX> | null = null): HTMLElement {
        if (attrs != null) {
            for (const [k, v] of Object.entries(attrs)) {
                this.attr1_(elm, k, v);
            }
        }
        return elm;
    }

    /// Create a text node.
    static createText_(content: string): Text {
        return new Text(content);
    }

    static offline1_(doc: Document, tag: string, ...classes: string[]) {
        return new DomBuilder(doc.createElement(tag)).addClasses_(classes);
    }

    /// Create a DOM root that is not attached to a parent.
    static offline_(doc: Document, tag: string, attrs: StringMap<stringX> | null = null): DomBuilder {
        return new DomBuilder(doc.createElement(tag), attrs);
    }

    #stack = new Stack<HTMLElement>();
    #cursor: HTMLElement;

    /// Use the given element as root of the tree.
    constructor(cursor: HTMLElement, attrs: StringMap<stringX> | null = null) {
        this.#cursor = DomBuilder.attrs1_(cursor, attrs);
    }

    /// This is basically a noop. However, it is useful for grouping statements in
    /// the same level and visualize nesting levels in typescript code. Typically,
    /// a group contains a matching push() and pop().
    /// Example: b.ul_().indent_(
    ///     b.push_().li_()...,
    ///     b.peek_().li_()...,
    ///     b.pop_().li_()...,
    /// )
    indent_(..._dontcare: any[]): this {
        return this;
    }

    /// Add attributes to the cursor element.
    attr_(key: string, value: string): this {
        DomBuilder.attr1_(this.#cursor, key, value);
        return this;
    }

    attrs_(keyvalues: StringMap<stringX>): this {
        DomBuilder.attrs1_(this.#cursor, keyvalues);
        return this;
    }

    attrx_(attrs: _DomAttrs[]): this {
        for (const attr of attrs) {
            if (attr instanceof Array) {
                this.attr_(attr[0], attr[1]);
            } else {
                this.attrs_(attr);
            }
        }
        return this;
    }

    addClass_(c: string): this {
        if (c.length > 0) this.#cursor.classList.add(c);
        return this;
    }

    addClasses_(c: string[]): this {
        for (const cc of c) { if (cc.length > 0) this.#cursor.classList.add(cc); }
        return this;
    }

    addStyle_(key: string, value: string): this {
        const style = (this.#cursor as HTMLElement).style;
        style.setProperty(key, value);
        return this;
    }

    addStyles_(...styles: _DomAttrs[]): this {
        const style = (this.#cursor as HTMLElement).style;
        for (const e of styles) {
            if (e instanceof Array && e.length == 2) {
                style.setProperty(e[0], e[1]);
            } else {
                for (const [key, value] of Object.entries(e)) {
                    style.setProperty(key, value);
                }
            }
        }
        return this;
    }

    append_(child: string | HTMLElement, attrs: StringMap<stringX> | null = null): this {
        this.#cursor.appendChild(typeof (child) === "string"
            ? this.createElement_(child, attrs)
            : DomBuilder.attrs1_(child, attrs));
        return this;
    }

    appendNodes_(...child: Node[]): this {
        for (const n of child) {
            this, this.#cursor.appendChild(n);
        }
        return this;
    }

    append1_(child: string | HTMLElement, ...classes: string[]): this {
        return this.append_(child, smap1_("class", classes.join(" ")));
    }

    append2_(child: string | HTMLElement, name: string, value: string): this {
        return this.append_(child, smap1_(name, value));
    }

    /// Insert node/nodes before the next node as children to the cursor element.
    /// Overloads:
    ///     (Node node, String tag, [attrs])
    ///     (Node node, HTMLElement  newchild, [attrs])
    ///     (Node node, Array<Node> newchildren)
    ///     (Node node, Node newchild)
    insertBefore_(next: Node | null, child: string | HTMLElement | Array<Node> | Node, attrs: StringMapX<stringX> = null): this {
        if (child instanceof Array) {
            for (const n of child) {
                this.#cursor.insertBefore(n, next);
            }
        } else {
            this.#cursor.insertBefore(
                typeof (child) === "string"
                    ? this.createElement_(child, attrs)
                    : (child.nodeType == Node.ELEMENT_NODE)
                        ? DomBuilder.attrs1_(child as HTMLElement, attrs)
                        : child,
                next);
        }
        return this;
    }

    prepend_(child: string | HTMLElement, attrs: SStringMap | null = null): this {
        return this.insertBefore_(this.#cursor.firstChild, child, attrs);
    }

    prependNodes_(...child: Node[]): this {
        const next = this.#cursor.firstChild;
        for (const n of child) {
            this.insertBefore_(next, n);
        }
        return this;
    }

    prepend1_(child: string | HTMLElement, ...classes: string[]): this {
        return this.prepend_(child, smap1_("class", classes.join(" ")));
    }

    prepend2_(child: string | HTMLElement, name: string, value: string): this {
        return this.prepend_(child, smap1_(name, value));
    }

    /// Append a child and use it as cursor.
    /// Overloads:
    /// (String, [SStringMap attrs])
    /// (HTMLElement)
    child_(child: string | HTMLElement, attrs: StringMap<stringX> | null = null): this {
        this.#cursor = this.#cursor.appendChild((typeof (child) === "string")
            ? this.createElement_(child, attrs)
            : DomBuilder.attrs1_(child, attrs));
        return this;
    }

    /// Append a child and use it as cursor.
    child1_(child: string | HTMLElement, ...classes: string[]): this {
        return this.child_(child).addClasses_(classes);
    }

    /// Append a child and use it as cursor.
    child2_(child: string | HTMLElement, name: string, value: string): this {
        return this.child_(child).attr_(name, value);
    }

    /// Create and insert node as child of the cursor before the given next node.
    /// Overloads:
    /// (Node next, String tag, [SStringMap attrs])
    /// (Node next, HTMLElement child)
    childBefore_(next: Node | null, child: string | HTMLElement, attrs: StringMap<stringX> | null = null): this {
        this.#cursor = this.#cursor.insertBefore((typeof (child) === "string"
            ? this.createElement_(child, attrs)
            : DomBuilder.attrs1_(child, attrs)),
            next);
        return this;
    }

    childBefore1_(next: Node | null, tag: string | HTMLElement, ...classes: string[]): this {
        return this.childBefore_(next, tag).addClasses_(classes);
    }

    childBefore2_(next: Node | null, tag: string | HTMLElement, name: string, value: string): this {
        return this.childBefore_(next, tag).attr_(name, value);
    }

    childBeforeFirst_(child: string | HTMLElement, attrs: SStringMap | null = null): this {
        return this.childBefore_(this.#cursor.firstChild, child, attrs);
    }

    childBeforeFirst1_(tag: string | HTMLElement, ...classes: string[]): this {
        return this.childBefore_(this.#cursor.firstChild, tag).addClasses_(classes);
    }

    childBeforeFirst2_(tag: string | HTMLElement, name: string, value: string): this {
        return this.childBefore_(this.#cursor.firstChild, tag).attr_(name, value);
    }

    /// Insert a sibling before the cursor and use it as new cursor.
    /// Overloads:
    /// (String tag, [SStringMap attrs])
    /// (HTMLElement elm)
    siblingBefore_(child: string | HTMLElement, attrs: StringMap<stringX> | null = null): this {
        this.#cursor = this.#cursor.parentNode!.insertBefore((typeof (child) === "string"
            ? this.createElement_(child, attrs)
            : DomBuilder.attrs1_(child, attrs)),
            this.#cursor);
        return this;
    }

    /// Insert a sibling after the cursor and use it as new cursor.
    /// Overloads:
    /// (String tag, [SStringMap attrs])
    /// (HTMLElement elm)
    siblingAfter_(child: string | HTMLElement, attrs: StringMap<stringX> | null = null): this {
        this.#cursor = this.#cursor.parentNode!.insertBefore((typeof (child) === "string"
            ? this.createElement_(child, attrs)
            : DomBuilder.attrs1_(child, attrs)),
            this.#cursor.nextSibling);
        return this;
    }

    /// Append text as child to cursor.
    text_(text: string): this {
        this.#cursor.appendChild(DomBuilder.createText_(text));
        return this;
    }

    /// Append text as child to cursor.
    textBefore_(next: NodeX, text: string): this {
        this.#cursor.insertBefore(DomBuilder.createText_(text), next);
        return this;
    }

    /// Create a text node and insert as a sibling after the cursor.
    textSiblingAfter_(text: string): Text {
        const textnode = DomBuilder.createText_(text);
        this.#cursor.parentNode!.insertBefore(textnode, this.#cursor.nextSibling);
        return textnode;
    }

    /// Remove the given child from the current cursor element.
    removeChild_(child: Node): this {
        child.parentNode?.removeChild(child);
        return this;
    }

    removeChildren_(children: Node[]): this {
        for (const c of children) {
            c.parentNode?.removeChild(c);
        }
        return this;
    }

    /// Replace the given child with the given bynode from the current cursor element.
    replaceChild_(child: Node, bynode: Node): this {
        this.#cursor.insertBefore(bynode, child);
        child.parentNode?.removeChild(child);
        return this;
    }

    /// Remove children start up to but not including end of the given element
    /// and append as children of cursor.
    moveChildren_(start: NodeX, end: NodeX): this {
        let c: Node | null = start;
        while (c != null && c != end) {
            const n: Node | null = c.nextSibling;
            c.parentNode?.removeChild(c);
            this.#cursor.append(c);
            c = n;
        }
        return this;
    }

    /// Append children of the given element and insert as children of
    /// cursor before the given next node.
    moveChildrenBefore_(next: Node, start: NodeX, end: NodeX): this {
        let c: Node | null = start;
        while (c != null && c != end) {
            const n: Node | null = c.nextSibling;
            c.parentNode?.removeChild(c);
            this.#cursor.insertBefore(c, next);
            c = n;
        }
        return this;
    }

    /// Wrap the cursor with the given tag and use the wrapper as cursor.
    wrap_(tag: string | HTMLElement, attrs: StringMap<stringX>): this {
        const target = this.cursor_();
        this.up_().childBefore_(target, tag, attrs).push_().up_().removeChild_(target).pop_().appendNodes_(target);
        return this;
    }

    /// Move children of given child to as sibling before child and remove child.
    unwrap_(child: Node): this {
        this.moveChildrenBefore_(child, child.firstChild, null);
        child.parentNode?.removeChild(child);
        return this;
    }

    /// Remove all children of the cursor.
    empty_(): this {
        for (let c = this.#cursor.firstChild; c != null;) {
            const n = c.nextSibling;
            c.remove();
            c = n;
        }
        return this;
    }

    /// Push cursor onto stack.
    push_(): this {
        this.#stack.push_(this.#cursor);
        return this;
    }

    /// Pop the element from the cursor stack and use it as the cursor element.
    pop_(n: number = 1): this {
        while (--n >= 0) {
            const e = this.#stack.pop_();
            if (e === undefined) throw new Error();
            this.#cursor = e;
        }
        return this;
    }

    /// Restore but do not remove the cursor element from top of the cursor stack.
    peek_(): this {
        this.#cursor = this.#stack.peek_()!;
        return this;
    }

    /// Swap cursor with top of stack.
    swap_(): this {
        const cursor = this.#stack.pop_()!;
        this.#stack.push_(this.#cursor);
        this.#cursor = cursor;
        return this;
    }

    /// Use parent element of the cursor element.
    /// If it is null, throw an Error.
    up_(): this {
        const parent = this.#cursor.parentElement;
        if (parent == null) { throw new Error(); }
        this.#cursor = parent;
        return this;
    }

    /// Use the next sibling element of the cursor element.
    /// If it is null, throw an Error.
    right_(): this {
        const sibling = this.#cursor.nextElementSibling;
        if (sibling == null) { throw new Error(); }
        this.#cursor = sibling as HTMLElement;
        return this;
    }

    /// Use the previous sibling element of the cursor element.
    /// If it is null, throw an Error.
    left_(): this {
        const sibling = this.#cursor.previousElementSibling;
        if (sibling == null) { throw new Error(); }
        this.#cursor = sibling as HTMLElement;
        return this;
    }

    /// Use the first child element of the cursor element.
    /// If it is null, throw an Error.
    first_(): this {
        const child = this.#cursor.firstElementChild;
        if (child == null) { throw new Error(); }
        this.#cursor = child as HTMLElement;
        return this;
    }

    setCursor_(elm: HTMLElement): this {
        this.#cursor = elm;
        return this;
    }

    cursor_(): HTMLElement {
        return this.#cursor;
    }

    classList_(): DOMTokenList {
        return this.#cursor.classList;
    }

    /// @return The document of the cursor.
    doc_(): Document {
        return this.#cursor.ownerDocument;
    }

    /// Create a selection in the document.defaultView.
    /// Overloads:
    ///     () Select the cursor element.
    ///     (Node child) Select the given child node of the cursor.
    ///     (Node start, Node end) Select child start inclusive to child end exclusive of the cursor.
    /// If end is null, select from start to last child of the cursor.
    select_(start: Node | null = null, end: Node | null = null): this {
        const selection = this.doc_().defaultView?.getSelection();
        if (selection != null) {
            selection.removeAllRanges();
            selection.addRange(this.rangeOf_(start, end));
        }
        return this;
    }

    selectTextRange_(text: Node, start: number, end: number): this {
        const selection = this.doc_().defaultView?.getSelection();
        if (selection != null) {
            const range = this.createRange_();
            range.setStart(text, start);
            range.setEnd(text, end);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return this;
    }

    /// ScrollTo the given x, y document coordinate in the document.defaultView
    scrollTo_(x: number, y: number): this {
        this.doc_().defaultView?.scrollTo(x, y);
        return this;
    }

    /// Execute the given function as fn(cursor()) and return this builder.
    exec_(fn: Fun10<HTMLElement>): this {
        fn(this.#cursor);
        return this;
    }

    /// Execute the given function on each child of the cursor, break if fn() return false.
    children_(fn: Fun21<Node, HTMLElement, boolean>): this {
        for (let c = this.#cursor.firstChild; c != null; c = c.nextSibling) {
            if (!fn(c, this.#cursor)) break;
        }
        return this;
    }

    /// Execute fn(child, cursor) for the given children of the cursor, break if fn() return false.
    each_(start: Node | null, end: Node | null, fn: Fun21<Node, HTMLElement, boolean>): this {
        for (let c = start; c != null && c != end;) {
            const n = c.nextSibling;
            if (!fn(c, this.#cursor)) break;
            c = n;
        }
        return this;
    }

    /// Create an element with given tag and attributes.
    createElement_(tag: string, attrs: StringMap<stringX> | null = null): HTMLElement {
        return DomBuilder.attrs1_(this.#cursor.ownerDocument.createElement(tag), attrs);
    }

    /// @return Index of the given child node of the cursor.
    indexOf_(child: Node): number {
        let i: number = 0;
        for (let c = this.#cursor.firstChild; c != null; c = c.nextSibling, ++i) {
            if (c === child) { return i; }
        }
        return -1;
    }

    /// @param start A child of cursor. If null select the cursor.
    /// @param end A child of cursor, If null use lastChild.
    /// @return A range that start before start and end after end.
    rangeOf_(start: Node | null, end: Node | null = null): Range {
        const ret: Range = this.createRange_();
        if (start == null) {
            ret.selectNode(this.#cursor);
        } else {
            ret.setStartBefore(start);
            ret.setEndAfter(end ?? this.#cursor.lastChild ?? start);
        }
        return ret;
    }

    /// @return An empty range.
    createRange_(): Range {
        return this.#cursor.ownerDocument.createRange();
    }

    /// Return the current cursor, but pop n element after it.
    cursorPop_(n: number = 1): HTMLElement {
        const ret = this.cursor_();
        this.pop_(n);
        return ret;
    }

    iframe_(...attrs: _DomAttrs[]): this {
        return this.child_("iframe").attrx_(attrs);
    }

    iframe1_(...classes: string[]): this {
        return this.child1_("iframe", ...classes);
    }

    div_(...attrs: _DomAttrs[]): this {
        return this.child_("div").attrx_(attrs);
    }

    div1_(...classes: string[]): this {
        return this.child1_("div", ...classes);
    }

    div2_(name: string, value: string): this {
        return this.child2_("div", name, value);
    }

    span_(...attrs: _DomAttrs[]): this {
        return this.child_("span").attrx_(attrs);
    }

    span1_(...classes: string[]): this {
        return this.child1_("span", ...classes);
    }

    span2_(name: string, value: string): this {
        return this.child2_("span", name, value);
    }

    br_(...attrs: _DomAttrs[]): this {
        return this.child_("br").attrx_(attrs);
    }

    br1_(...classes: string[]): this {
        return this.child1_("br", ...classes);
    }

    br2_(name: string, value: string): this {
        return this.child2_("br", name, value);
    }

    hr_(...attrs: _DomAttrs[]): this {
        return this.child_("hr").attrx_(attrs);
    }

    hr1_(...classes: string[]): this {
        return this.child1_("hr", ...classes);
    }

    hr2_(name: string, value: string): this {
        return this.child2_("hr", name, value);
    }

    ul_(...attrs: _DomAttrs[]): this {
        return this.child_("ul").attrx_(attrs);
    }

    ul1_(...classes: string[]): this {
        return this.child1_("ul", ...classes);
    }

    ul2_(name: string, value: string): this {
        return this.child2_("ul", name, value);
    }

    li_(...attrs: _DomAttrs[]): this {
        return this.child_("li").attrx_(attrs);
    }

    li1_(...classes: string[]): this {
        return this.child1_("li", ...classes);
    }

    li2_(name: string, value: string): this {
        return this.child2_("li", name, value);
    }

    input_(...attrs: _DomAttrs[]): this {
        return this.child_("input").attrx_(attrs);
    }

    input1_(...classes: string[]): this {
        return this.child1_("input", ...classes);
    }

    input2_(name: string, value: string): this {
        return this.child2_("input", name, value);
    }

    option_(...attrs: _DomAttrs[]): this {
        return this.child_("option").attrx_(attrs);
    }

    option1_(...classes: string[]): this {
        return this.child1_("option", ...classes);
    }

    option2_(name: string, value: string): this {
        return this.child2_("option", name, value);
    }

    textarea_(...attrs: _DomAttrs[]): this {
        return this.child_("textarea").attrx_(attrs);
    }

    textarea1_(...classes: string[]): this {
        return this.child1_("textarea", ...classes);
    }

    textarea2_(name: string, value: string): this {
        return this.child2_("textarea", name, value);
    }

    table_(...attrs: _DomAttrs[]): this {
        return this.child_("table").attrx_(attrs);
    }

    table1_(...classes: string[]): this {
        return this.child1_("table", ...classes);
    }

    table2_(name: string, value: string): this {
        return this.child2_("table", name, value);
    }

    tbody_(...attrs: _DomAttrs[]): this {
        return this.child_("tbody").attrx_(attrs);
    }

    tbody1_(...classes: string[]): this {
        return this.child1_("tbody", ...classes);
    }

    tbody2_(name: string, value: string): this {
        return this.child2_("tbody", name, value);
    }

    tr_(...attrs: _DomAttrs[]): this {
        return this.child_("tr").attrx_(attrs);
    }

    tr1_(...classes: string[]): this {
        return this.child1_("tr", ...classes);
    }

    tr2_(name: string, value: string): this {
        return this.child2_("tr", name, value);
    }

    td_(...attrs: _DomAttrs[]): this {
        return this.child_("td").attrx_(attrs);
    }

    td1_(...classes: string[]): this {
        return this.child1_("td", ...classes);
    }

    td2_(name: string, value: string): this {
        return this.child2_("td", name, value);
    }

    th_(...attrs: _DomAttrs[]): this {
        return this.child_("th").attrx_(attrs);
    }

    th1_(...classes: string[]): this {
        return this.child1_("th", ...classes);
    }

    th2_(name: string, value: string): this {
        return this.child2_("th", name, value);
    }

    button_(...attrs: _DomAttrs[]): this {
        return this.child_("button").attrx_(attrs);
    }

    button1_(...classes: string[]): this {
        return this.child1_("button", ...classes);
    }

    button2_(name: string, value: string): this {
        return this.child2_("button", name, value);
    }

    b_(...attrs: _DomAttrs[]): this {
        return this.child_("b").attrx_(attrs);
    }

    b1_(...classes: string[]): this {
        return this.child1_("b", ...classes);
    }

    b2_(name: string, value: string): this {
        return this.child2_("b", name, value);
    }

    code_(...attrs: _DomAttrs[]): this {
        return this.child_("code").attrx_(attrs);
    }

    code1_(...classes: string[]): this {
        return this.child1_("code", ...classes);
    }

    code2_(name: string, value: string): this {
        return this.child2_("code", name, value);
    }

    a_(...attrs: _DomAttrs[]): this {
        return this.child_("a").attrx_(attrs);
    }

    a1_(...classes: string[]): this {
        return this.child1_("a", ...classes);
    }

    a2_(name: string, value: string): this {
        return this.child2_("a", name, value);
    }

    ahref_(href: string | _DomAttrs | null = null, ...attrs: _DomAttrs[]): this {
        if (href != null) {
            if (typeof (href) === "string") {
                attrs.unshift(["href", href]);
            } else {
                attrs.unshift(href);
            }
        }
        return this.child_("a").attrx_(attrs);
    }

    ahref1_(href: stringX, ...classes: string[]): this {
        return this.ahref_(href).addClasses_(classes);
    }

    img_(src: string | _DomAttrs | null = null, ...attrs: _DomAttrs[]): this {
        if (src != null) {
            if (typeof (src) === "string") {
                attrs.unshift(["src", src]);
            } else {
                attrs.unshift(src);
            }
        }
        return this.child_("img").attrx_(attrs);
    }

    img1_(src: stringX, ...classes: string[]): this {
        return this.img_(src).addClasses_(classes);
    }

    img2_(name: string, value: string): this {
        return this.child2_("img", name, value);
    }

    onclick_(callback: Fun10<MouseEvent>): this {
        this.#cursor.addEventListener("click", (e) => { callback(e); });
        return this;
    }
}

class ColorValue {
    private static readonly X_RGBA = new RegExp("rgba?\\(\\s*(.*?)\\s*\\)");
    private static readonly X_COMMA = new RegExp("\\s*,\\s*", "g");
    static readonly X_TRANSPARENT = ColorValue.fromRGBA_(255, 255, 255, 0.0);
    static readonly X_TRANSPARENT_DARK = ColorValue.fromRGBA_(0, 0, 0, 0.5);
    static readonly X_WHITE = ColorValue.fromRGBA_(255, 255, 255, 1.0);
    static readonly X_GREY = ColorValue.fromRGBA_(127, 127, 127, 1.0);
    static readonly X_RED = ColorValue.fromRGBA_(255, 0, 0, 1.0);
    static readonly X_BLACK = ColorValue.fromRGBA_(0, 0, 0, 1.0);

    /// Red color component. Value ranges from [0..255]
    /// Green color component. Value ranges from [0..255]
    /// Blue color component. Value ranges from [0..255]

    constructor(private _r: Int = 0, private _g: Int = 0, private _b: Int = 0, private _a: Double = 1.0) { }

    /// Parses the color value with the following format:
    ///    "#fff"
    ///    "#abcdef"
    ///    "#fff, 1.0"
    ///    "#abcdef, 1.0"
    ///    "fff",
    ///    "abcdef",
    ///    "255, 255, 255"
    ///    "255, 255, 255, 1.0"
    ///    "rgb(255, 255, 255)"
    ///    "rgba(255, 255, 255, 1.0)"
    static from_(value: stringXX, defa: Double = 1.0): ColorValue | null {
        if (value === null || value === undefined || value.length == 0 || value.length == 0) return null;
        if (value.startsWith("#")) {
            value = value.substring(1);
            return this.parseHex_(value, defa);
        }
        if (!value.includes(",")) {
            return this.parseHex_(value, defa);
        }
        let m = ColorValue.X_RGBA.exec(value);
        if (m != null) {
            value = m[1];
        }
        return this.parseDec_(value, defa);
    }

    static fromRGB_(r: Int, g: Int, b: Int): ColorValue {
        return new ColorValue(r, g, b);
    }

    static fromRGBA_(r: Int, g: Int, b: Int, a: Double): ColorValue {
        return new ColorValue(r, g, b, a);
    }

    static copy(other: ColorValue): ColorValue {
        return new ColorValue(other._r, other._g, other._b, other._a);
    }

    /// @return null instead of throwing exception on invalid input.
    /// @param a If not specified, default is 1.0.
    static parseSafe_(value: string, a: Double = 1.0): ColorValue | null {
        if (value == null || value.length == 0) {
            return null;
        }
        try {
            let ret = ColorValue.from_(value, a);
            if (ret != null) {
                return ret;
            }
        } catch (e) {
        }
        return null;
    }

    get r$(): number {
        return this._r;
    }

    get g$(): number {
        return this._g;
    }

    get b$(): number {
        return this._b;
    }

    get a$(): number {
        return this._a;
    }

    private static parseDec_(value: string, defa: number): ColorValue | null {
        let tokens = value.split(ColorValue.X_COMMA);
        let len = tokens.length;
        if (len != 3 && len != 4) {
            return null;
        }
        let r = Ut.parseInt_(tokens[0], -1);
        let g = Ut.parseInt_(tokens[1], -1);
        let b = Ut.parseInt_(tokens[2], -1);
        let a = defa;
        if (len == 4) a = Ut.parseDouble_(tokens[3]);
        if (r < 0 || r > 255
            || g < 0 || g > 255
            || b < 0 || b > 255
            || a < 0.0 || a > 1.0) {
            return null;
        }
        return new ColorValue(r, g, b, a);
    }

    /// Parses the color value in the format FFFFFFFF, FFFFFF or FFF
    /// ignorecase and optionally followed by , alpha in the later two cases.
    private static parseHex_(value: string, defa: number): ColorValue | null {
        let tokens = value.split(ColorValue.X_COMMA);
        let len = tokens.length;
        let hex;
        let a = defa;
        if (len == 1) {
            hex = tokens[0];
            if (hex.length != 3 && hex.length != 6 && hex.length != 8) {
                return null;
            }
            if (hex.length == 8) {
                hex = hex.substring(0, 6);
                a = Ut.parseInt_(`0x${hex.substring(6, 8)}`, -1) / 255;
            }
        } else if (len == 2) {
            hex = tokens[0];
            if (hex.length != 3 && hex.length != 6) {
                return null;
            }
            a = Ut.parseDouble_(tokens[1]);
        } else {
            return null;
        }
        if (a < 0 || a > 1.0) {
            return null;
        }
        if (hex.length == 3) {
            let r = hex.substring(0, 1);
            let g = hex.substring(1, 2);
            let b = hex.substring(2, 3);
            hex = `${r}${r}${g}${g}${b}${b}`;
        }
        let hexR = hex.substring(0, 2);
        let hexG = hex.substring(2, 4);
        let hexB = hex.substring(4, 6);
        let r = parseInt(hexR, 16);
        let g = parseInt(hexG, 16);
        let b = parseInt(hexB, 16);
        if (Ut.nan_(r, g, b)) return null;
        return new ColorValue(r, g, b, a);
    }

    mult_(value: number): ColorValue {
        return ColorValue.fromRGB_(
            Math.floor(this._r * value),
            Math.floor(this._g * value),
            Math.floor(this._b * value));
    }

    add_(other: ColorValue): ColorValue {
        return ColorValue.fromRGB_(
            Math.floor(this._r + other._r),
            Math.floor(this._g + other._g),
            Math.floor(this._b + other._b));
    }

    minus_(other: ColorValue): ColorValue {
        return ColorValue.fromRGB_(
            Math.floor(this._r - other._r),
            Math.floor(this._g - other._g),
            Math.floor(this._b - other._b));
    }

    equals_(other: ColorValue): boolean {
        return other != null && this._r == other._r && this._g == other._g && this._b == other._b && this.alphaString_() == other.alphaString_();
    }

    rgbEquals_(other: ColorValue): boolean {
        return other != null && this._r == other._r && this._g == other._g && this._b == other._b;
    }

    get isOpaque$(): boolean {
        return this._a == null || this._a == 1.0;
    }

    alphaString_(): string {
        return this._a == null ? "1.00" : this._a.toFixed(2);
    }

    toRgbArray_() {
        return [this._r, this._g, this._b];
    }

    toRgbaString_() {
        return `${this._r}, ${this._g}, ${this._b}, ${this.alphaString_()}`;
    }

    toRgbString_() {
        return `${this._r}, ${this._g}, ${this._b}`;
    }

    toHex3String_() {
        return `${this.hex_(this.r$)}${this.hex_(this.g$)}${this.hex_(this.b$)}`;
    }

    toRgbOrRgbaString_(): string {
        return this.isOpaque$ ? this.toRgbString_() : this.toRgbaString_();
    }

    toHexOrRgbaString_(): string {
        return this.isOpaque$ ? `#${this.toHex3String_()}` : this.toRgbaString_();
    }

    toCSSString_(): string {
        return this.isOpaque$ ? `rgb(${this.toRgbString_()})` : `rgba(${this.toRgbaString_()})`;
    }

    toHexOrCSSString_(): string {
        return this.isOpaque$ ? `#${this.toHex3String_()}` : `rgba(${this.toRgbaString_()})`;
    }

    toString_(): string {
        return `rgba(${this.toRgbaString_()})`;
    }

    hex_(v: number): string {
        return v.toString(16).padStart(2, "0");
    }
}

type OnPointChangeCallback = (x: number, y: number) => void;

////////////////////////////////////////////////////////////////////////

class DumbSnapper<T> implements ISnapper<T> {
    snap(x: T, y: T, callback: (x: T, y: T) => void) {
        callback(x, y);
    }
}

////////////////////////////////////////////////////////////////////////

class RubberBandListener {
    private _pointers: number[] | null = null;
    private _dist0: numberX = null;
    private _dist1: numberX = null;
    private _center: Point<number> | null = null;
    private _delta = 0.0;

    constructor(
        target: HTMLElement,
        private _useTouch: boolean,
        private _callback: Fun21<Point<number> | null, number, number>) {
        target.addEventListener(Conf.pointerstart$, (e) => this.onTouchStart(e));
        target.addEventListener(Conf.pointermove$, (e) => this.onTouchMove(e));
        target.addEventListener(Conf.pointerend$, (e) => this.onTouchEnd(e));
    }

    onTouchStart(e: Event): void {
        this._pointers = this._useTouch
            ? this._touchPointers(e as TouchEvent)
            : this._mousePointers(e as MouseEvent, null);
        
        if (this._pointers == null) {
            this._reset();
            return;
        }
        An.stopevent_(e);
        this._dist0 = An.dist1_(this._pointers, 0.0);
        this._dist1 = this._dist0;
        const x0 = this._useTouch ? this._midx(this._pointers) : this._pointers[0];
        const y0 = this._useTouch ? this._midy(this._pointers) : this._pointers[1];
        this._center = new Point(x0, y0);
        this._delta = 0.0;
        this._callback(this._center, this._delta);
    }

    onTouchMove(e: Event): void {
        if (this._dist0 != null) {
            An.stopevent_(e);
            const pointers = this._useTouch
                ? this._touchPointers(e as TouchEvent)
                : this._mousePointers(e as MouseEvent, this._pointers!);
            
            if (pointers != null) {
                const dist1 = An.dist1_(pointers, null);
                if (dist1 != null) {
                    this._delta = this._callback(null, this._delta + dist1 - this._dist1!);
                    this._dist1 = dist1;
                }
            }
        }
    }

    onTouchEnd(e: Event): void {
        if (this._dist0 != null) {
            An.stopevent_(e);
            const pointers = this._useTouch
                ? this._touchPointers(e as TouchEvent)
                : this._mousePointers(e as MouseEvent, this._pointers);
            
            if (pointers != null) {
                const dist1 = An.dist1_(pointers, null);
                if (dist1 != null) {
                    this._callback(null, this._delta + dist1 - this._dist1!);
                    this._reset();
                }
            }
        }
    }

    private _touchPointers(e: TouchEvent): number[] | null {
        const touches = e.touches;
        if (touches != null && touches.length == 2) {
            const ret: number[] = [];
            for (const touch of new ItemsIterable(touches)) {
                ret.push(Math.floor(touch.screenX));
                ret.push(Math.floor(touch.screenY));
            }
            return ret;
        }
        return null;
    }

    private _mousePointers(e: MouseEvent, previous: number[] | null): number[] | null {
        if (e.ctrlKey) {
            const ret: number[] = [];
            if (previous != null && previous.length >= 2) {
                ret.push(previous[0]);
                ret.push(previous[1]);
            }
            ret.push(Math.floor(e.screenX));
            ret.push(Math.floor(e.screenY));
            return ret;
        }
        return null;
    }

    private _reset(): void {
        this._dist0 = null;
        this._dist1 = null;
        this._pointers = null;
        this._center = null;
        this._delta = 0.0;
    }

    private _midx(a: number[]): number {
        return (a[0] + a[2]) / 2;
    }

    private _midy(a: number[]): number {
        return (a[1] + a[3]) / 2;
    }
}

////////////////////////////////////////////////////////////////////////

export class GradientPicker {

    private readonly _radius = 4;

    private _cX = 0;
    private _cY = 0;
    private _snapper: ISnapper<number>;
    private _canvas: HTMLCanvasElement;
    private _ctx: CanvasRenderingContext2D;

    /// Listener for mouse events in the canvas element
    private _mouseListener: UIUt$.IPointerListener;

    constructor(
        container: HTMLElement,
        private _width: number,
        private _height: number,
        x: number,
        y: number,
        useTouch: boolean,
        snapper: ISnapper<number>,
        private _onChangeCallback: OnPointChangeCallback
    ) {
        y = 1.0 - y;
        this._snapper = (snapper != null ? snapper : new DumbSnapper<number>());
        this._canvas = container.ownerDocument.createElement("canvas");
        this._canvas.width = _width;
        this._canvas.height = _height;
        this._ctx = this._canvas.getContext("2d")!;
        this._ctx.fillStyle = "rgba(255, 255, 255, 1.0)";
        this._ctx.fillRect(0, 0, _width, _height);
        this._mouseListener = useTouch
            ? new UIUt$.TouchListener(this._canvas, true)
            : new UIUt$.MouseListener(this._canvas, true);
        this._mouseListener.onPointerDown((x, y, buttons) => this.onMouseDown(x, y, buttons));
        this._mouseListener.onPointerMoved((x, y, buttons) => this.onMouseMoved(x, y, buttons));
        this._snapper.snap(x, y, (x, y) => {
            this._cX = Math.round(_width * x);
            this._cY = Math.round(_height * y);
            this._draw();
            this._onChange();
        });
    }

    get canvas$(): HTMLCanvasElement {
        return this._canvas;
    }

    setValue(x: number, y: number): void {
        this._setCursorPosition(Math.floor(this._width * x), Math.floor(this._height * y));
    }

    private _draw(): void {
        this._drawCursor();
    }

    /// Draws the cursor on the currently selected color position
    private _drawCursor() {
        this._ctx.strokeStyle = "rgba(0, 0, 0, 1.0)";
        this._ctx.beginPath();
        this._ctx.arc(this._cX, this._cY, this._radius, 0, 2 * Math.PI, false);
        this._ctx.closePath();
        this._ctx.stroke();
    }

    onMouseDown(x: number, y: number, _buttons: number): boolean {
        this._setCursorPosition(x, y);
        return true;
    }

    onMouseMoved(x: number, y: number, _buttons: number): void {
        this._setCursorPosition(x, y);
    }

    private _setCursorPosition(x: number, y: number): void {
        this._snapper.snap(x / this._width, y / this._height, (dx: number, dy: number) => {
            const x = Math.round(this._width * dx);
            const y = Math.round(this._height * dy);
            this._ctx.fillRect(this._cX - 2 * this._radius, this._cY - 2 * this._radius, this._radius * 4, this._radius * 4);
            this._cX = x;
            this._cY = y;
            this._onChange();
            this._draw();
        });
    }

    /// Notify the observer that the color has changed
    private _onChange(): void {
        this._onChangeCallback?.(this._cX / this._width, 1.0 - this._cY / this._height);
    }
}

namespace UIUt$ {
    type PointerEventCallback = (x: number, y: number, buttons: number) => void;
    type PointerDownEventCallback = (x: number, y: number, buttons: number) => boolean;
    export interface IPointerListener {
        onPointerDown(callback: PointerDownEventCallback): void;
        onPointerMoved(callback: PointerEventCallback): void;
        onPointerUp(callback: PointerEventCallback): void;
    }

    export class MouseListener implements IPointerListener {
        private _limiter: IRateLimiter;
        private _handlerDownRef: StreamSubscription;
        private _handlerMoveRef: StreamSubscription | null = null;
        private _handlerUpRef: StreamSubscription | null = null;
        private _onMouseDown: PointerDownEventCallback | null = null;
        private _onMouseMoved: PointerEventCallback | null = null;
        private _onMouseUp: PointerEventCallback | null = null;
        private _startMouseEvent: MouseEvent | null = null;
        private _startMouseX: numberX = null;
        private _startMouseY: numberX = null;
        private _cursorX: number = 0;
        private _cursorY: number = 0;
        private _capturing: boolean = false;

        constructor(public element: HTMLElement, public dragMode: boolean = true) {
            this._handlerDownRef = An.subscriptEvent_<MouseEvent>(element, "mousedown", (e) => this._handlerDown(e));
            this._limiter = new FrameLimiter(2);
            if (!dragMode) {
                this._handlerUpRef = An.subscriptEvent_<MouseEvent>(element, "mouseup", (e) => this._handlerUp(e));
                this._handlerMoveRef = An.subscriptEvent_<MouseEvent>(element, "mousemove", (e) => this._handlerMove(e));
            }
        }

        dispose(): void {
            this._handlerDownRef.cancel_();
            if (this._handlerUpRef != null) {
                this._handlerUpRef.cancel_();
            }
            if (this._handlerMoveRef != null) {
                this._handlerMoveRef.cancel_();
            }
        }

        onPointerDown(e: PointerDownEventCallback): void {
            this._onMouseDown = e;
        }

        onPointerMoved(e: PointerEventCallback): void {
            this._onMouseMoved = e;
        }

        onPointerUp(e: PointerEventCallback): void {
            this._onMouseUp = e;
        }

        private _handlerDown(event: Event): void {
            const e = event as MouseEvent;
            this._capturing = false;
            this._startMouseEvent = e;
            this._startMouseX = e.offsetX;
            this._startMouseY = e.offsetY;
            this._cursorX = this._startMouseX;
            this._cursorY = this._startMouseY;
            this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
            this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
            if (this._onMouseDown == null || this._onMouseDown(this._cursorX, this._cursorY, e.buttons)) {
                DomUt.stopEvent_(e);
                if (this.dragMode) {
                    this._handlerMoveRef = An.subscriptEvent_<MouseEvent>(document.body, "mousemove", (e) => this._handlerMove(e));
                    this._handlerUpRef = An.subscriptEvent_<MouseEvent>(document.body, "mouseup", (e) => this._handlerUp(e));
                }
                this._capturing = true;
            }
        }

        private _handlerMove(event: MouseEvent): void {
            if (!this._capturing) return;
            DomUt.stopEvent_(event);
            this._cursorX = this._startMouseX! + event.pageX - this._startMouseEvent!.pageX;
            this._cursorY = this._startMouseY! + event.pageY - this._startMouseEvent!.pageY;
            this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
            this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
            this._limiter.queue_(() => {
                this._onMouseMoved?.(this._cursorX, this._cursorY, event.buttons);
            });
        }

        private _handlerUp(e: MouseEvent): void {
            if (!this._capturing) return;
            DomUt.stopEvent_(e);
            this._cursorX = this._startMouseX! + e.pageX - this._startMouseEvent!.pageX;
            this._cursorY = this._startMouseY! + e.pageY - this._startMouseEvent!.pageY;
            this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
            this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
            if (this.dragMode) {
                if (this._handlerMoveRef != null) this._handlerMoveRef.cancel_();
                if (this._handlerUpRef != null) this._handlerUpRef.cancel_();
            }
            this._limiter.queue_(() => {
                this._onMouseUp?.(this._cursorX, this._cursorY, e.buttons);
            });
        }
    }

    export class TouchListener implements IPointerListener {
        private _limiter: IRateLimiter;
        private _handlerDownRef: StreamSubscription;
        private _handlerMoveRef: StreamSubscription | null = null;
        private _handlerUpRef: StreamSubscription | null = null;
        private _handlerCancelRef: StreamSubscription | null = null;
        private _onMouseDown: PointerDownEventCallback | null = null;
        private _onMouseMoved: PointerEventCallback | null = null;
        private _onMouseUp: PointerEventCallback | null = null;
        private _startMouseEvent: Touch | null = null;
        private _elementX: numberX = null;
        private _elementY: numberX = null;
        private _touchId: numberX = null;
        private _startMouseX: numberX = null;
        private _startMouseY: numberX = null;
        private _cursorX: number = 0;
        private _cursorY: number = 0;
        private _capturing: boolean = false;

        constructor(public element: HTMLElement, public dragMode: boolean = true) {
            this._handlerDownRef = An.subscriptEvent_<TouchEvent>(element, "touchstart", (e) => this._handlerDown(e));
            this._limiter = new FrameLimiter(4);
            if (!dragMode) {
                this._handlerUpRef = An.subscriptEvent_<TouchEvent>(element, "touchend", (e) => this._handlerUp(e));
                this._handlerMoveRef = An.subscriptEvent_<TouchEvent>(element, "touchmove", (e) => this._handlerMove(e));
            }
        }

        dispose(): void {
            this._handlerDownRef.cancel_();
            if (this._handlerUpRef != null) {
                this._handlerUpRef.cancel_();
            }
            if (this._handlerMoveRef != null) {
                this._handlerMoveRef.cancel_();
            }
        }

        onPointerDown(e: PointerDownEventCallback): void {
            this._onMouseDown = e;
        }

        onPointerMoved(e: PointerEventCallback): void {
            this._onMouseMoved = e;
        }

        onPointerUp(e: PointerEventCallback): void {
            this._onMouseUp = e;
        }

        private _handlerDown(e: TouchEvent): void {
            this._capturing = false;
            const touches = e.changedTouches;
            if (touches.length < 1) {
                return;
            }
            const touch = touches[0];
            let docoffset = An.documentOffset_(this.element);
            this._elementX = docoffset.x;
            this._elementY = docoffset.y;
            this._startMouseEvent = touch;
            this._touchId = touch.identifier;
            this._startMouseX = touch.pageX - this._elementX;
            this._startMouseY = touch.pageY - this._elementY;
            this._cursorX = this._startMouseX;
            this._cursorY = this._startMouseY;
            this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
            this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
            if (this._onMouseDown == null || this._onMouseDown(this._cursorX, this._cursorY, e.touches.length)) {
                DomUt.stopEvent_(e);
                if (this.dragMode) {
                    this._handlerMoveRef = An.subscriptEvent_<TouchEvent>(document.body, "touchmove", (e) => this._handlerMove(e));
                    this._handlerUpRef = An.subscriptEvent_<TouchEvent>(document.body, "touchend", (e) => this._handlerUp(e));
                    this._handlerCancelRef = An.subscriptEvent_<TouchEvent>(document.body, "touchcancel", (e) => this._handlerUp(e));
                }
                this._capturing = true;
            }
        }

        private _handlerMove(event: TouchEvent): void {
            if (!this._capturing) return;
            for (const touch of new ItemsIterable(event.changedTouches)) {
                if (touch.identifier == this._touchId) {
                    DomUt.stopEvent_(event);
                    this._cursorX = this._startMouseX! + touch.pageX - this._startMouseEvent!.pageX;
                    this._cursorY = this._startMouseY! + touch.pageY - this._startMouseEvent!.pageY;
                    this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
                    this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
                    if (this._onMouseMoved != null) {
                        this._limiter.queue_(() => {
                            this._onMouseMoved!(this._cursorX, this._cursorY, event.touches.length);
                        });
                    }
                    return;
                }
            }
        }

        private _handlerUp(event: TouchEvent): void {
            if (!this._capturing) return;
            for (const touch of new ItemsIterable(event.changedTouches)) {
                if (touch.identifier == this._touchId) {
                    DomUt.stopEvent_(event);
                    this._cursorX = this._startMouseX! + touch.pageX - this._startMouseEvent!.pageX;
                    this._cursorY = this._startMouseY! + touch.pageY - this._startMouseEvent!.pageY;
                    this._cursorX = Math.max(0, Math.min(this.element.clientWidth, this._cursorX));
                    this._cursorY = Math.max(0, Math.min(this.element.clientHeight, this._cursorY));
                    if (this.dragMode) {
                        if (this._handlerMoveRef != null) this._handlerMoveRef.cancel_();
                        if (this._handlerUpRef != null) this._handlerUpRef.cancel_();
                        if (this._handlerCancelRef != null) this._handlerCancelRef.cancel_();
                    }
                    this._limiter.queue_(() => {
                        this._onMouseUp?.(this._cursorX, this._cursorY, event.touches.length);
                    });
                }
            }
        }
    }

    export class CheckboxSelector {
        private _viewport: HTMLElement;
        private _offsets: Point<Int> | null = null;
        private _boundingboxes = new Array<[DOMRect, HTMLInputElement]>();
        private _current = new Array<boolean>();
        private _initial = new Array<boolean>();
        private _checked = false;
        private _start: [DOMRect, HTMLInputElement] | null = null;

        constructor(private _checklist: HTMLElement, private _changedCallback: Fun00X) {
            this._viewport = _checklist.parentElement!!;
        }

        private initboundingboxes_(offsets: Point<Int>) {
            this._offsets = offsets;
            this._boundingboxes = native$.iQueryAll_<HTMLInputElement>(
                `input[type=checkbox], input[type=radio]`, this._checklist).map((elm) => {
                    const item = elm.parentElement!!.parentElement!!;
                    return [item.getBoundingClientRect(), elm];
                });
        }

        onshow_() {
            this.initboundingboxes_(An.documentOffset_(this._viewport));
        }

        onclick_(pagex: number, pagey: number) {
            if (this._start == null) return;
            this._checkviewport();
            if (this._isinside(this._start[0], pagex, pagey)) {
                let_(this._start[1], (input) => {
                    if (!input.disabled) input.checked = !input.checked;
                    this._changedCallback?.();
                });
            }
        }

        onstart_(target: EventTarget, x: number, y: number): boolean {
            this._checkviewport();
            const index = this._boundingboxes.findIndex(([rect, _e]) => {
                return this._isinside(rect, x, y);
            });
            const elm = DomUt.asHTMLElement_(target);
            const dragging = elm != null && (elm.nodeName == "INPUT" || elm.classList.contains(CSS.AnPromptCheckboxInput));
            const a = this._boundingboxes[index] ?? null;
            this._start = a;
            if (a != null && dragging) {
                this._initial = this._boundingboxes.map(([_, e]) => e.checked);
                this._current = Array.from(this._initial);
                let_(a[1], (input) => {
                    this._checked = !input.checked;
                    if (!input.disabled) {
                        this._current[index] = this._checked;
                        input.checked = this._checked;
                    }
                });
                return true;
            }
            return false;
        }

        onmove_(dragger: Dragger, scrolltop: number): boolean {
            if (this._start == null) return false;
            const state = dragger.state_();
            const top = this._start[0].top;
            const pagey = state.pageY + scrolltop;
            const a = this._boundingboxes.find(([rect, _]) => this._isinside(rect, rect.left, pagey));
            if (a == null) return false;
            const start = pagey > top ? top : a[0].top;
            const end = pagey > top ? a[0].bottom - 1 : top + this._start[0].height - 1;
            const reverse = pagey < top;
            this._boundingboxes.forEach(([rect, e], index) => {
                if (e.disabled) return;
                const checked = (this._isselected(rect, start, end, reverse)) ? this._checked : this._initial[index];
                if (this._current[index] != checked) {
                    this._current[index] = checked;
                    e.checked = checked;
                }
            });
            return true;
        }

        onend_(): void {
            if (this._start == null) return;
            this._start = null;
            this._changedCallback?.();
        }

        _checkviewport() {
            const offsets = An.documentOffset_(this._viewport);
            if (this._offsets == null || offsets.x != this._offsets.x || offsets.y != this._offsets.y) {
                this.initboundingboxes_(offsets);
            }
        }
        _isinside(rect: DOMRect, x: number, y: number): boolean {
            return x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
        }

        _isselected(rect: DOMRect, y0: number, y1: number, reverse: boolean): boolean {
            const y = reverse ? rect.bottom - rect.height / 4 : rect.top + rect.height / 4;
            return y >= y0 && y < y1;
        }
    }

    export class CheckboxSelectListener implements IDraggerHandler {
        private _selectors = new Array<CheckboxSelector>();
        private _selector: CheckboxSelector | null = null;

        constructor(private _viewport: HTMLElement) {
            new Dragger(this._viewport, this).bind_();
            An.onClickMatching_(this._viewport, `.${CSS.AnPromptChecklist} > div > *, .${CSS.AnPromptChecklist} > div`, (target, e) => {
                An.stopevent_(e);
                if (target.nodeName != "INPUT" && !target.classList.contains(CSS.AnPromptCheckboxInput)) {
                    const page = JsUtil.pageLocationOf_(e, this._viewport);
                    if (page == null) return;
                    for (const selector of this._selectors) {
                        selector.onclick_(page.x, page.y);
                    }
                }
            });
        }

        addSelector_(selector: CheckboxSelector) {
            this._selectors.push(selector);
        }

        onShow_() {
            for (const selector of this._selectors) {
                selector.onshow_();
            }
        }

        onDragstart_(_dragger: Dragger, target: EventTarget, pagex: number, pagey: number): boolean {
            const x = pagex + this._viewport.scrollLeft;
            const y = pagey + this._viewport.scrollTop;
            for (const selector of this._selectors) {
                if (selector.onstart_(target, x, y)) {
                    this._selector = selector;
                    return true;
                }
            }
            this._selector = null;
            return false;
        }

        onDragmove_(dragger: Dragger): void {
            this._selector?.onmove_(dragger, this._viewport.scrollTop);
        }

        onDragend_(_dragger: Dragger, _e: UIEvent): void {
            this._selector?.onend_();
            this._selector = null;
        }
    }

    export class TooltipsListener {
        private _tooltipsTimer: Timer | null = null;
        private _tooltipsShown: boolean = false;
        constructor(target: HTMLElement, private _callback: TargetEventCallback | null) {
            An.onEventMatching_(target, Conf.pointerstart$, `div[${ATTR.xTooltips}], button[${ATTR.xTooltips}]`, (target, e) => {
                this.stopTooltipsTimer_();
                this._tooltipsShown = false;
                this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                    this._tooltipsTimer = null;
                    this._tooltipsShown = true;
                    this._callback?.(target, e);
                });
            });
            An.onPointerEnd_(target, (e) => {
                this.stopTooltipsTimer_();
                if (this._tooltipsShown) {
                    this._tooltipsShown = false;
                    An.stopevent_(e);
                }
            });
        }
        stopTooltipsTimer_(): void {
            if (this._tooltipsTimer != null) {
                this._tooltipsTimer.cancel_();
                this._tooltipsTimer = null;
            }
        }
    }
}

/// Color picker from Dart color_picker module.
namespace ColorValue$ {

    export type ColorChangeListener = (color: ColorValue, hue: number, saturation: number, brightness: number) => void;

    class colorutils {
        static getColorLuma_(color: ColorValue): number {
            return (0.3 * color.r$ + 0.59 * color.g$ + 0.11 * color.b$) / 255;
        }

        static getHsvValueComponent_(color: ColorValue): number {
            return Math.max(Math.max(color.r$, color.g$), color.b$);
        }

        static getHueColor_(angle: number): ColorValue {
            const slots = [
                ColorValue.fromRGB_(255, 0, 0),
                ColorValue.fromRGB_(255, 255, 0),
                ColorValue.fromRGB_(0, 255, 0),
                ColorValue.fromRGB_(0, 255, 255),
                ColorValue.fromRGB_(0, 0, 255),
                ColorValue.fromRGB_(255, 0, 255)
            ];

            let degrees: number = Math.round(angle * 180 / Math.PI);
            degrees %= 360;
            const slotPosition = degrees / 60;
            const slotIndex = Math.floor(slotPosition);
            const slotDelta = slotPosition - slotIndex;
            const startColor = slots[slotIndex];
            const endColor = slots[(slotIndex + 1) % slots.length];
            return endColor.minus_(startColor).mult_(slotDelta).add_(startColor);
        }
    }

    export class HsvGradientPicker implements HueChangeListener {
        hue!: number;

        colorChangeListener: ColorChangeListener | null = null;

        canvas: HTMLCanvasElement;

        private chroma!: number;

        private saturation!: number;

        private value!: number;

        private _color: ColorValue = new ColorValue();

        get color$(): ColorValue {
            return this._color;
        }
        set color$(value: ColorValue) {
            if (this._color.rgbEquals_(value)) {
                return;
            }
            this._color = value;
            this._rebuildColor();
            this._draw();
        }

        private hueColor: ColorValue | null = null;

        private readonly cursorRadius = 4;

        private context: CanvasRenderingContext2D;
        private buffer: ImageData | null = null;

        private _cursorX: number = 0;
        private _cursorY: number = 0;

        private _mouseListener: UIUt$.IPointerListener;

        constructor(container: HTMLElement, width: number, height: number, useTouch: boolean = false) {
            this.canvas = container.ownerDocument.createElement("canvas");
            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.classList.add("color-picker-hsv-gradient");
            this.context = this.canvas.getContext("2d")!;
            this._mouseListener = useTouch
                ? new UIUt$.TouchListener(this.canvas, true)
                : new UIUt$.MouseListener(this.canvas, true);
            this._mouseListener.onPointerDown((x, y, buttons) => this.onMouseDown(x, y, buttons));
            this._mouseListener.onPointerMoved((x, y, buttons) => this.onMouseMoved(x, y, buttons));
            this._rebuildColor();
            this._draw();
            this._notifyColorChanged();
        }

        private _rebuildColor(): void {
            this._calculateHSV(true);
            this._rebuildGradient();
            this._cursorX = Math.floor(this.canvas.width * this.saturation!);
            this._cursorY = Math.floor(this.canvas.height * (1 - this.value! / 255));
        }

        private _rebuildGradient(): void {
            this.buffer = this.context.createImageData(this.canvas.width, this.canvas.height);
            const height = this.buffer.height;
            const width = this.buffer.width;
            const intensityDelta = 1 / (width - 1);
            const _buffer = this.buffer.data;
            let index: number = 0;
            for (let h = 0; h < height; h++) {
                const intensity: number = (height - 1 - h) / (height - 1);
                const greyScaleComponent: number = Math.floor(255 * intensity);
                const startColor = ColorValue.fromRGB_(greyScaleComponent, greyScaleComponent, greyScaleComponent);
                const endColor = this.hueColor!.mult_(intensity);
                let pixelIntensity: number = 0;
                for (let w = 0; w < width; w++) {
                    const pixelColor = endColor.minus_(startColor).mult_(pixelIntensity).add_(startColor);
                    _buffer[index++] = pixelColor.r$;
                    _buffer[index++] = pixelColor.g$;
                    _buffer[index++] = pixelColor.b$;
                    _buffer[index++] = 255;
                    pixelIntensity += intensityDelta;
                }
            }
        }

        private _calculateHSV(calculateHue: boolean = false): void {
            this.value = colorutils.getHsvValueComponent_(this._color);
            if (calculateHue) {
                const alpha = (2 * this._color.r$ - this._color.g$ - this._color.b$) / 2;
                const beta = Math.sqrt(3) / 2 * (this._color.g$ - this._color.b$);
                this.hue = Math.atan2(beta, alpha);
                if (this.hue < 0) {
                    this.hue += Math.PI * 2;
                }
                this.chroma = Math.sqrt(alpha * alpha + beta * beta);
                this.saturation = (this.chroma == 0) ? 0 : this.chroma / this.value;
            }
            this.hueColor = colorutils.getHueColor_(this.hue!);
        }

        private _draw(): void {
            this.context.putImageData(this.buffer!, 0, 0);
            this._drawCursor();
        }

        onHueChanged(angle: number): void {
            this.hue = angle;

            this.hueColor = colorutils.getHueColor_(this.hue);

            this._recalculateColorFromCursor();

            this._rebuildGradient();
            this._draw();
            this._notifyColorChanged();
        }

        private _drawCursor() {
            const luma = colorutils.getColorLuma_(this._color);
            let cursorColor = "black";
            if (luma < 0.5) {
                cursorColor = "white";
            }
            this.context.strokeStyle = cursorColor;
            this.context.beginPath();
            this.context.arc(this._cursorX, this._cursorY, this.cursorRadius, 0, 2 * Math.PI, false);
            this.context.closePath();
            this.context.stroke();
        }

        private onMouseDown(x: number, y: number, _buttons: number): boolean {
            this._setCursorPosition(x, y);
            return true;
        }

        private onMouseMoved(x: number, y: number, _buttons: number): void {
            this._setCursorPosition(x, y);
        }

        private _setCursorPosition(x: number, y: number): void {
            this._cursorX = x;
            this._cursorY = y;
            this._recalculateColorFromCursor();
            this._calculateHSV();
            this._notifyColorChanged();
            this._draw();
        }

        private _recalculateColorFromCursor(): void {
            this.saturation = this._cursorX / this.canvas.width;
            this.value = (this.canvas.height - this._cursorY) / this.canvas.height * 255;

            const nvalue: number = this.value / 255;
            const valueColor = this.hueColor!.mult_(nvalue);

            const intensity = Math.round(nvalue * 255);
            const startColor = ColorValue.fromRGB_(intensity, intensity, intensity);
            const endColor = valueColor;
            this._color = endColor.minus_(startColor).mult_(this.saturation).add_(startColor);
        }

        private _notifyColorChanged(): void {
            if (this.colorChangeListener != null) {
                this.colorChangeListener(this._color, this.hue!, this.saturation!, this.value!);
            }
        }
    }

    export class HueSlider {
        hueChangelistener: HueChangeListener | null = null;

        canvas: HTMLCanvasElement;

        private _mouseListener: UIUt$.IPointerListener;

        private gradient!: CanvasGradient;

        private _hueAngle: number = 0;

        get hueAngle$(): number {
            return this._hueAngle;
        }
        set hueAngle$(value: number) {
            this._hueAngle = value;
            this._draw();
        }

        constructor(container: HTMLElement, width: number, height: number, useTouch: boolean = false) {
            this.canvas = container.ownerDocument.createElement("canvas");
            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.classList.add("color-picker-hue-slider");
            this._mouseListener = useTouch
                ? new UIUt$.TouchListener(this.canvas, true)
                : new UIUt$.MouseListener(this.canvas, true);
            this._mouseListener.onPointerDown((x, y, buttons) => this.onMouseDown(x, y, buttons));
            this._mouseListener.onPointerMoved((x, y, buttons) => this.onMouseMoved(x, y, buttons));
            this._buildGradient();
            this._draw();
        }

        private _draw(): void {
            const context = this.canvas.getContext("2d")!;
            context.fillStyle = this.gradient;
            context.fillRect(0, 0, this.canvas.width, this.canvas.height);

            let cursorColor = "black";

            const hueColor = colorutils.getHueColor_(this._hueAngle);

            const hueLuma = colorutils.getColorLuma_(hueColor);
            if (hueLuma < 0.5) {
                cursorColor = "white";
            }

            const y = this.canvas.height * this._hueAngle / (2 * Math.PI) + 0.5;
            context.save();
            context.strokeStyle = cursorColor;
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(this.canvas.width, y);
            context.closePath();
            context.stroke();
            context.restore();
        }

        private _buildGradient(): void {
            const hueColors = [
                ColorValue.fromRGB_(255, 0, 0),
                ColorValue.fromRGB_(255, 255, 0),
                ColorValue.fromRGB_(0, 255, 0),
                ColorValue.fromRGB_(0, 255, 255),
                ColorValue.fromRGB_(0, 0, 255),
                ColorValue.fromRGB_(255, 0, 255),
                ColorValue.fromRGB_(255, 0, 0)
            ];

            const context = this.canvas.getContext("2d")!;
            this.gradient = context.createLinearGradient(0, 0, 0, this.canvas.height);

            const gradientStopDelta = 1 / (hueColors.length - 1);
            let gradientStop: number = 0;
            for (let i = 0; i < hueColors.length - 1; i++) {
                this.gradient.addColorStop(gradientStop, hueColors[i].toString_());
                gradientStop += gradientStopDelta;
            }
            this.gradient.addColorStop(1.0, ArrayUt.last_(hueColors)!.toString_());
        }

        private onMouseDown(x: number, y: number, _buttons: number): boolean {
            this._updateHue(x, y);
            return true;
        }

        private onMouseMoved(x: number, y: number, _buttons: number): void {
            this._updateHue(x, y);
        }

        private _updateHue(_x: number, y: number): void {
            y %= this.canvas.height;
            const ratio: number = y / this.canvas.height;
            this._hueAngle = 2 * Math.PI * ratio;

            if (this.hueChangelistener != null) {
                this.hueChangelistener.onHueChanged(this._hueAngle);
            }

            this._draw();
        }
    }

    abstract class HueChangeListener {
        /**
         * Called whenever the hue angle is changed.
         * [angle] is in radians
         */
        abstract onHueChanged(angle: number): void;
    }
}

namespace Unicode$ {
    /**
     * Copyright (C) 2013 Edwin Bhler. All Rights Reserved.
     * @author Edwin Bhler
     */

    /**
     * This list class is slow and only useful for very large arrays with chunks of the same value.
     *
     * Sequences with the same value are compressed simply with [startIndex, numberOfValues, value].
     * [0,0,0,1,1,2,2,2,2,3] is store internal as [[0,3,0],[3,2,1],[5,4,2],[9,1,3]].
     *
     *     theList = new SparseList.from([0,0,0,1,1,2,2,2,2,3]);
     *     theList.createScript()
     *
     *
     *
     */

    class SparseList<E> {
        basicList = new Array<[number, number, E]>();
        itemsLength = 0;

        constructor() { }

        get isEmpty$(): boolean {
            return this.basicList.length == 0;
        }

        get isNotEmpty$(): boolean { return !this.isEmpty$; };

        get first$(): E {
            if (this.itemsLength == 0) throw new Error("No elements");
            return this.elementAt(0);
        }

        get last$(): E {
            if (this.itemsLength == 0) throw new Error("No elements");
            return this.elementAt(this.itemsLength - 1);
        }

        get length$(): number {
            return this.itemsLength;
        }

        elementAt(index: number): E {
            return this.basicList[this._chunkPositionForElementAt(index)][2];
        }

        get itemList$(): E[] {
            const theList = new Array<E>();
            let chunkSize;
            let chunkValue;
            this.basicList.forEach((each) => {
                chunkSize = each[1];
                chunkValue = each[2];
                for (let i = 0; i < chunkSize; i++) {
                    theList.push(chunkValue);
                }
            });
            return theList;
        }
        toList(_growable: boolean = true): E[] {
            return Array.from(this.itemList$);
        }
        forEach(action: (element: E) => void): void {
            const length: number = this.itemsLength;
            let chunkSize;
            let chunkValue;
            this.basicList.forEach((each) => {
                chunkSize = each[1];
                chunkValue = each[2];
                for (let i = 0; i < chunkSize; i++) {
                    action(chunkValue);
                    if (length != this.itemsLength) {
                        throw new Error();
                    }
                }
            });
        }

        static from<E>(other: E[]) {
            const newList = new SparseList();
            let currentValue, previousValue;
            let item: [number, number, E];
            for (let i = 0; i < other.length; i++) {
                currentValue = other[i];
                if (previousValue != currentValue) {
                    item = [i, 1, currentValue];
                    newList.basicList.push(item);
                } else {
                    ArrayUt.last_(newList.basicList)![1]++;
                }
                previousValue = currentValue;

            }
            newList.itemsLength = other.length;
            return newList;
        }

        static fromSparseList<E>(other: Array<[number, number, E]>): SparseList<E> {
            const newList = new SparseList<E>();
            other.forEach((each) => {
                newList.basicList.push(each);
                newList.itemsLength = newList.itemsLength + each[1];
            });
            return newList;
        }

        private _chunkPositionForElementAt(index: number): number {
            if (this.length$ <= index) throw new Error("Not enough elements");
            let result: number | null = null;
            let startChunk, endChunk;
            let fuzzyPosition = Math.round((index * this.basicList.length) / this.itemsLength);
            if (fuzzyPosition >= this.basicList.length) {
                fuzzyPosition = this.basicList.length - 1;
            }
            const fuzzyChunk = this.basicList[fuzzyPosition];
            if (index >= fuzzyChunk[0]) {
                for (let i = fuzzyPosition; i < this.basicList.length; i++) {
                    startChunk = this.basicList[i][0];
                    endChunk = startChunk + this.basicList[i][1];
                    if ((index >= startChunk) && (index < endChunk)) {
                        result = i;
                        break;
                    }
                }
            } else {
                for (let i = (fuzzyPosition - 1); i < this.basicList.length; i--) {
                    startChunk = this.basicList[i][0];
                    endChunk = startChunk + this.basicList[i][1];
                    if ((index >= startChunk) && (index < endChunk)) {
                        result = i;
                        break;
                    }
                }
            }
            if (result == null) throw new Error();
            return result;
        }

        set(index: number, value: E): void {
            const oldChunkPosition = this._chunkPositionForElementAt(index);
            const currentChunk = this.basicList[oldChunkPosition];
            const currentValue = currentChunk[2];
            if (value != currentValue) {
                const updatedChunk: [number, number, E] = [currentChunk[0], (index - currentChunk[0]), currentValue];
                const newElementChunk: [number, number, E] = [index, 1, value];
                const newRestChunk: [number, number, E] = [(index + 1), (currentChunk[1] - updatedChunk[1] - 1), currentValue];
                if (newRestChunk[1] > 0) {
                    ArrayUt.insert_(this.basicList, (oldChunkPosition + 1), newRestChunk);
                }
                ArrayUt.insert_(this.basicList, (oldChunkPosition + 1), newElementChunk);
                if (updatedChunk[1] == 0) {
                    this.basicList.splice(oldChunkPosition, 1);
                } else {
                    this.basicList[oldChunkPosition] = updatedChunk;
                }
            }
        }

        add(value: E): void {
            const item: [number, number, E] = [0, 0, value];
            this.basicList.push(item);
            this.itemsLength++;
        }

        addItem(aItem: [number, number, E]): void {
            this.basicList.push(aItem);
            this.itemsLength = this.itemsLength + aItem[1];
        }
    }
    /**
     * Copyright (C) 2013 Edwin Bhler. All Rights Reserved.
     * @author Edwin Bhler
     */

    const unicodeCharacterCategory = SparseList.fromSparseList<number>([
        [0, 32, 1], [32, 1, 29], [33, 3, 21], [36, 1, 23], [37, 3, 21], [40, 1, 22], [41, 1, 18], [42, 1, 21], [43, 1, 25], [44, 1, 21],
        [45, 1, 17], [46, 2, 21], [48, 10, 13], [58, 2, 21], [60, 3, 25], [63, 2, 21], [65, 26, 9], [91, 1, 22], [92, 1, 21],
        [93, 1, 18], [94, 1, 24], [95, 1, 16], [96, 1, 24], [97, 26, 5], [123, 1, 22], [124, 1, 25], [125, 1, 18], [126, 1, 25],
        [127, 33, 1], [160, 1, 29], [161, 1, 21], [162, 4, 23], [166, 2, 26], [168, 1, 24], [169, 1, 26], [170, 1, 5], [171, 1, 20],
        [172, 1, 25], [173, 1, 17], [174, 1, 26], [175, 1, 24], [176, 1, 26], [177, 1, 25], [178, 2, 15], [180, 1, 24], [181, 1, 5],
        [182, 1, 26], [183, 1, 21], [184, 1, 24], [185, 1, 15], [186, 1, 5], [187, 1, 19], [188, 3, 15], [191, 1, 21], [192, 23, 9],
        [215, 1, 25], [216, 7, 9], [223, 24, 5], [247, 1, 25], [248, 8, 5], [256, 1, 9], [257, 1, 5], [258, 1, 9], [259, 1, 5],
        [260, 1, 9], [261, 1, 5], [262, 1, 9], [263, 1, 5], [264, 1, 9], [265, 1, 5], [266, 1, 9], [267, 1, 5], [268, 1, 9],
        [269, 1, 5], [270, 1, 9], [271, 1, 5], [272, 1, 9], [273, 1, 5], [274, 1, 9], [275, 1, 5], [276, 1, 9], [277, 1, 5],
        [278, 1, 9], [279, 1, 5], [280, 1, 9], [281, 1, 5], [282, 1, 9], [283, 1, 5], [284, 1, 9], [285, 1, 5], [286, 1, 9],
        [287, 1, 5], [288, 1, 9], [289, 1, 5], [290, 1, 9], [291, 1, 5], [292, 1, 9], [293, 1, 5], [294, 1, 9], [295, 1, 5],
        [296, 1, 9], [297, 1, 5], [298, 1, 9], [299, 1, 5], [300, 1, 9], [301, 1, 5], [302, 1, 9], [303, 1, 5], [304, 1, 9],
        [305, 1, 5], [306, 1, 9], [307, 1, 5], [308, 1, 9], [309, 1, 5], [310, 1, 9], [311, 2, 5], [313, 1, 9], [314, 1, 5],
        [315, 1, 9], [316, 1, 5], [317, 1, 9], [318, 1, 5], [319, 1, 9], [320, 1, 5], [321, 1, 9], [322, 1, 5], [323, 1, 9],
        [324, 1, 5], [325, 1, 9], [326, 1, 5], [327, 1, 9], [328, 2, 5], [330, 1, 9], [331, 1, 5], [332, 1, 9], [333, 1, 5],
        [334, 1, 9], [335, 1, 5], [336, 1, 9], [337, 1, 5], [338, 1, 9], [339, 1, 5], [340, 1, 9], [341, 1, 5], [342, 1, 9],
        [343, 1, 5], [344, 1, 9], [345, 1, 5], [346, 1, 9], [347, 1, 5], [348, 1, 9], [349, 1, 5], [350, 1, 9], [351, 1, 5],
        [352, 1, 9], [353, 1, 5], [354, 1, 9], [355, 1, 5], [356, 1, 9], [357, 1, 5], [358, 1, 9], [359, 1, 5], [360, 1, 9],
        [361, 1, 5], [362, 1, 9], [363, 1, 5], [364, 1, 9], [365, 1, 5], [366, 1, 9], [367, 1, 5], [368, 1, 9], [369, 1, 5],
        [370, 1, 9], [371, 1, 5], [372, 1, 9], [373, 1, 5], [374, 1, 9], [375, 1, 5], [376, 2, 9], [378, 1, 5], [379, 1, 9],
        [380, 1, 5], [381, 1, 9], [382, 3, 5], [385, 2, 9], [387, 1, 5], [388, 1, 9], [389, 1, 5], [390, 2, 9], [392, 1, 5],
        [393, 3, 9], [396, 2, 5], [398, 4, 9], [402, 1, 5], [403, 2, 9], [405, 1, 5], [406, 3, 9], [409, 3, 5], [412, 2, 9],
        [414, 1, 5], [415, 2, 9], [417, 1, 5], [418, 1, 9], [419, 1, 5], [420, 1, 9], [421, 1, 5], [422, 2, 9], [424, 1, 5],
        [425, 1, 9], [426, 2, 5], [428, 1, 9], [429, 1, 5], [430, 2, 9], [432, 1, 5], [433, 3, 9], [436, 1, 5], [437, 1, 9],
        [438, 1, 5], [439, 2, 9], [441, 2, 5], [443, 1, 7], [444, 1, 9], [445, 3, 5], [448, 4, 7], [452, 1, 9], [453, 1, 8],
        [454, 1, 5], [455, 1, 9], [456, 1, 8], [457, 1, 5], [458, 1, 9], [459, 1, 8], [460, 1, 5], [461, 1, 9], [462, 1, 5],
        [463, 1, 9], [464, 1, 5], [465, 1, 9], [466, 1, 5], [467, 1, 9], [468, 1, 5], [469, 1, 9], [470, 1, 5], [471, 1, 9],
        [472, 1, 5], [473, 1, 9], [474, 1, 5], [475, 1, 9], [476, 2, 5], [478, 1, 9], [479, 1, 5], [480, 1, 9], [481, 1, 5],
        [482, 1, 9], [483, 1, 5], [484, 1, 9], [485, 1, 5], [486, 1, 9], [487, 1, 5], [488, 1, 9], [489, 1, 5], [490, 1, 9],
        [491, 1, 5], [492, 1, 9], [493, 1, 5], [494, 1, 9], [495, 2, 5], [497, 1, 9], [498, 1, 8], [499, 1, 5], [500, 1, 9],
        [501, 1, 5], [502, 3, 9], [505, 1, 5], [506, 1, 9], [507, 1, 5], [508, 1, 9], [509, 1, 5], [510, 1, 9], [511, 1, 5],
        [512, 1, 9], [513, 1, 5], [514, 1, 9], [515, 1, 5], [516, 1, 9], [517, 1, 5], [518, 1, 9], [519, 1, 5], [520, 1, 9],
        [521, 1, 5], [522, 1, 9], [523, 1, 5], [524, 1, 9], [525, 1, 5], [526, 1, 9], [527, 1, 5], [528, 1, 9], [529, 1, 5],
        [530, 1, 9], [531, 1, 5], [532, 1, 9], [533, 1, 5], [534, 1, 9], [535, 1, 5], [536, 1, 9], [537, 1, 5], [538, 1, 9],
        [539, 1, 5], [540, 1, 9], [541, 1, 5], [542, 1, 9], [543, 1, 5], [544, 1, 9], [545, 1, 0], [546, 1, 9], [547, 1, 5],
        [548, 1, 9], [549, 1, 5], [550, 1, 9], [551, 1, 5], [552, 1, 9], [553, 1, 5], [554, 1, 9], [555, 1, 5], [556, 1, 9],
        [557, 1, 5], [558, 1, 9], [559, 1, 5], [560, 1, 9], [561, 1, 5], [562, 1, 9], [563, 1, 5], [564, 28, 0], [592, 94, 5],
        [686, 2, 0], [688, 9, 6], [697, 2, 24], [699, 7, 6], [706, 14, 24], [720, 2, 6], [722, 14, 24], [736, 5, 6], [741, 9, 24],
        [750, 1, 6], [751, 17, 0], [768, 80, 12], [848, 16, 0], [864, 16, 12], [880, 4, 0], [884, 2, 24], [886, 4, 0], [890, 1, 6],
        [891, 3, 0], [894, 1, 21], [895, 5, 0], [900, 2, 24], [902, 1, 9], [903, 1, 21], [904, 3, 9], [907, 1, 0], [908, 1, 9],
        [909, 1, 0], [910, 2, 9], [912, 1, 5], [913, 17, 9], [930, 1, 0], [931, 9, 9], [940, 35, 5], [975, 1, 0], [976, 2, 5],
        [978, 3, 9], [981, 3, 5], [984, 1, 9], [985, 1, 5], [986, 1, 9], [987, 1, 5], [988, 1, 9], [989, 1, 5], [990, 1, 9],
        [991, 1, 5], [992, 1, 9], [993, 1, 5], [994, 1, 9], [995, 1, 5], [996, 1, 9], [997, 1, 5], [998, 1, 9], [999, 1, 5],
        [1000, 1, 9], [1001, 1, 5], [1002, 1, 9], [1003, 1, 5], [1004, 1, 9], [1005, 1, 5], [1006, 1, 9], [1007, 5, 5], [1012, 1, 9],
        [1013, 1, 5], [1014, 1, 25], [1015, 9, 0], [1024, 48, 9], [1072, 48, 5], [1120, 1, 9], [1121, 1, 5], [1122, 1, 9],
        [1123, 1, 5], [1124, 1, 9], [1125, 1, 5], [1126, 1, 9], [1127, 1, 5], [1128, 1, 9], [1129, 1, 5], [1130, 1, 9], [1131, 1, 5],
        [1132, 1, 9], [1133, 1, 5], [1134, 1, 9], [1135, 1, 5], [1136, 1, 9], [1137, 1, 5], [1138, 1, 9], [1139, 1, 5], [1140, 1, 9],
        [1141, 1, 5], [1142, 1, 9], [1143, 1, 5], [1144, 1, 9], [1145, 1, 5], [1146, 1, 9], [1147, 1, 5], [1148, 1, 9], [1149, 1, 5],
        [1150, 1, 9], [1151, 1, 5], [1152, 1, 9], [1153, 1, 5], [1154, 1, 26], [1155, 4, 12], [1159, 1, 0], [1160, 2, 11],
        [1162, 1, 9], [1163, 1, 5], [1164, 1, 9], [1165, 1, 5], [1166, 1, 9], [1167, 1, 5], [1168, 1, 9], [1169, 1, 5], [1170, 1, 9],
        [1171, 1, 5], [1172, 1, 9], [1173, 1, 5], [1174, 1, 9], [1175, 1, 5], [1176, 1, 9], [1177, 1, 5], [1178, 1, 9], [1179, 1, 5],
        [1180, 1, 9], [1181, 1, 5], [1182, 1, 9], [1183, 1, 5], [1184, 1, 9], [1185, 1, 5], [1186, 1, 9], [1187, 1, 5], [1188, 1, 9],
        [1189, 1, 5], [1190, 1, 9], [1191, 1, 5], [1192, 1, 9], [1193, 1, 5], [1194, 1, 9], [1195, 1, 5], [1196, 1, 9], [1197, 1, 5],
        [1198, 1, 9], [1199, 1, 5], [1200, 1, 9], [1201, 1, 5], [1202, 1, 9], [1203, 1, 5], [1204, 1, 9], [1205, 1, 5], [1206, 1, 9],
        [1207, 1, 5], [1208, 1, 9], [1209, 1, 5], [1210, 1, 9], [1211, 1, 5], [1212, 1, 9], [1213, 1, 5], [1214, 1, 9], [1215, 1, 5],
        [1216, 2, 9], [1218, 1, 5], [1219, 1, 9], [1220, 1, 5], [1221, 1, 9], [1222, 1, 5], [1223, 1, 9], [1224, 1, 5], [1225, 1, 9],
        [1226, 1, 5], [1227, 1, 9], [1228, 1, 5], [1229, 1, 9], [1230, 1, 5], [1231, 1, 0], [1232, 1, 9], [1233, 1, 5], [1234, 1, 9],
        [1235, 1, 5], [1236, 1, 9], [1237, 1, 5], [1238, 1, 9], [1239, 1, 5], [1240, 1, 9], [1241, 1, 5], [1242, 1, 9], [1243, 1, 5],
        [1244, 1, 9], [1245, 1, 5], [1246, 1, 9], [1247, 1, 5], [1248, 1, 9], [1249, 1, 5], [1250, 1, 9], [1251, 1, 5], [1252, 1, 9],
        [1253, 1, 5], [1254, 1, 9], [1255, 1, 5], [1256, 1, 9], [1257, 1, 5], [1258, 1, 9], [1259, 1, 5], [1260, 1, 9], [1261, 1, 5],
        [1262, 1, 9], [1263, 1, 5], [1264, 1, 9], [1265, 1, 5], [1266, 1, 9], [1267, 1, 5], [1268, 1, 9], [1269, 1, 5], [1270, 2, 0],
        [1272, 1, 9], [1273, 1, 5], [1274, 6, 0], [1280, 1, 9], [1281, 1, 5], [1282, 1, 9], [1283, 1, 5], [1284, 1, 9], [1285, 1, 5],
        [1286, 1, 9], [1287, 1, 5], [1288, 1, 9], [1289, 1, 5], [1290, 1, 9], [1291, 1, 5], [1292, 1, 9], [1293, 1, 5], [1294, 1, 9],
        [1295, 1, 5], [1296, 33, 0], [1329, 38, 9], [1367, 2, 0], [1369, 1, 6], [1370, 6, 21], [1376, 1, 0], [1377, 39, 5],
        [1416, 1, 0], [1417, 1, 21], [1418, 1, 17], [1419, 6, 0], [1425, 17, 12], [1442, 1, 0], [1443, 23, 12], [1466, 1, 0],
        [1467, 3, 12], [1470, 1, 21], [1471, 1, 12], [1472, 1, 21], [1473, 2, 12], [1475, 1, 21], [1476, 1, 12], [1477, 11, 0],
        [1488, 27, 7], [1515, 5, 0], [1520, 3, 7], [1523, 2, 21], [1525, 23, 0], [1548, 1, 21], [1549, 14, 0], [1563, 1, 21],
        [1564, 3, 0], [1567, 1, 21], [1568, 1, 0], [1569, 26, 7], [1595, 5, 0], [1600, 1, 6], [1601, 10, 7], [1611, 11, 12],
        [1622, 10, 0], [1632, 10, 13], [1642, 4, 21], [1646, 2, 7], [1648, 1, 12], [1649, 99, 7], [1748, 1, 21], [1749, 1, 7],
        [1750, 7, 12], [1757, 1, 2], [1758, 1, 11], [1759, 6, 12], [1765, 2, 6], [1767, 2, 12], [1769, 1, 26], [1770, 4, 12],
        [1774, 2, 0], [1776, 10, 13], [1786, 3, 7], [1789, 2, 26], [1791, 1, 0], [1792, 14, 21], [1806, 1, 0], [1807, 1, 2],
        [1808, 1, 7], [1809, 1, 12], [1810, 27, 7], [1837, 3, 0], [1840, 27, 12], [1867, 53, 0], [1920, 38, 7], [1958, 11, 12],
        [1969, 1, 7], [1970, 335, 0], [2305, 2, 12], [2307, 1, 10], [2308, 1, 0], [2309, 53, 7], [2362, 2, 0], [2364, 1, 12],
        [2365, 1, 7], [2366, 3, 10], [2369, 8, 12], [2377, 4, 10], [2381, 1, 12], [2382, 2, 0], [2384, 1, 7], [2385, 4, 12],
        [2389, 3, 0], [2392, 10, 7], [2402, 2, 12], [2404, 2, 21], [2406, 10, 13], [2416, 1, 21], [2417, 16, 0], [2433, 1, 12],
        [2434, 2, 10], [2436, 1, 0], [2437, 8, 7], [2445, 2, 0], [2447, 2, 7], [2449, 2, 0], [2451, 22, 7], [2473, 1, 0],
        [2474, 7, 7], [2481, 1, 0], [2482, 1, 7], [2483, 3, 0], [2486, 4, 7], [2490, 2, 0], [2492, 1, 12], [2493, 1, 0],
        [2494, 3, 10], [2497, 4, 12], [2501, 2, 0], [2503, 2, 10], [2505, 2, 0], [2507, 2, 10], [2509, 1, 12], [2510, 9, 0],
        [2519, 1, 10], [2520, 4, 0], [2524, 2, 7], [2526, 1, 0], [2527, 3, 7], [2530, 2, 12], [2532, 2, 0], [2534, 10, 13],
        [2544, 2, 7], [2546, 2, 23], [2548, 6, 15], [2554, 1, 26], [2555, 7, 0], [2562, 1, 12], [2563, 2, 0], [2565, 6, 7],
        [2571, 4, 0], [2575, 2, 7], [2577, 2, 0], [2579, 22, 7], [2601, 1, 0], [2602, 7, 7], [2609, 1, 0], [2610, 2, 7],
        [2612, 1, 0], [2613, 2, 7], [2615, 1, 0], [2616, 2, 7], [2618, 2, 0], [2620, 1, 12], [2621, 1, 0], [2622, 3, 10],
        [2625, 2, 12], [2627, 4, 0], [2631, 2, 12], [2633, 2, 0], [2635, 3, 12], [2638, 11, 0], [2649, 4, 7], [2653, 1, 0],
        [2654, 1, 7], [2655, 7, 0], [2662, 10, 13], [2672, 2, 12], [2674, 3, 7], [2677, 12, 0], [2689, 2, 12], [2691, 1, 10],
        [2692, 1, 0], [2693, 7, 7], [2700, 1, 0], [2701, 1, 7], [2702, 1, 0], [2703, 3, 7], [2706, 1, 0], [2707, 22, 7],
        [2729, 1, 0], [2730, 7, 7], [2737, 1, 0], [2738, 2, 7], [2740, 1, 0], [2741, 5, 7], [2746, 2, 0], [2748, 1, 12],
        [2749, 1, 7], [2750, 3, 10], [2753, 5, 12], [2758, 1, 0], [2759, 2, 12], [2761, 1, 10], [2762, 1, 0], [2763, 2, 10],
        [2765, 1, 12], [2766, 2, 0], [2768, 1, 7], [2769, 15, 0], [2784, 1, 7], [2785, 5, 0], [2790, 10, 13], [2800, 17, 0],
        [2817, 1, 12], [2818, 2, 10], [2820, 1, 0], [2821, 8, 7], [2829, 2, 0], [2831, 2, 7], [2833, 2, 0], [2835, 22, 7],
        [2857, 1, 0], [2858, 7, 7], [2865, 1, 0], [2866, 2, 7], [2868, 2, 0], [2870, 4, 7], [2874, 2, 0], [2876, 1, 12],
        [2877, 1, 7], [2878, 1, 10], [2879, 1, 12], [2880, 1, 10], [2881, 3, 12], [2884, 3, 0], [2887, 2, 10], [2889, 2, 0],
        [2891, 2, 10], [2893, 1, 12], [2894, 8, 0], [2902, 1, 12], [2903, 1, 10], [2904, 4, 0], [2908, 2, 7], [2910, 1, 0],
        [2911, 3, 7], [2914, 4, 0], [2918, 10, 13], [2928, 1, 26], [2929, 17, 0], [2946, 1, 12], [2947, 1, 7], [2948, 1, 0],
        [2949, 6, 7], [2955, 3, 0], [2958, 3, 7], [2961, 1, 0], [2962, 4, 7], [2966, 3, 0], [2969, 2, 7], [2971, 1, 0], [2972, 1, 7],
        [2973, 1, 0], [2974, 2, 7], [2976, 3, 0], [2979, 2, 7], [2981, 3, 0], [2984, 3, 7], [2987, 3, 0], [2990, 8, 7], [2998, 1, 0],
        [2999, 3, 7], [3002, 4, 0], [3006, 2, 10], [3008, 1, 12], [3009, 2, 10], [3011, 3, 0], [3014, 3, 10], [3017, 1, 0],
        [3018, 3, 10], [3021, 1, 12], [3022, 9, 0], [3031, 1, 10], [3032, 15, 0], [3047, 9, 13], [3056, 3, 15], [3059, 14, 0],
        [3073, 3, 10], [3076, 1, 0], [3077, 8, 7], [3085, 1, 0], [3086, 3, 7], [3089, 1, 0], [3090, 23, 7], [3113, 1, 0],
        [3114, 10, 7], [3124, 1, 0], [3125, 5, 7], [3130, 4, 0], [3134, 3, 12], [3137, 4, 10], [3141, 1, 0], [3142, 3, 12],
        [3145, 1, 0], [3146, 4, 12], [3150, 7, 0], [3157, 2, 12], [3159, 9, 0], [3168, 2, 7], [3170, 4, 0], [3174, 10, 13],
        [3184, 18, 0], [3202, 2, 10], [3204, 1, 0], [3205, 8, 7], [3213, 1, 0], [3214, 3, 7], [3217, 1, 0], [3218, 23, 7],
        [3241, 1, 0], [3242, 10, 7], [3252, 1, 0], [3253, 5, 7], [3258, 4, 0], [3262, 1, 10], [3263, 1, 12], [3264, 5, 10],
        [3269, 1, 0], [3270, 1, 12], [3271, 2, 10], [3273, 1, 0], [3274, 2, 10], [3276, 2, 12], [3278, 7, 0], [3285, 2, 10],
        [3287, 7, 0], [3294, 1, 7], [3295, 1, 0], [3296, 2, 7], [3298, 4, 0], [3302, 10, 13], [3312, 18, 0], [3330, 2, 10],
        [3332, 1, 0], [3333, 8, 7], [3341, 1, 0], [3342, 3, 7], [3345, 1, 0], [3346, 23, 7], [3369, 1, 0], [3370, 16, 7],
        [3386, 4, 0], [3390, 3, 10], [3393, 3, 12], [3396, 2, 0], [3398, 3, 10], [3401, 1, 0], [3402, 3, 10], [3405, 1, 12],
        [3406, 9, 0], [3415, 1, 10], [3416, 8, 0], [3424, 2, 7], [3426, 4, 0], [3430, 10, 13], [3440, 18, 0], [3458, 2, 10],
        [3460, 1, 0], [3461, 18, 7], [3479, 3, 0], [3482, 24, 7], [3506, 1, 0], [3507, 9, 7], [3516, 1, 0], [3517, 1, 7],
        [3518, 2, 0], [3520, 7, 7], [3527, 3, 0], [3530, 1, 12], [3531, 4, 0], [3535, 3, 10], [3538, 3, 12], [3541, 1, 0],
        [3542, 1, 12], [3543, 1, 0], [3544, 8, 10], [3552, 18, 0], [3570, 2, 10], [3572, 1, 21], [3573, 12, 0], [3585, 48, 7],
        [3633, 1, 12], [3634, 2, 7], [3636, 7, 12], [3643, 4, 0], [3647, 1, 23], [3648, 6, 7], [3654, 1, 6], [3655, 8, 12],
        [3663, 1, 21], [3664, 10, 13], [3674, 2, 21], [3676, 37, 0], [3713, 2, 7], [3715, 1, 0], [3716, 1, 7], [3717, 2, 0],
        [3719, 2, 7], [3721, 1, 0], [3722, 1, 7], [3723, 2, 0], [3725, 1, 7], [3726, 6, 0], [3732, 4, 7], [3736, 1, 0], [3737, 7, 7],
        [3744, 1, 0], [3745, 3, 7], [3748, 1, 0], [3749, 1, 7], [3750, 1, 0], [3751, 1, 7], [3752, 2, 0], [3754, 2, 7], [3756, 1, 0],
        [3757, 4, 7], [3761, 1, 12], [3762, 2, 7], [3764, 6, 12], [3770, 1, 0], [3771, 2, 12], [3773, 1, 7], [3774, 2, 0],
        [3776, 5, 7], [3781, 1, 0], [3782, 1, 6], [3783, 1, 0], [3784, 6, 12], [3790, 2, 0], [3792, 10, 13], [3802, 2, 0],
        [3804, 2, 7], [3806, 34, 0], [3840, 1, 7], [3841, 3, 26], [3844, 15, 21], [3859, 5, 26], [3864, 2, 12], [3866, 6, 26],
        [3872, 10, 13], [3882, 10, 15], [3892, 1, 26], [3893, 1, 12], [3894, 1, 26], [3895, 1, 12], [3896, 1, 26], [3897, 1, 12],
        [3898, 1, 22], [3899, 1, 18], [3900, 1, 22], [3901, 1, 18], [3902, 2, 10], [3904, 8, 7], [3912, 1, 0], [3913, 34, 7],
        [3947, 6, 0], [3953, 14, 12], [3967, 1, 10], [3968, 5, 12], [3973, 1, 21], [3974, 2, 12], [3976, 4, 7], [3980, 4, 0],
        [3984, 8, 12], [3992, 1, 0], [3993, 36, 12], [4029, 1, 0], [4030, 8, 26], [4038, 1, 12], [4039, 6, 26], [4045, 2, 0],
        [4047, 1, 26], [4048, 48, 0], [4096, 34, 7], [4130, 1, 0], [4131, 5, 7], [4136, 1, 0], [4137, 2, 7], [4139, 1, 0],
        [4140, 1, 10], [4141, 4, 12], [4145, 1, 10], [4146, 1, 12], [4147, 3, 0], [4150, 2, 12], [4152, 1, 10], [4153, 1, 12],
        [4154, 6, 0], [4160, 10, 13], [4170, 6, 21], [4176, 6, 7], [4182, 2, 10], [4184, 2, 12], [4186, 70, 0], [4256, 38, 9],
        [4294, 10, 0], [4304, 41, 7], [4345, 2, 0], [4347, 1, 21], [4348, 4, 0], [4352, 90, 7], [4442, 5, 0], [4447, 68, 7],
        [4515, 5, 0], [4520, 82, 7], [4602, 6, 0], [4608, 7, 7], [4615, 1, 0], [4616, 63, 7], [4679, 1, 0], [4680, 1, 7],
        [4681, 1, 0], [4682, 4, 7], [4686, 2, 0], [4688, 7, 7], [4695, 1, 0], [4696, 1, 7], [4697, 1, 0], [4698, 4, 7], [4702, 2, 0],
        [4704, 39, 7], [4743, 1, 0], [4744, 1, 7], [4745, 1, 0], [4746, 4, 7], [4750, 2, 0], [4752, 31, 7], [4783, 1, 0],
        [4784, 1, 7], [4785, 1, 0], [4786, 4, 7], [4790, 2, 0], [4792, 7, 7], [4799, 1, 0], [4800, 1, 7], [4801, 1, 0], [4802, 4, 7],
        [4806, 2, 0], [4808, 7, 7], [4815, 1, 0], [4816, 7, 7], [4823, 1, 0], [4824, 23, 7], [4847, 1, 0], [4848, 31, 7],
        [4879, 1, 0], [4880, 1, 7], [4881, 1, 0], [4882, 4, 7], [4886, 2, 0], [4888, 7, 7], [4895, 1, 0], [4896, 39, 7],
        [4935, 1, 0], [4936, 19, 7], [4955, 6, 0], [4961, 8, 21], [4969, 9, 13], [4978, 11, 15], [4989, 35, 0], [5024, 85, 7],
        [5109, 12, 0], [5121, 620, 7], [5741, 2, 21], [5743, 8, 7], [5751, 9, 0], [5760, 1, 29], [5761, 26, 7], [5787, 1, 22],
        [5788, 1, 18], [5789, 3, 0], [5792, 75, 7], [5867, 3, 21], [5870, 3, 14], [5873, 15, 0], [5888, 13, 7], [5901, 1, 0],
        [5902, 4, 7], [5906, 3, 12], [5909, 11, 0], [5920, 18, 7], [5938, 3, 12], [5941, 2, 21], [5943, 9, 0], [5952, 18, 7],
        [5970, 2, 12], [5972, 12, 0], [5984, 13, 7], [5997, 1, 0], [5998, 3, 7], [6001, 1, 0], [6002, 2, 12], [6004, 12, 0],
        [6016, 52, 7], [6068, 3, 10], [6071, 7, 12], [6078, 8, 10], [6086, 1, 12], [6087, 2, 10], [6089, 11, 12], [6100, 3, 21],
        [6103, 1, 6], [6104, 3, 21], [6107, 1, 23], [6108, 1, 7], [6109, 3, 0], [6112, 10, 13], [6122, 22, 0], [6144, 6, 21],
        [6150, 1, 17], [6151, 4, 21], [6155, 3, 12], [6158, 1, 2], [6159, 1, 0], [6160, 10, 13], [6170, 6, 0], [6176, 35, 7],
        [6211, 1, 6], [6212, 52, 7], [6264, 8, 0], [6272, 41, 7], [6313, 1, 12], [6314, 1366, 0], [7680, 1, 9], [7681, 1, 5],
        [7682, 1, 9], [7683, 1, 5], [7684, 1, 9], [7685, 1, 5], [7686, 1, 9], [7687, 1, 5], [7688, 1, 9], [7689, 1, 5], [7690, 1, 9],
        [7691, 1, 5], [7692, 1, 9], [7693, 1, 5], [7694, 1, 9], [7695, 1, 5], [7696, 1, 9], [7697, 1, 5], [7698, 1, 9], [7699, 1, 5],
        [7700, 1, 9], [7701, 1, 5], [7702, 1, 9], [7703, 1, 5], [7704, 1, 9], [7705, 1, 5], [7706, 1, 9], [7707, 1, 5], [7708, 1, 9],
        [7709, 1, 5], [7710, 1, 9], [7711, 1, 5], [7712, 1, 9], [7713, 1, 5], [7714, 1, 9], [7715, 1, 5], [7716, 1, 9], [7717, 1, 5],
        [7718, 1, 9], [7719, 1, 5], [7720, 1, 9], [7721, 1, 5], [7722, 1, 9], [7723, 1, 5], [7724, 1, 9], [7725, 1, 5], [7726, 1, 9],
        [7727, 1, 5], [7728, 1, 9], [7729, 1, 5], [7730, 1, 9], [7731, 1, 5], [7732, 1, 9], [7733, 1, 5], [7734, 1, 9], [7735, 1, 5],
        [7736, 1, 9], [7737, 1, 5], [7738, 1, 9], [7739, 1, 5], [7740, 1, 9], [7741, 1, 5], [7742, 1, 9], [7743, 1, 5], [7744, 1, 9],
        [7745, 1, 5], [7746, 1, 9], [7747, 1, 5], [7748, 1, 9], [7749, 1, 5], [7750, 1, 9], [7751, 1, 5], [7752, 1, 9], [7753, 1, 5],
        [7754, 1, 9], [7755, 1, 5], [7756, 1, 9], [7757, 1, 5], [7758, 1, 9], [7759, 1, 5], [7760, 1, 9], [7761, 1, 5], [7762, 1, 9],
        [7763, 1, 5], [7764, 1, 9], [7765, 1, 5], [7766, 1, 9], [7767, 1, 5], [7768, 1, 9], [7769, 1, 5], [7770, 1, 9], [7771, 1, 5],
        [7772, 1, 9], [7773, 1, 5], [7774, 1, 9], [7775, 1, 5], [7776, 1, 9], [7777, 1, 5], [7778, 1, 9], [7779, 1, 5], [7780, 1, 9],
        [7781, 1, 5], [7782, 1, 9], [7783, 1, 5], [7784, 1, 9], [7785, 1, 5], [7786, 1, 9], [7787, 1, 5], [7788, 1, 9], [7789, 1, 5],
        [7790, 1, 9], [7791, 1, 5], [7792, 1, 9], [7793, 1, 5], [7794, 1, 9], [7795, 1, 5], [7796, 1, 9], [7797, 1, 5], [7798, 1, 9],
        [7799, 1, 5], [7800, 1, 9], [7801, 1, 5], [7802, 1, 9], [7803, 1, 5], [7804, 1, 9], [7805, 1, 5], [7806, 1, 9], [7807, 1, 5],
        [7808, 1, 9], [7809, 1, 5], [7810, 1, 9], [7811, 1, 5], [7812, 1, 9], [7813, 1, 5], [7814, 1, 9], [7815, 1, 5], [7816, 1, 9],
        [7817, 1, 5], [7818, 1, 9], [7819, 1, 5], [7820, 1, 9], [7821, 1, 5], [7822, 1, 9], [7823, 1, 5], [7824, 1, 9], [7825, 1, 5],
        [7826, 1, 9], [7827, 1, 5], [7828, 1, 9], [7829, 7, 5], [7836, 4, 0], [7840, 1, 9], [7841, 1, 5], [7842, 1, 9], [7843, 1, 5],
        [7844, 1, 9], [7845, 1, 5], [7846, 1, 9], [7847, 1, 5], [7848, 1, 9], [7849, 1, 5], [7850, 1, 9], [7851, 1, 5], [7852, 1, 9],
        [7853, 1, 5], [7854, 1, 9], [7855, 1, 5], [7856, 1, 9], [7857, 1, 5], [7858, 1, 9], [7859, 1, 5], [7860, 1, 9], [7861, 1, 5],
        [7862, 1, 9], [7863, 1, 5], [7864, 1, 9], [7865, 1, 5], [7866, 1, 9], [7867, 1, 5], [7868, 1, 9], [7869, 1, 5], [7870, 1, 9],
        [7871, 1, 5], [7872, 1, 9], [7873, 1, 5], [7874, 1, 9], [7875, 1, 5], [7876, 1, 9], [7877, 1, 5], [7878, 1, 9], [7879, 1, 5],
        [7880, 1, 9], [7881, 1, 5], [7882, 1, 9], [7883, 1, 5], [7884, 1, 9], [7885, 1, 5], [7886, 1, 9], [7887, 1, 5], [7888, 1, 9],
        [7889, 1, 5], [7890, 1, 9], [7891, 1, 5], [7892, 1, 9], [7893, 1, 5], [7894, 1, 9], [7895, 1, 5], [7896, 1, 9], [7897, 1, 5],
        [7898, 1, 9], [7899, 1, 5], [7900, 1, 9], [7901, 1, 5], [7902, 1, 9], [7903, 1, 5], [7904, 1, 9], [7905, 1, 5], [7906, 1, 9],
        [7907, 1, 5], [7908, 1, 9], [7909, 1, 5], [7910, 1, 9], [7911, 1, 5], [7912, 1, 9], [7913, 1, 5], [7914, 1, 9], [7915, 1, 5],
        [7916, 1, 9], [7917, 1, 5], [7918, 1, 9], [7919, 1, 5], [7920, 1, 9], [7921, 1, 5], [7922, 1, 9], [7923, 1, 5], [7924, 1, 9],
        [7925, 1, 5], [7926, 1, 9], [7927, 1, 5], [7928, 1, 9], [7929, 1, 5], [7930, 6, 0], [7936, 8, 5], [7944, 8, 9], [7952, 6, 5],
        [7958, 2, 0], [7960, 6, 9], [7966, 2, 0], [7968, 8, 5], [7976, 8, 9], [7984, 8, 5], [7992, 8, 9], [8000, 6, 5], [8006, 2, 0],
        [8008, 6, 9], [8014, 2, 0], [8016, 8, 5], [8024, 1, 0], [8025, 1, 9], [8026, 1, 0], [8027, 1, 9], [8028, 1, 0], [8029, 1, 9],
        [8030, 1, 0], [8031, 1, 9], [8032, 8, 5], [8040, 8, 9], [8048, 14, 5], [8062, 2, 0], [8064, 8, 5], [8072, 8, 8],
        [8080, 8, 5], [8088, 8, 8], [8096, 8, 5], [8104, 8, 8], [8112, 5, 5], [8117, 1, 0], [8118, 2, 5], [8120, 4, 9], [8124, 1, 8],
        [8125, 1, 24], [8126, 1, 5], [8127, 3, 24], [8130, 3, 5], [8133, 1, 0], [8134, 2, 5], [8136, 4, 9], [8140, 1, 8],
        [8141, 3, 24], [8144, 4, 5], [8148, 2, 0], [8150, 2, 5], [8152, 4, 9], [8156, 1, 0], [8157, 3, 24], [8160, 8, 5],
        [8168, 5, 9], [8173, 3, 24], [8176, 2, 0], [8178, 3, 5], [8181, 1, 0], [8182, 2, 5], [8184, 4, 9], [8188, 1, 8],
        [8189, 2, 24], [8191, 1, 0], [8192, 12, 29], [8204, 4, 2], [8208, 6, 17], [8214, 2, 21], [8216, 1, 20], [8217, 1, 19],
        [8218, 1, 22], [8219, 2, 20], [8221, 1, 19], [8222, 1, 22], [8223, 1, 20], [8224, 8, 21], [8232, 1, 27], [8233, 1, 28],
        [8234, 5, 2], [8239, 1, 29], [8240, 9, 21], [8249, 1, 20], [8250, 1, 19], [8251, 4, 21], [8255, 2, 16], [8257, 3, 21],
        [8260, 1, 25], [8261, 1, 22], [8262, 1, 18], [8263, 11, 21], [8274, 1, 25], [8275, 4, 0], [8279, 1, 21], [8280, 7, 0],
        [8287, 1, 29], [8288, 4, 2], [8292, 6, 0], [8298, 6, 2], [8304, 1, 15], [8305, 1, 5], [8306, 2, 0], [8308, 6, 15],
        [8314, 3, 25], [8317, 1, 22], [8318, 1, 18], [8319, 1, 5], [8320, 10, 15], [8330, 3, 25], [8333, 1, 22], [8334, 1, 18],
        [8335, 17, 0], [8352, 18, 23], [8370, 30, 0], [8400, 13, 12], [8413, 4, 11], [8417, 1, 12], [8418, 3, 11], [8421, 6, 12],
        [8427, 21, 0], [8448, 2, 26], [8450, 1, 9], [8451, 4, 26], [8455, 1, 9], [8456, 2, 26], [8458, 1, 5], [8459, 3, 9],
        [8462, 2, 5], [8464, 3, 9], [8467, 1, 5], [8468, 1, 26], [8469, 1, 9], [8470, 3, 26], [8473, 5, 9], [8478, 6, 26],
        [8484, 1, 9], [8485, 1, 26], [8486, 1, 9], [8487, 1, 26], [8488, 1, 9], [8489, 1, 26], [8490, 4, 9], [8494, 1, 26],
        [8495, 1, 5], [8496, 2, 9], [8498, 1, 26], [8499, 1, 9], [8500, 1, 5], [8501, 4, 7], [8505, 1, 5], [8506, 1, 26],
        [8507, 2, 0], [8509, 1, 5], [8510, 2, 9], [8512, 5, 25], [8517, 1, 9], [8518, 4, 5], [8522, 1, 26], [8523, 1, 25],
        [8524, 7, 0], [8531, 13, 15], [8544, 36, 14], [8580, 12, 0], [8592, 5, 25], [8597, 5, 26], [8602, 2, 25], [8604, 4, 26],
        [8608, 1, 25], [8609, 2, 26], [8611, 1, 25], [8612, 2, 26], [8614, 1, 25], [8615, 7, 26], [8622, 1, 25], [8623, 31, 26],
        [8654, 2, 25], [8656, 2, 26], [8658, 1, 25], [8659, 1, 26], [8660, 1, 25], [8661, 31, 26], [8692, 268, 25], [8960, 8, 26],
        [8968, 4, 25], [8972, 20, 26], [8992, 2, 25], [8994, 7, 26], [9001, 1, 22], [9002, 1, 18], [9003, 81, 26], [9084, 1, 25],
        [9085, 30, 26], [9115, 25, 25], [9140, 1, 22], [9141, 1, 18], [9142, 1, 21], [9143, 24, 26], [9167, 49, 0], [9216, 39, 26],
        [9255, 25, 0], [9280, 11, 26], [9291, 21, 0], [9312, 60, 15], [9372, 78, 26], [9450, 21, 15], [9471, 1, 0], [9472, 183, 26],
        [9655, 1, 25], [9656, 9, 26], [9665, 1, 25], [9666, 54, 26], [9720, 8, 25], [9728, 20, 26], [9748, 2, 0], [9750, 2, 26],
        [9752, 1, 0], [9753, 86, 26], [9839, 1, 25], [9840, 14, 26], [9854, 2, 0], [9856, 10, 26], [9866, 119, 0], [9985, 4, 26],
        [9989, 1, 0], [9990, 4, 26], [9994, 2, 0], [9996, 28, 26], [10024, 1, 0], [10025, 35, 26], [10060, 1, 0], [10061, 1, 26],
        [10062, 1, 0], [10063, 4, 26], [10067, 3, 0], [10070, 1, 26], [10071, 1, 0], [10072, 7, 26], [10079, 2, 0], [10081, 7, 26],
        [10088, 1, 22], [10089, 1, 18], [10090, 1, 22], [10091, 1, 18], [10092, 1, 22], [10093, 1, 18], [10094, 1, 22],
        [10095, 1, 18], [10096, 1, 22], [10097, 1, 18], [10098, 1, 22], [10099, 1, 18], [10100, 1, 22], [10101, 1, 18],
        [10102, 30, 15], [10132, 1, 26], [10133, 3, 0], [10136, 24, 26], [10160, 1, 0], [10161, 14, 26], [10175, 17, 0],
        [10192, 22, 25], [10214, 1, 22], [10215, 1, 18], [10216, 1, 22], [10217, 1, 18], [10218, 1, 22], [10219, 1, 18],
        [10220, 4, 0], [10224, 16, 25], [10240, 256, 26], [10496, 131, 25], [10627, 1, 22], [10628, 1, 18], [10629, 1, 22],
        [10630, 1, 18], [10631, 1, 22], [10632, 1, 18], [10633, 1, 22], [10634, 1, 18], [10635, 1, 22], [10636, 1, 18],
        [10637, 1, 22], [10638, 1, 18], [10639, 1, 22], [10640, 1, 18], [10641, 1, 22], [10642, 1, 18], [10643, 1, 22],
        [10644, 1, 18], [10645, 1, 22], [10646, 1, 18], [10647, 1, 22], [10648, 1, 18], [10649, 63, 25], [10712, 1, 22],
        [10713, 1, 18], [10714, 1, 22], [10715, 1, 18], [10716, 32, 25], [10748, 1, 22], [10749, 1, 18], [10750, 258, 25],
        [11008, 896, 0], [11904, 26, 26], [11930, 1, 0], [11931, 89, 26], [12020, 12, 0], [12032, 214, 26], [12246, 26, 0],
        [12272, 12, 26], [12284, 4, 0], [12288, 1, 29], [12289, 3, 21], [12292, 1, 26], [12293, 1, 6], [12294, 1, 7],
        [12295, 1, 14], [12296, 1, 22], [12297, 1, 18], [12298, 1, 22], [12299, 1, 18], [12300, 1, 22], [12301, 1, 18],
        [12302, 1, 22], [12303, 1, 18], [12304, 1, 22], [12305, 1, 18], [12306, 2, 26], [12308, 1, 22], [12309, 1, 18],
        [12310, 1, 22], [12311, 1, 18], [12312, 1, 22], [12313, 1, 18], [12314, 1, 22], [12315, 1, 18], [12316, 1, 17],
        [12317, 1, 22], [12318, 2, 18], [12320, 1, 26], [12321, 9, 14], [12330, 6, 12], [12336, 1, 17], [12337, 5, 6],
        [12342, 2, 26], [12344, 3, 14], [12347, 1, 6], [12348, 1, 7], [12349, 1, 21], [12350, 2, 26], [12352, 1, 0],
        [12353, 86, 7], [12439, 2, 0], [12441, 2, 12], [12443, 2, 24], [12445, 2, 6], [12447, 1, 7], [12448, 1, 17],
        [12449, 90, 7], [12539, 1, 16], [12540, 3, 6], [12543, 1, 7], [12544, 5, 0], [12549, 40, 7], [12589, 4, 0], [12593, 94, 7],
        [12687, 1, 0], [12688, 2, 26], [12690, 4, 15], [12694, 10, 26], [12704, 24, 7], [12728, 56, 0], [12784, 16, 7],
        [12800, 29, 26], [12829, 3, 0], [12832, 10, 15], [12842, 26, 26], [12868, 13, 0], [12881, 15, 15], [12896, 28, 26],
        [12924, 3, 0], [12927, 1, 26], [12928, 10, 15], [12938, 39, 26], [12977, 15, 15], [12992, 12, 26], [13004, 4, 0],
        [13008, 47, 26], [13055, 1, 0], [13056, 119, 26], [13175, 4, 0], [13179, 99, 26], [13278, 2, 0], [13280, 31, 26],
        [13311, 1, 0], [13312, 6582, 7], [19894, 74, 0], [19968, 20902, 7], [40870, 90, 0], [40960, 1165, 7], [42125, 3, 0],
        [42128, 55, 26], [42183, 1849, 0], [44032, 11264, 7], [55296, 1, 4], [55297, 894, 0], [56191, 2, 4], [56193, 126, 0],
        [56319, 2, 4], [56321, 1022, 0], [57343, 1, 4], [57344, 1, 3], [57345, 6398, 0], [63743, 1, 3], [63744, 302, 7],
        [64046, 2, 0], [64048, 59, 7], [64107, 149, 0], [64256, 7, 5], [64263, 12, 0], [64275, 5, 5], [64280, 5, 0],
        [64285, 1, 7], [64286, 1, 12], [64287, 10, 7], [64297, 1, 25], [64298, 13, 7], [64311, 1, 0], [64312, 5, 7],
        [64317, 1, 0], [64318, 1, 7], [64319, 1, 0], [64320, 2, 7], [64322, 1, 0], [64323, 2, 7], [64325, 1, 0], [64326, 108, 7],
        [64434, 33, 0], [64467, 363, 7], [64830, 1, 22], [64831, 1, 18], [64832, 16, 0], [64848, 64, 7], [64912, 2, 0],
        [64914, 54, 7], [64968, 40, 0], [65008, 12, 7], [65020, 1, 23], [65021, 3, 0], [65024, 16, 12], [65040, 16, 0],
        [65056, 4, 12], [65060, 12, 0], [65072, 1, 21], [65073, 2, 17], [65075, 2, 16], [65077, 1, 22], [65078, 1, 18],
        [65079, 1, 22], [65080, 1, 18], [65081, 1, 22], [65082, 1, 18], [65083, 1, 22], [65084, 1, 18], [65085, 1, 22],
        [65086, 1, 18], [65087, 1, 22], [65088, 1, 18], [65089, 1, 22], [65090, 1, 18], [65091, 1, 22], [65092, 1, 18],
        [65093, 2, 21], [65095, 2, 0], [65097, 4, 21], [65101, 3, 16], [65104, 3, 21], [65107, 1, 0], [65108, 4, 21],
        [65112, 1, 17], [65113, 1, 22], [65114, 1, 18], [65115, 1, 22], [65116, 1, 18], [65117, 1, 22], [65118, 1, 18],
        [65119, 3, 21], [65122, 1, 25], [65123, 1, 17], [65124, 3, 25], [65127, 1, 0], [65128, 1, 21], [65129, 1, 23],
        [65130, 2, 21], [65132, 4, 0], [65136, 5, 7], [65141, 1, 0], [65142, 135, 7], [65277, 2, 0], [65279, 1, 2], [65280, 1, 0],
        [65281, 3, 21], [65284, 1, 23], [65285, 3, 21], [65288, 1, 22], [65289, 1, 18], [65290, 1, 21], [65291, 1, 25],
        [65292, 1, 21], [65293, 1, 17], [65294, 2, 21], [65296, 10, 13], [65306, 2, 21], [65308, 3, 25], [65311, 2, 21],
        [65313, 26, 9], [65339, 1, 22], [65340, 1, 21], [65341, 1, 18], [65342, 1, 24], [65343, 1, 16], [65344, 1, 24],
        [65345, 26, 5], [65371, 1, 22], [65372, 1, 25], [65373, 1, 18], [65374, 1, 25], [65375, 1, 22], [65376, 1, 18],
        [65377, 1, 21], [65378, 1, 22], [65379, 1, 18], [65380, 1, 21], [65381, 1, 16], [65382, 10, 7], [65392, 1, 6],
        [65393, 45, 7], [65438, 2, 6], [65440, 31, 7], [65471, 3, 0], [65474, 6, 7], [65480, 2, 0], [65482, 6, 7], [65488, 2, 0],
        [65490, 6, 7], [65496, 2, 0], [65498, 3, 7], [65501, 3, 0], [65504, 2, 23], [65506, 1, 25], [65507, 1, 24], [65508, 1, 26],
        [65509, 2, 23], [65511, 1, 0], [65512, 1, 26], [65513, 4, 25], [65517, 2, 26], [65519, 10, 0], [65529, 3, 2],
        [65532, 2, 26], [65534, 770, 0], [66304, 31, 7], [66335, 1, 0], [66336, 4, 15], [66340, 12, 0], [66352, 26, 7],
        [66378, 1, 14], [66379, 181, 0], [66560, 38, 9], [66598, 2, 0], [66600, 38, 5], [66638, 52146, 0], [118784, 246, 26],
        [119030, 10, 0], [119040, 39, 26], [119079, 3, 0], [119082, 59, 26], [119141, 2, 10], [119143, 3, 12], [119146, 3, 26],
        [119149, 6, 10], [119155, 8, 2], [119163, 8, 12], [119171, 2, 26], [119173, 7, 12], [119180, 30, 26], [119210, 4, 12],
        [119214, 48, 26], [119262, 546, 0], [119808, 26, 9], [119834, 26, 5], [119860, 26, 9], [119886, 7, 5], [119893, 1, 0],
        [119894, 18, 5], [119912, 26, 9], [119938, 26, 5], [119964, 1, 9], [119965, 1, 0], [119966, 2, 9], [119968, 2, 0],
        [119970, 1, 9], [119971, 2, 0], [119973, 2, 9], [119975, 2, 0], [119977, 4, 9], [119981, 1, 0], [119982, 8, 9],
        [119990, 4, 5], [119994, 1, 0], [119995, 1, 5], [119996, 1, 0], [119997, 4, 5], [120001, 1, 0], [120002, 2, 5],
        [120004, 1, 0], [120005, 11, 5], [120016, 26, 9], [120042, 26, 5], [120068, 2, 9], [120070, 1, 0], [120071, 4, 9],
        [120075, 2, 0], [120077, 8, 9], [120085, 1, 0], [120086, 7, 9], [120093, 1, 0], [120094, 26, 5], [120120, 2, 9],
        [120122, 1, 0], [120123, 4, 9], [120127, 1, 0], [120128, 5, 9], [120133, 1, 0], [120134, 1, 9], [120135, 3, 0],
        [120138, 7, 9], [120145, 1, 0], [120146, 26, 5], [120172, 26, 9], [120198, 26, 5], [120224, 26, 9], [120250, 26, 5],
        [120276, 26, 9], [120302, 26, 5], [120328, 26, 9], [120354, 26, 5], [120380, 26, 9], [120406, 26, 5], [120432, 26, 9],
        [120458, 26, 5], [120484, 4, 0], [120488, 25, 9], [120513, 1, 25], [120514, 25, 5], [120539, 1, 25], [120540, 6, 5],
        [120546, 25, 9], [120571, 1, 25], [120572, 25, 5], [120597, 1, 25], [120598, 6, 5], [120604, 25, 9], [120629, 1, 25],
        [120630, 25, 5], [120655, 1, 25], [120656, 6, 5], [120662, 25, 9], [120687, 1, 25], [120688, 25, 5], [120713, 1, 25],
        [120714, 6, 5], [120720, 25, 9], [120745, 1, 25], [120746, 25, 5], [120771, 1, 25], [120772, 6, 5], [120778, 4, 0],
        [120782, 50, 13], [120832, 10240, 0], [131072, 1, 7], [131073, 42709, 0], [173782, 1, 7], [173783, 20777, 0],
        [194560, 542, 7], [195102, 722403, 0], [917505, 1, 2], [917506, 30, 0], [917536, 96, 2]
    ]);

    export abstract class Cat {
        /**
         * Copyright (C) 2013 Edwin Bhler. All Rights Reserved.
         * @author Edwin Bhler
         */

        /// This Implementation is based on the algorithm by the Squeak/Pharo Smalltalk Unicode class.

        /**
         * This library is a workaround for non ascii characters.
         *
         * Some simple functions like isLetter(int charCode) checking a unicode
         * table with a given unicode value.
         *
         * ### Functions
         *
         *     bool isLetter(int c);
         *     bool isUppercase(int c);
         *     bool isLowercase(int c);
         *     bool isDigit(int c);
         *     bool isCurrency(int c);
         *     bool isSeparator(int c);
         *     bool isControl(int c);
         *
         */

        /*
        Lu Letter, Uppercase
        Ll Letter, Lowercase
        Lt Letter, Titlecase
        Lm Letter, Modifier
        Lo Letter, Other
        Mn Mark, Non-Spacing
        Mc Mark, Spacing Combining
        Me Mark, Enclosing
        Nd Number, Decimal
        Nl Number, Letter
        No Number, Other
        Pc Punctuation, Connector
        Pd Punctuation, Dash
        Ps Punctuation, Open
        Pe Punctuation, Close
        Pi Punctuation, Initial quote (may behave like Ps or Pe depending on usage)
        Pf Punctuation, Final quote (may behave like Ps or Pe depending on usage)
        Po Punctuation, Other
        Sm Symbol, Math
        Sc Symbol, Currency
        Sk Symbol, Modifier
        So Symbol, Other
        Zs Separator, Space
        Zl Separator, Line
        Zp Separator, Paragraph
        Cc Other, Control
        Cf Other, Format
        Cs Other, Surrogate
        Co Other, Private Use
        Cn Other, Not Assigned (no characters in the file have this property)

          Correlated with Unicode 3.2
          Start Code..End Code; Block Name
        0000..007F; Basic Latin
        0080..00FF; Latin-1 Supplement
        0100..017F; Latin Extended-A
        0180..024F; Latin Extended-B
        0250..02AF; IPA Extensions
        02B0..02FF; Spacing Modifier Letters
        0300..036F; Combining Diacritical Marks
        0370..03FF; Greek and Coptic
        0400..04FF; Cyrillic
        0500..052F; Cyrillic Supplementary
        0530..058F; Armenian
        0590..05FF; Hebrew
        0600..06FF; Arabic
        0700..074F; Syriac
        0780..07BF; Thaana
        0900..097F; Devanagari
        0980..09FF; Bengali
        0A00..0A7F; Gurmukhi
        0A80..0AFF; Gujarati
        0B00..0B7F; Oriya
        0B80..0BFF; Tamil
        0C00..0C7F; Telugu
        0C80..0CFF; Kannada
        0D00..0D7F; Malayalam
        0D80..0DFF; Sinhala
        0E00..0E7F; Thai
        0E80..0EFF; Lao
        0F00..0FFF; Tibetan
        1000..109F; Myanmar
        10A0..10FF; Georgian
        1100..11FF; Hangul Jamo
        1200..137F; Ethiopic
        13A0..13FF; Cherokee
        1400..167F; Unified Canadian Aboriginal Syllabics
        1680..169F; Ogham
        16A0..16FF; Runic
        1700..171F; Tagalog
        1720..173F; Hanunoo
        1740..175F; Buhid
        1760..177F; Tagbanwa
        1780..17FF; Khmer
        1800..18AF; Mongolian
        1E00..1EFF; Latin Extended Additional
        1F00..1FFF; Greek Extended
        2000..206F; General Punctuation
        2070..209F; Superscripts and Subscripts
        20A0..20CF; Currency Symbols
        20D0..20FF; Combining Diacritical Marks for Symbols
        2100..214F; Letterlike Symbols
        2150..218F; Number Forms
        2190..21FF; Arrows
        2200..22FF; Mathematical Operators
        2300..23FF; Miscellaneous Technical
        2400..243F; Control Pictures
        2440..245F; Optical Character Recognition
        2460..24FF; Enclosed Alphanumerics
        2500..257F; Box Drawing
        2580..259F; Block Elements
        25A0..25FF; Geometric Shapes
        2600..26FF; Miscellaneous Symbols
        2700..27BF; Dingbats
        27C0..27EF; Miscellaneous Mathematical Symbols-A
        27F0..27FF; Supplemental Arrows-A
        2800..28FF; Braille Patterns
        2900..297F; Supplemental Arrows-B
        2980..29FF; Miscellaneous Mathematical Symbols-B
        2A00..2AFF; Supplemental Mathematical Operators
        2E80..2EFF; CJK Radicals Supplement
        2F00..2FDF; Kangxi Radicals
        2FF0..2FFF; Ideographic Description Characters
        3000..303F; CJK Symbols and Punctuation
        3040..309F; Hiragana
        30A0..30FF; Katakana
        3100..312F; Bopomofo
        3130..318F; Hangul Compatibility Jamo
        3190..319F; Kanbun
        31A0..31BF; Bopomofo Extended
        31F0..31FF; Katakana Phonetic Extensions
        3200..32FF; Enclosed CJK Letters and Months
        3300..33FF; CJK Compatibility
        3400..4DBF; CJK Unified Ideographs Extension A
        4E00..9FFF; CJK Unified Ideographs
        A000..A48F; Yi Syllables
        A490..A4CF; Yi Radicals
        AC00..D7AF; Hangul Syllables
        D800..DB7F; High Surrogates
        DB80..DBFF; High Private Use Surrogates
        DC00..DFFF; Low Surrogates
        E000..F8FF; Private Use Area
        F900..FAFF; CJK Compatibility Ideographs
        FB00..FB4F; Alphabetic Presentation Forms
        FB50..FDFF; Arabic Presentation Forms-A
        FE00..FE0F; Variation Selectors
        FE20..FE2F; Combining Half Marks
        FE30..FE4F; CJK Compatibility Forms
        FE50..FE6F; Small Form Variants
        FE70..FEFF; Arabic Presentation Forms-B
        FF00..FFEF; Halfwidth and Fullwidth Forms
        FFF0..FFFF; Specials
        10300..1032F; Old Italic
        10330..1034F; Gothic
        10400..1044F; Deseret
        1D000..1D0FF; Byzantine Musical Symbols
        1D100..1D1FF; Musical Symbols
        1D400..1D7FF; Mathematical Alphanumeric Symbols
        20000..2A6DF; CJK Unified Ideographs Extension B
        2F800..2FA1F; CJK Compatibility Ideographs Supplement
        E0000..E007F; Tags
        F0000..FFFFF; Supplementary Private Use Area-A
        100000..10FFFF; Supplementary Private Use Area-B
         */

        static readonly Cn = 0;
        static readonly Cc = 1;
        static readonly Cf = 2;
        static readonly Co = 3;
        static readonly Cs = 4;
        static readonly Ll = 5;
        static readonly Lm = 6;
        static readonly Lo = 7;
        static readonly Lt = 8;
        static readonly Lu = 9;
        static readonly Mc = 10;
        static readonly Me = 11;
        static readonly Mn = 12;
        static readonly Nd = 13;
        static readonly Nl = 14;
        static readonly No = 15;
        static readonly Pc = 16;
        static readonly Pd = 17;
        static readonly Pe = 18;
        static readonly Pf = 19;
        static readonly Pi = 20;
        static readonly Po = 21;
        static readonly Ps = 22;
        static readonly Sc = 23;
        static readonly Sk = 24;
        static readonly Sm = 25;
        static readonly So = 26;
        static readonly Zl = 27;
        static readonly Zp = 28;
        static readonly Zs = 29;

    }

    export function unicodeCat_(c: Int): Int {
        return unicodeCharacterCategory.elementAt(c);
    }

    export function isValidUnicode_(c: Int): boolean {
        const cat = unicodeCharacterCategory.elementAt(c);
        return (cat > Unicode$.Cat.Cn) && (cat <= Unicode$.Cat.Zs);
    }
}

type TestResult = string | string[] | JSONObjectX;

class CF {
    static readonly HOST = "localhost";

    static readonly SCHEME = "http";
    static readonly HOSTPORT = "localhost:8080";
    static readonly SCHEME_HOSTPORT = "http://localhost:8080";
    static readonly SCHEME_HOSTPORT_ = "http://localhost:8080/";
    static readonly PORT = 8080;

}

abstract class RS {
    static readonly Tooltips_ColorOrange = "XxXQW";
    static readonly Tooltips_ConvertSpacesToNonBreakSpaces = "XxXFw";
    static readonly VERY_HARD = "XxXsD";
    static readonly FileNotFound = "XxX04";
    static readonly ActionPlayAllPauseTooltips = "XxXpam";
    static readonly ANextPageLinkAlreadyExists = "XxXmi";
    static readonly Tooltips_ShowKeyboard = "XxXK8";
    static readonly Tooltips_Help = "XxXOw";
    static readonly Tooltips_ShowContextmenu = "XxXtQ";
    static readonly ChangesNotPersistedToStylesheetFile_ = "XxXKQ";
    static readonly ClickToDismiss = "XxXLB";
    static readonly PleaseWaitWhileProcessingData = "XxXxP";
    static readonly widgetPictureFrameTitle = "XxX6M";
    static readonly Tomorrow = "XxXpP";
    static readonly ErrorFindingFiles_ = "XxXDT";
    static readonly Tooltips_CopySelection = "XxX7Y";
    static readonly action_ListText = "XxXuS";
    static readonly Tooltips_ExtendSelection = "XxXsS";
    static readonly TagIsRequired = "XxXl1";
    static readonly Tooltips_SelectAnAreaForImport = "XxXZc";
    static readonly Action_Cancelled = "XxXbg";
    static readonly ToasterHint = "XxXmg";
    static readonly action_AnnotationShow = "XxX9v";
    static readonly YouMustLoginToImportEvents = "XxXSh";
    static readonly widgetFlexboxStyleBasic = "XxXwH";
    static readonly Height = "XxXls";
    static readonly ErrorDecodingAnnotation = "XxXfZ";
    static readonly action_InsertElementChild = "XxXjp";
    static readonly Converting = "XxXhs";
    static readonly AssertExpectingStringListOrMap_ = "XxX1g";
    static readonly ActionRequireASingleNodeOrACollapsedSelection = "XxXdu";
    static readonly Dirs = "XxXWr";
    static readonly Tooltips_PreviousBlog = "XxX4V";
    static readonly promptDimensionMessage = "XxXO0";
    static readonly Tooltips_EmbedImage = "XxX6e";
    static readonly DocumentIsNotEditable = "XxXqp";
    static readonly Kind = "XxXbE";
    static readonly Tooltips_ImportImageToTheSpecifiedPath = "XxXOX";
    static readonly Tooltips_TextShadow = "XxXvR";
    static readonly Scribbler_GridMessage = "XxXST";
    static readonly BackupKeyRegenerateMessage = "XxXSQ";
    static readonly Filter_opacity = "XxXZm";
    static readonly BarcodeNotFound = "XxXVS";
    static readonly AudioChannels = "XxXAe";
    static readonly ThereIsNoNextSibling = "XxXLI";
    static readonly action_AnnotateImage = "XxXE1";
    static readonly LeftAndRightSidepanelAlreadyExistsAbort = "XxX2Y";
    static readonly Cut_ = "XxXmm";
    static readonly RepeatMonthlyMarker = "XxXpq";
    static readonly Tooltips_PasteSymbol = "XxXOK";
    static readonly TemplateMarkerNotFound = "XxXF7";
    static readonly deletedFiles = "XxX7V";
    static readonly RecentsNoMoreHistoryAvailable = "XxXBW";
    static readonly EnterFilepath = "XxXXQ";
    static readonly Tooltips_ImportExportMove = "XxXkd";
    static readonly AudioPlaybackNotInProgress = "XxXcD";
    static readonly Center = "XxXTn";
    static readonly widgetStickerTitle = "XxXaS";
    static readonly CreateEventTitle = "XxXxK";
    static readonly Backspace = "XxXG1";
    static readonly OriginalSize = "XxXgT";
    static readonly action_RemoveStyle = "XxXe7";
    static readonly Scribbler_MissingImageURI = "XxXQ2";
    static readonly Tooltips_InsertImageElement = "XxXZa";
    static readonly AddCSSRuleTitle = "XxXTp";
    static readonly Tooltips_AlignLeft = "XxXAW";
    static readonly ReadingPassEndOfFile_ = "XxX1l";
    static readonly Tooltips_Keyboard = "XxX1T";
    static readonly Tooltips_Games = "XxXh4";
    static readonly ErrorCreatingDocumentFromTemplate = "XxXcn";
    static readonly ConfirmDeletingRecursively = "XxX1q";
    static readonly Tooltips_RebuildKeywordSearchIndex = "XxXf9";
    static readonly history_calcTotal = "XxXCv";
    static readonly ErrorUpdatingSettings = "XxXYQ";
    static readonly DestinationExistsNotOverwriting = "XxXenw";
    static readonly ErrorRemovingEvents = "XxXcr";
    static readonly EditBGImageMessage = "XxXnX";
    static readonly InsertLinkTitle = "XxX4o";
    static readonly FilenameMustNotBeEmpty = "XxX4p";
    static readonly InvalidLineNumber = "XxXXn";
    static readonly app_name = "XxXFJ";
    static readonly ActionRequireDocumentVersion_0_OrAbove = "XxXVX";
    static readonly Tooltips_ImportAudio = "XxXYM";
    static readonly MissingImageInfoSize = "XxXaX";
    static readonly Tooltips_EnterAsText = "XxXOH";
    static readonly CannotDeleteTopOrRootDirectory = "XxXgZ";
    static readonly Tooltips_RelativePath = "XxXyU";
    static readonly XrefsRefBy = "XxXxrb";
    static readonly Rotation = "XxX1i";
    static readonly InvalidImagePath_ = "XxXbQ";
    static readonly BoxShadow = "XxXX9";
    static readonly AudioRecordingStopFailed = "XxXdp";
    static readonly Tooltips_Annotation = "XxXpo";
    static readonly DeselectAll = "XxX3q";
    static readonly Dimension = "XxX6x";
    static readonly ExpectingImageExt = "XxXWL";
    static readonly ColorStops = "XxXrP";
    static readonly URL = "XxXn6";
    static readonly ClientActionClassesPlaceholder = "XxXCt";
    static readonly Tooltips_ImageConversion = "XxX9o";
    static readonly UnsupportedFileType_ = "XxXusf";
    static readonly AssertInvalidPathKind_ = "XxXRY";
    static readonly Tooltips_InsertLinebreak = "XxXpF";
    static readonly widgetFlexboxTitle = "XxXc6";
    static readonly TextBullet_Title = "XxXGq";
    static readonly Test = "XxXKR";
    static readonly ResetUserSettingsTitle = "XxXcm";
    static readonly Enable = "XxXO8";
    static readonly action_Delete = "XxXIe";
    static readonly Fragment = "XxXwd";
    static readonly ErrorReading_ = "XxXUo";
    static readonly ColorAnnotation = "XxXtq";
    static readonly Description = "XxXta";
    static readonly history_placeholder = "XxXJo";
    static readonly Help_AddCSSRuleMessage = "XxX9L";
    static readonly FactoryResetTooltips = "XxXSn";
    static readonly On = "XxXjw";
    static readonly Dimensions = "XxXpr";
    static readonly CannotRepositionResizeOrRotateElement = "XxXat";
    static readonly PromptCopyNotWritable1 = "XxXgm";
    static readonly ConfirmBackupKeyTo_ = "XxX9S";
    static readonly action_Rotate = "XxX0T";
    static readonly EditAlign = "XxXFW";
    static readonly Result1 = "XxXrok";
    static readonly ErrorStartingAudioRecording = "XxXrH";
    static readonly StyleEditorHint = "XxXIZ";
    static readonly hints = "XxXQD";
    static readonly Tooltips_AddPrevPageLink = "XxXc2";
    static readonly ButtonDataUrlTooltips = "XxX6d";
    static readonly FailedToCreateCipherOutputStream = "XxX6Z";
    static readonly NotFound = "XxXwY";
    static readonly FilesRecursive = "XxXBE";
    static readonly widgetTodoTitle = "XxXFn";
    static readonly Checksum = "XxXHb";
    static readonly Key = "XxXUr";
    static readonly ActionCancelled = "XxXRQ";
    static readonly NoImageInfoAvailable = "XxXB0";
    static readonly InvalidDocument = "XxXXT";
    static readonly Tooltips_CutDone = "XxXWc";
    static readonly TimeZone = "XxXtzz";
    static readonly action_EditElement = "XxXsh";
    static readonly FailedToEncrypt_ = "XxXXf";
    static readonly Tooltips_Symbols = "XxXgp";
    static readonly EditStyleTitle = "XxXIE";
    static readonly Tooltips_Discard = "XxX78";
    static readonly widgetAnnotationImageTitle = "XxX4O";
    static readonly MissingOperandFor_ = "XxXoq";
    static readonly Orientation = "XxXnC";
    static readonly Recursive = "XxXNf";
    static readonly Tooltips_ColorNames = "XxXD4";
    static readonly Files = "XxXmO";
    static readonly widgetTocTitle = "XxXNF";
    static readonly PleaseSpecifyAnImageUri = "XxX88";
    static readonly deleteFile = "XxXfm";
    static readonly ThumbnailLarge = "XxXV3";
    static readonly Text = "XxXSg";
    static readonly LicenseNotValid = "XxXkT";
    static readonly Tooltips_FontStyles = "XxXfp";
    static readonly Name = "XxXwp";
    static readonly RecognizeTextNotFound = "XxXln";
    static readonly InvalidSelection = "XxXX1";
    static readonly widgetTodoDesc = "XxXtL";
    static readonly RequireBiometric = "XxXv4";
    static readonly Scribbler_MissingSourceImage = "XxXMg";
    static readonly PromptSidebarTabTitle = "XxXy2";
    static readonly ZIndex = "XxXCg";
    static readonly ConfirmSaveOrDiscard = "XxX6u";
    static readonly Tooltips_DrawRectangles = "XxXiq";
    static readonly ActionRequireMultipleElementsOrACollapsedSelection = "XxX35";
    static readonly LiteOperationNotAvailable = "XxXj8";
    static readonly Tooltips_PasteFromSystemClipboard = "XxXsd";
    static readonly Tooltips_TextColor = "XxXlw";
    static readonly PromptCopyCancelled = "XxXQN";
    static readonly ToggleAll = "XxXL3";
    static readonly action_MoveToParent = "XxXSL";
    static readonly Rules = "XxXTt";
    static readonly ReachedStartOfDocument = "XxXtr";
    static readonly TimeZoneLocal = "XxXtzl";
    static readonly UnsupportedBackupArchiveVersion_ = "XxXLz";
    static readonly failedToCreateElement_ = "XxXtZ";
    static readonly VideoNotFound = "XxXq6";
    static readonly Tooltips_FilesPanel = "XxXsx";
    static readonly DestinationNotWritable = "XxXdnw";
    static readonly Tooltips_InsertSymbol = "XxXen";
    static readonly BackdropFilter = "XxXTz";
    static readonly Tooltips_RecordVideo = "XxXWw";
    static readonly PasswordNotMatch = "XxXV6";
    static readonly ErrorReadingCachedThumbnail_ = "XxX6A";
    static readonly Tooltips_ListWithDateBullet = "XxXWb";
    static readonly SearchAborted = "XxXFx";
    static readonly InsertImageTitle = "XxX6n";
    static readonly Tooltips_ListItemWithSymbolBullet = "XxXlK";
    static readonly Tooltips_ImageViewerContextmenu = "XxXwJ";
    static readonly Tooltips_CollapseAll = "XxX9G";
    static readonly Tooltips_RegexSearch = "XxXv6";
    static readonly InsertTextHere = "XxXYm";
    static readonly widgetSidebarTabTitle = "XxX1N";
    static readonly DestinationExpectingAFile = "XxXZH";
    static readonly FilenameMustNotEndsWithSpaces = "XxXVQ";
    static readonly CorrectionOptionCorrectPerspective = "XxXDZ";
    static readonly Tooltips_SearchFilename = "XxXL2";
    static readonly ActionFixBrokenLinksKnownGoodDir = "XxXfbm";
    static readonly ScribblerText = "XxXr4";
    static readonly ActionPlayAllNextMediaTooltips = "XxXpan";
    static readonly ThereIsNoPreviousSibling = "XxXZK";
    static readonly Tooltips_ShowInitialSelection = "XxXhP";
    static readonly Tooltips_MoveDown = "XxXMU";
    static readonly Tooltips_ColorPlum = "XxXED";
    static readonly action_InsertLink = "XxXSE";
    static readonly FilepathInputMustNotBeEmpty = "XxXus";
    static readonly Tooltips_ShowOrHideDoneEvents = "XxXDr";
    static readonly ConfirmDeletingRuleset = "XxXXV";
    static readonly DesktopOperationTakePhotoNotAvailable = "XxXyX";
    static readonly PickFile = "XxXSb";
    static readonly LiteOperationRecordVideoNotAvailable = "XxXtH";
    static readonly InvalidRegex_ = "XxX5D";
    static readonly MatchFound = "XxXhV";
    static readonly Tooltips_Settings = "XxXyJ";
    static readonly Tooltips_PickFromSamples = "XxXfJ";
    static readonly SamplePerSecond = "XxXYd";
    static readonly Tooltips_HideSelection = "XxXPD";
    static readonly BackupKeyManagerTitle = "XxXww";
    static readonly Tooltips_CharacterStyles = "XxXzD";
    static readonly ScribblerPolygon = "XxXkh";
    static readonly ExportToPhotoLibraryOK = "XxXXN";
    static readonly XrefsInuse = "XxXxri";
    static readonly EnterLoginPassword = "XxX17";
    static readonly GameMinesNewGame = "XxX19";
    static readonly GradientRadial = "XxXNB";
    static readonly ActionFixBrokenLinksTooltips = "XxXftp";
    static readonly Tooltips_InsertNonBreakSpace = "XxXBM";
    static readonly AsIs = "XxXHm";
    static readonly Allow = "XxXIX";
    static readonly Tooltips_UndoHistory = "XxXWH";
    static readonly APrevPageLinkAlreadyExists = "XxXiW";
    static readonly BackupForward = "XxXwL";
    static readonly ConfirmOverwriting = "XxXLr";
    static readonly Tooltips_GotoTargetDocumentDirectory = "XxXOQ";
    static readonly LiteOperationDrawingCanvasNotAvailable = "XxXX4";
    static readonly ConfirmUnlinkStylesheet = "XxXh8";
    static readonly AudioUsingSampleAsPlaceholder = "XxX4f";
    static readonly Moving = "XxXMm";
    static readonly TemplateShoppingTitle = "XxXlD";
    static readonly ErrorUpdatingEvents = "XxX8P";
    static readonly Error = "XxXN3";
    static readonly AssertFail_ = "XxXqF";
    static readonly ExpectingCSSExt_ = "XxXAs";
    static readonly Font = "XxXR2";
    static readonly DirsRecursive = "XxXyF";
    static readonly NoEnclosingBlockElementFound = "XxXP2";
    static readonly PreserveExisting = "XxXvH";
    static readonly InvalidCSSClassName = "XxXaV";
    static readonly NotDeletable = "XxXt7";
    static readonly VideoQualityDefault = "XxXjl";
    static readonly Total_files = "XxX4T";
    static readonly DestinationNotValid = "XxX2R";
    static readonly AddStylesheetMessage = "XxX8Q";
    static readonly CopiedToLocalClipboard_ = "XxXJq";
    static readonly Tooltips_DrawPolylineOrPolygons = "XxXqw";
    static readonly EASY = "XxXxf";
    static readonly PleaseWaitWhileIndexerIsBusy = "XxXbM";
    static readonly PlaceholderOptional = "XxXjY";
    static readonly Tooltips_SetBackgroundColor = "XxXQ8";
    static readonly Tooltips_RecentsPanel = "XxXFI";
    static readonly GameStateRestored = "XxXO3";
    static readonly ImageArea = "XxXnH";
    static readonly Tooltips_InsertParagraph = "XxXnd";
    static readonly GradientFarthestCorner = "XxX6b";
    static readonly action_Reposition = "XxXkC";
    static readonly Custom = "XxXSi";
    static readonly action_DestructSplitpanel = "XxXoS";
    static readonly Tooltips_ColorGray = "XxX3Z";
    static readonly Adjust = "XxXP5";
    static readonly ErrorRestoringEvents = "XxXUG";
    static readonly Tooltips_DocumentLinks = "XxX7w";
    static readonly DirectoryMustUnderHome = "XxXiJ";
    static readonly SourceDirectory = "XxXez";
    static readonly SizePosition = "XxXFP";
    static readonly AudioRecordingAlreadyInProgress = "XxXW3";
    static readonly TakePhotoTitle = "XxXIx";
    static readonly Tooltips_TakePhotoAndImportToSpecifiedPath = "XxXf5";
    static readonly Repeat = "XxXK6";
    static readonly FilenameMustNotBeNull = "XxXn7";
    static readonly ClipboardPasteStringOnly = "XxXIJ";
    static readonly Tooltips_Superscript = "XxXBO";
    static readonly Clear = "XxXjD";
    static readonly Tooltips_Fit = "XxX06";
    static readonly GameMinesInstruction = "XxXFy";
    static readonly DestinationNotDeletable = "XxXUf";
    static readonly InvalidUriChar_ = "XxXqR";
    static readonly Version = "XxXuw";
    static readonly CancelEdit = "XxXoQ";
    static readonly ScribblerBackground = "XxXWh";
    static readonly Tooltips_RemoveStyles = "XxX0F";
    static readonly Tooltips_SaveAndQuitEditing = "XxXi8";
    static readonly action_EditAlign = "XxXAG";
    static readonly Confirm = "XxXnq";
    static readonly PleaseEnterSearchText = "XxXm0";
    static readonly RecipientsSelected = "XxXrO";
    static readonly HighlightColor = "XxXIT";
    static readonly Tooltips_NewGame = "XxXs5";
    static readonly ReplaceSymbolTitle = "XxXd7";
    static readonly NotCopying = "XxX3R";
    static readonly Tooltips_ImportPDF = "XxXFk";
    static readonly PromptCanvasTitle = "XxXo8";
    static readonly Paragraph = "XxXet";
    static readonly widgetGlassTitle = "XxXvQ";
    static readonly AssertSettingsMustNotBeNull = "XxXMy";
    static readonly PosterAt = "XxX9P";
    static readonly NothingToDelete = "XxXIs";
    static readonly InvalidOutputPath_ = "XxXk9";
    static readonly FailedToDecryptData = "XxXDG";
    static readonly elementNotEditable_ = "XxXeT";
    static readonly Tooltips_ClearCanvasAndDrawingHistory = "XxXDB";
    static readonly TemplateMemoTitle = "XxXV8";
    static readonly Tooltips_InsertDateTimeString = "XxXli";
    static readonly Filter_invert = "XxXQz";
    static readonly ErrorSavingRecentsList = "XxXgt";
    static readonly FailedToWriteTo_ = "XxXnF";
    static readonly InvalidDataUrl = "XxXof";
    static readonly Login = "XxXyj";
    static readonly Size = "XxXCJ";
    static readonly Border = "XxX5g";
    static readonly EventsRepeatEveryWorkdayNotSupported = "XxXWN";
    static readonly ScribblerEllipse = "XxX1S";
    static readonly Tooltips_Contextmenu = "XxXYa";
    static readonly EditBGImageTitle = "XxXgI";
    static readonly app_name_lite = "XxXie";
    static readonly FontSample = "XxXav";
    static readonly InvalidTemplate = "XxXKn";
    static readonly Operator = "XxX1c";
    static readonly Tooltips_ShowBackground = "XxX5n";
    static readonly Theme_Light = "XxXLv";
    static readonly BorderLeft = "XxXel";
    static readonly Tooltips_RemoveEmptyDirs = "XxXqD";
    static readonly ErrorCreatingCacheFile = "XxX40";
    static readonly AudioRecorderMaxDurationReached = "XxXcz";
    static readonly BackupConversionTooltips = "XxXtO";
    static readonly Tooltips_OK = "XxXhl";
    static readonly CopyOK = "XxXmq";
    static readonly ReplacedSymbol_ = "XxXwC";
    static readonly Tooltips_Filterbar = "XxXee";
    static readonly EditDrawingTitle = "XxX7K";
    static readonly action_InsertImage = "XxXdk";
    static readonly Tooltips_SearchRegex = "XxXNQ";
    static readonly Tooltips_ListWithoutBulletAndIndent = "XxX0G";
    static readonly WxH = "XxXgY";
    static readonly Tooltips_ImportExportCopy = "XxXY0";
    static readonly CreateDirectoryFailed_ = "XxXK4";
    static readonly DestinationNotWritableFile = "XxXl9";
    static readonly BackupFilenameMismatch = "XxXbH";
    static readonly ErrorPostingEvent = "XxXqE";
    static readonly Disallow = "XxXqA";
    static readonly Tooltips_AlignCenter = "XxXXi";
    static readonly Tooltips_SaveAndQuit = "XxXRw";
    static readonly sec = "XxX0v";
    static readonly Tooltips_ExportToBackupDirectories = "XxX3a";
    static readonly SourceNotReadable = "XxXXd";
    static readonly StickOnScreen = "XxXTl";
    static readonly InsertAudioTitle = "XxXtU";
    static readonly AudioNotFound = "XxX7s";
    static readonly ExpectingCSS = "XxXfC";
    static readonly Tooltips_Logout = "XxX0i";
    static readonly action_EditLink = "XxXKc";
    static readonly PasswordTooShort_ = "XxXg6";
    static readonly InvalidDimensionAbort = "XxXKp";
    static readonly EnterPassword = "XxXRa";
    static readonly Tooltips_ExpandAll = "XxXpz";
    static readonly action_EditRawStyle = "XxX05";
    static readonly Scribbler_UnknownAction_ = "XxXed";
    static readonly InsertAudioTooltips = "XxXJj";
    static readonly CopiedToLocalAndSystemClipboard_ = "XxXyc";
    static readonly RedirectedToHomePage = "XxXdT";
    static readonly BorderRadius = "XxX8X";
    static readonly Tooltips_TextHighlight = "XxXzM";
    static readonly Fit = "XxXaq";
    static readonly BarcodeKindQRCode = "XxXuT";
    static readonly ConfirmBackupEventsTo_ = "XxXp7";
    static readonly FailedToDecryptKeys = "XxXHG";
    static readonly ScribblerMove = "XxXhb";
    static readonly InvalidKeyLength_ = "XxX7M";
    static readonly ActionOK = "XxXvF";
    static readonly Tooltips_ExportToFile = "XxX4n";
    static readonly Tooltips_ColorBlue = "XxXzt";
    static readonly dotted = "XxXQZ";
    static readonly Effects = "XxXMP";
    static readonly widgetStickerStyleImage = "XxXJk";
    static readonly InvalidPath = "XxXFZ";
    static readonly Tooltips_ToggleNobackup = "XxXAn";
    static readonly Layer0 = "XxXay";
    static readonly TnSize = "XxXQR";
    static readonly PlaceholderRequiredUrl = "XxXvk";
    static readonly SourceNotDeletable = "XxXdn";
    static readonly Display = "XxXRL";
    static readonly DestinationFileAlreadyExistsOpenInsteadOfCreating = "XxXJV";
    static readonly history_placeholders = "XxXn4";
    static readonly Tooltips_DestructWidget = "XxXC7";
    static readonly PromptScribblerHistoryTitle = "XxXI3";
    static readonly action_DestructAnnotation = "XxXBY";
    static readonly action_DestructSidebarTab = "XxXzv";
    static readonly ActionRequirePermission_ = "XxXA9";
    static readonly InvalidFilepath = "XxXBC";
    static readonly ExportingWholeCanvas = "XxXZR";
    static readonly AlarmPosted_ = "XxXOi";
    static readonly Tooltips_CutNotDone = "XxXZL";
    static readonly InvalidExpression = "XxXoz";
    static readonly invalidAction_ = "XxXnu";
    static readonly NotDeleting_ = "XxX20";
    static readonly Tooltips_EditEvent = "XxXIl";
    static readonly Grid = "XxXF9";
    static readonly Tooltips = "XxXeO";
    static readonly ActionAddBorderTooltips = "XxXmp";
    static readonly Tooltips_ListStyles = "XxX2j";
    static readonly NothingToFormat = "XxX2A";
    static readonly ConfirmClearEvents = "XxXUS";
    static readonly FixPerspectiveTitle = "XxXZj";
    static readonly EditElementTitle = "XxXi3";
    static readonly Tooltips_SortAlphaAsc = "XxXqZ";
    static readonly BackupKeyManagerTooltips = "XxXiR";
    static readonly Tooltips_InsertCalendar = "XxXr5";
    static readonly NoSuitableMediaFileFound = "XxXLM";
    static readonly EditSpacingMessage = "XxXV5";
    static readonly Tooltips_AddRule = "XxX5a";
    static readonly PlaceholderRequired = "XxX3Q";
    static readonly InvalidBackupArchive = "XxXi9";
    static readonly Off = "XxXIc";
    static readonly Filename = "XxXWF";
    static readonly DestinationExpectingADir = "XxXG2";
    static readonly Backup = "XxXLi";
    static readonly Tooltips_EditAlignments = "XxXo3";
    static readonly Link = "XxXJg";
    static readonly Tooltips_ExportImage = "XxX81";
    static readonly Copy_ = "XxXoe";
    static readonly BackupKeyImportFromCameraTooltips = "XxXWy";
    static readonly Removed = "XxXgx";
    static readonly SearchResultIsEmpty = "XxXTA";
    static readonly InvalidFilepickerCommand_ = "XxXgP";
    static readonly action_InsertParagraph = "XxXov";
    static readonly app_name_alpha = "XxXRW";
    static readonly DestinationPathIsRequired = "XxXpH";
    static readonly IllegalFilenameCharacter_ = "XxXbk";
    static readonly Tooltips_ShowMainToolbar = "XxXzW";
    static readonly Tooltips_ToggleShowBrokenLinksOnly = "XxXh9";
    static readonly ActionGotoParentDirTooltips = "XxXgpd";
    static readonly False = "XxX9J";
    static readonly Tooltips_CutToLocalClipboard = "XxXvX";
    static readonly SearchFromStart = "XxXg8";
    static readonly LiteOperationLocalSearchNotAvailable = "XxXcV";
    static readonly Tooltips_ClearEvents = "XxXsn";
    static readonly RecognizeTextTooltips = "XxXBP";
    static readonly Tooltips_RecordAudio = "XxXgO";
    static readonly action_Unwrap = "XxXDM";
    static readonly history_toggle = "XxXr9";
    static readonly PlaceholderOptionalFilepath = "XxX6E";
    static readonly Tooltips_RestoreCalendarEvents = "XxXhh";
    static readonly Audio = "XxXx6";
    static readonly Tooltips_RestoreDataFromFullBackup = "XxXwo";
    static readonly Tooltips_ResizeCanvas = "XxXJb";
    static readonly ErrorFormattingDocument = "XxXl5";
    static readonly Tooltips_ExportAsImage = "XxXgQ";
    static readonly AlreadyAtTopLevel = "XxXYS";
    static readonly Tooltips_CreateKeysBackup = "XxXgf";
    static readonly InvalidInputDimension = "XxXV2";
    static readonly action_Save = "XxXnK";
    static readonly invalidStyle_ = "XxX1F";
    static readonly ScribblerImage = "XxXb0";
    static readonly NoNextPage = "XxXba";
    static readonly ExpectingPDF = "XxXjP";
    static readonly Padding = "XxXzX";
    static readonly confirmDeletingElement = "XxXWi";
    static readonly widgetShoppingDesc = "XxXlx";
    static readonly SelectedNodeIsNotEditableStylesheet = "XxXCU";
    static readonly Tooltips_GotoHomePage = "XxXdU";
    static readonly FromDir = "XxXFrd";
    static readonly RequirePassword = "XxXOt";
    static readonly nameValueOutOfRange = "XxXZq";
    static readonly ActionShredTooltips = "XxXty";
    static readonly CorrectionOptionCrop = "XxXaA";
    static readonly ConfirmCreateIncrementalBackupTo_ = "XxXTq";
    static readonly Grow = "XxXVN";
    static readonly history_node = "XxXRB";
    static readonly widgetAnnotationStylePhoto = "XxXV1";
    static readonly Cells = "XxXgJ";
    static readonly FactoryResetTitle = "XxXCu";
    static readonly EditAbortedTitle = "XxXQS";
    static readonly ScribblerShift = "XxXbU";
    static readonly Filter_brightness = "XxXc0";
    static readonly CreateLoginMessage = "XxXhi";
    static readonly StylesheetNotFound = "XxXjb";
    static readonly Tooltips_CreateFullDataBackup = "XxXBG";
    static readonly Tooltips_EditNodeAsRawText = "XxXSt";
    static readonly removed_events = "XxX2a";
    static readonly Tooltips_StrikeThrough = "XxX4x";
    static readonly InvalidEvent = "XxXv0";
    static readonly Tooltips_InsertWidget = "XxXmG";
    static readonly Tooltips_UndoTextEdit = "XxXVG";
    static readonly Tooltips_ImagePicker = "XxXdL";
    static readonly ThereIsNoInitialDocumentSelection = "XxXxD";
    static readonly action_ToSpace = "XxX0w";
    static readonly ActionFixBrokenLinksConfirm = "XxXfbc";
    static readonly action_MoveToPrev = "XxXUt";
    static readonly RepeatPassword = "XxXmJ";
    static readonly ActionFixBrokenLinksNothingToFix = "XxXfbn";
    static readonly RepeatWorkdaysMarker = "XxXtz";
    static readonly widgetAnnotationTitle = "XxXPW";
    static readonly CreateThumbnailFailed_ = "XxX15";
    static readonly DestinationFile = "XxXmh";
    static readonly ActionRequireASingleElementSelection = "XxXxx";
    static readonly InvalidColor_ = "XxXsq";
    static readonly FailedToWriteLoginCf = "XxXGW";
    static readonly Tooltips_PasteFromLocalClipboard = "XxXLX";
    static readonly GalleryUpdateFailed = "XxXUI";
    static readonly Tooltips_InsertAsNextSibling = "XxX5E";
    static readonly Tooltips_SidebarTemplates = "XxXc7";
    static readonly widgetStickerStyleBadge = "XxXnW";
    static readonly BackupKeyRegenerateTitle = "XxXwv";
    static readonly Width = "XxX2W";
    static readonly AssertInvalidStateForUndo = "XxXHP";
    static readonly action_DestructSticker = "XxXKK";
    static readonly Tooltips_DocumentSettings = "XxXeR";
    static readonly ConfirmRestoreEventsFrom_ = "XxXGt";
    static readonly ActionFixBrokenLinksResult__ = "XxXfbr";
    static readonly Tooltips_EnterSearchText = "XxXhk";
    static readonly Share = "XxX0N";
    static readonly action_InsertCalendar = "XxXvI";
    static readonly BackdropBlur = "XxXNL";
    static readonly ConfirmCreateDestinationDirectory = "XxXIY";
    static readonly Tooltips_TimePicker = "XxXSz";
    static readonly action_ParaStyle = "XxXBb";
    static readonly InvalidCSSRule_ = "XxXIg";
    static readonly LiteTemplateCanvasNotAvailable = "XxXHX";
    static readonly EventsConfirmDone = "XxXecd";
    static readonly InsertTextTitle = "XxXst";
    static readonly InvalidInput_ = "XxXpD";
    static readonly Tooltips_DocumentOutline = "XxXzg";
    static readonly PickDir = "XxXae";
    static readonly InvalidPath_ = "XxXnD";
    static readonly GameStateSaved = "XxXnR";
    static readonly Correction = "XxXKM";
    static readonly RepeatDailyMarker = "XxXwm";
    static readonly BorderRight = "XxX5C";
    static readonly Html = "XxXAm";
    static readonly Style = "XxXUA";
    static readonly Tooltips_Edit = "XxXaW";
    static readonly PromptCopy1 = "XxXJR";
    static readonly AudioRecordingTitle = "XxXec";
    static readonly SpecifiedFileAlreadyExistsPleaseTryAgain = "XxX7d";
    static readonly action_UpdateAudioInfo = "XxXu9";
    static readonly IndexingInProgress = "XxXkZ";
    static readonly widgetAnnotationStyleImage = "XxXuy";
    static readonly Tooltips_FilepathFilter = "XxXzi";
    static readonly Filter_dropShadow = "XxXuI";
    static readonly Tooltips_MakeListNotCompact = "XxXQM";
    static readonly Tooltips_NewDocument = "XxXjR";
    static readonly Tooltips_CreateTextNode = "XxXlq";
    static readonly failed = "XxXSv";
    static readonly Tooltips_CreateElement = "XxXhz";
    static readonly Copied_files = "XxXbr";
    static readonly Duration = "XxXbn";
    static readonly widgetAnnotationType = "XxX0S";
    static readonly PleaseSelectAnItemForTheAction = "XxXeD";
    static readonly Tooltips_Calculator = "XxXnj";
    static readonly Caption = "XxX83";
    static readonly BackupPleaseSpecifyABackupFile = "XxXK2";
    static readonly Tooltips_AnnotateImageOrCanvas = "XxXDv";
    static readonly NotEditing = "XxXrz";
    static readonly TemplateHomeTitle = "XxXVR";
    static readonly Tooltips_InsertText = "XxXfx";
    static readonly history_templateCycleAction = "XxXn0";
    static readonly DestinationNotExists = "XxXCm";
    static readonly Tooltips_PickFont = "XxXqV";
    static readonly SanitizeActionError = "XxXrm";
    static readonly Tooltips_Home = "XxXkF";
    static readonly Tooltips_CreateEvent = "XxXLn";
    static readonly ExpectingAudioExt = "XxXwW";
    static readonly InvalidOperand = "XxXou";
    static readonly ConvertingNot = "XxXhsn";
    static readonly Tooltips_Bold = "XxX22";
    static readonly AudioRecordingStopOK = "XxXwr";
    static readonly ConfirmRestoreIncrementalBackupFrom_ = "XxXxa";
    static readonly Rotate = "XxXUH";
    static readonly Tooltips_Clear = "XxXjn";
    static readonly NoImageFound = "XxXNn";
    static readonly Tooltips_EscapeText = "XxXgG";
    static readonly ActionQuitTitle = "XxXWa";
    static readonly Both = "XxXGI";
    static readonly Mime = "XxXEu";
    static readonly CannotRenameToSelf = "XxX7h";
    static readonly Tooltips_UnwrapSelection = "XxXqo";
    static readonly Tooltips_Recording = "XxXQv";
    static readonly BackupKeyImportFromQRCodeTooltips = "XxXUe";
    static readonly Layer1 = "XxX2t";
    static readonly action_PasteChild = "XxXqh";
    static readonly NothingToRedo = "XxX6t";
    static readonly at_center = "XxXeq";
    static readonly Pending = "XxXHc";
    static readonly ActionRequireASingleNodeSelection = "XxXTg";
    static readonly AValidatorIsRequired = "XxXwZ";
    static readonly InputMustNotBeEmpty = "XxXGT";
    static readonly Title = "XxXSp";
    static readonly ImageDimension = "XxXhS";
    static readonly Tooltips_DatePicker = "XxXY6";
    static readonly Tooltips_RenameFileOrDirectory = "XxXdI";
    static readonly ConfirmDeletingNextPageLink = "XxXDw";
    static readonly Tooltips_Move = "XxXio";
    static readonly GalleryOverwriteWarning = "XxXsw";
    static readonly Tooltips_ZoomToFitScreen = "XxXxA";
    static readonly ListElementNotFound = "XxXNX";
    static readonly ActionRequireASelectionWithASrcOrHrefAttribute = "XxXiI";
    static readonly destructWidget = "XxXCC";
    static readonly PickImage = "XxXWd";
    static readonly action_DestructFlexbox = "XxXzN";
    static readonly Tooltips_RemoveBrokenEntries = "XxXvw";
    static readonly ExpectingHtmlExt = "XxX44";
    static readonly Tooltips_EventDetails = "XxXJY";
    static readonly SourceNotWritable = "XxX6j";
    static readonly action_Paste = "XxXGr";
    static readonly FailedToReadLoginCf = "XxXZV";
    static readonly Tooltips_PasteAsNextSibling = "XxXCn";
    static readonly DeleteFailed_ = "XxXyk";
    static readonly Tooltips_RotateElement = "XxX3k";
    static readonly Tooltips_AlignRight = "XxXHK";
    static readonly Digits = "XxXmV";
    static readonly Tooltips_Opacity = "XxX99";
    static readonly BarcodeGenerateFailed = "XxXbgf";
    static readonly BackupKeyExportAsQRCodeTooltips = "XxXeB";
    static readonly ClientActionClassesTitle = "XxXvd";
    static readonly UnauthorizedAccess_ = "XxX4y";
    static readonly Import = "XxXxd";
    static readonly widgetSampleLink1 = "XxXF8";
    static readonly Tooltips_Refresh = "XxXzo";
    static readonly ClientActionClassesConfirmDelete = "XxXqB";
    static readonly DropTextCopiedToClipboard = "XxXLm";
    static readonly AnnotateImage = "XxXVa";
    static readonly Tooltips_OpenFileOrDirectory = "XxX84";
    static readonly Tooltips_DeleteFileOrDirectory = "XxXuP";
    static readonly ShareTooltips = "XxXZC";
    static readonly WrapSelection = "XxXcB";
    static readonly Borders = "XxXaH";
    static readonly Tooltips_ColorDodgerBlue = "XxXmH";
    static readonly action_InsertDate = "XxXWX";
    static readonly Tooltips_Cancel = "XxXNp";
    static readonly Tooltips_GlobalSearchPanel = "XxXhU";
    static readonly Tooltips_SelectDirectoryToExport = "XxXMJ";
    static readonly PleaseWait = "XxXIb";
    static readonly DirectoryNotExists_ = "XxX3j";
    static readonly Gutter = "XxXlI";
    static readonly EditText = "XxXKD";
    static readonly ExpectingImageMime = "XxXmj";
    static readonly Relative = "XxXXA";
    static readonly action_CharStyle = "XxXqg";
    static readonly TnHeight = "XxXi5";
    static readonly FixPerspectiveTooltips = "XxXQC";
    static readonly RecipientsAll = "XxXsH";
    static readonly Scribbler_MissingURIForImageAction = "XxXxB";
    static readonly PickRectTitle = "XxXprt";
    static readonly InvalidCSSStyle_ = "XxXpI";
    static readonly VERY_EASY = "XxXJK";
    static readonly Tooltips_TargetDate = "XxXub";
    static readonly NoMatchFound = "XxXuW";
    static readonly DestinationParentDirectoriesCreationFailed = "XxXG5";
    static readonly CannotReplaceReservedSymbol = "XxXE9";
    static readonly GradientRepeatingRadialEllipse = "XxXDO";
    static readonly URLExpectingAnImageExt = "XxXuC";
    static readonly CommandOKSeeOutputAt_ = "XxXbp";
    static readonly DesktopOperationRecordVideoNotAvailable = "XxXo0";
    static readonly Preview = "XxXNC";
    static readonly BackupKeyDeleteTooltips = "XxXYI";
    static readonly Done = "XxXzV";
    static readonly Filter_hueRotate = "XxXHi";
    static readonly ImageNotFound = "XxXzx";
    static readonly YouMustLoginToPerformThisAction = "XxXW1";
    static readonly Tooltips_ClearSearchText = "XxXdw";
    static readonly GradientRadialEllipse = "XxXfM";
    static readonly Positioning = "XxXUL";
    static readonly ErrorSaving = "XxXjg";
    static readonly GameRestoreSnapshot = "XxXIH";
    static readonly ActionRequireANonCollapsedSelection = "XxXdq";
    static readonly ErrorValidatingHtml = "XxXA4";
    static readonly widgetAnnotationStyleList = "XxX33";
    static readonly NotFound_ = "XxXIW";
    static readonly Direction = "XxXUd";
    static readonly TimeFormat = "XxX6h";
    static readonly ErrorDeleting_ = "XxXSC";
    static readonly Moved_files = "XxXUP";
    static readonly Resize = "XxXLw";
    static readonly Overwriting = "XxXz5";
    static readonly FilenameMustBeEmpty = "XxXtT";
    static readonly ActionInsertNamedAnchorTitle = "XxXwB";
    static readonly action_InsertElementSibling = "XxXJX";
    static readonly Help_GameMinds = "XxXhO";
    static readonly Tooltips_Media = "XxXeC";
    static readonly MkdirTitle = "XxXkD";
    static readonly ExpectingUrlWithoutQueryOrFragment = "XxXQd";
    static readonly BackupExportTooltips = "XxXzk";
    static readonly Recover = "XxXoI";
    static readonly DocumentSaved = "XxXLo";
    static readonly action_DestructSidepanel = "XxXF3";
    static readonly UIFont = "XxXSF";
    static readonly action_UpdateVideoInfo = "XxXtg";
    static readonly Tooltips_BorderOnePx = "XxXzY";
    static readonly BarcodeGenerateTitle = "XxXpE";
    static readonly action_memoryInfo = "XxXPT";
    static readonly ERROR = "XxXFe";
    static readonly PromptCanvasMessage = "XxXOx";
    static readonly RepeatOffMarker = "XxXcj";
    static readonly Tooltips_PageTemplates = "XxXtE";
    static readonly SpecifiedFileDoesNotExistsPleaseTryAgain = "XxXrW";
    static readonly RenameMessage = "XxXkJ";
    static readonly widgetSampleLink2 = "XxXeI";
    static readonly ErrorDeletingDirectory_ = "XxXgS";
    static readonly Tooltips_ResizeElement = "XxXU1";
    static readonly Position = "XxXEA";
    static readonly action_PasteSibling = "XxXQy";
    static readonly BackupVerifyTooltips = "XxXem";
    static readonly ActionClearHistoryMessage = "XxXEa";
    static readonly WildcardSearch = "XxX2w";
    static readonly Tooltips_InsertElement = "XxXol";
    static readonly BGImageURL = "XxX9a";
    static readonly TotalSize = "XxXJA";
    static readonly Tooltips_GoBackInHistory = "XxXkH";
    static readonly ActionRequireACollapsedSelection = "XxX8m";
    static readonly action_EditTextNode = "XxXoL";
    static readonly ActionClearStylesMessage = "XxXX0";
    static readonly ThumbnailScrollable = "XxXstn";
    static readonly LeftOrRight = "XxXmd";
    static readonly ErrorCopyingAssets = "XxXSl";
    static readonly FilenameMustNotStartsWithSpaces = "XxXvP";
    static readonly Tooltips_SearchBar = "XxX3t";
    static readonly Horizontal = "XxXWn";
    static readonly Tooltips_GenerateGallery = "XxXFN";
    static readonly Tooltips_ColorDarkBlue = "XxXTL";
    static readonly PromptCloneTitle = "XxX8F";
    static readonly Quality = "XxXqX";
    static readonly CSS = "XxXz7";
    static readonly Tooltips_ImportFromPhotoLibrary = "XxXx9";
    static readonly ConfirmDeleting_Items = "XxX8f";
    static readonly GradientRepeatingRadialCircle = "XxXjt";
    static readonly Tooltips_SwapPositionWithNextSibling = "XxX5p";
    static readonly PromptCopyOverwrite1 = "XxXhF";
    static readonly AudioRecorderError = "XxX3w";
    static readonly Margin = "XxXY9";
    static readonly BackupKeyImportTooltips = "XxXe9";
    static readonly action_ListSymbol = "XxXIQ";
    static readonly MatchFoundButNotVisible = "XxXg1";
    static readonly Tooltips_NextMatch = "XxXmz";
    static readonly Tooltips_ToggleZoom = "XxXdX";
    static readonly KeyAlias = "XxXR8";
    static readonly InvalidEncryptedFile = "XxXlZ";
    static readonly SaveAs = "XxXhA";
    static readonly DurationMs = "XxXZu";
    static readonly action_MoveToNext = "XxXmn";
    static readonly Tooltips_IgnoreCase = "XxXZi";
    static readonly InvalidURL_ = "XxXOY";
    static readonly Redo = "XxXAP";
    static readonly Today = "XxXOE";
    static readonly Recursive1 = "XxXHd";
    static readonly AM = "XxXZZ";
    static readonly ErrorListingDirectory_ = "XxX3l";
    static readonly Scale = "XxXnG";
    static readonly DateFormat = "XxXHk";
    static readonly ImageViewerTitle = "XxXct";
    static readonly Scrollable = "XxXYv";
    static readonly Tooltips_ToggleFullscreen = "XxX9b";
    static readonly Tooltips_InsertObjects = "XxXo9";
    static readonly Tooltips_DrawCurves = "XxXDX";
    static readonly widgetAnnotationStyleHBox = "XxXDS";
    static readonly FixPerspectiveCroppedSize = "XxXv7";
    static readonly Tooltips_SidebarDocument = "XxXOJ";
    static readonly InvalidCharacter_ = "XxXUp";
    static readonly Recents = "XxXp3";
    static readonly ErrorReadingBackup = "XxXjE";
    static readonly widgetFlexboxMessage = "XxXqe";
    static readonly Tooltips_ShowInfo = "XxXCq";
    static readonly FailedToGenerateKeys = "XxXOy";
    static readonly GradientRepeatingLinear = "XxXrY";
    static readonly history_text = "XxXfi";
    static readonly Copying = "XxXkw";
    static readonly Corner = "XxXhr";
    static readonly LiteOperationGlobalSearchNotAvailable = "XxX4U";
    static readonly Tooltips_EditLink = "XxXIt";
    static readonly Tooltips_Save = "XxXfa";
    static readonly MediaTypeNotSupported = "XxXu5";
    static readonly ImageURL = "XxXIF";
    static readonly Tooltips_SwapPositionWithPrevSibling = "XxXxG";
    static readonly Recipients = "XxX7Z";
    static readonly AudioRecorderMaxFileSizeReached = "XxXcO";
    static readonly Tooltips_AddRuleset = "XxX56";
    static readonly loadingDefaultHomePage = "XxXUu";
    static readonly InvalidRotation_ = "XxXvE";
    static readonly Tooltips_ListOrdered = "XxX0g";
    static readonly ErrorLoading = "XxX9X";
    static readonly InvalidIntegerValue = "XxXck";
    static readonly FailedToCopy_ = "XxXCH";
    static readonly FilesFsckResult = "XxXYk";
    static readonly VideoQualityHigh = "XxXJy";
    static readonly Tooltips_PathKind = "XxXic";
    static readonly DocumentChangesDiscarded = "XxXYu";
    static readonly UnsupportedInputFormat_ = "XxXzT";
    static readonly action_InsertNbsp = "XxXQq";
    static readonly DestinationNotValid_ = "XxXdnv";
    static readonly Tooltips_EditStyle = "XxXPe";
    static readonly PlacholderRegexSearch = "XxXtB";
    static readonly Tooltips_KeywordSearch = "XxXq4";
    static readonly PromptPasteTitle = "XxX5I";
    static readonly BackdropFilterSamplesTooltips = "XxXSB";
    static readonly Tooltips_CloneObject = "XxXUQ";
    static readonly Tooltips_Italic = "XxXkv";
    static readonly CannotDelete_ = "XxXM6";
    static readonly Tooltips_RestoreData = "XxXTi";
    static readonly NoMoreItems = "XxXPn";
    static readonly Tooltips_CreateCalendarEventsBackup = "XxXGL";
    static readonly Filter_blur = "XxXur";
    static readonly ConfirmUnlinkDefaultStylesheet = "XxXFX";
    static readonly Tooltips_ToggleKeyboard = "XxXuE";
    static readonly Tooltips_ToggleShowHex = "XxXfn";
    static readonly AssertIndexOfNodeNotFound_ = "XxXFb";
    static readonly TemplateInventoryTitle = "XxXYr";
    static readonly Tooltips_ColorYellow = "XxX4L";
    static readonly Tooltips_PickSymbol = "XxX86";
    static readonly BackupKeyDeleteConfirmMesesage = "XxXLO";
    static readonly ActionInsertNamedAnchorTooltips = "XxXfr";
    static readonly Tooltips_ListWithoutBullet = "XxXja";
    static readonly AreYouSureToContinue = "XxX3N";
    static readonly HistoryIgnore = "XxX6J";
    static readonly Top = "XxXZk";
    static readonly Tooltips_Rotate = "XxXym";
    static readonly Tooltips_RootFolder = "XxX6q";
    static readonly AbstractMethodNotImplemented = "XxXkR";
    static readonly ActionShredTitle = "XxXtyt";
    static readonly imageAreaLimit = "XxXSU";
    static readonly Tooltips_ImportEvents = "XxXs4";
    static readonly MODERATE = "XxXVm";
    static readonly widgetStickerStyleCanvas = "XxXsM";
    static readonly PromptDateTimeTitle = "XxXwa";
    static readonly Tooltips_RemoveRuleset = "XxX1K";
    static readonly RowHeight = "XxX4Q";
    static readonly TakePhotoAlreadyInProgress = "XxXAx";
    static readonly Help_GameSudoku = "XxXM2";
    static readonly Tooltips_Apply = "XxXPU";
    static readonly Moved1file = "XxXTM";
    static readonly TextCorrection = "XxXtN";
    static readonly FormatActionError = "XxXF4";
    static readonly YouMustLoginToExportEvents = "XxXGC";
    static readonly TemplateContextNotFound = "XxXFE";
    static readonly Tooltips_Print = "XxX46";
    static readonly AnElementValidatorIsRequired = "XxX4i";
    static readonly BGColor = "XxXmt";
    static readonly AudioRecordingNotInProgress = "XxXMB";
    static readonly Tooltips_TakePhoto = "XxX7G";
    static readonly EnterLoginPasswordOrBiometric = "XxX8I";
    static readonly Tooltips_ToggleHidden = "XxXEY";
    static readonly Tooltips_EditStyleAsRawText = "XxXgE";
    static readonly BackupKeyShowAsQRCodeTooltips = "XxX6i";
    static readonly ActionPlayAllPrevMediaTooltips = "XxXpap";
    static readonly InvalidURL = "XxX6O";
    static readonly invalidFilepath_ = "XxXx0";
    static readonly Thumbnail = "XxXt2";
    static readonly AudioPlaybackAlreadyInProgress = "XxXgH";
    static readonly ATextValidatorIsRequired = "XxXYE";
    static readonly KeyFile = "XxXsb";
    static readonly Gradient = "XxX80";
    static readonly Tooltips_Backup = "XxXZp";
    static readonly CopiedToSystemClipboard_ = "XxX8A";
    static readonly MapSize = "XxXCi";
    static readonly ColorHeading = "XxXqY";
    static readonly ErrorReadingStyles = "XxXkU";
    static readonly VideoQualityMedium = "XxXuG";
    static readonly DivideByZeroError = "XxXTO";
    static readonly Theme_Dark = "XxXn5";
    static readonly CreationDate = "XxXfu";
    static readonly DestinationNotWritable_ = "XxXd1";
    static readonly ActionConvertFailed_ = "XxXcvf";
    static readonly NotExists = "XxXmb";
    static readonly Tooltips_MoveFileOrDirectory = "XxXri";
    static readonly Tooltips_MakeListCompact = "XxXUT";
    static readonly CalculationContextNotFound = "XxXzC";
    static readonly inputMustNotBeEmpty_ = "XxXXK";
    static readonly Video = "XxXoh";
    static readonly BGPosition = "XxXv9";
    static readonly PromptCopyInvalidClipboardContent = "XxXBh";
    static readonly FitMinorDimension = "XxXVW";
    static readonly EditStylesheet = "XxXG9";
    static readonly Left = "XxXzO";
    static readonly Attributes = "XxXJ7";
    static readonly TargetNodeNotExists = "XxXzK";
    static readonly placeholderImportImageDimension = "XxX43";
    static readonly BarcodeScanTooltips = "XxXMb";
    static readonly ImageFilterSamplesTooltips = "XxXvN";
    static readonly FullTextSearchNotAvailable = "XxXdx";
    static readonly DeleteLogin = "XxXPj";
    static readonly URLInputMustNotBeEmpty = "XxXcs";
    static readonly ActionScreenshotTitle = "XxXXC";
    static readonly NotDeletingNodeOnBackspace = "XxXuJ";
    static readonly Tooltips_DrawText = "XxXSr";
    static readonly HARD = "XxXBj";
    static readonly Tooltips_ConvertNonBreakSpacesToSpaces = "XxXTU";
    static readonly Tooltips_ShowOrHideRightSidebar = "XxXBZ";
    static readonly widgetGlassMessage = "XxXnB";
    static readonly AssertMultiSelectionMustBeUnderTheSameParent = "XxXau";
    static readonly CropTooltips = "XxXHo";
    static readonly RecoverEveryDeletedFileInThisDirectory_Confirmation = "XxXr8";
    static readonly Shrink = "XxX5w";
    static readonly FailedToInitCipher = "XxXYt";
    static readonly Tooltips_GotoCurrentDocumentDirectory = "XxXTw";
    static readonly NoPrevPage = "XxXMs";
    static readonly ErrorCreatingAudioPlayer = "XxX9k";
    static readonly ClientActionClassesLabel = "XxXTf";
    static readonly Alarm = "XxXsl";
    static readonly ActionFixBrokenLinksFixing_ = "XxXfbf";
    static readonly AssertMutationObserverSupportIsRequired = "XxXxg";
    static readonly Tooltips_WidgetTemplates = "XxXPg";
    static readonly UnsupportedMutationRecordType_ = "XxXyv";
    static readonly AddStylesheetUnable = "XxX7H";
    static readonly LiteOperationTakePhotoNotAvailable = "XxXhQ";
    static readonly destructWidgetAndContent = "XxXX2";
    static readonly Tooltips_ImportImage = "XxXVM";
    static readonly FontStyle = "XxX55";
    static readonly action_InsertVideo = "XxX0y";
    static readonly Tooltips_ImportImageFile = "XxXje";
    static readonly InvalidDirectoryName_ = "XxXFq";
    static readonly Trash = "XxXT6";
    static readonly NoPreviousSiblingFound = "XxXeE";
    static readonly Filter_grayscale = "XxXYz";
    static readonly Tooltips_InsertAsFirstChild = "XxX3h";
    static readonly CreateThumbnailOK = "XxXkS";
    static readonly Tooltips_ColorGreen = "XxXsK";
    static readonly Tooltips_Filter = "XxXgl";
    static readonly Result2 = "XxXly";
    static readonly history_templateRadioAction = "XxXoG";
    static readonly Tooltips_GameMinds = "XxX0X";
    static readonly InvalidOperator = "XxXnb";
    static readonly TextBullet_Message = "XxX82";
    static readonly ActionScreenshotTooltips = "XxXr0";
    static readonly Tooltips_CreateLink = "XxXng";
    static readonly GradientRepeatingRadial = "XxX2G";
    static readonly FailedToRead_ = "XxX1z";
    static readonly Filter_contrast = "XxXxJ";
    static readonly ErrorLoadingDocument = "XxXne";
    static readonly RepeatEvents = "XxXTK";
    static readonly action_ListDatetime = "XxXRK";
    static readonly widgetShoppingTitle = "XxXbG";
    static readonly Tooltips_RemoveLink = "XxXdb";
    static readonly DropDataTypeNotSupported = "XxX64";
    static readonly Tooltips_OpenOrAddPage = "XxXo2";
    static readonly Tooltips_Search = "XxXNu";
    static readonly ActionRequireGmCommandFromTheGraphicsMagickPackage = "XxXagm";
    static readonly GameOver = "XxXS1";
    static readonly LineHeight = "XxXDl";
    static readonly actionRequireOneOfTheFollowingTags_ = "XxXtb";
    static readonly SingleSection = "XxXBw";
    static readonly Tooltips_Redo = "XxXnI";
    static readonly PickStyle = "XxXyr";
    static readonly Tooltips_ShowImageInfo = "XxXbX";
    static readonly BitPerSecond = "XxXYO";
    static readonly ActionAddBorderTitle = "XxXr6";
    static readonly ExpectingAnOperator = "XxXBH";
    static readonly MissingImageInfoFormat = "XxXaXa";
    static readonly PlaceholderRequiredHeight = "XxXSf";
    static readonly FloatRight = "XxXp1";
    static readonly NoMoreMatches = "XxXwR";
    static readonly Tooltips_CutSelection = "XxXDh";
    static readonly StyleSize = "XxXX7";
    static readonly ButtonSize = "XxXOL";
    static readonly RefuseToProcessImageLargerThan_ = "XxX0j";
    static readonly Export = "XxXQj";
    static readonly Tooltips_ExportZip = "XxXKk";
    static readonly Help_BackupFilepicker = "XxX4C";
    static readonly BackupKeyRegenerateTooltips = "XxXV7";
    static readonly FileTooLarge = "XxXR1";
    static readonly Result = "XxXuh";
    static readonly ContentNotMovable = "XxXBT";
    static readonly ResetUserSettingsTooltips = "XxXEi";
    static readonly VerticalAlign = "XxXxq";
    static readonly Tooltips_ListWithSymbolBullet = "XxXpa";
    static readonly ExportPublicKeyForSelf = "XxXFs";
    static readonly FailedToEncryptData = "XxXw2";
    static readonly ActionFailed = "XxXk0";
    static readonly Tooltips_Replace = "XxX8H";
    static readonly AssertUnsupportedOperation = "XxXk8";
    static readonly widgetSlideshowInvalidSelection = "XxXrG";
    static readonly ScribblerPolycurve = "XxXB7";
    static readonly PlaceholderRequiredWidth = "XxXRE";
    static readonly Tooltips_MoveUpAsNextSiblingOfParent = "XxXrF";
    static readonly Tooltips_ListItemWithDateBullet = "XxXIq";
    static readonly Tooltips_Info = "XxXwV";
    static readonly EditImgTitle = "XxX4h";
    static readonly SearchFailed_ = "XxXA1";
    static readonly NoSuchAlgorithm_ = "XxXrc";
    static readonly ScribblerMore = "XxXGn";
    static readonly VideoRecordingTitle = "XxXWM";
    static readonly Tooltips_ColorPalette = "XxXZW";
    static readonly NotExists_ = "XxXeS";
    static readonly InvalidInputPath_ = "XxXEk";
    static readonly Tooltips_RotateImage = "XxXAl";
    static readonly Weekdays = "XxXto";
    static readonly ActionRequireASingleElementOrACollapsedSelection = "XxXBd";
    static readonly DocumentNotFound = "XxXu6";
    static readonly NoMoreCheats = "XxXLY";
    static readonly Months = "XxXdD";
    static readonly history_attributes = "XxXdN";
    static readonly history_nongrouped = "XxXlR";
    static readonly CorrectionOptionCorrectPerspectiveCrop = "XxXKZ";
    static readonly XrefsRebuildTitle = "XxXxrt";
    static readonly action_Drop = "XxXrT";
    static readonly Cancel = "XxXzw";
    static readonly DestinationDir = "XxX74";
    static readonly BackupKeyExportTooltips = "XxXMS";
    static readonly InvalidWidgetStructureForUndo = "XxXuQ";
    static readonly Tooltips_ImportMedia = "XxXaL";
    static readonly editLinkMessage = "XxXDf";
    static readonly PlaceholderRequiredText = "XxXC4";
    static readonly Difficulty = "XxXW6";
    static readonly UnexpectedException = "XxXbq";
    static readonly Undo = "XxXhc";
    static readonly HtmlAttributeInvalid_ = "XxXGv";
    static readonly NotADirectory_ = "XxXYZ";
    static readonly Tooltips_HighlightStyles = "XxXT5";
    static readonly ConfirmRemove_Events = "XxXrK";
    static readonly InvalidFilenameCharacter_ = "XxXNm";
    static readonly widgetSlideshowTitle = "XxXE8";
    static readonly ValueMustBe0To100 = "XxXRk";
    static readonly AreYouSureYouWantToCheat = "XxXrL";
    static readonly EnterBackupFilePasswordForRestore = "XxXD9";
    static readonly ActionFixBrokenLinksTitle = "XxXfbt";
    static readonly emptyDirectories = "XxXmK";
    static readonly SelectedNodeIsNotEditable = "XxX9H";
    static readonly widgetTocDesc = "XxXpS";
    static readonly ParameterMissingBaseurl = "XxX6B";
    static readonly Tooltips_EditRuleset = "XxXRf";
    static readonly Tooltips_OtherActions = "XxXj6";
    static readonly widgetSampleAnnotation = "XxXU5";
    static readonly SourceNotFound = "XxXOV";
    static readonly ErrorGettingEvents = "XxXQh";
    static readonly BackupRestore = "XxX8t";
    static readonly BackupSelectKeyTooltips = "XxXDD";
    static readonly invalidNameValue = "XxX8j";
    static readonly InvalidValue_ = "XxXxL";
    static readonly Tooltips_Underline = "XxXWU";
    static readonly Descending = "XxXXY";
    static readonly day = "XxX2i";
    static readonly Tooltips_PreviousPage = "XxXhu";
    static readonly FontSize = "XxXxI";
    static readonly Tooltips_Today = "XxXLx";
    static readonly TimeZoneUTC = "XxXtzu";
    static readonly Tooltips_PasteFileOrDirectory = "XxXUK";
    static readonly CreateAPasswordLoginWithTheLoginAction = "XxXKt";
    static readonly License = "XxXDp";
    static readonly PleaseSpecifyAnImageId = "XxX02";
    static readonly CannotDeleteNonEmptyDirectory_ = "XxXFm";
    static readonly WidgetNotFound = "XxXU2";
    static readonly FilesFsckTooltips = "XxX9K";
    static readonly history_templateStyleAction = "XxXaw";
    static readonly ColorDialogBG = "XxXan";
    static readonly Filter = "XxXoC";
    static readonly PM = "XxXKI";
    static readonly ConfirmCreateFullBackupTo_ = "XxXS4";
    static readonly Tooltips_AlignJustify = "XxXFi";
    static readonly ActionRequireASingleImgOrCanvasElementSelection = "XxXb3";
    static readonly cut0ItemsToClipboard = "XxXEo";
    static readonly TodoItemNotFound = "XxXlU";
    static readonly InvalidKeyAlias = "XxXts";
    static readonly TextIsRequired = "XxXWu";
    static readonly ActionRequireASelectionThatStartsAndEndsUnderTheSameParent = "XxXFz";
    static readonly AudioRecordingStarted = "XxXPa";
    static readonly DestinationMustNotBeSameAsSource = "XxXQe";
    static readonly StrokeColor = "XxXmR";
    static readonly RepeatOnceMarker = "XxXeb";
    static readonly action_DestructSlideshow = "XxXU7";
    static readonly EnterBackupFilePasswordForBackup = "XxXpZ";
    static readonly Tooltips_CreateOrOpenDocument = "XxXtK";
    static readonly Zoom = "XxXbs";
    static readonly ActionNotPermittedOnBodyElement = "XxX6D";
    static readonly ConfirmDeletingPrevPageLink = "XxXUi";
    static readonly IllegalPasswordCharacter = "XxXNd";
    static readonly ImageReadFailed = "XxXJc";
    static readonly widgetSlideshowNoImageFound = "XxX51";
    static readonly Tooltips_EventsPanel = "XxXJ4";
    static readonly Tooltips_QuitWithoutSave = "XxXre";
    static readonly action_alarm = "XxXRh";
    static readonly widgetAnnotationTypeTransparent = "XxXOA";
    static readonly Color = "XxXSI";
    static readonly VideoUsingSampleAsPlaceholder = "XxXij";
    static readonly Tooltips_DrawEllipses = "XxXeG";
    static readonly Tooltips_PickImage = "XxXr2";
    static readonly BackgroundImageSamplesTooltips = "XxX01";
    static readonly PromptDimensionTitle = "XxXz8";
    static readonly Tooltips_AddLink = "XxXQi";
    static readonly SaveOnPauseMessage = "XxX5h";
    static readonly TextAlign = "XxXfe";
    static readonly Tooltips_Subscript = "XxXB1";
    static readonly widgetAnnotationPhotoTitle = "XxXaJ";
    static readonly Tooltips_Dismiss = "XxX6r";
    static readonly TextColor = "XxX5X";
    static readonly RecentsInvalidCommand = "XxXLP";
    static readonly action_InsertSymbol = "XxXig";
    static readonly deletedEverything = "XxXUE";
    static readonly ConfirmRemove_Event = "XxXs3";
    static readonly Tooltips_ExportButton = "XxX8R";
    static readonly Deleting = "XxXnZ";
    static readonly FilesFsckTitle = "XxXT3";
    static readonly Absolute = "XxXCz";
    static readonly Tooltips_Recover = "XxXYn";
    static readonly Tooltips_CutFileOrDirectory = "XxXyV";
    static readonly Tooltips_CopyToLocalClipboard = "XxX7m";
    static readonly TrashConfirmAutoCleanup = "XxXEO";
    static readonly Tooltips_WrapSelection = "XxXJD";
    static readonly Tooltips_ToggleIgnoreCase = "XxXnA";
    static readonly Filter_saturate = "XxXeW";
    static readonly Tooltips_ListItemWithTimeBullet = "XxXoa";
    static readonly FilePermission = "XxXDV";
    static readonly ScribblerEmbeddedImage = "XxXZr";
    static readonly ErrorDeletingFile_ = "XxXQc";
    static readonly deleteEmptyDirectory = "XxXHI";
    static readonly Tooltips_PasteAsFirstChild = "XxXQ3";
    static readonly ScribblerRectangle = "XxXvL";
    static readonly Tooltips_DocumentStylesheet = "XxXD6";
    static readonly FailedToDecrypt_ = "XxX4w";
    static readonly Tooltips_EditDrawingHistory = "XxXcb";
    static readonly XrefsRebuildResult = "XxXxrr";
    static readonly Scribbler_MissingDataForEmbeddedImageAction = "XxXQO";
    static readonly NoMoreChild = "XxXLk";
    static readonly PleaseSpecifyAFilename = "XxXmu";
    static readonly PleaseLoginToProceed = "XxXgV";
    static readonly PleaseSpecifyADestinationDirectory = "XxXNs";
    static readonly Tooltips_GoForwardInHistory = "XxXAY";
    static readonly Monospace = "XxXaN";
    static readonly Action_Failed = "XxXzh";
    static readonly ImageFilter = "XxXNh";
    static readonly Tooltips_ImportFromBackupDirectories = "XxXtk";
    static readonly action_Wrap = "XxXlP";
    static readonly ConfirmDeletingEmptyDirectories = "XxX53";
    static readonly action_AnnotationHide = "XxXjS";
    static readonly widgetAnnotationTypeDefault = "XxXws";
    static readonly CopyFailed_ = "XxXUy";
    static readonly RenameFailed_ = "XxXH9";
    static readonly InvalidEncryptedData = "XxXda";
    static readonly Tooltips_Restore = "XxX4e";
    static readonly EMPTY = "";
    static readonly DestinationAlreadyExists = "XxXWE";
    static readonly confirmDeletingTemplateInstance = "XxX0c";
    static readonly AudioPlaybackFailed = "XxX0s";
    static readonly Tooltips_BorderThick = "XxX76";
    static readonly Tooltips_Indent = "XxXsr";
    static readonly YouWin = "XxXTj";
    static readonly FactoryResetOption1 = "XxXgF";
    static readonly IllegalSearchText_ = "XxX7n";
    static readonly Tooltips_GotoInitialDirectory = "XxX60";
    static readonly Tooltips_RestoreDataFromIncrementalBackup = "XxXl0";
    static readonly Tooltips_NextPage = "XxXi0";
    static readonly InsertElementTitle = "XxXkP";
    static readonly Help_GameMines = "XxXjs";
    static readonly StylesheetNotExists = "XxXhd";
    static readonly Tooltips_ShowOrHideLeftSidepanel = "XxXwy";
    static readonly ExpectingHtml = "XxXOj";
    static readonly ErrorClearingEvents = "XxXmr";
    static readonly Tooltips_CanvasActions = "XxXmx";
    static readonly Attachment = "XxXZs";
    static readonly Bottom = "XxXPq";
    static readonly YouMustLoginToRestoreData = "XxXX5";
    static readonly Tooltips_StopAudioRecording = "XxXID";
    static readonly Tooltips_InsertLinkElement = "XxXTB";
    static readonly app_name_beta = "XxXle";
    static readonly Scroll = "XxXNT";
    static readonly Category = "XxXlY";
    static readonly action_RemoveStyles = "XxXMX";
    static readonly Scribbler_GridTitle = "XxXpe";
    static readonly ADelegateIsRequired = "XxX4q";
    static readonly Tooltips_InsertCanvas = "XxXbc";
    static readonly BarcodeGenerateTooltips = "XxXfl";
    static readonly Tooltips_EditNode = "XxX9A";
    static readonly Tooltips_Toolbar = "XxXkA";
    static readonly widgetAnnotationStyleBasic = "XxXZ7";
    static readonly ConfirmExportDirectoryTo_ = "XxXL8";
    static readonly FGColor = "XxXSM";
    static readonly action_EditStyle = "XxXms";
    static readonly Tooltips_DrawFreehandCurves = "XxXEU";
    static readonly Tooltips_SelectAnAreaToExport = "XxXKf";
    static readonly StyleNowrapTooltips = "XxXDj";
    static readonly ParameterMissingURI = "XxX3L";
    static readonly QualityPercent = "XxX4N";
    static readonly Tooltips_ColorWhite = "XxXbC";
    static readonly RoundCorners = "XxXvU";
    static readonly Tooltips_ListUnordered = "XxXj7";
    static readonly InvalidSidebarStructure = "XxXgi";
    static readonly Tooltips_MoveUp = "XxX7B";
    static readonly Action_OK = "XxXWv";
    static readonly Tooltips_GlobalSettingsPanel = "XxXUR";
    static readonly InvalidSalt = "XxXd0";
    static readonly SaveOnPauseTitle = "XxXI0";
    static readonly Date = "XxXKe";
    static readonly Restore = "XxXNx";
    static readonly history_imageholder = "XxXj2";
    static readonly StickOnDocument = "XxXev";
    static readonly ReachedEndOfDocument = "XxXcv";
    static readonly AssertNotNull = "XxXkc";
    static readonly InvalidFileKind_ = "XxXVb";
    static readonly InsertSymbolTitle = "XxXEQ";
    static readonly Unzip = "XxXip";
    static readonly Right = "XxXgh";
    static readonly action_List = "XxXDU";
    static readonly ScribblerEdit = "XxXQa";
    static readonly Tooltips_SpawnSibling = "XxXSD";
    static readonly GameConfirmRestart = "XxXcw";
    static readonly ActionFixBrokenLinksFailed = "XxXfbx";
    static readonly NoNextSiblingFound = "XxXpV";
    static readonly app_name_x = "XxX9e";
    static readonly action_ListItem = "XxX6I";
    static readonly ErrorParsingStyle = "XxXPA";
    static readonly EditLinkTitle = "XxXa6";
    static readonly ActionNotPermitted = "XxXjI";
    static readonly action_InsertLinebreak = "XxXsI";
    static readonly True = "XxXkq";
    static readonly RepeatWeeklyMarker = "XxX11";
    static readonly Tooltips_Down = "XxX0A";
    static readonly Scribbler_ExportImageOK = "XxXC5";
    static readonly ExpectingSimpleFilename = "XxXwc";
    static readonly ErrorCreatingFile_ = "XxXSc";
    static readonly Tooltips_EventDone = "XxXgz";
    static readonly Tooltips_ListItemWithTextBullet = "XxXJC";
    static readonly ActionDeleteColorTooltips = "XxXdct";
    static readonly widgetStickerStyleBasic = "XxXAd";
    static readonly widgetAnnotationStyleVBox = "XxXkm";
    static readonly Tooltips_GameMines = "XxXg7";
    static readonly ActionFixBrokenLinksCancelled = "XxXfbC";
    static readonly GameSaved = "XxX2J";
    static readonly ActionCleanHomeTitle = "XxXGP";
    static readonly Tooltips_Gradient = "XxXIu";
    static readonly ToasterHolding = "XxXRg";
    static readonly action_recording = "XxXH0";
    static readonly Private = "XxXcd";
    static readonly Operand = "XxXGa";
    static readonly SourceNotValid = "XxXNR";
    static readonly editAbortedMessage = "XxXmy";
    static readonly insertElementFailed_ = "XxXfI";
    static readonly ClipboardIsEmptyOrInvalid = "XxX6R";
    static readonly widgetSidepanelSample = "XxXII";
    static readonly YouMustLoginToBackupData = "XxXx8";
    static readonly FilenameMustNotStartsWithDot = "XxX2s";
    static readonly TemplateNotesTitle = "XxXTs";
    static readonly Tooltips_Up = "XxXoY";
    static readonly Tooltips_FloatLeft = "XxXlL";
    static readonly NoItemFound = "XxXKv";
    static readonly SearchFromEnd = "XxXx2";
    static readonly AnUrlValidatorIsRequired = "XxXW0";
    static readonly UnsupportedTag = "XxXL0";
    static readonly UnsupportedOutputFormat_ = "XxX5K";
    static readonly Tooltips_ColorRed = "XxXIa";
    static readonly Tooltips_More = "XxXbf";
    static readonly FixPerspectiveUncroppedSize = "XxXFc";
    static readonly FloatLeft = "XxXgn";
    static readonly Vertical = "XxXVj";
    static readonly SourceDeletionFailed = "XxXfB";
    static readonly Tooltips_ClearHistory = "XxXeF";
    static readonly Tooltips_BorderThin = "XxXFd";
    static readonly Tooltips_ColorTeal = "XxXvV";
    static readonly BackupForwardTooltips = "XxXbY";
    static readonly Help_GalleryItemThreshold = "XxXmA";
    static readonly PleaseSelectAFileToOpen = "XxXum";
    static readonly NotMoving = "XxXHQ";
    static readonly Tooltips_ImportFile = "XxX70";
    static readonly ScribblerCurve = "XxXAT";
    static readonly Tooltips_NextBlog = "XxXTu";
    static readonly BackupKeyExportFilepickerHelp = "XxXwO";
    static readonly Tooltips_ExportDirectoryAsZip = "XxXxv";
    static readonly Tooltips_BorderNone = "XxXiV";
    static readonly Layer3 = "XxXco";
    static readonly UnexpectedException_ = "XxX72";
    static readonly ActionTemplateToggleTitle = "XxX3r";
    static readonly Tooltips_Reset = "XxX8r";
    static readonly PickFiles = "XxXAD";
    static readonly RecipientsSelf = "XxXRm";
    static readonly ActionRequireAValidSelection = "XxXXt";
    static readonly XrefsRebuildTooltips = "XxXxrp";
    static readonly ActionShredConfirm = "XxXtyc";
    static readonly ConfirmRestoreFullBackupFrom_ = "XxX28";
    static readonly widgetSidepanelTitle = "XxXQI";
    static readonly Tooltips_DateFormat = "XxXam";
    static readonly confirmOpenDocument1 = "XxXk4";
    static readonly Tooltips_DocumentStyles = "XxXSo";
    static readonly Content = "XxXiX";
    static readonly Tooltips_Undo = "XxXt5";
    static readonly Tooltips_PickColor = "XxXju";
    static readonly AssertInvalidZIndex_ = "XxX4M";
    static readonly XrefsFixTooltips = "XxXfxx";
    static readonly ClipboardIsEmpty = "XxXSq";
    static readonly FileNotFound_ = "XxXEP";
    static readonly Tooltips_ColorPicker = "XxXHZ";
    static readonly BorderTop = "XxXoU";
    static readonly PlaceholderRequiredDuration = "XxXuZ";
    static readonly GradientLinear = "XxXpv";
    static readonly VideoQualityLow = "XxXIn";
    static readonly TemplateNotFound_ = "XxX2o";
    static readonly ConfirmAction = "XxXWK";
    static readonly action_DestructPictureFrame = "XxX6V";
    static readonly RepeatYearlyMarker = "XxX5e";
    static readonly ActionInsertNamedAnchorShowIcon = "XxXSK";
    static readonly UnexpectedEndOfFile = "XxXF2";
    static readonly Tooltips_AddNextPageLink = "XxX2P";
    static readonly FactoryResetOption3 = "XxXZT";
    static readonly Float = "XxXIp";
    static readonly NoEnclosingElementFound = "XxXVO";
    static readonly DragPinchClick = "XxXKj";
    static readonly BackupFile = "XxXJZ";
    static readonly deleteEverythingUnderDirectory = "XxXOP";
    static readonly PlaceholderRequiredFilepath = "XxXwn";
    static readonly InsertCalendarTitle = "XxXFo";
    static readonly action_InsertTextChild = "XxXvv";
    static readonly Tooltips_GameSudoku = "XxXR9";
    static readonly Tooltips_CloneFile = "XxXiS";
    static readonly action_ToNbsp = "XxXaB";
    static readonly GameSudokuAutofillTooltips = "XxXWs";
    static readonly TnWidth = "XxXSX";
    static readonly found_items = "XxXAw";
    static readonly CannotChangeFileExt = "XxXeK";
    static readonly dash = "XxX98";
    static readonly Crop = "XxXN7";
    static readonly hour = "XxX24";
    static readonly Image = "XxXAO";
    static readonly PleaseSpecifyASourceImage = "XxXWQ";
    static readonly Subject = "XxXhy";
    static readonly BackupSyncFilesActionTooltips = "XxXPQ";
    static readonly action_Spawn = "XxX2V";
    static readonly Tooltips_StartEditing = "XxX2q";
    static readonly FactoryResetOption2 = "XxXQs";
    static readonly CannotCopyToSelf = "XxXlm";
    static readonly FailedToEncryptKeys = "XxXd5";
    static readonly ImportImageTitle = "XxXlh";
    static readonly RotationDeg = "XxXTJ";
    static readonly ErrorSavingStylesheet = "XxXP8";
    static readonly Tooltips_ExportEvents = "XxXkg";
    static readonly Cornering = "XxXe0";
    static readonly ActionQuitTooltips = "XxXcF";
    static readonly action_Cut = "XxXKJ";
    static readonly Tooltips_Highlight = "XxXzr";
    static readonly LinkURL = "XxXaT";
    static readonly AddClientCssMessage = "XxXVl";
    static readonly Tooltips_PreviousMatch = "XxXJG";
    static readonly InsertVideoTooltips = "XxXMT";
    static readonly Directory = "XxX0Q";
    static readonly BackupKeyImportFilepickerHelp = "XxXsP";
    static readonly ActionImageSourceTooltips = "XxX3i";
    static readonly Alignment = "XxXMZ";
    static readonly AStyleValidatorIsRequired = "XxXv1";
    static readonly Tooltips_ExportToPhotoLibrary = "XxXoF";
    static readonly ContextmenuNotAvailable = "XxXWf";
    static readonly SourcePath = "XxX4k";
    static readonly PleaseSpecifySearchText = "XxXa3";
    static readonly widgetSplitpanelTitle = "XxXHf";
    static readonly imageDimensionLimit_ = "XxXLd";
    static readonly history_templateButtonAction = "XxXil";
    static readonly ActionRequireASingleImgElementSelection = "XxXLp";
    static readonly ActionNotPermittedOnElement_ = "XxXZd";
    static readonly NoEnclosingDivOrPElementFound = "XxXQ5";
    static readonly AddStylesheetTitle = "XxXzj";
    static readonly Static = "XxX7p";
    static readonly Tooltips_CreateIncrementalDataBackup = "XxXvt";
    static readonly TotalSizeRecursive = "XxXdo";
    static readonly action_AnnotateCanvas = "XxX9p";
    static readonly min = "XxXJd";
    static readonly Layer2 = "XxXrf";
    static readonly PickSymbol = "XxXlt";
    static readonly Tooltips_FloatRight = "XxXo6";
    static readonly action_ToggleVisibility = "XxXUZ";
    static readonly ErrorRestoringRecentsList = "XxX26";
    static readonly SelectAll = "XxXyx";
    static readonly InsertNbspTitle = "XxX2K";
    static readonly ConfirmNotSavingToStylesheetFile = "XxXD7";
    static readonly action_EditIMG = "XxXXw";
    static readonly DropTargetInvalid = "XxXmc";
    static readonly Tooltips_CropCanvasToFitContent = "XxX4F";
    static readonly Tooltips_ParagraphStyles = "XxXyh";
    static readonly FactoryResetOptionTItle = "XxXy9";
    static readonly Tooltips_CreateThumbnail = "XxX7D";
    static readonly CSSSyntaxError_ = "XxX2v";
    static readonly PromptElementMessage = "XxXKz";
    static readonly InsertVideoTitle = "XxXgM";
    static readonly OK = "XxXZv";
    static readonly PickColor = "XxXFp";
    static readonly CutOK = "XxXPo";
    static readonly Tooltips_StopAudioPlayback = "XxXL5";
    static readonly Tooltips_ShowWhitespaceNodes = "XxXrt";
    static readonly InvalidThumbnailKind_ = "XxXBx";
    static readonly ms = "XxXpf";
    static readonly BorderBottom = "XxXqU";
    static readonly ErrorGettingMemoryInfo = "XxXUl";
    static readonly Tooltips_ListItem = "XxX2b";
    static readonly Help_RestoreDataFilepicker = "XxXGB";
    static readonly None = "XxXbx";
    static readonly Assists = "XxX3v";
    static readonly FillColor = "XxXtx";
    static readonly CreateLogin = "XxXci";
    static readonly TemplateTodoTitle = "XxX9g";
    static readonly Tooltips_PickFile = "XxXho";
    static readonly VideoRecordingAlreadyInProgress = "XxXpk";
    static readonly DesktopOperationRecordAudioNotAvailable = "XxXmk";
    static readonly AssertNotReach = "XxXRO";
    static readonly ClientActionClassesDeleteTooltips = "XxXxZ";
    static readonly Tooltips_SelectParent = "XxXCP";
    static readonly ConfirmDiscard = "XxXpl";
    static readonly Transform = "XxX1U";
    static readonly Filepath = "XxXA5";
    static readonly EditRulesetTitle = "XxXuz";
    static readonly Weight = "XxXeo";
    static readonly Tooltips_HideWhitespaceNodes = "XxXp9";
    static readonly StylePropertyNameInvalid_ = "XxXw3";
    static readonly LiteOperationRecordAudioNotAvailable = "XxXg0";
    static readonly Tooltips_ImportVideo = "XxXEG";
    static readonly CreateParentDirectoryFailed_ = "XxXcpd";
    static readonly ImageNotFound_ = "XxXIy";
    static readonly DeleteFailed = "XxXrD";
    static readonly action_InsertTextSibling = "XxXwl";
    static readonly UnsupportedEncryptedFileVersion_ = "XxX3U";
    static readonly GameHistoryIsEmpty = "XxXbL";
    static readonly ActionOnlyWorksWhenCurrentDocumentIsABlogPage = "XxX25";
    static readonly TnWxH = "XxXcu";
    static readonly ImportImageFailed = "XxXYs";
    static readonly ColorLink = "XxX8T";
    static readonly Confirm_Proceed = "XxXU6";
    static readonly PromptFilepathTitle = "XxXgr";
    static readonly Tooltips_EditStylesheet = "XxX5A";
    static readonly ActionPlayAllMediasTooltips = "XxXptp";
    static readonly Tooltips_AnnotateImage = "XxXod";
    static readonly GradientRadialCircle = "XxX1Y";
    static readonly MustLoginForRestoringBackup = "XxXZg";
    static readonly widgetFlexboxStyleImage = "XxX7c";
    static readonly YouMustLoginToClearEvents = "XxXTD";
    static readonly widgetAccordionTitle = "XxXNz";
    static readonly ZipTooltips = "XxX2l";
    static readonly ActionFileMoveFixingXrefsTooltips = "XxXfmt";
    static readonly Tooltips_ColorBlack = "XxXfA";
    static readonly LitePanelNotAvailable = "XxXoB";
    static readonly Tooltips_CalendarPanel = "XxXWx";
    static readonly Tooltips_Login = "XxXFR";
    static readonly Tooltips_Delete = "XxXf1";
    static readonly Tooltips_PasteAsChild = "XxXMj";
    static readonly DropActionNotSupported = "XxXkl";
    static readonly Tooltips_Remove = "XxXwA";
    static readonly Tooltips_CopyFileOrDirectory = "XxX8G";
    static readonly ActionCleanHomeTooltips = "XxX0D";
    static readonly GameHistoryIsFull = "XxXrN";
    static readonly LeftAndRightSplitpanelAlreadyExistsAbort = "XxXTN";
    static readonly AudioDataIsOverLimit = "XxXQV";
    static readonly RenameTitle = "XxXIM";
    static readonly XrefsRefTo = "XxXxrs";
    static readonly ScribblerExport = "XxXoc";
    static readonly DocumentBrowsingSaved = "XxX1s";
    static readonly ImageAnnotator_ConfirmClearMessage = "XxXWT";
    static readonly OnlyUrlWithPathQueryFragmentPartsIsAllowed = "XxX2y";
    static readonly ActionConvertDeleteSource = "XxXcds";
    static readonly ExpectingFileExt_ = "XxXHn";
    static readonly ConfirmDeletingEmptyTextNodeOnBackspace = "XxXSY";
    static readonly Tooltips_Cleanup = "XxXoD";
    static readonly Tooltips_SidebarExplore = "XxXE2";
    static readonly action_InsertAudio = "XxXEN";
    static readonly ConfirmDiscardPhoto = "XxXxe";
    static readonly StylesheetSaveOK = "XxXJ8";
    static readonly Copied1file = "XxXQn";
    static readonly Tooltips_ShiftCanvas = "XxXvT";
    static readonly Tooltips_CreateDirectory = "XxXvi";
    static readonly StyleEditorExpectingSingleRulesetOnly = "XxXmS";
    static readonly Wait = "XxXjU";
    static readonly NothingToUndo = "XxXsX";
    static readonly Sample = "XxXsam";
    static readonly PreviewTooltips = "XxXzH";
    static readonly Filter_sepia = "XxX7a";
    static readonly Boxes = "XxXw1";
    static readonly AlarmsPending_ = "XxXlr";
    static readonly solid = "XxXPJ";
}

////////////////////////////////////////////////////////////////////////

class MSG {
    private static readonly X_RX0: RegExp = new RegExp("\\$\\{0\\}");
    private static readonly X_RX1: RegExp = new RegExp("\\$\\{1\\}");
    private static readonly X_RX2: RegExp = new RegExp("\\$\\{2\\}");
    private static readonly _resourcesObject = (window as any).
        XxXJz
        ;
    private static _stringObject = MSG._resourcesObject;
    private static _stringArrayObject = MSG._resourcesObject;

    static XXX$ = MSG.string_(RS.InsertTextHere);

    static string_(id: string): string {
        let ret: string = MSG._stringObject[id];
        if (ret == null) {
            throw new Error(id);
        }
        return ret;
    }

    static string1_(id: string, arg1: string): string {
        return `${MSG.string_(id)}${arg1}`;
    }

    static string2_(id: string, arg1: string, arg2: string): string {
        return `${MSG.string_(id)}${arg1}${arg2}`;
    }

    static stringArray_(id: string): string[] {
        let ret: string = MSG._stringArrayObject[id];
        if (ret == null) {
            throw new Error(id);
        }
        return ret.split("\n");
    }

    static format1_(id: string, arg1: string): string {
        let format: string = MSG._stringObject[id];
        return format.replace(MSG.X_RX0, arg1);
    }

    static format2_(id: string, arg1: string, arg2: string): string {
        let format: string = MSG._stringObject[id];
        return format.replace(MSG.X_RX0, arg1).replace(MSG.X_RX1, arg2);
    }

    static format3_(id: string, arg1: string, arg2: string, arg3: string): string {
        let format: string = MSG._stringObject[id];
        return format.replace(MSG.X_RX0, arg1).replace(MSG.X_RX1, arg2).replace(MSG.X_RX2, arg3);
    }

    static formatArray1_(id: string, arg1: string): string[] {
        return MSG.format1_(id, arg1).split("\n");
    }

    static formatArray2_(id: string, arg1: string, arg2: string): string[] {
        return MSG.format2_(id, arg1, arg2).split("\n");
    }

    static formatArray3_(id: string, arg1: string, arg2: string, arg3: string): string[] {
        return MSG.format3_(id, arg1, arg2, arg3).split("\n");
    }

    static actionOK_(id: string) {
        return MSG.format1_(RS.Action_OK, MSG.string_(id));
    }

    static actionCancelled_(id: string) {
        return MSG.format1_(RS.Action_Cancelled, MSG.string_(id));
    }

    static actionFailed_(id: string) {
        return MSG.format1_(RS.Action_Failed, MSG.string_(id));
    }

    static confirmProceed_(id: string) {
        return MSG.format1_(RS.Confirm_Proceed, MSG.string_(id));
    }
}

class DateTime {
    static readonly FOREVER = 1 << 30;
    static readonly MINUTE = 1000 * 60;
    static readonly HOUR = DateTime.MINUTE * 60;
    static readonly DAY = DateTime.HOUR * 24;
    static readonly SUNDAY = 0;
    static readonly MONDAY = 1;
    static readonly TUEDAY = 2;
    static readonly WEDNESDAY = 3;
    static readonly THURSDAY = 4;
    static readonly FRIDAY = 5;
    static readonly SATURDAY = 6;
    #date: Date;
    /// @date Either ms in UTC or a Date object.
    /// @options.isUtc Specify if date parameter is utc or local time. Default is utc.
    constructor(date: Long | Date, isUtc: boolean = settings$.isUtc$) {
        this.#date = (date instanceof Date ? date : new Date(date));
        if (isUtc === false) {
            this.#date = new Date(this.#date.valueOf() + this.#date.getTimezoneOffset() * DateTime.MINUTE);
        }
    }
    static local_(
        year: number,
        month: number,
        day?: number,
        hour?: number,
        minute?: number,
        second?: number,
        ms?: number,
    ) {
        return new DateTime(Date.UTC(year, month - 1, day ?? 1, hour ?? 0, minute ?? 0, second ?? 0, ms ?? 0), false);
    }
    static utc_(
        year: number,
        month: number,
        day?: number,
        hour?: number,
        minute?: number,
        second?: number,
        ms?: number,
    ) {
        return new DateTime(Date.UTC(year, month - 1, day ?? 1, hour ?? 0, minute ?? 0, second ?? 0, ms ?? 0), true);
    }
    /// @param ms UTC time in ms since 01/01/1970.
    /// @param isUtc default from settings.
    static fromMs_(ms: number, isUtc: boolean = settings$.isUtc$): DateTime {
        return new DateTime(ms, isUtc);
    }
    static now_(): DateTime {
        return new DateTime(new Date());
    }
    static ms_(): Long {
        return Date.now();
    }

    /// @return Today string in form yyyymmdd
    static today_(): string {
        const now = this.now_();
        const year = now.year$.toFixed(0);
        const month = now.month$.toFixed(0).padStart(2, "0");
        const day = now.day$.toFixed(0).padStart(2, "0");
        return year + month + day;
    }
    add_(ms: number): DateTime {
        return new DateTime(this.#date.valueOf() + ms);
    }
    subtract_(ms: number): DateTime {
        return new DateTime(this.#date.valueOf() - ms);
    }
    isAfter_(date: DateTime): boolean {
        return this.millisecondsSinceEpoch$ > date.millisecondsSinceEpoch$;
    }
    /// @return Milliseconds since 01/01/1970 in UTC time.
    get millisecondsSinceEpoch$(): Long {
        return this.#date.getTime();
    }
    /// Day of the month starting from 1.
    get day$(): Int {
        return this.#date.getDate();
    }
    get weekday$(): Int {
        return this.#date.getDay();
    }
    /// Month of the year starting from 1.
    get month$(): Int {
        return this.#date.getMonth() + 1;
    }
    get year$(): Int {
        return this.#date.getFullYear();
    }
    get hour$(): Int {
        return this.#date.getHours();
    }
    get minute$(): Int {
        return this.#date.getMinutes();
    }
    get second$(): Int {
        return this.#date.getSeconds();
    }
}

class Basepath {
    #path: string;
    #basepath: { dir$: stringX, filename$: string, stem$: string, suffix$: string; };

    constructor(...segments: string[]) {
        this.#path = Basepath.cleanFilepath_(segments.join(FS));
        this.#basepath = Basepath.parse_(this.#path);
    }

    get path$(): string {
        return this.#path;
    }

    get dir$(): stringX {
        return this.#basepath.dir$;
    }

    get filename$(): string {
        return this.#basepath.filename$;
    }

    get stem$(): string {
        return this.#basepath.stem$;
    }

    get suffix$(): string {
        return this.#basepath.suffix$;
    }

    get lcSuffix$(): string {
        return this.#basepath.suffix$.toLowerCase();
    }

    get ext$(): string | null {
        let suffix = this.suffix$;
        return suffix.length == 0 ? null : suffix.substring(1);
    }

    get lcExt$(): string | null {
        let suffix = this.lcSuffix$;
        return suffix.length == 0 ? null : suffix.substring(1);
    }

    get parent$(): Basepath | null {
        return this.dir$ == null ? null : new Basepath(this.dir$);
    }

    sibling_(filename: string): Basepath {
        return this.dir$ == null ? new Basepath(filename) : new Basepath(this.dir$, filename);
    }

    file_(rpath: string): Basepath {
        return new Basepath(this.path$, rpath);
    }

    changeFilename_(filename: string): Basepath {
        return this.sibling_(filename);
    }

    changeStem_(stem: string): Basepath {
        return this.changeFilename_(stem + this.suffix$);
    }

    changeSuffix_(suffix: string): Basepath {
        return this.changeFilename_(this.stem$ + suffix);
    }

    dirAndStem_(): string {
        return Basepath.joinPath_(this.dir$, this.stem$);
    }

    toString(): string {
        return this.path$;
    }

    static parse_(path: string) {
        function splitpath(dir: stringX, filename: string) {
            if (filename == "" || filename == ".") return { dir$: dir, filename$: "", stem$: "", suffix$: "" };
            if (filename == "..") return { dir$: dir, filename$: "..", stem$: "..", suffix$: "" };
            const [stem, suffix] = Basepath.splitFilename_(filename);
            return { dir$: dir, filename$: filename, stem$: stem, suffix$: suffix };
        }
        const index = path.lastIndexOf(FS);
        if (index < 0) return splitpath(null, path);
        const dir = path.substring(0, index);
        return splitpath((dir == "" ? FS : dir), path.substring(index + 1));
    }

    static splitFilename_(filename: string): [base: string, suffix: string] {
        const index = filename.lastIndexOf(".");
        return (index <= 0 ? [filename, ""] : TextUt.splitAt_(filename, index));
    }

    static lcSuffixOfFilename_(filename: string): string {
        return this.splitFilename_(filename)[1].toLowerCase();
    }

    /**
     * @return A clean path with redundant //, ./ and ../ removed.
     * Note that the return path keep the leading / and trailing / of the input path.
     */
    static cleanFilepath_(path: string): string {
        if (path.indexOf(FS) < 0) return path;
        path = path.trim().replace(RX.Slashes_g, FS);
        const a = path.split(FS);
        const b = [];
        for (let i = 0; i < a.length; ++i) {
            let s = a[i];
            if (s == ".") {
                if (i == a.length - 1) b.push("");
                continue;
            } else if (s == "..") {
                let blen = b.length;
                if (blen > 0 && b[blen - 1].length > 0 && b[blen - 1] != "..") {
                    b.pop();
                    continue;
                }
            }
            b.push(s);
        }
        const ret = b.join(FS);
        return path.startsWith(FS) && !ret.startsWith(FS) ? FS + ret : ret;
    }

    /**
     * Specialize cleanPath() for rpathOrNull.
     * Result may not be same as cleanPath(), but good for rpathOrNull.
     * Note that this remove the leading "" segment of a absolute path,
     * so join(ret) is always a relative path without leading /.
     */
    static cleanPathSegments_(segments: string[]): string[] {
        let len = segments.length;
        if (len == 0) return segments;
        let ret = [];
        for (let i = 0; i < len; ++i) {
            let segment = segments[i];
            if ((segment.length == 0 || "." == segment) && ret.length > 0) continue;
            if (".." == segment && ret.length > 0) {
                ret.pop();
                continue;
            }
            ret.push(segment);
        }
        return ret;
    }

    /**
     * @return Relative path without leading / or null if file is not under basedir.
     */
    static rpathOrNull_(basedir: string, path: string): stringX {
        const b = this.cleanPathSegments_(basedir.split(FS));
        const f = this.cleanPathSegments_(path.split(FS));
        if (f.includes("..") || b.includes("..")) return null;
        const blen = b.length;
        const flen = f.length;
        let i = 0;
        while (i < blen && i < flen) {
            if (b[i] != f[i]) break;
            ++i;
        }
        if (i < blen) return null;
        return f.slice(i, flen).join(FS);
    }

    /**
     * @return Relative path without leading /, allowing .. if file is not under basedir.
     */
    static rpath_(basedir: string, path: string): string {
        const b = this.cleanPathSegments_(basedir.split(FS));
        const f = this.cleanPathSegments_(path.split(FS));
        const blen = b.length;
        const flen = f.length;
        let i = 0;
        while (i < blen && i < flen) {
            if (b[i] != f[i]) break;
            ++i;
        }
        const ret = f.slice(i, flen);
        if (i == blen) return ret.join(FS);
        while (++i <= blen) ret.unshift("..");
        return ret.join(FS);
    }

    static rpathFromSegments_(base: string[], path: string[]): string[] {
        let baselen = base.length;
        let pathlen = path.length;
        let i = 0;
        for (; i < baselen && i < pathlen; ++i) {
            if (base[i] != path[i]) {
                break;
            }
        }
        let ret = [];
        for (let k = i + 1; k < baselen; ++k) {
            ret.push("..");
        }
        for (; i < pathlen; ++i) {
            ret.push(path[i]);
        }
        return ret;
    }

    static suffix_(path: string): string {
        return new Basepath(path).suffix$;
    }

    static lcSuffix_(path: string): string {
        return Basepath.suffix_(path).toLowerCase();
    }

    static filename_(path: string): string {
        return new Basepath(path).filename$;
    }

    static stem_(path: string): string {
        return new Basepath(path).stem$;
    }

    static changeFilename_(path: string, name: string): string {
        return new Basepath(path).changeFilename_(name).toString();
    }

    static changeStem_(path: string, name: string): string {
        return new Basepath(path).changeStem_(name).toString();
    }

    static changeSuffix_(path: string, suffix: string): string {
        return new Basepath(path).changeSuffix_(suffix).toString();
    }

    static dir_(path: string): stringX {
        return new Basepath(path).dir$;
    }

    static ext_(path: stringXX): string | null {
        if (path === null || path === undefined) return null;
        let suffix = Basepath.suffix_(path);
        return suffix.length == 0 ? null : suffix.substring(1);
    }

    static lcExt_(path: stringXX): string | null {
        if (path === null || path === undefined) return null;
        let suffix = Basepath.suffix_(path);
        return suffix.length == 0 ? null : suffix.substring(1).toLowerCase();
    }

    static stemAndSuffix_(path: string): [stem: string, suffix: string] {
        const basepath = new Basepath(path);
        return [basepath.stem$, basepath.suffix$];
    }

    static join_(segments: string[]): string {
        return segments.join(FS);
    }

    static joinPath_(dir: stringX, name: string): string {
        if (dir == null || dir == FS) return `/${name}`;
        return `${dir}/${name}`;
    }

    /// Like joinPath() but return a relative path if directory is empty.
    static joinRpath_(dir: stringX, name: string): string {
        if (dir == null || dir.length == 0) return name;
        if (dir == FS) return `/${name}`;
        return `${dir}/${name}`;
    }

    /// This differ from Basepath() in that it returns empty filename if path ends with /.
    static splitPath_(path: string): [dir: string, filename: string] {
        let name = Basepath.cleanFilepath_(path);
        let dir = "";
        const index = name.lastIndexOf(FS);
        if (index >= 0) {
            dir = name.substring(0, index);
            name = name.substring(index + 1);
        }
        return [dir, name == "." ? "" : name];
    }

    /// Split the first segment and the rest of a path.
    /// If path has single segment, return null for the first segment.
    static splitFirst_(path: string): [first: stringX, rest: string] {
        const index = path.indexOf(FS);
        if (index < 0) return [null, path];
        return [path.substring(0, index), path.substring(index + 1)];
    }

    static trim_(path: string, sep: string = FS): string {
        let start = 0;
        let end = path.length;
        let slen = sep.length;
        while (start + slen <= end && path.startsWith(sep, start)) start += slen;
        while (start + slen <= end && path.endsWith(sep, end)) end -= slen;
        if (start == 0 && end == path.length) return path;
        return path.substring(start, end);
    }

    static trimLeading_(path: string, sep: string = FS): string {
        let start = 0;
        let end = path.length;
        let slen = sep.length;
        while (start + slen <= end && path.startsWith(sep, start)) start += slen;
        if (start == 0 && end == path.length) return path;
        return path.substring(start, end);
    }

    static trimTrailing_(path: string, sep: string = FS): string {
        let start = 0;
        let end = path.length;
        let slen = sep.length;
        while (start + slen <= end && path.endsWith(sep, end)) end -= slen;
        if (start == 0 && end == path.length) return path;
        return path.substring(start, end);
    }

    static ensureLeading_(path: string, sep: string = FS): string {
        if (path.startsWith(sep)) return path;
        return sep + path;
    }

    static ensureTrailing_(path: string, sep: string = FS): string {
        if (path.endsWith(sep)) return path;
        return path + sep;
    }
}

type BaseUri = Uri;
type BaseUriX = BaseUri | null;
type Basedir = string;
type BasedirX = Basedir | null;
type UriPathPart = string | string[];
type UriPathPartX = UriPathPart | null;
type UriSearchPart = string | Map<string, string>;

class Uri {
    private static readonly BASEURI = new URL(CF.SCHEME_HOSTPORT_);
    private static readonly PAT = new RegExp("^(\\w*:)?(//[\\w@]+)?(:\\d+)?(.*?)(\\?.*)?(\\#.*?)?\$");
    static get ROOT$() { return Uri.from_(FS); };

    #url: URL;
    #basedir: string;
    #decodedPath: string;

    private constructor(
        url: URL,
        basedir: string,
        decodedPath: string,
        readonly isRelative$: boolean,
    ) {
        this.#url = url;
        this.#basedir = basedir;
        this.#decodedPath = decodedPath;
    }
    /// @param href A relative href if baseurl is specified, an absolute href if baseurl is not specified.
    /// @param baseurl Base Uri for the href. If not specified, href is taken as absolute and default scheme://host:port/ is used as basepath.
    /// @return A relative Uri if href is relative, an absolute Uri if href is absolute.
    /// @throw Error on error.
    static parse_(href: string, baseurl?: BaseUriX): Uri {
        let url = replaceAll_(replaceAll_(href, "[", "%5B"), "]", "%5D");
        const m = Uri.PAT.exec(url);
        if (m == null) { throw new Error(MSG.string_(RS.InvalidURL)); }
        const scheme = m[1] ?? "";
        const host = m[2] ?? "";
        const port = m[3] ?? "";
        const path = m[4];
        const isrel = scheme.length == 0 && host.length == 0 && port.length == 0 && !path.startsWith(FS);
        const base = baseurl === undefined || baseurl === null
            ? this.BASEURI
            : typeof (baseurl) === "string"
                ? new URL(baseurl)
                : baseurl.#url;
        const u = new URL(url, base);
        const decodedpath = decodeURIComponent(u.pathname);
        const decoded = An.dataUrlScheme_(scheme) != null ? decodedpath : Basepath.cleanFilepath_(decodedpath);
        const segments = decodeURIComponent(base.pathname).split(FS);
        if (segments.length > 0) segments.pop();
        let basedir = segments.join(FS);
        if (!basedir.startsWith(FS)) { basedir = FS + basedir; }
        return new Uri(u, basedir, decoded, isrel);
    }
    /// @param path Encoded path as string or decoded path segments as Array<string>.
    /// If baseuri is provided and not null, the path is considered as relative to baseuri.
    /// @param search Encoded search string with leading "?" or empty string if search not present, or decoded key/value pairs.
    /// @param hash Encoded fragment with leading "#" or empty string if fragment not present.
    /// @param baseurl Must provided for relative url, ignored if url is absolute.
    /// @throws On error.
    static from_(path: string[] | string, search: Map<string, string> | string = "", hash: string = "", baseurl?: BaseUriX): Uri {
        let pathstring = FS;
        if (typeof (path) === "string") {
            pathstring = path;
        } else if (path.length > 0) {
            pathstring = path.map((s) => encodeURIComponent(s)).join(FS);
        }
        let searchstring = "";
        if (typeof (search) === "string") {
            searchstring = search;
        } else if (search.size > 0) {
            searchstring = "?";
            for (let [key, value] of search) {
                if (searchstring.length > 1) searchstring += "&";
                searchstring += encodeURIComponent(key) + (value.length > 0 ? "=" + encodeURIComponent(value) : "");
            }
        }
        return Uri.parse_(pathstring + searchstring + hash, baseurl);
    }
    static asMap_(query: URLSearchParams): Map<string, string> {
        let ret = new Map<string, string>();
        query.forEach((value, key) => ret.set(key, value));
        return ret;
    }
    get hash$(): string {
        return this.#url.hash;
    }
    get host$(): string {
        return this.#url.host;
    }
    get hostname$(): string {
        return this.#url.hostname;
    }
    /// Absolute URL string including scheme, host, port, ... etc..
    get href$(): string {
        return this.#url.href;
    }
    get origin$(): string {
        return this.#url.origin;
    }
    get password$(): string {
        return this.#url.password;
    }
    /// Absolute encoded URL path.
    get pathname$(): string {
        return this.#url.pathname;
    }
    get port$(): string {
        return this.#url.port;
    }
    get protocol$(): string {
        return this.#url.protocol;
    }
    get search$(): string {
        return this.#url.search;
    }
    get searchParams$(): URLSearchParams {
        return this.#url.searchParams;
    }
    get username$(): string {
        return this.#url.username;
    }
    get hasQuery$(): boolean {
        return this.search$.length > 0;
    }
    get hasFragment$(): boolean {
        return this.hash$.length > 0;
    }
    /// @return The decoded absolute or relative path.
    /// @throws If Uri is invald.
    get path$(): string {
        let ret = this.isRelative$ ? Basepath.rpath_(this.#basedir, this.#decodedPath) : this.#decodedPath;
        return (ret.length > 0 && this.#decodedPath.endsWith(FS) && !ret.endsWith(FS)) ? ret + FS : ret;
    }
    get encodedPath$(): string {
        return this.path$.split(FS).map(value => encodeURIComponent(value)).join(FS);
    }
    /// LIke href$ but without scheme://host:port, unless it is a dataurl.
    get encoded$(): string {
        if (this.isDataUrl$) return this.protocol$ + this.#decodedPath + this.search$ + this.hash$;
        return this.encodedPath$ + this.search$ + this.hash$;
    }
    get pathSegments$(): string[] {
        return this.path$.split(FS);
    }
    get isDataUrl$(): boolean {
        return An.dataUrlScheme_(this.protocol$) != null;
    }
    get filename$(): string {
        return Basepath.filename_(this.#decodedPath);
    }
    get lcSuffix$(): string {
        return Basepath.lcSuffix_(this.#decodedPath);
    }
    changeSearchParams(search: Map<string, string>, baseuri: BaseUriX): Uri {
        return Uri.from_(this.encodedPath$, search, this.hash$, baseuri);
    }
    /// @return If already relative, return self, otherwise a new Uri relative to the baseurl.
    /// @throws If baseurl is not valid.
    toRelative_(): Uri {
        if (this.isRelative$) { return this; };
        return new Uri(this.#url, this.#basedir, this.#decodedPath, true);
    }
    /// @return If already absolute, return self, otherwise a new absolute Uri.
    toAbsolute_(): Uri {
        if (!this.isRelative$) { return this; }
        return new Uri(this.#url, this.#basedir, this.#decodedPath, false);
    }
    /// @param href A href or Uri.
    /// @return A relative Uri relative to this Uri if href is relative, an absolute Uri if href is absolute.
    /// @throws On error.
    resolveUri_(href: string | Uri): Uri {
        href = (typeof (href) === "string" ? href : href.toString());
        return Uri.parse_(href, this);
    }
    equals(other: Uri): boolean {
        return this.toString() == other.toString();
    }
    toShortString(): string {
        return (ArrayUt.last_(this.pathSegments$) ?? "") + this.search$ + this.hash$;
    }
    toString(): string {
        return this.encoded$;
    }
}

type UriX = Uri | null;

abstract class UriUt {
    private static readonly PAT = new RegExp("^(\\w*:)?(//[\\w@]+)?(:\\d+)?(.*?)(\\?.*)?(\\#.*?)?\$");
    static split_(href: string): [string, string, string] {
        let [path, search] = TextUt.splitAt_(href, href.indexOf("?"));
        let hash: string;
        if (search.length == 0) {
            [path, hash] = TextUt.splitAt_(path, path.indexOf("#"));
        } else {
            [search, hash] = TextUt.splitAt_(search, search.indexOf("#"));
        }
        path = this.stripSchemeHost(path);
        return [path, search, hash];
    }

    /// Strip scheme://host:port, or //host:port
    static stripSchemeHost(href: string): string {
        if (href.startsWith("data:") || href.startsWith("blob:")) return href;
        let match = this.PAT.exec(href);
        if (match == null) return href;
        return (match[4] ?? "") + (match[5] ?? "") + (match[6] ?? "");
    }

    static filename_(uri: UriX): string {
        if (uri == null) return "";
        return ArrayUt.last_(uri.pathSegments$) ?? "";
    }

    static stem_(uri: UriX): string {
        return Basepath.splitFilename_(this.filename_(uri))[0];
    }

    static suffix_(uri: UriX): string {
        return Basepath.splitFilename_(this.filename_(uri))[1];
    }

    static lcSuffix_(uri: UriX): string {
        return this.suffix_(uri).toLowerCase();
    }

    static lcSuffixOfSegments_(segments: string[]): string {
        return Basepath.lcSuffixOfFilename_(ArrayUt.last_(segments) ?? "");
    }
}

class Point<T> {
    constructor(public x: T, public y: T) { }
}

class StringBuffer {
    private buf = sarray_();
    constructor(s: string = "") {
        if (s.length > 0) this.buf.push(s);
    }
    write_(s: string): this {
        if (s.length > 0) this.buf.push(s);
        return this;
    }
    get length$(): Int {
        return this.buf.length;
    }
    toString(sep: string = ""): string {
        return this.buf.join(sep);
    }
}

interface ITimer {
    cancel_(): void;
    isActive_(): boolean;
}

class Timer implements ITimer {
    private timer$: any;
    constructor(ms: Long, callback: Fun00) {
        this.timer$ = setTimeout(() => {
            callback();
        }, ms);
    }
    static sleep_(ms: number, callback: Fun00): Timer {
        return new Timer(ms, callback);
    }
    static sleep0_ = (callback: Fun00) => {
        return new Timer(0, callback);
    };
    static sleep00_ = (callback: Fun00) => {
        new Timer(0, () => {
            new Timer(0, callback);
        });
    };
    static sleep1_ = (callback: Fun00) => {
        window.requestAnimationFrame(() => {
            callback();
        });
    };
    static frame11_ = (callback: Fun00) => {
        window.requestAnimationFrame(() => {
            window.requestAnimationFrame(() => {
                callback();
            });
        });
    };
    static optional0_ = <T>(value: T | null | undefined, callback: Fun10<T>) => {
        if (value === null || value === undefined) { return; }
        Timer.sleep0_(() => callback(value));
    };
    cancel_() {
        if (this.timer$ != null) {
            clearTimeout(this.timer$);
            this.timer$ = null;
        }
    }
    isActive_(): boolean {
        return this.timer$ != null;
    }
}
class PeriodicTimer implements ITimer {
    private timer$: any;
    private active$ = false;
    constructor(ms: Long, callback: Fun10<PeriodicTimer>) {
        this.active$ = true;
        this.timer$ = setInterval(() => {
            this.active$ = false;
            callback(this.timer$);
        }, ms);
    }
    cancel_() {
        if (this.timer$ != null) {
            this.active$ = false;
            clearTimeout(this.timer$);
            this.timer$ = null;
        }
    }
    isActive_(): boolean {
        return this.active$;
    }
}

class StreamSubscription {
    constructor(
        readonly receiver$: EventTarget,
        readonly type$: string,
        readonly listener$: EventListener) { }
    cancel_() {
        this.receiver$.removeEventListener(this.type$, this.listener$);
    }
}

////////////////////////////////////////////////////////////////////////

type EventName = keyof HTMLElementEventMap;
type IntUnit = [size: Int, unit: string];
type DoubleUnit = [size: Double, unit: string];
type DoubleStringUnit = [size: string, unit: string];
type BoolCallback = (b: boolean) => void;
type MediaInfoCallback = (info: MediaInfo) => void;
type CanvasCallback = (e: HTMLCanvasElement) => void;
type ClipboardGetter = (callback: JSONCallback) => void;
type ClipboardSetter = (value: string) => void;
type ConfirmCallback = (callback: BoolCallback) => void;
type DoubleCallback = (value: number) => void;
type FileInfoCallback = (info: FileInfo) => void;
type IFrameEventCallback = (e: Event) => void;
type IntCallback = (value: number) => void;
type IntXCallback = (value: numberX) => void;
type JSONCallback = (ret: JSONObject) => void;
type TestResultCallback = (value: TestResult) => void;
type StringCallback = (value: string) => void;
type String2Callback = (value1: string, value2: string) => void;
type StringXCallback = (value: stringX) => void;
type StringListCallback = (values: string[]) => void;
type StringListXCallback = (values: string[] | null) => void;
type MouseEventCallback = (e: MouseEvent) => void;
type KeyboardEventCallback = (e: KeyboardEvent) => void;
type EventCallback = (e: Event) => void;
type EventCallback1<T extends Event> = (e: T) => void;
type TargetEventCallback<E extends Event = Event> = (target: HTMLElement, e: E) => void;
type UriXCallback = (uri: UriX) => void;
type IntCallback0 = () => number;
type DoubleCallback0 = () => number;
type DateFormatter = (year: string, month: string, day: string) => string;
type TimeFormatter = (hour: number, minute: string, second: string) => string;

/// @param callback Use next(true) to terminate iteration.
type AsyncListIterator<T> = (item: T, index: number, next: (terminate: boolean) => void) => void;
type IGestureListener = (event: string, data: JSONObject) => boolean;

type BusyWaitCallback<T> = (data: T) => void;
type AsyncWaitPredicate<T> = (callback: BusyWaitCallback<T>) => void;

////////////////////////////////////////////////////////////////////////

const BUILD_VERSION = 3000005;

const K = 1024;
const _H02 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",];
const _HEX = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F",];
const INVALID_TAGS = [
    "embed",
    "frame",
    "iframe",
    "object",
    "script"
];
const IMAGE_SIZE_LIST = [
    "",
    "256",
    "512",
    "640",
    "800",
    "960",
    "1024",
    "1280",
    "1600",
    "1920",
    "2048",
    "2560",
    "3072",
    "3840",
    "4096",
    "5120",
    "8192",
];
const _LINEBREAKS = [
    0x000a,
    0x000d,
    0x2028,
    0x2029,
];
const _SPACES = [
    0x0009,
    0x000b,
    0x000c,
    0xfeff,
    0x0020,
    0x00A0,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2007,
    0x2008,
    0x2009,
    0x200A,
    0x200B,
    0x202F,
    0x3000,
];

const _WHITESPACES = [
    0x000a,
    0x000d,
    0x2028,
    0x2029,
    0x0009,
    0x000b,
    0x000c,
    0xfeff,
    0x0020,
    0x00A0,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2007,
    0x2008,
    0x2009,
    0x200A,
    0x200B,
    0x202F,
    0x3000,
];
const AMP = "&".codePointAt(0)!;

abstract class ATTR {
    static readonly AnUndoing = "xxx-jk";
    static readonly AnAction = "xxx-i5";
    static readonly id = "id";
    static readonly AnNoClick = "xxx-0p";
    static readonly classes = "class";
    static readonly xAnnotation = "x-a";
    static readonly xRole = "x-role";
    static readonly name$ = "name";
    static readonly autocomplete = "autocomplete";
    static readonly tabindex = "tabindex";
    static readonly href = "href";
    static readonly spellcheck = "spellcheck";
    static readonly xButton = "x-bt";
    static readonly AnIndex = "xxx-as";
    static readonly xTooltips = "x-t";
    static readonly autocapitalize = "autocapitalize";
    static readonly AnInfo = "xxx-h5";
    static readonly AnText = "xxx-htx";
    static readonly AnKey = "xxx-key";
    static readonly AnValue = "xxx-val";
    static readonly contenteditable = "contenteditable";
    static readonly AnOptions = "xxx-8f";
    static readonly xDateFormat = "x-f";
    static readonly AnToggleGroup = "xxx-80";
    static readonly src = "src";
    static readonly AnMime = "xxx-j2";
    static readonly style = "style";
    static readonly AnRedoing = "xxx-1l";
    static readonly xTemplate = "x-tp";
    static readonly xPlaceholder = "x-ph";
    static readonly xTemplatePlaceholder = "x-th";
    static readonly placeholder = "placeholder";
    static readonly xAction = "x-action";
    static readonly AnSaved = "xxx-lg";
    static readonly xPageTemplate = "x-pt";
    static readonly xInfo = "x-i";
    static readonly xHref = "x-href";
    static readonly autocorrect = "autocorrect";
}
abstract class AVALUE {
    static readonly xStop = "stop";
}
abstract class AjaxAction {
    static readonly showSidepanel = "XxXjH";
    static readonly toasterOnLoad = "XxXtol";
    static readonly onResizeWindow = "XxXxI";
    static readonly resume = "XxXAd";
    static readonly ajax = "XxX6e";
    static readonly videoRecordingResult = "XxXpu";
    static readonly scanDocumentResult = "XxXiW";
    static readonly audioStatusChanged = "XxXy9";
    static readonly toaster = "XxXcg";
    static readonly spinnerHide = "XxXZZ";
    static readonly login = "XxXDJ";
    static readonly spinnerShow = "XxXdH";
    static readonly onNotificationResponse = "XxXED";
    static readonly takePhotoResult = "XxXA6";
    static readonly restore = "XxX0G";
    static readonly onCallback = "XxXoO";
    static readonly spinner = "XxXww";
    static readonly showIncoming = "XxXr9";
    static readonly backup = "XxXMs";
    static readonly browse = "XxXsa";
    static readonly refreshEvents = "XxX6y";
    static readonly gesture = "XxXPq";
    static readonly navigateBack = "XxX8V";
    static readonly pause = "XxXGE";
    static readonly hideCaret = "XxXN1";
    static readonly export = "XxX30";
    static readonly loginResult = "XxXFv";
}
abstract class CSS {
    static readonly FaDollar = "XxXKW";
    static readonly FaCalendar = "XxXin";
    static readonly FaShoppingCart = "XxXyo";
    static readonly xWidgetTodo = "x-w-todo";
    static readonly xVideoPoster = "x-video-poster";
    static readonly AnContextButton = "XxXTB";
    static readonly xDodgerblue = "x-dodgerblue";
    static readonly FaAmbulance = "XxXQV";
    static readonly FaUnlockAlt = "XxXQI";
    static readonly xCalcItem = "x-calc-item";
    static readonly AnEventsToday = "XxXUH";
    static readonly xButtonCell = "x-button-cell";
    static readonly FaMicrophoneSlash = "XxXX0";
    static readonly AnFlashSpotlight = "XxXrc";
    static readonly xColorDodgerblue = "x-color-dodgerblue";
    static readonly xDateHoliday = "x-date-holiday";
    static readonly AnMarginH5 = "XxXyq";
    static readonly xShadowSeGray = "x-shadow-se-gray";
    static readonly FaEllipsisH = "XxXUm";
    static readonly FaArchive = "XxXE2";
    static readonly AnImageAnnotator = "XxXyA";
    static readonly AnButtonInline = "XxXIW";
    static readonly AnFlexButton = "XxXBA";
    static readonly xColorBlue = "x-color-blue";
    static readonly Fa = "XxXqU";
    static readonly AnSmokescreen = "XxXTT";
    static readonly xRightSplitcontent = "x-rightsplitcontent";
    static readonly xDate = "x-date";
    static readonly xAnnotationStyleImage = "x-a-style-image";
    static readonly xAlignRight = "x-align-right";
    static readonly FaSlack = "XxXto";
    static readonly xShadowRed = "x-shadow-red";
    static readonly AnAudioBanner = "XxXKb";
    static readonly FaCheckSquare = "XxX0o";
    static readonly FaHandOUp = "XxXcm";
    static readonly xHcaption = "x-hcaption";
    static readonly xButtonWidth = "x-button-width";
    static readonly AnBorderSampleInner = "XxXld";
    static readonly FaCamera = "XxXO0";
    static readonly xDraggable = "x-draggable";
    static readonly xControl = "x-control";
    static readonly FaStop = "XxXUt";
    static readonly xCalendar = "x-calendar";
    static readonly FaSmileO = "XxXbk";
    static readonly AnToasterOK = "XxXqN";
    static readonly AnCalHead = "XxX8Z";
    static readonly xSlider = "x-slider";
    static readonly xPictureframe = "x-pictureframe";
    static readonly AnSidepanelDocument = "XxXH6";
    static readonly AnViewportContent = "XxXb0";
    static readonly FaShare = "XxXmQ";
    static readonly FaMinusSquareO = "XxX8h";
    static readonly xBullet = "x-bullet";
    static readonly AnEventsDone = "XxXnz";
    static readonly FaWindows = "XxXFK";
    static readonly xWidgetToc2 = "x-w-toc2";
    static readonly xGutter = "x-gutter";
    static readonly AnSliderHandle = "XxXVd";
    static readonly FaLongArrowRight = "XxXlv";
    static readonly xColorPlum = "x-color-plum";
    static readonly AnBlue = "XxXsQ";
    static readonly xBorderNone = "x-border-none";
    static readonly AnSubmenuContainer = "XxXse";
    static readonly xAudio = "x-audio";
    static readonly xAudioholder = "x-audioholder";
    static readonly FaBookmark = "XxXNV";
    static readonly FaListUl = "XxX15";
    static readonly FaStickyNoteO = "XxXkj";
    static readonly FaMinusSquare = "XxXnG";
    static readonly FaUserPlus = "XxXCR";
    static readonly xxTitle = "xx-title";
    static readonly xImageholder = "x-imageholder";
    static readonly xPlaceholder = "x-placeholder";
    static readonly AnContentViewport = "XxXMl";
    static readonly AnTreeExpanded = "XxXnX";
    static readonly FaToggleRight = "XxXVD";
    static readonly xCalHead = "x-cal-head";
    static readonly FaFlag = "XxXEt";
    static readonly xAnnotationContent = "x-a-content";
    static readonly AnEventsTomorrow = "XxXcu";
    static readonly xGreen = "x-green";
    static readonly AnEventsDate = "XxXlz";
    static readonly FaReplyAll = "XxX6K";
    static readonly FaFolder = "XxXDY";
    static readonly xFontFixed = "x-font-fixed";
    static readonly xWidgetTocStyle01 = "x-w-toc-style01";
    static readonly AnTextList = "XxXy1";
    static readonly xStyle = "x-style";
    static readonly AnMenuSelect = "XxX9R";
    static readonly FaRotateLeft = "XxX2y";
    static readonly xCalcPrice = "x-calc-price";
    static readonly AnTab = "XxXie";
    static readonly FaTh = "XxXfth";
    static readonly FaRefresh = "XxXvd";
    static readonly FaRss = "XxXas";
    static readonly xHead3 = "x-head3";
    static readonly AnGalleryContent = "XxXdv";
    static readonly xAudioChannels = "x-audio-channels";
    static readonly FaTruck = "XxXPy";
    static readonly AnButtonFa = "XxXOL";
    static readonly FaShareAlt = "XxX6l";
    static readonly xDisabledInDesktop = "x-disabled-in-desktop";
    static readonly xOrange = "x-orange";
    static readonly xEmojiHome = "x-emoji-home";
    static readonly AnDateSelected = "XxXBn";
    static readonly xAlignCenter = "x-align-center";
    static readonly FaThLarge = "XxXthl";
    static readonly AnTreeNode = "XxXat";
    static readonly FaShareSquare = "XxXMG";
    static readonly AnAudioFilename = "XxX1j";
    static readonly AnDirInfo = "XxXLd";
    static readonly FaArrowCircleLeft = "XxX81";
    static readonly xMediaFilesize = "x-media-filesize";
    static readonly xAnchor = "x-anchor";
    static readonly FaPrint = "XxXKJ";
    static readonly xCode = "x-code";
    static readonly FaUserSecret = "XxXCy";
    static readonly AnSpacerTop5 = "XxXTX";
    static readonly xShadowGreen = "x-shadow-green";
    static readonly AnWidth3 = "XxXAd";
    static readonly FaRub = "XxXyl";
    static readonly xEmojiTodo = "x-emoji-todo";
    static readonly AnFilepicker = "XxXpH";
    static readonly AnIndicatorTopRight = "XxXHD";
    static readonly xShadowBlue = "x-shadow-blue";
    static readonly xPlay = "x-play";
    static readonly xEmojiBlank = "x-emoji-blank";
    static readonly xHideDone = "x-hide-done";
    static readonly FaHistory = "XxXvB";
    static readonly FaFileImageO = "XxXKH";
    static readonly AnInputButton = "XxX16";
    static readonly xWidgetShoppingTotal = "x-w-shopping-total";
    static readonly FaBomb = "XxXRg";
    static readonly FaCheckCircle = "XxXoG";
    static readonly AnSymbolList = "XxXoj";
    static readonly FaBellSlashO = "XxXL5";
    static readonly xPictureframeRotated = "x-pictureframe-rotated";
    static readonly AnLineNumberInput = "XxXJT";
    static readonly AnEventsItem = "XxXeJ";
    static readonly FaList = "XxX7n";
    static readonly AnSearchbox = "XxXTN";
    static readonly AnAtt = "XxXz3";
    static readonly FaDeviantart = "XxX7y";
    static readonly FaImage = "XxXF0";
    static readonly FaToggleOff = "XxXKw";
    static readonly AnAudioControl = "XxXwG";
    static readonly xBox = "x-box";
    static readonly FaSave = "XxX1e";
    static readonly AnCalcCell = "XxXVH";
    static readonly FaFileAudioO = "XxX3R";
    static readonly FaKey = "XxXHr";
    static readonly AnToasterContent = "XxXFg";
    static readonly AnPromptViewport = "XxXUy";
    static readonly xDisabled = "x-disabled";
    static readonly AnTabbar = "XxX92";
    static readonly xAudioRate = "x-audio-rate";
    static readonly FaAlignLeft = "XxX99";
    static readonly AnFlex0 = "XxXfk";
    static readonly xPhoto = "x-photo";
    static readonly AnDisabledInDesktop = "XxXhid";
    static readonly xWidgetTodoContent = "x-w-todo-content";
    static readonly xCalcQuantity = "x-calc-quantity";
    static readonly AnTemplateHeader = "XxXYT";
    static readonly FaPlus = "XxX1w";
    static readonly xVcaption = "x-vcaption";
    static readonly AnPromptInputSlider = "XxXLZ";
    static readonly AnSelectedHighlight = "XxXfz";
    static readonly xBorderLine = "x-border-line";
    static readonly xWidgetToc3 = "x-w-toc3";
    static readonly FaHourglassO = "XxX9d";
    static readonly xZindex80 = "x-zindex-80";
    static readonly xNowrap = "x-nowrap";
    static readonly xBoldColor = "x-bold-color";
    static readonly xEmojiPhoto = "x-emoji-photo";
    static readonly xMatchT = "x-m-t";
    static readonly FaPaperclip = "XxX2v";
    static readonly FaFolderOpen = "XxXfS";
    static readonly FaBarcode = "XxXob";
    static readonly AnFlex00Auto = "XxXji";
    static readonly xZindex60 = "x-zindex-60";
    static readonly xBulletFa = "x-bullet-fa";
    static readonly xHideable = "x-hideable";
    static readonly xAudioinfo = "x-audioinfo";
    static readonly AnMarginTop5 = "XxXb3";
    static readonly xSegment = "x-segment";
    static readonly xShadowSe2Black = "x-shadow-se2-black";
    static readonly xHidetemp = "x-hidetemp";
    static readonly xListStyleNone = "x-list-style-none";
    static readonly AnTemplateMenu = "XxXn9";
    static readonly FaCutMarked = "XxX57";
    static readonly FaCompress = "XxXBk";
    static readonly xWidgetShoppingPrice = "x-w-shopping-price";
    static readonly AnCalcOp = "XxXFX";
    static readonly AnSmall = "XxXVc";
    static readonly xPortrait = "x-portrait";
    static readonly AnBold = "XxXcU";
    static readonly xHlayout = "x-hlayout";
    static readonly xCalcError = "x-calc-error";
    static readonly FaEdit = "XxXVj";
    static readonly xVideoFilesize = "x-video-filesize";
    static readonly xButton = "x-button";
    static readonly FaFileVideoO = "XxXNl";
    static readonly AnFilename = "XxXR6";
    static readonly AnPromptStatus = "XxX8I";
    static readonly xZindex70 = "x-zindex-70";
    static readonly xxDrawing = "xx-drawing";
    static readonly FaArrows = "XxXvY";
    static readonly AnFlexStretch = "XxXE3";
    static readonly FaAngleDoubleDown = "XxXIs";
    static readonly FaCut = "XxXH2";
    static readonly AnSpacer5 = "XxXot";
    static readonly FaGlobe = "XxXLP";
    static readonly FaBars = "XxXwT";
    static readonly xMediaCaption = "x-media-caption";
    static readonly xBlue = "x-blue";
    static readonly AnFlashHighlight = "XxXBp";
    static readonly AnSelect = "XxXK9";
    static readonly xZBottom = "x-z-bottom";
    static readonly xZindex40 = "x-zindex-40";
    static readonly AnCalcDisplay = "XxXXd";
    static readonly xCalBody = "x-cal-body";
    static readonly xSlideshowPlay = "x-slideshow-play";
    static readonly AnTemplateCell = "XxXXr";
    static readonly FaArrowCircleDown = "XxXdj";
    static readonly xContent = "x-content";
    static readonly AnWidth2 = "XxXqT";
    static readonly AnTxt = "XxXcw";
    static readonly AnMenurow6 = "XxXmK";
    static readonly AnAudioPlayer = "XxXb2";
    static readonly FaTrash = "XxXRj";
    static readonly xTodoItem = "x-todo-item";
    static readonly xNarrow = "x-narrow";
    static readonly AnFull = "XxXOY";
    static readonly xHighlightColor = "x-highlight-color";
    static readonly xBody = "x-body";
    static readonly xRotate = "x-rotate";
    static readonly FaSearch = "XxXNP";
    static readonly FaWrench = "XxXWW";
    static readonly AnTextOverlay = "XxX3N";
    static readonly FaFileTextO = "XxXWl";
    static readonly xAnnotationTarget = "x-a-target";
    static readonly AnFlex = "XxX1P";
    static readonly xColorDarkblue = "x-color-darkblue";
    static readonly FaCommentO = "XxXzR";
    static readonly xEmojiBlog = "x-emoji-blog";
    static readonly AnEventsPending = "XxXCJ";
    static readonly AnSidebarTab = "XxXbz";
    static readonly FaHeader = "XxXxg";
    static readonly xRightSidebarPadding = "x-rsb-padding";
    static readonly AnMenuInput = "XxXMS";
    static readonly AnButtonDown = "XxXe0";
    static readonly AnTreeControl = "XxXGr";
    static readonly xCalcSubtotal = "x-calc-subtotal";
    static readonly FaVolumeUp = "XxXG2";
    static readonly AnUnderline = "XxX8U";
    static readonly xZindex100 = "x-zindex-100";
    static readonly xRoundedCorners = "x-rounded-corners";
    static readonly FaItalic = "XxXkJ";
    static readonly FaPlayCircleO = "XxXdN";
    static readonly xCalcContext = "x-calc-context";
    static readonly xHead2 = "x-head2";
    static readonly FaColumns = "XxXRJ";
    static readonly AnTabPanel = "XxXiu";
    static readonly AnDialog = "XxX2o";
    static readonly xSlideshowImage = "x-slideshow-image";
    static readonly AnAudioSlider = "XxXSH";
    static readonly xHighlightGreen = "x-highlight-green";
    static readonly xShadowGray = "x-shadow-gray";
    static readonly xZindex10 = "x-zindex-10";
    static readonly xZindex30 = "x-zindex-30";
    static readonly xPhotoDef = "x-photo-def";
    static readonly xCalcTotal = "x-calc-total";
    static readonly xColorGray = "x-color-gray";
    static readonly FaDesktop = "XxXAb";
    static readonly xEmojiCards = "x-emoji-cards";
    static readonly FaMagic = "XxX7I";
    static readonly FaShower = "XxXd2";
    static readonly AnToasterInfo = "XxXCV";
    static readonly AnTextButton = "XxXwn";
    static readonly FaSquare = "XxXaK";
    static readonly AnPromptInput = "XxXNQ";
    static readonly xVideoResolution = "x-video-resolution";
    static readonly FaLongArrowUp = "XxX1h";
    static readonly xColorWhite = "x-color-white";
    static readonly xList = "x-list";
    static readonly AnFlex01Auto = "XxXZA";
    static readonly xRightSidepanel = "x-rightsidepanel";
    static readonly xxBullet = "xx-bullet";
    static readonly AnHalf = "XxX4k";
    static readonly xVideoDuration = "x-video-duration";
    static readonly FaCertificate = "XxXFu";
    static readonly FaCalendarPlusO = "XxXEY";
    static readonly xFloatRightClearNone = "x-float-right-clear-none";
    static readonly FaTumblr = "XxXI3";
    static readonly AnRecents = "XxXJ1";
    static readonly xUnderline = "x-underline";
    static readonly AnVerticalMenu = "XxXx2";
    static readonly FaUnlock = "XxXPp";
    static readonly xPageBreakAfter = "x-page-break-after";
    static readonly xFlexbox = "x-flexbox";
    static readonly xSymbol = "x-symbol";
    static readonly FaBellSlash = "XxXwy";
    static readonly AnWidth4 = "XxXo3";
    static readonly xButtonHeight = "x-button-height";
    static readonly AnRoundCorners = "XxX3r";
    static readonly xWidgetShoppingQuantity = "x-w-shopping-quantity";
    static readonly xWidgetTodoBody = "x-w-todo-body";
    static readonly AnImageViewer = "XxXmN";
    static readonly FaCutNotMarked = "XxXyF";
    static readonly xNone = "x-none";
    static readonly FaCheckCircleO = "XxXYj";
    static readonly FaFileArchiveO = "XxX39";
    static readonly AnPromptTextarea = "XxXnf";
    static readonly AnHeading = "XxXA0";
    static readonly FaSearchPlus = "XxX3H";
    static readonly FaClone = "XxXf8";
    static readonly AnFlexCenter = "XxXbn";
    static readonly FaParagraph = "XxXWR";
    static readonly AnFileInfo = "XxX8A";
    static readonly xLeftSplitpanel = "x-leftsplitpanel";
    static readonly xBold = "x-bold";
    static readonly xStyleLight = "x-style-light";
    static readonly FaTag = "XxX5O";
    static readonly xAudioDatetime = "x-audio-datetime";
    static readonly AnFill = "XxXLO";
    static readonly xItalic = "x-italic";
    static readonly xSubscript = "x-subscript";
    static readonly xSelected = "x-selected";
    static readonly xRed = "x-red";
    static readonly xHideInDesktop = "x-hide-in-desktop";
    static readonly FaExpand = "XxXDK";
    static readonly xPre = "x-pre";
    static readonly xClientHide = "x-client-hide";
    static readonly FaEye = "XxXRH";
    static readonly FaSquareO = "XxXu3";
    static readonly AnButtonFlat = "XxXlZ";
    static readonly FaListOl = "XxXAx";
    static readonly xAccordionContent = "x-accordion-content";
    static readonly AnUpperMainMenu = "XxXvZ";
    static readonly xPlaytime = "x-playtime";
    static readonly FaFont = "XxXKm";
    static readonly xListContent = "x-list-content";
    static readonly FaHandODown = "XxXEG";
    static readonly AnMarker = "XxXau";
    static readonly AnTreeLeaf = "XxXyN";
    static readonly FaRandom = "XxXHS";
    static readonly FaQrcode = "XxXVV";
    static readonly xAudioPoster = "x-audio-poster";
    static readonly xHeader = "x-header";
    static readonly FaSortAlphaAsc = "XxXqD";
    static readonly xHideInSmallScreen = "x-hide-in-small-screen";
    static readonly FaExternalLink = "XxX3X";
    static readonly FaSuperscript = "XxXTP";
    static readonly FaBraille = "XxXtg";
    static readonly xEmojiShopping = "x-emoji-shopping";
    static readonly xSlideshow = "x-slideshow";
    static readonly xFooter = "x-footer";
    static readonly FaInfoCircle = "XxXPR";
    static readonly FaSlideshare = "XxXqz";
    static readonly AnWidth6 = "XxXBH";
    static readonly xWidgetTodoStyle01 = "x-w-todo-style01";
    static readonly xWidgetShoppingHeader = "x-w-shopping-header";
    static readonly FaChevronCircleUp = "XxXFI";
    static readonly xToolbarFontsize = "x-toolbar-fontsize";
    static readonly AnSpotlight = "XxXTi";
    static readonly FaCircleThin = "XxX7m";
    static readonly xZindex20 = "x-zindex-20";
    static readonly FaFolderOpenO = "XxX0R";
    static readonly FaToggleUp = "XxXQ2";
    static readonly AnPromptMsg = "XxXfN";
    static readonly AnBoxShadow = "XxXic";
    static readonly xShadowSeBlack = "x-shadow-se-black";
    static readonly FaPaste = "XxX4a";
    static readonly AnColorFG = "XxXEH";
    static readonly xRightSidebarTab = "x-rsb-tab";
    static readonly FaInfo = "XxX5P";
    static readonly FaChevronLeft = "XxXUi";
    static readonly AnSpinner = "XxXV9";
    static readonly xAudioDuration = "x-audio-duration";
    static readonly FaRotateRight = "XxXkv";
    static readonly FaExternalLinkSquare = "XxX1p";
    static readonly xSmokescreen = "x-smokescreen";
    static readonly xLeftSidepanel = "x-leftsidepanel";
    static readonly FaStackExchange = "XxXy3";
    static readonly xColorYellow = "x-color-yellow";
    static readonly xMedia = "x-media";
    static readonly FaAlignCenter = "XxXpj";
    static readonly FaBold = "XxXio";
    static readonly FaPlay = "XxXUl";
    static readonly AnPromptCheckboxInput = "XxXmX";
    static readonly AnPromptContent = "XxXbG";
    static readonly AnSelected = "XxXQv";
    static readonly xAccordionShow = "x-accordion-show";
    static readonly xShadowOrange = "x-shadow-orange";
    static readonly AnPromptSelect = "XxXbq";
    static readonly AnRow = "XxX36";
    static readonly FaThList = "XxXD0";
    static readonly xSticker = "x-sticker";
    static readonly AnColorInput2 = "XxX2a";
    static readonly FaUnderline = "XxXBB";
    static readonly FaArrowCircleRight = "XxXcI";
    static readonly AnDateHoliday = "XxXtu";
    static readonly xWidgetTocBullet = "x-w-toc-bullet";
    static readonly FaSignOut = "XxXcf";
    static readonly AnEventsPanel = "XxXkt";
    static readonly AnNot = "XxXeU";
    static readonly xPeek = "x-peek";
    static readonly AnMenubar = "XxXnA";
    static readonly xxError = "xx-error";
    static readonly xColorRed = "x-color-red";
    static readonly AnCalcDigit = "XxXik";
    static readonly xHideInLargeScreen = "x-hide-in-large-screen";
    static readonly xAccordionButton = "x-accordion-button";
    static readonly AnRuler = "XxXg5";
    static readonly AnZebra = "XxXcA";
    static readonly xEmojiCalendar = "x-emoji-calendar";
    static readonly AnButtonLeft = "XxX32";
    static readonly xColorBlack = "x-color-black";
    static readonly AnToolbar = "XxXoy";
    static readonly AnGray = "XxXUL";
    static readonly AnFaSlash = "XxXCk";
    static readonly AnVerticalViewportWide = "XxXff";
    static readonly xZindex90 = "x-zindex-90";
    static readonly AnPromptList = "XxX6J";
    static readonly FaTerminal = "XxXBq";
    static readonly xCanvas = "x-canvas";
    static readonly xColorGreen = "x-color-green";
    static readonly FaCommentsO = "XxXDd";
    static readonly xMsg = "x-msg";
    static readonly xVideo = "x-video";
    static readonly xVideoholder = "x-videoholder";
    static readonly AnButton = "XxXH4";
    static readonly FaCrop = "XxXOv";
    static readonly xFa90 = "x-fa90";
    static readonly FaClockO = "XxXgD";
    static readonly xGray = "x-gray";
    static readonly FaArrowsH = "XxXcz";
    static readonly xZindex50 = "x-zindex-50";
    static readonly Noto = "XxXUk";
    static readonly xBoxGray = "x-box-gray";
    static readonly AnBox3 = "XxXb9";
    static readonly AnPromptCheckbox = "XxXN9";
    static readonly AnWsp = "XxXAe";
    static readonly AnStyleRowHeight = "XxXC5";
    static readonly xError = "x-error";
    static readonly AnRightAlignLabel = "XxX9N";
    static readonly FaGear = "XxXUX";
    static readonly xColorTeal = "x-color-teal";
    static readonly FaArrowsV = "XxXD5";
    static readonly AnFaDot = "XxXFt";
    static readonly FaVolumeDown = "XxXAw";
    static readonly FaRecycle = "XxXDl";
    static readonly AnOverlayCanvas = "XxXiG";
    static readonly AnSlider = "XxXGt";
    static readonly FaQuoteRight = "XxX5G";
    static readonly FaShareSquareO = "XxXHk";
    static readonly xStickOnScreen = "x-stick-on-screen";
    static readonly FaSignIn = "XxXB4";
    static readonly xHighlightGray = "x-highlight-gray";
    static readonly AnFlashLowlight = "XxXHa";
    static readonly xShowInEdit = "x-show-in-edit";
    static readonly FaPencil = "XxXyZ";
    static readonly AnFlex11Auto = "XxXrg";
    static readonly xBulletDatetime = "x-bullet-datetime";
    static readonly FaEyedropper = "XxXnH";
    static readonly AnWarning = "XxXkG";
    static readonly FaArrowRight = "XxX4y";
    static readonly xShadowSe2Gray = "x-shadow-se2-gray";
    static readonly FaFlipHorizontal = "XxXvv";
    static readonly AnTreeContent = "XxXV3";
    static readonly FaWarning = "XxXx1";
    static readonly AnTabbarAtBottom = "XxXVe";
    static readonly AnGalleryCell = "XxXSl";
    static readonly xFloatRight = "x-float-right";
    static readonly AnErr = "XxX3J";
    static readonly AnFullscreenViewport = "XxX1G";
    static readonly FaToggleOn = "XxXOM";
    static readonly FaCheckSquareO = "XxXh0";
    static readonly AnWindow = "XxXLQ";
    static readonly xLarge = "x-large";
    static readonly AnSidepanelTemplates = "XxXzA";
    static readonly xTag = "x-tag";
    static readonly xFa = "x-fa";
    static readonly xAlarm = "x-alarm";
    static readonly AnAudioTimeline = "XxXyI";
    static readonly xHighlightRed = "x-highlight-red";
    static readonly AnButtonPadding = "XxXEm";
    static readonly AnSidepanelExplore = "XxXZS";
    static readonly xWidgetShoppingDesc = "x-w-shopping-desc";
    static readonly AnViewport = "XxX9I";
    static readonly xWidgetTocs = "x-w-tocs";
    static readonly AnInput4 = "XxXjA";
    static readonly xZMiddle = "x-z-middle";
    static readonly AnDisabled = "XxXLn";
    static readonly xTitle = "x-title";
    static readonly xEmojiMemo = "x-emoji-memo";
    static readonly xVideoDatetime = "x-video-datetime";
    static readonly AnTemplateContainer = "XxXx7";
    static readonly AnPromptChecklist = "XxXsz";
    static readonly xEmojiAudio = "x-emoji-audio";
    static readonly xShort = "x-short";
    static readonly AnOK = "XxXy9";
    static readonly xTodoStatus = "x-todo-status";
    static readonly FaPause = "XxXcg";
    static readonly xMediaMissing = "x-media-missing";
    static readonly AnSpacer10 = "XxXXV";
    static readonly FaTimesCircleO = "XxX5o";
    static readonly AnFullscreenFlexCenter = "XxXKS";
    static readonly FaUpload = "XxXG1";
    static readonly AnUpperFontMenu = "XxXKC";
    static readonly NotoColon = "XxXA4";
    static readonly FaPlusSquareO = "XxXTM";
    static readonly AnToasterModal = "XxXn8";
    static readonly FaLongArrowDown = "XxXuu";
    static readonly FaCircleO = "XxXF8";
    static readonly AnTemplateContent = "XxXhg";
    static readonly FaThumbsOUp = "XxXGm";
    static readonly AnSettingsSample = "XxXmc";
    static readonly xBubble = "x-bubble";
    static readonly xWarn = "x-warn";
    static readonly FaVideoCamera = "XxXHG";
    static readonly xTemplateButton = "x-t-button";
    static readonly xMediaPhoto = "x-media-photo";
    static readonly xWidgetToc1 = "x-w-toc1";
    static readonly AnColorStops = "XxXXE";
    static readonly xZindex00 = "x-zindex-00";
    static readonly xLandscape = "x-landscape";
    static readonly xRoundedBottom = "x-rounded-bottom";
    static readonly FaWon = "XxX1f";
    static readonly FaSpinner = "XxXw2";
    static readonly xWidgetShoppingStyle01 = "x-w-shopping-style01";
    static readonly xPageBreakBefore = "x-page-break-before";
    static readonly AnBullet = "XxXei";
    static readonly AnPadBottom = "XxXGl";
    static readonly xWidgetTodoStatus = "x-w-todo-status";
    static readonly FaHashtag = "XxXIJ";
    static readonly xVlayout = "x-vlayout";
    static readonly AnColorList = "XxX42";
    static readonly FaFileText = "XxXdl";
    static readonly FaPlusSquare = "XxXc8";
    static readonly xPause = "x-pause";
    static readonly xAlignJustify = "x-align-justify";
    static readonly AnEventsRepeat = "XxXvF";
    static readonly AnMarginLeft10 = "XxXUC";
    static readonly AnButton1 = "XxXUV";
    static readonly xPdf = "x-pdf";
    static readonly xDarkblue = "x-darkblue";
    static readonly xShadowYellow = "x-shadow-yellow";
    static readonly FaPaintBrush = "XxX7s";
    static readonly FaDownload = "XxX6V";
    static readonly FaFolderO = "XxXhO";
    static readonly AnColorBG = "XxXKZ";
    static readonly AnTemplateCategory = "XxXpe";
    static readonly FaArrowLeft = "XxXXZ";
    static readonly AnFlexVertical = "XxXjT";
    static readonly xBulletText = "x-bullet-text";
    static readonly AnAnnotationStyleText = "XxXDA";
    static readonly AnTreeTable = "XxXzC";
    static readonly AnGrayOption = "XxXx0";
    static readonly AnBorderSample = "XxXt0";
    static readonly xZUpper = "x-z-upper";
    static readonly xxHide = "xx-hide";
    static readonly FaKeyboardO = "XxXeX";
    static readonly FaChevronRight = "XxXif";
    static readonly FaChevronUp = "XxXcup";
    static readonly xHighlightBlue = "x-highlight-blue";
    static readonly xStickOnScreenRoot = "x-stick-on-screen-root";
    static readonly xMediaStatus = "x-media-status";
    static readonly xWidgetVideo = "x-w-video";
    static readonly xClientShow = "x-client-show";
    static readonly AnPiano = "XxXlR";
    static readonly FaToggleDown = "XxXfx";
    static readonly xWidgetShopping = "x-w-shopping";
    static readonly FaCube = "XxX0l";
    static readonly xZTop = "x-z-top";
    static readonly FaLink = "XxXwR";
    static readonly AnButtonInput = "XxXMw";
    static readonly xBorderThin = "x-border-thin";
    static readonly AnDirpath = "XxXDO";
    static readonly AnHideInDesktop = "XxXtR";
    static readonly AnToasterBottom = "XxXhn";
    static readonly xxStatus = "xx-status";
    static readonly FaBellO = "XxXmf";
    static readonly FaAngleDoubleLeft = "XxXFa";
    static readonly AnRedoItem = "XxXNn";
    static readonly AnFlexColumnNoWrap = "XxX6m";
    static readonly xCompact = "x-compact";
    static readonly xWidgetTodoSubject = "x-w-todo-subject";
    static readonly AnEventsDesc = "XxXMH";
    static readonly FaMinus = "XxXEc";
    static readonly AnTitle = "XxXSM";
    static readonly FaMicrophone = "XxXXg";
    static readonly xFloatLeftClearNone = "x-float-left-clear-none";
    static readonly AnToasterWarn = "XxXE7";
    static readonly xShadowSeWhite = "x-shadow-se-white";
    static readonly xShadowSe2White = "x-shadow-se2-white";
    static readonly FaPlayCircle = "XxXpyc";
    static readonly FaPencilSquare = "XxXvC";
    static readonly xVideoFilename = "x-video-filename";
    static readonly AnToasterDetails = "XxXx4";
    static readonly xBorderOnePx = "x-border-onepx";
    static readonly xHead1 = "x-head1";
    static readonly FaRetweet = "XxXqA";
    static readonly xWidgetShoppingStatus = "x-w-shopping-status";
    static readonly xAnnotationColor = "x-annotation-color";
    static readonly AnPromptAttributes = "XxXtY";
    static readonly AnNoWrap = "XxX22";
    static readonly AnAnnotationStyleImage = "XxXp6";
    static readonly xWidgetAudio = "x-w-audio";
    static readonly AnDirtree = "XxXDk";
    static readonly FaToggleLeft = "XxXsE";
    static readonly xPara = "x-para";
    static readonly AnContentPanel = "XxXTV";
    static readonly xMatchA = "x-m-a";
    static readonly FaCopy = "XxXJK";
    static readonly FaAlignRight = "XxXc2";
    static readonly FaAlignJustify = "XxXk2";
    static readonly NotoLeftBrace = "XxX7u";
    static readonly xStickOnDocument = "x-stick-on-document";
    static readonly xEmojiNotes = "x-emoji-notes";
    static readonly AnTag = "XxXN6";
    static readonly AnBulletRow = "XxXQQ";
    static readonly xIndent = "x-indent";
    static readonly AnFaSpace = "XxXuI";
    static readonly xEmojiCanvas = "x-emoji-canvas";
    static readonly xImageDef = "x-image-def";
    static readonly xHideInWideScreen = "x-hide-in-wide-screen";
    static readonly xxTodo = "xx-todo";
    static readonly AnSpin = "XxXdn";
    static readonly FaBookmarkO = "XxXzL";
    static readonly FaLevelUp = "XxXlup";
    static readonly xHighlightOrange = "x-highlight-orange";
    static readonly FaTags = "XxXCZ";
    static readonly xStrikethrough = "x-strikethrough";
    static readonly AnAudioButton = "XxXec";
    static readonly xTimeline = "x-timeline";
    static readonly FaCode = "XxXmj";
    static readonly xHighlightYellow = "x-highlight-yellow";
    static readonly xWidgetToc4 = "x-w-toc4";
    static readonly AnTreeRoot = "XxXOD";
    static readonly AnHint = "XxXca";
    static readonly AnFlexBaseline = "XxXKi";
    static readonly AnToasterTop = "XxX1l";
    static readonly FaExchange = "XxXns";
    static readonly FaQuestionCircle = "XxXEE";
    static readonly FaQuoteLeft = "XxXy2";
    static readonly xHidden = "x-hidden";
    static readonly xFloatLeft = "x-float-left";
    static readonly xAnnotationStyleText = "x-a-style-text";
    static readonly FaHome = "XxXf1";
    static readonly xBlack = "x-black";
    static readonly FaClose = "XxXN2";
    static readonly AnPromptSelectExt = "XxXRC";
    static readonly AnError = "XxXK0";
    static readonly xLeftSplitcontent = "x-leftsplitcontent";
    static readonly AnLnk = "XxXNJ";
    static readonly AnMarginV5 = "XxX9V";
    static readonly xPlum = "x-plum";
    static readonly AnFaNbsp = "XxXK8";
    static readonly AnMenurow = "XxXHE";
    static readonly xMediaContent = "x-media-content";
    static readonly xColorOrange = "x-color-orange";
    static readonly xWidgetTodos = "x-w-todos";
    static readonly xRoundedTop = "x-rounded-top";
    static readonly FaAngleDoubleUp = "XxXc5";
    static readonly xAccordionHide = "x-accordion-hide";
    static readonly FaCalculator = "XxX7q";
    static readonly AnToasterError = "XxXUN";
    static readonly AnFile = "XxXPN";
    static readonly AnPanel = "XxXrZ";
    static readonly xZLower = "x-z-lower";
    static readonly AnPromptContentWithOutline = "XxXcG";
    static readonly xSubject = "x-subject";
    static readonly FaEyeSlash = "XxXfj";
    static readonly xTodoDone = "x-todo-done";
    static readonly xRightSidebarContent = "x-rsb-content";
    static readonly AnTn = "XxX66";
    static readonly xSuperscript = "x-superscript";
    static readonly FaCalendarO = "XxX25";
    static readonly FaStarO = "XxXW5";
    static readonly xFlashRightsidebar = "x-frsb";
    static readonly FaBan = "XxXHv";
    static readonly FaIndent = "XxXR0";
    static readonly FaStrikethrough = "XxXfc";
    static readonly FaTimesCircle = "XxXw1";
    static readonly xSmall = "x-small";
    static readonly xRowHeight = "x-rowheight";
    static readonly FaCheck = "XxXXK";
    static readonly AnTreeCollapsed = "XxXej";
    static readonly AnTreeContainer = "XxX17";
    static readonly xBorderThick = "x-border-thick";
    static readonly AnBulletLeft = "XxX7i";
    static readonly AnSmaller = "XxX2F";
    static readonly AnWidth1 = "XxX7O";
    static readonly xAlignLeft = "x-align-left";
    static readonly AnLink = "XxXMP";
    static readonly AnToggleOff = "XxXbO";
    static readonly AnDir = "XxXdP";
    static readonly FaArrowCircleUp = "XxXBY";
    static readonly FaArrowDown = "XxXq0";
    static readonly AnFilesPanel = "XxXSn";
    static readonly AnOutlineBottom = "XxXvM";
    static readonly AnSidepanel = "XxXp2";
    static readonly FaReply = "XxXIm";
    static readonly xDatetime = "x-datetime";
    static readonly AnMenu = "XxXJF";
    static readonly AnIndicatorEvent = "XxXLR";
    static readonly AnIndicatorDone = "XxXLRd";
    static readonly AnIndicatorEmpty = "XxXLRe";
    static readonly AnIndicator = "XxXHDr";
    static readonly AnToaster = "XxX2b";
    static readonly FaIdCardO = "XxXo9";
    static readonly FaTrashO = "XxXZ0";
    static readonly FaCameraRetro = "XxXhW";
    static readonly xxSymbol = "xx-symbol";
    static readonly FaPlusCircle = "XxXQe";
    static readonly xLinkColor = "x-link-color";
    static readonly xSlideshowContent = "x-slideshow-content";
    static readonly xAudioFilesize = "x-audio-filesize";
    static readonly AnVerticalViewport = "XxXAt";
    static readonly xWidgetToc = "x-w-toc";
    static readonly FaLock = "XxX9v";
    static readonly FaDotCircleO = "XxX1c";
    static readonly xViewport = "x-viewport";
    static readonly AnBulletList = "XxXBK";
    static readonly AnOverflowAuto = "XxXTR";
    static readonly FaSubscript = "XxXZ4";
    static readonly xAudioFilename = "x-audio-filename";
    static readonly AnNone = "XxXrh";
    static readonly xRightSplitpanel = "x-rightsplitpanel";
    static readonly FaHeartO = "XxXOV";
    static readonly xStyleDark = "x-style-dark";
    static readonly AnIndicatorAlarm = "XxXuk";
    static readonly AnIndicatorBlog = "XxXukb";
    static readonly AnDirpathDir = "XxXTE";
    static readonly AnAudioPlaytime = "XxXRz";
    static readonly AnPalette = "XxXna";
    static readonly FaHandORight = "XxXqI";
    static readonly xxDone = "xx-done";
    static readonly AnContextmenu = "XxXCq";
    static readonly xRoot = "x-root";
    static readonly AnFlexRowNoWrap = "XxXAl";
    static readonly AnFullscreenPlayer = "XxXBS";
    static readonly AnTabPanelContainer = "XxX9t";
    static readonly xAnnotation = "x-annotation";
    static readonly AnRuler1Dotted = "XxXXO";
    static readonly xHideInNarrowScreen = "x-hide-in-narrow-screen";
    static readonly AnCalBody = "XxXwF";
    static readonly AnMarginLeft5 = "XxXj6";
    static readonly AnTreeSelected = "XxXhb";
    static readonly AnSec = "XxXeZ";
    static readonly FaFileO = "XxXlM";
    static readonly FaGbp = "XxXKR";
    static readonly xDocumentScan = "x-document-scan";
    static readonly xSegments = "x-segments";
    static readonly FaArrowUp = "XxXDz";
    static readonly FaBell = "XxX4C";
    static readonly AnColorCell = "XxXmk";
    static readonly FaUnlink = "XxX5K";
    static readonly FaEllipsisV = "XxXWA";
    static readonly xWide = "x-wide";
    static readonly xEmojiSticker = "x-emoji-sticker";
    static readonly xWhite = "x-white";
    static readonly AnLinkList = "XxX5j";
    static readonly FaSearchMinus = "XxX7J";
    static readonly xFlex = "x-flex";
    static readonly xVideoinfo = "x-videoinfo";
    static readonly AnNoto = "XxXqu";
    static readonly FaFilter = "XxXfil";
    static readonly AnRoot = "XxXeO";
    static readonly AnToggleOn = "XxXd3";
}
abstract class ClientAction {
    static readonly style = "s/";
    static readonly toggle = "T/";
    static readonly bg = "bg/";
    static readonly classes = "classes/";
    static readonly move = "m/";
    static readonly show = "show/";
    static readonly radio = "r/";
    static readonly hide = "hide/";
    static readonly cycle = "c/";
    static readonly cycle1 = "C/";
}
abstract class DEF {
    static readonly zindexClientStickerOnDocument = 50;
    static readonly filepickerHistorySize = 16;
    static readonly themeBorderRadius = "0.35rem";
    static readonly CORRECTED = ".~c~";
    static readonly zindexMax = 9999;
    static readonly opacityResizing = 0.1;
    static readonly backupKeyPrefix = "#";
    static readonly templateCSSRuleset = "selector {\n}\n";
    static readonly zindexAbove100 = 100;
    static readonly NO_SERIAL = -1;
    static readonly themeBorderWidth = 1.0;
    static readonly themeBorderWidthPx = "1px";
    static readonly System = "System";
    static readonly thumbnailSize = 512;
    static readonly BASIS_40 = 40;
    static readonly maxLongToastLen = 256;
    static readonly toolbarBG = "#ccc";
    static readonly zindexClientSidepanel = 1100;
    static readonly QUERY = 63;
    static readonly templateBlank = "/assets/templates/blank/blank.html";
    static readonly dialogMaxWidthSmall = 7;
    static readonly jpegQualityThumbnail = 85;
    static readonly SQUOTE = 39;
    static readonly FontAwesome = "FontAwesome";
    static readonly zindexImageAnnotator = 3000;
    static readonly maxBarcodeScale = 10;
    static readonly recentFilePositionCount = 50;
    static readonly maxClientActionClassesLength = 20;
    static readonly LBRACKET = 91;
    static readonly zindexToolbar = 1990;
    static readonly themeBoxShadow = "2px 2px 10px rgba(0,0,0,0.5)";
    static readonly previewPhotoSize = 1024;
    static readonly maxToastLen = 64;
    static readonly zindexSidepanel = 2100;
    static readonly opacitySmoke = 0.5;
    static readonly alarmMargin = 500;
    static readonly zoomScale = 0.01;
    static readonly NOOP = "NOOP";
    static readonly DECIMAL_VALUE_UNITS = ["", "k", "m", "g", "t"];
    static readonly PERCENT = 37;
    static readonly DOT = 46;
    static readonly thumbnailSizeMicro = 96;
    static readonly maxOutputImageArea = 67108864;
    static readonly insertImgAttrString = "style width:240px;max-width:50vw;";
    static readonly minFontSize = 6;
    static readonly Emoji = "Emojis";
    static readonly opacityOpaque = 1.0;
    static readonly opacityEnabled = 1.0;
    static readonly zoomDelta = 2.0;
    static readonly dialogMaxWidthXLarge = 16;
    static readonly SLASH = 47;
    static readonly zindexPrompt = 4100;
    static readonly trashAutoCleanupInterval = 86400000;
    static readonly sidepanelWidth = 450;
    static readonly zindexClientSearchResult = 1200;
    static readonly pdfScale = 3;
    static readonly historyTextLength = 64;
    static readonly xmlNameChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-";
    static readonly SEMICOLON = 59;
    static readonly thumbnailThreshold = 524288;
    static readonly BASIS_60 = 60;
    static readonly nobackup = "~nobackup~";
    static readonly lightBorder = "1px solid rgba(0, 0, 0, 0.25)";
    static readonly dialogMaxWidthLarge = 12;
    static readonly tmpBackupSuffix = "~tmp~.tmp";
    static readonly opacityDisabled = 0.25;
    static readonly BASIS_50 = 50;
    static readonly zindexResizer = 6000;
    static readonly dailyBackupDir = "~DailyBackup~";
    static readonly dragBorderDivider = 2;
    static readonly dialogBorderWidth = 10;
    static readonly jpegQualityHigh = 95;
    static readonly keepLongerDays = 7;
    static readonly BASIS_20 = 20;
    static readonly zindexContextmenu = 4000;
    static readonly zindexClientShow = 500;
    static readonly zindexClientStickerOnScreen = 75;
    static readonly galleryItemThreshold = 24;
    static readonly templateCSSRule = "name value;";
    static readonly pdfPosterSize = 1024;
    static readonly keepLongerSizeLimit = 16777216;
    static readonly BASIS_34 = 34;
    static readonly dialogBG = "#ddd";
    static readonly zindexUnder = -1;
    static readonly BASIS_66 = 66;
    static readonly zindexToasterWarning = 5100;
    static readonly zindexSidebar = 2000;
    static readonly sidepanelMarginBottom = 10;
    static readonly recentSymbolCount = 100;
    static readonly imageDimensionSnap = 128;
    static readonly toolbarFontSizeRatio = 0.5;
    static readonly BASIS_80 = 80;
    static readonly webkitPrefix = "-webkit-";
    static readonly QUOTE = 34;
    static readonly dialogPaddingWidth = 10;
    static readonly jpegQuality = 90;
    static readonly symbolFontSizeRatio = 0.45;
    static readonly contextmenuMargin = 10;
    static readonly RBRACKET = 93;
    static readonly FILESIZE_UNITS = ["B", "K", "M", "G", "T"];
    static readonly FRAGMENT = 35;
    static readonly xSidepanelWidth = 50;
    static readonly zindexAbove10 = 10;
    static readonly opacityShowBackground = 0.35;
    static readonly maxFontSize = 64;
    static readonly themeBorder = "1px solid rgba(0, 0, 0, 0.5)";
    static readonly zindexClientSidebar = 1800;
    static readonly themeBorderColor = "rgba(0, 0, 0, 0.5)";
    static readonly jpegQualityLow = 75;
    static readonly zindexToasterError = 5200;
    static readonly databaseKeyAlias = "#db";
    static readonly BASIS_25 = 25;
    static readonly LINEBREAK = "\n";
    static readonly filepickerMaxWidth = 640;
    static readonly zindexConfirm = 4900;
    static readonly dialogMaxWidthMedium = 9;
    static readonly zindexPromptSave = 2500;
    static readonly zindexToaster = 5000;
    static readonly keepShorterDays = 1;
    static readonly opacitySpinner = 0.75;
    static readonly opacityTransparent = 0.0;
    static readonly LF = "\n";
    static readonly zindexClientAnnotation = 1300;
    static readonly maxNodeInfoLen = 128;
    static readonly backupKeyAlias = "#self";
}
abstract class Effect {
    static readonly NONE = 0;
    static readonly GRAY4 = 2;
    static readonly GRAY256 = 5;
    static readonly GRAY16 = 4;
    static readonly GRAY2 = 1;
    static readonly GRAY8 = 3;
}
abstract class EventKey {
    static readonly Description = "desc";
    static readonly Pending = "pending";
    static readonly Ms = "ms";
    static readonly Version = "V";
    static readonly Events = "A";
    static readonly Lastms = "lastms";
    static readonly Id = "id";
    static readonly Done = "done";
    static readonly Exists = "exists";
    static readonly Private = "private";
    static readonly DoneMs = "donems";
    static readonly DoneDesc = "donedesc";
    static readonly Serial = "S";
    static readonly Url = "url";
    static readonly Repeat = "repeat";
    static readonly Color = "color";
}
abstract class EventRepeat {
    static readonly Workdays = "Workdays";
    static readonly Daily = "Daily";
    static readonly Weekly = "Weekly";
    static readonly Once = "Once";
    static readonly Monthly = "Monthly";
    static readonly values = ["Off", "Once", "Daily", "Workdays", "Weekly", "Monthly", "Yearly"];
    static readonly Yearly = "Yearly";
    static readonly Off = "Off";
}
abstract class FilepickerCmd {
    static readonly MKDIRS = 7;
    static readonly DELETE_DIRSUBTREE = 13;
    static readonly LISTDIR = 4;
    static readonly COPY_INFO = 10;
    static readonly DELETE_EMPTY_DIRS = 20;
    static readonly LOCAL_IMAGE_THUMBNAILS = 18;
    static readonly SHRED = 24;
    static readonly FILEINFO = 1;
    static readonly DIRINFO = 23;
    static readonly FILEINFOS = 22;
    static readonly DELETE_INFO = 15;
    static readonly DELETE = 11;
    static readonly DELETE_ALL = 14;
    static readonly RENAME = 8;
    static readonly LOCAL_IMAGE_INFOS = 17;
    static readonly COPY = 9;
    static readonly INVALID = 0;
    static readonly LIST_RECURSIVE = 21;
}
abstract class FontCategories {
    static readonly SansSerif = "Sans Serif";
    static readonly Monospace = "Monospace";
    static readonly Decorative = "Decorative";
    static readonly All = "All";
    static readonly System = "System";
    static readonly Serif = "Serif";
    static readonly Others = "Others";
}
abstract class FontInfoKey {
    static readonly fontfaceformat = "fontfaceformat";
    static readonly glyphs = "glyphs";
    static readonly size = "size";
    static readonly subsets = "subsets";
    static readonly category = "category";
    static readonly fontname = "fontname";
    static readonly styles = "styles";
    static readonly license = "license";
    static readonly url = "url";
    static readonly glyphnames = "glyphnames";
    static readonly glyphcount = "glyphcount";
}
abstract class GestureEvent {
    static readonly rightOutward = "ro";
    static readonly leftOutward = "lo";
    static readonly pinchZoom = "pz";
    static readonly leftInward = "li";
    static readonly rightInward = "ri";
}
abstract class GestureKey {
    static readonly event = "e";
    static readonly y = "y";
}
abstract class ID {
    static readonly sidebarTemplates = "XxXT1";
    static readonly sidebarResize = "XxXGz";
    static readonly toolbar = "XxX0V";
    static readonly contextmenuSelect = "XxXhL";
    static readonly contentIFrame = "XxXci";
    static readonly xLeftSidepanel = "x-leftsidepanel";
    static readonly xOpenRightSidepanel = "x-open-rightsidepanel";
    static readonly splash = "XxXk4";
    static readonly xRightSidepanel = "x-rightsidepanel";
    static readonly sidebarExplore = "XxXgA";
    static readonly xContent = "x-content";
    static readonly searchResult = "XxXhK";
    static readonly xRightSidebar = "x-rightsidebar";
    static readonly content = "XxXFP";
    static readonly xLeftSplitpanel = "x-leftsplitpanel";
    static readonly accessories = "XxXs5";
    static readonly focusbox = "XxXqS";
    static readonly sidebarDocument = "XxXdW";
    static readonly xViewer = "x-viewer";
    static readonly xOpenLeftSidepanel = "x-open-leftsidepanel";
    static readonly csseditor = "code";
    static readonly sidebar = "XxX16";
    static readonly xRightSplitpanel = "x-rightsplitpanel";
    static readonly xMarkers = "x-markers";
    static readonly sidepanel = "XxXO1";
}
abstract class Key {
    static readonly dimension = "XxXdb";
    static readonly isregex = "XxXqo";
    static readonly key = "XxXMG";
    static readonly forward = "XxXhP";
    static readonly level = "XxX1n";
    static readonly imageinfo = "XxXKK";
    static readonly busy = "XxXq4";
    static readonly isplaying = "XxXqe";
    static readonly dst = "XxXkZ";
    static readonly dirinfo = "XxXnr";
    static readonly filestat = "XxXWQ";
    static readonly player = "XxXjE";
    static readonly overwriting = "XxXaA";
    static readonly style = "XxXEa";
    static readonly backward = "XxXSG";
    static readonly attrs = "XxXet";
    static readonly filter = "XxXOC";
    static readonly timestamp = "XxXOS";
    static readonly deleting = "XxXU0";
    static readonly poster = "XxXLq";
    static readonly warns = "XxX2P";
    static readonly filterIgnorecase = "XxXT5";
    static readonly tnpath = "XxXoz";
    static readonly text = "XxXOd";
    static readonly baseurl = "XxX5h";
    static readonly result = "XxXJL";
    static readonly cssrule = "XxXJ8";
    static readonly css = "XxXcss";
    static readonly total = "XxXcL";
    static readonly fails = "XxX6v";
    static readonly filename = "XxXdN";
    static readonly hold = "XxXx2";
    static readonly linkinfo = "XxXoW";
    static readonly meminfo = "XxXVd";
    static readonly expectedfailure = "XxXNT";
    static readonly cut = "XxXS4";
    static readonly width = "XxXUQ";
    static readonly rpaths = "XxXPB";
    static readonly stacktrace = "XxXBq";
    static readonly notdeleting = "XxXxo";
    static readonly rpath = "XxXhk";
    static readonly size = "XxXpl";
    static readonly errors = "XxXox";
    static readonly recorder = "XxX4q";
    static readonly status = "XxXGT";
    static readonly infos = "XxX4y";
    static readonly dirpath = "XxXtB";
    static readonly cpath = "XxXCa";
    static readonly checksum = "XxXmq";
    static readonly expectedresult = "XxXIS";
    static readonly src = "XxXPm";
    static readonly mediainfo = "XxXKv";
    static readonly type = "XxXCl";
    static readonly searchIgnorecase = "XxXVc";
    static readonly element = "XxXqh";
    static readonly orientation = "XxX0m";
    static readonly version = "XxXL9";
    static readonly tag = "XxX2b";
    static readonly serial = "XxXG9";
    static readonly copying = "XxXEI";
    static readonly links = "XxXmu";
    static readonly fileinfo = "XxXML";
    static readonly template = "XxX1I";
    static readonly count = "XxXiI";
    static readonly free = "XxXSM";
    static readonly notcopying = "XxXMA";
    static readonly data = "XxXXD";
    static readonly path = "XxXQm";
    static readonly paths = "XxXQms";
    static readonly time = "XxXNn";
    static readonly height = "XxXiE";
    static readonly id = "XxXYP";
    static readonly mime = "XxXG2";
    static readonly url = "XxX9D";
    static readonly expire = "XxX5i";
    static readonly dirtree = "XxXi5";
    static readonly pass = "XxXes";
    static readonly supportwebp = "XxXhgm";
    static readonly quality = "XxXqty";
    static readonly xrefs = "XxXxrs";
}
abstract class LinkInfoKey {
    static readonly HEAD = "H";
    static readonly value = "v";
    static readonly targetpath = "p";
    static readonly name$ = "n";
    static readonly tag = "t";
    static readonly BODY = "B";
    static readonly status = "s";
    static readonly rel = "r";
}
abstract class LinkInfoStatus {
    static readonly INVALID = "I";
    static readonly NOTEXISTS = "N";
    static readonly EXISTS = "E";
}
abstract class LinkVerifierCmd {
    static readonly LINKINFOS = 1;
    static readonly LINKINFO = 2;
    static readonly INVALID = 0;
}
abstract class MetainfoKey {
    static readonly Patches = "P";
    static readonly CreatedBy = "C";
    static readonly Features = "F";
    static readonly ModifiedBy = "M";
    static readonly FeatureCalc = "Cc";
}
abstract class NAME {
    static readonly contextmenuGallery = "XxXU0";
    static readonly browsingContextmenu = "XxXbE";
    static readonly contextmenuSelect = "XxX9x";
    static readonly contextmenuHighlight = "XxXKR";
    static readonly submenuFont = "XxXIG";
    static readonly submenuOthers = "XxXS4";
    static readonly contextmenu = "XxXJW";
    static readonly contextmenuAssists = "XxX3a";
    static readonly submenuPara = "XxXiJ";
    static readonly contextmenuPage = "XxXYA";
    static readonly contextmenuChar = "XxXHD";
    static readonly contextmenuWidget = "XxX3q";
    static readonly contextmenuImage = "XxXPz";
    static readonly contextmenuTemplate = "XxXrA";
    static readonly contextmenuPara = "XxXW1";
    static readonly submenuMedia = "XxXAB";
    static readonly submenuList = "XxXVU";
    static readonly submenuChar = "XxXHE";
    static readonly contextmenuClasses = "XxXIV";
}
abstract class PATH {
    static readonly _HomeIndexHtml = "/Home/index.html";
    static readonly _assetsFontsPng = "/assets/images/res/fonts.png";
    static readonly _assetsGameMinesHtml = "/assets/templates/res/gamemines.html";
    static readonly _PrivateAudios_ = "/Private/audios/";
    static readonly _assetsGameSudokuHtml = "/assets/templates/res/gamesudoku.html";
    static readonly _PrivateDrafts_ = "/Private/drafts/";
    static readonly _assetsImagesLandscapeSample = "/assets/images/samples/backlight.jpg";
    static readonly _assetsGameMindsCss = "/assets/css/gameminds.css";
    static readonly _assetsManual_ = "/assets/manual/";
    static readonly _assetsImagesSig01Png = "/assets/images/res/sig01.png";
    static readonly _assetsCSSEditorJs = "/assets/js/c.js";
    static readonly assetsTemplatesFaviconIco = "assets/templates/res/favicon.ico";
    static readonly _assetsClientCss = "/assets/css/client-v1.css";
    static readonly Home = "Home";
    static readonly _assetsTemplatesIndexHtml = "/assets/templates/res/index.html";
    static readonly _assetsCss_ = "/assets/css/";
    static readonly _assetsTemplates500Html = "/assets/templates/res/500.html";
    static readonly _assetsGameSudokuJs = "/assets/js/g.js";
    static readonly _internal = "/Internal";
    static readonly _Home = "/Home";
    static readonly assetsCss_ = "assets/css/";
    static readonly _assetsGameMinesCss = "/assets/css/gamemines.css";
    static readonly _assetsClient = "/assets/css/client-";
    static readonly _assetsCSSEditorHtml = "/assets/templates/res/csseditor.html";
    static readonly _assetsReleaseNotesHtml = "/assets/manual/en/release-notes/release-notes.html";
    static readonly External_ = "External/";
    static readonly _assetsAudioSample = "/assets/manual/samples/audios/audio-33.m4a";
    static readonly _assetsMonoPng = "/assets/images/res/mono.png";
    static readonly _HomeIncoming = "/Home/incoming";
    static readonly _HomeIncoming_ = "/Home/incoming/";
    static readonly HomeIndexHtml = "Home/index.html";
    static readonly _HomeDrafts_ = "/Home/drafts/";
    static readonly _assetsImagesSamplesAngels = "/assets/images/samples/angels.jpg";
    static readonly _assets_ = "/assets/";
    static readonly Internal_ = "Internal/";
    static readonly _External_ = "/External/";
    static readonly _PrivateVideos_ = "/Private/videos/";
    static readonly _pdfSample = "/assets/manual/samples/pdf/release-notes.pdf";
    static readonly _InternalIncoming = "/Internal/incoming";
    static readonly _Internal_ = "/Internal/";
    static readonly _assetsTemplates_ = "/assets/templates/";
    static readonly _Home_ = "/Home/";
    static readonly drafts = "drafts";
    static readonly _assetsTemplates404Html = "/assets/templates/res/404.html";
    static readonly _assetsCore = "/assets/css/core-";
    static readonly _pdfPoster = "/assets/templates/res/pdf.png";
    static readonly _assetsTemplatesBlogHtml = "/assets/templates/blog/blog-v2.html";
    static readonly _assetsGameSudokuCss = "/assets/css/gamesudoku.css";
    static readonly _HomeDrafts = "/Home/drafts";
    static readonly assetsTemplatesIndexHtml = "assets/templates/res/index.html";
    static readonly _assetsGameMindsJs = "/assets/js/g.js";
    static readonly _assetsGameMinesJs = "/assets/js/g.js";
    static readonly _assetsCSSEditorCss = "/assets/css/csseditor.css";
    static readonly _assetsImagesPortraitSample = "/assets/images/samples-oilify/pink.jpg";
    static readonly _assetsVideoSample = "/assets/manual/samples/videos/BasicEditing.mp4";
    static readonly _videoPoster = "/assets/images/res/cloud1024c.png";
    static readonly External = "External";
    static readonly _assetsGameMindsHtml = "/assets/templates/res/gameminds.html";
    static readonly _assetsTemplatesFaviconIco = "/assets/templates/res/favicon.ico";
    static readonly Internal = "Internal";
    static readonly assetsTemplates_ = "assets/templates/";
    static readonly Home_ = "Home/";
    static readonly _assetsImagesSamplesLamp = "/assets/images/samples/lamp.jpg";
    static readonly _PrivateImages_ = "/Private/images/";
}
abstract class Param {
    static readonly path = "path";
    static readonly mime = "mime";
    static readonly t = "t";
    static readonly session = "s";
    static readonly msg = "msg";
    static readonly view = "view";
    static readonly ignorecase = "ignorecase";
    static readonly edit = "edit";
    static readonly create = "create";
    static readonly poster = "poster";
    static readonly save = "save";
    static readonly redirect = "redirect";
    static readonly isregex = "isregex";
    static readonly seek = "seek";
    static readonly fragment = "fragment";
    static readonly searchtext = "searchtext";
}
abstract class Placeholder {
    static readonly xpPhoto = "photo";
    static readonly xpImageNoCaption = "image0";
    static readonly xpDate = "date";
    static readonly xpImage = "image";
    static readonly xpTimeShort = "time-short";
    static readonly xpAnnotationImage = "a-image";
    static readonly xpAudioinfo = "audioinfo";
    static readonly xpCanvasImage = "canvas-image";
    static readonly xpCanvas = "canvas";
    static readonly xpDatetime = "datetime";
    static readonly xpShortTime = "short-time";
    static readonly xpShortDate = "short-date";
    static readonly xpShortDatetime = "short-datetime";
    static readonly xpVideo = "video";
    static readonly xpTime = "time";
    static readonly xpCanvasPhoto = "canvas-photo";
    static readonly xpAnnotation = "annotation";
    static readonly xpCalendar = "calendar";
    static readonly xpAudio = "audio";
    static readonly xpDateAuto = "date-auto";
    static readonly xpAnnotationPhotoNoCaption = "a-photo0";
    static readonly xpAnnotationPhoto = "a-photo";
    static readonly xpVideoinfo = "videoinfo";
    static readonly xpDateShort = "date-short";
    static readonly xpDraggable = "draggable";
    static readonly xpAudio2 = "audio2";
    static readonly xpDatetimeShort = "datetime-short";
}
abstract class ROLE {
    static readonly Generated = "generated";
}
abstract class RecentsCmd {
    static readonly INFO = 3;
    static readonly INVALID = 0;
    static readonly PEEK = 5;
    static readonly CLEAN = 2;
    static readonly CLEAR = 1;
    static readonly BACK = 4;
    static readonly SORTED = 7;
    static readonly FORWARD = 6;
}
abstract class SessionParam {
    static readonly x = "x";
    static readonly XROOT = "X";
    static readonly type = "t";
    static readonly poster = "p";
    static readonly z = "z";
    static readonly y = "y";
    static readonly X_ROOT = "x-root";
}
abstract class SessionPreferencesKey {
    static readonly gameSudokuAssists = "GSDA";
    static readonly symbolRecents = "SYBR";
    static readonly gameMindsCells = "GMDC";
    static readonly indentTab = "INDT";
    static readonly gameSudokuSave = "GSDS";
    static readonly photoDefaultOutputSize = "PDOS";
    static readonly filePositions = "FPOS";
    static readonly showDoneEvents = "SDEV";
    static readonly gameSudokuAutofill = "GSDF";
    static readonly sidepanelWidth = "SPWD";
    static readonly imageDefaultOutputSize = "IDOS";
    static readonly photoDefaultOutputFormat = "PDOF";
    static readonly imageDefaultOutputQuality = "IDOQ";
    static readonly imageDefaultOutputFormat = "IDOF";
    static readonly gameMinesDifficulty = "GMID";
    static readonly symbolFamily = "SYBF";
    static readonly gameSudokuDifficulty = "GSDD";
    static readonly gameMindsDigits = "GMDD";
    static readonly gameMindsSave = "GMDS";
    static readonly gameMinesSave = "GMIS";
    static readonly templatesRecents = "TPLR";
    static readonly photoDefaultOutputQuality = "PDOQ";
    static readonly trashAutoCleanupTimestamp = "TACT";
    static readonly gameMinesMapSize = "GMIM";
    static readonly dirHistory = "DIRH";
}
abstract class SettingsKey {
    static readonly fontCategories = "fontCategories";
    static readonly fixedFontName = "fixedFontName";
    static readonly buttonSize = "buttonSize";
    static readonly current = "current";
    static readonly htmlTemplates = "htmlTemplates";
    static readonly headingColor = "boldColor";
    static readonly bgImgSamples = "bgImgSamples";
    static readonly defaults = "defaults";
    static readonly charStyles = "charStyles";
    static readonly paraStyles = "paraStyles";
    static readonly builtinParaStyles = "builtinParaStyles";
    static readonly uiFontSize = "uiFontSize";
    static readonly imageDimension = "imageDimension";
    static readonly fixedFontSize = "fixedFontSize";
    static readonly highlightStyles = "highlightStyles";
    static readonly highlightColor = "highlightColor";
    static readonly uiFontName = "uiFontName";
    static readonly dialogBGColor = "dialogBGColor";
    static readonly linkColor = "linkColor";
    static readonly annotationColor = "annotationColor";
    static readonly fontFamilies = "fontFamilies";
    static readonly fixedFontStyle = "fixedFontStyle";
    static readonly timeFormat = "timeFormat";
    static readonly builtinCharStyles = "builtinCharStyles";
    static readonly uiFontStyle = "uiFontStyle";
    static readonly symbolFamilies = "symbolFamilies";
    static readonly dateFormat = "dateFormat";
    static readonly timeZone = "timeZone";
    static readonly hasExtraImageConversionSupport = "extraImageConversion";
}
abstract class StyleKey {
    static readonly label = "label";
    static readonly group = "group";
    static readonly name$ = "name";
}
abstract class TemplateAction {
    static readonly hide = "hide";
    static readonly widget = "widget";
    static readonly cutNotMarked = "X";
    static readonly cycle = "c";
    static readonly playall = "playall";
    static readonly cutMarked = "x";
    static readonly annotation = "a";
    static readonly blog = "b";
    static readonly template = "t";
    static readonly move = "m";
    static readonly save = "save";
    static readonly style = "s";
    static readonly show = "show";
    static readonly drag = "g";
    static readonly radio = "r";
    static readonly cycle1 = "C";
    static readonly postAlarm = "alarm";
    static readonly delete = "d";
    static readonly classes = "classes";
    static readonly bg = "bg";
    static readonly toggle = "T";
}
abstract class TemplateCat {
    static readonly Photo = "Photo";
    static readonly Blog = "Blog";
    static readonly Audio = "Audio";
    static readonly Home = "Home";
    static readonly Canvas = "Canvas";
}
abstract class TemplateMenuKey {
    static readonly path = "p";
    static readonly label = "l";
    static readonly classes = "c";
    static readonly cmd = "C";
    static readonly backgroundImage = "i";
    static readonly name$ = "n";
    static readonly background = "b";
    static readonly lcCat = "t";
    static readonly menu = "m";
    static readonly symbol = "s";
    static readonly action = "a";
    static readonly backgroundSize = "S";
}
abstract class TemplateName {
    static readonly photoWall = "photo-wall";
    static readonly mediaSticker = "media-sticker";
    static readonly mediaWall = "media-wall";
    static readonly audioV2 = "audio-v2";
    static readonly blogV2 = "blog-v2";
    static readonly photoSticker1 = "photo-sticker1";
    static readonly homeSimpler = "home-simpler";
}
abstract class XAction {
    static readonly view = "view";
}
abstract class XInfoKey {
    static readonly seek = "seek";
    static readonly poster = "poster";
}
abstract class XrefKey {
    static readonly LINKS = "l";
    static readonly POSITION = "p";
}
abstract class XrefKind {
    static readonly NONE = 0x00;
    static readonly STYLESHEET = 0x01;
    static readonly HREF = 0x0100;
    static readonly SRC = 0x0200;
    static readonly ANCHOR = 0x010000;
    static readonly IMAGE = 0x020000;
    static readonly AUDIO = 0x040000;
    static readonly VIDEO = 0x080000;
}
abstract class _TemplatesJSONKey {
    static readonly aliases = "aliases";
    static readonly classes = "classes";
    static readonly category = "category";
    static readonly templates = "templates";
    static readonly emoji = "emoji";
    static readonly name$ = "name";
    static readonly desc = "desc";
    static readonly label = "label";
    static readonly filepath = "filepath";
    static readonly template = "template";
}

abstract class PK {
    static readonly TextDecoration = "text-decoration";
    static readonly TableLayout = "table-layout";
    static readonly Columns = "columns";
    static readonly WebkitMarginAfterCollapse = "-webkit-margin-after-collapse";
    static readonly BoxSizing = "box-sizing";
    static readonly StopOpacity = "stop-opacity";
    static readonly WebkitRtlOrdering = "-webkit-rtl-ordering";
    static readonly MinWidth = "min-width";
    static readonly JustifySelf = "justify-self";
    static readonly Float = "float";
    static readonly Content = "content";
    static readonly Animation = "animation";
    static readonly Clear = "clear";
    static readonly Flex = "flex";
    static readonly WebkitColumnGap = "-webkit-column-gap";
    static readonly PointerEvents = "pointer-events";
    static readonly FlexShrink = "flex-shrink";
    static readonly ListStyleImage = "list-style-image";
    static readonly FlexFlow = "flex-flow";
    static readonly WebkitUserModify = "-webkit-user-modify";
    static readonly BreakBefore = "break-before";
    static readonly TransformStyle = "transform-style";
    static readonly AnimationDuration = "animation-duration";
    static readonly DominantBaseline = "dominant-baseline";
    static readonly BorderTopWidth = "border-top-width";
    static readonly MarginLeft = "margin-left";
    static readonly LineHeight = "line-height";
    static readonly WebkitTextDecorationsInEffect = "-webkit-text-decorations-in-effect";
    static readonly MarginBottom = "margin-bottom";
    static readonly WebkitBoxFlexGroup = "-webkit-box-flex-group";
    static readonly GridRow = "grid-row";
    static readonly TextAnchor = "text-anchor";
    static readonly WordSpacing = "word-spacing";
    static readonly TextAlignLast = "text-align-last";
    static readonly ColumnSpan = "column-span";
    static readonly GridTemplateRows = "grid-template-rows";
    static readonly ClipPath = "clip-path";
    static readonly R = "r";
    static readonly WebkitFlexFlow = "-webkit-flex-flow";
    static readonly WebkitClipPath = "-webkit-clip-path";
    static readonly WebkitBoxLines = "-webkit-box-lines";
    static readonly MaskType = "mask-type";
    static readonly StrokeLinecap = "stroke-linecap";
    static readonly AlignSelf = "align-self";
    static readonly WebkitTransformStyle = "-webkit-transform-style";
    static readonly WebkitOrder = "-webkit-order";
    static readonly FillRule = "fill-rule";
    static readonly WebkitTransitionProperty = "-webkit-transition-property";
    static readonly WebkitPerspectiveOrigin = "-webkit-perspective-origin";
    static readonly WebkitFlexGrow = "-webkit-flex-grow";
    static readonly WebkitMaskComposite = "-webkit-mask-composite";
    static readonly MarkerStart = "marker-start";
    static readonly BorderCollapse = "border-collapse";
    static readonly MarkerMid = "marker-mid";
    static readonly GridRowStart = "grid-row-start";
    static readonly Background = "background";
    static readonly BorderRadius = "border-radius";
    static readonly FlexWrap = "flex-wrap";
    static readonly WebkitTransitionDelay = "-webkit-transition-delay";
    static readonly WebkitMaskBoxImageOutset = "-webkit-mask-box-image-outset";
    static readonly AnimationDirection = "animation-direction";
    static readonly PageBreakBefore = "page-break-before";
    static readonly WebkitColumns = "-webkit-columns";
    static readonly WebkitFontSizeDelta = "-webkit-font-size-delta";
    static readonly WebkitBackfaceVisibility = "-webkit-backface-visibility";
    static readonly WebkitFlexBasis = "-webkit-flex-basis";
    static readonly OverflowWrap = "overflow-wrap";
    static readonly WebkitAppearance = "-webkit-appearance";
    static readonly FlexDirection = "flex-direction";
    static readonly WebkitTransition = "-webkit-transition";
    static readonly WebkitMaskBoxImageWidth = "-webkit-mask-box-image-width";
    static readonly WebkitColumnWidth = "-webkit-column-width";
    static readonly Left = "left";
    static readonly Orphans = "orphans";
    static readonly WebkitShapeImageThreshold = "-webkit-shape-image-threshold";
    static readonly ShapeOutside = "shape-outside";
    static readonly WordWrap = "word-wrap";
    static readonly BorderImageWidth = "border-image-width";
    static readonly WebkitAnimationTimingFunction = "-webkit-animation-timing-function";
    static readonly Display = "display";
    static readonly FontWeight = "font-weight";
    static readonly BorderColor = "border-color";
    static readonly Grid = "grid";
    static readonly MinHeight = "min-height";
    static readonly FloodColor = "flood-color";
    static readonly WebkitAnimationFillMode = "-webkit-animation-fill-mode";
    static readonly WebkitLocale = "-webkit-locale";
    static readonly BorderImageRepeat = "border-image-repeat";
    static readonly TextAlign = "text-align";
    static readonly Transform = "transform";
    static readonly AnimationFillMode = "animation-fill-mode";
    static readonly WebkitBoxAlign = "-webkit-box-align";
    static readonly WebkitColumnRule = "-webkit-column-rule";
    static readonly PaddingBottom = "padding-bottom";
    static readonly WebkitMaskPosition = "-webkit-mask-position";
    static readonly Stroke = "stroke";
    static readonly WebkitTextStroke = "-webkit-text-stroke";
    static readonly ColumnRuleColor = "column-rule-color";
    static readonly TabSize = "tab-size";
    static readonly CaptionSide = "caption-side";
    static readonly StrokeDasharray = "stroke-dasharray";
    static readonly Margin = "margin";
    static readonly AnimationPlayState = "animation-play-state";
    static readonly Color = "color";
    static readonly Cy = "cy";
    static readonly StrokeOpacity = "stroke-opacity";
    static readonly Height = "height";
    static readonly EmptyCells = "empty-cells";
    static readonly WebkitBoxReflect = "-webkit-box-reflect";
    static readonly BackgroundRepeat = "background-repeat";
    static readonly WebkitBorderVerticalSpacing = "-webkit-border-vertical-spacing";
    static readonly WebkitAspectRatio = "-webkit-aspect-ratio";
    static readonly WebkitBorderRadius = "-webkit-border-radius";
    static readonly WebkitBoxShadow = "-webkit-box-shadow";
    static readonly WebkitAnimationPlayState = "-webkit-animation-play-state";
    static readonly BorderWidth = "border-width";
    static readonly Overflow = "overflow";
    static readonly WebkitBorderImage = "-webkit-border-image";
    static readonly GridAutoFlow = "grid-auto-flow";
    static readonly UnicodeBidi = "unicode-bidi";
    static readonly WebkitTextEmphasisColor = "-webkit-text-emphasis-color";
    static readonly FlexBasis = "flex-basis";
    static readonly AlignContent = "align-content";
    static readonly WebkitAnimationName = "-webkit-animation-name";
    static readonly WebkitTransitionTimingFunction = "-webkit-transition-timing-function";
    static readonly OverscrollBehaviorX = "overscroll-behavior-x";
    static readonly WebkitMaskBoxImageSource = "-webkit-mask-box-image-source";
    static readonly ColumnCount = "column-count";
    static readonly MarkerEnd = "marker-end";
    static readonly WebkitColumnBreakInside = "-webkit-column-break-inside";
    static readonly BackgroundClip = "background-clip";
    static readonly WebkitBoxPack = "-webkit-box-pack";
    static readonly BorderRightStyle = "border-right-style";
    static readonly Speak = "speak";
    static readonly GridRowEnd = "grid-row-end";
    static readonly WebkitMaskClip = "-webkit-mask-clip";
    static readonly Transition = "transition";
    static readonly Width = "width";
    static readonly WebkitBoxDecorationBreak = "-webkit-box-decoration-break";
    static readonly TextUnderlinePosition = "text-underline-position";
    static readonly Top = "top";
    static readonly MaxHeight = "max-height";
    static readonly WebkitPerspective = "-webkit-perspective";
    static readonly FontFamily = "font-family";
    static readonly Page = "page";
    static readonly OutlineColor = "outline-color";
    static readonly BorderSpacing = "border-spacing";
    static readonly ZIndex = "z-index";
    static readonly WebkitTransform = "-webkit-transform";
    static readonly GridRowGap = "grid-row-gap";
    static readonly BackgroundOrigin = "background-origin";
    static readonly WebkitBoxFlex = "-webkit-box-flex";
    static readonly FontFeatureSettings = "font-feature-settings";
    static readonly ColumnFill = "column-fill";
    static readonly WebkitBackgroundSize = "-webkit-background-size";
    static readonly Resize = "resize";
    static readonly WebkitMarginBeforeCollapse = "-webkit-margin-before-collapse";
    static readonly GridAutoRows = "grid-auto-rows";
    static readonly FontVariantLigatures = "font-variant-ligatures";
    static readonly BorderTopRightRadius = "border-top-right-radius";
    static readonly WebkitMask = "-webkit-mask";
    static readonly WritingMode = "writing-mode";
    static readonly WebkitFlexDirection = "-webkit-flex-direction";
    static readonly WebkitColumnBreakBefore = "-webkit-column-break-before";
    static readonly BorderBottom = "border-bottom";
    static readonly TransitionDuration = "transition-duration";
    static readonly Padding = "padding";
    static readonly Cursor = "cursor";
    static readonly GridAutoColumns = "grid-auto-columns";
    static readonly WebkitFontSmoothing = "-webkit-font-smoothing";
    static readonly BorderImageOutset = "border-image-outset";
    static readonly BorderImageSource = "border-image-source";
    static readonly WebkitTransformOrigin = "-webkit-transform-origin";
    static readonly UserSelect = "user-select";
    static readonly Src = "src";
    static readonly BreakAfter = "break-after";
    static readonly WhiteSpace = "white-space";
    static readonly BorderTopColor = "border-top-color";
    static readonly AlignItems = "align-items";
    static readonly WebkitColumnBreakAfter = "-webkit-column-break-after";
    static readonly OverscrollBehaviorY = "overscroll-behavior-y";
    static readonly RowGap = "row-gap";
    static readonly WebkitPrintColorAdjust = "-webkit-print-color-adjust";
    static readonly BorderImageSlice = "border-image-slice";
    static readonly BackgroundAttachment = "background-attachment";
    static readonly WebkitMaskBoxImageRepeat = "-webkit-mask-box-image-repeat";
    static readonly PaintOrder = "paint-order";
    static readonly ObjectPosition = "object-position";
    static readonly WebkitTransitionDuration = "-webkit-transition-duration";
    static readonly Opacity = "opacity";
    static readonly BorderBottomLeftRadius = "border-bottom-left-radius";
    static readonly WebkitOpacity = "-webkit-opacity";
    static readonly AnimationTimingFunction = "animation-timing-function";
    static readonly BackgroundSize = "background-size";
    static readonly WebkitMaskSize = "-webkit-mask-size";
    static readonly BorderTop = "border-top";
    static readonly WebkitBorderBottomLeftRadius = "-webkit-border-bottom-left-radius";
    static readonly FontVariantNumeric = "font-variant-numeric";
    static readonly Filter = "filter";
    static readonly BorderBottomStyle = "border-bottom-style";
    static readonly Bottom = "bottom";
    static readonly FontSizeAdjust = "font-size-adjust";
    static readonly PerspectiveOrigin = "perspective-origin";
    static readonly TransitionTimingFunction = "transition-timing-function";
    static readonly ColorInterpolationFilters = "color-interpolation-filters";
    static readonly Right = "right";
    static readonly WebkitBorderTopRightRadius = "-webkit-border-top-right-radius";
    static readonly VectorEffect = "vector-effect";
    static readonly BackgroundBlendMode = "background-blend-mode";
    static readonly ColumnRuleStyle = "column-rule-style";
    static readonly GridColumnEnd = "grid-column-end";
    static readonly WebkitTapHighlightColor = "-webkit-tap-highlight-color";
    static readonly Order = "order";
    static readonly ShapeRendering = "shape-rendering";
    static readonly BorderLeftStyle = "border-left-style";
    static readonly WebkitHyphenateCharacter = "-webkit-hyphenate-character";
    static readonly AnimationDelay = "animation-delay";
    static readonly PageBreakInside = "page-break-inside";
    static readonly Hyphens = "hyphens";
    static readonly FontStretch = "font-stretch";
    static readonly WebkitAnimation = "-webkit-animation";
    static readonly FontSize = "font-size";
    static readonly WebkitColumnRuleColor = "-webkit-column-rule-color";
    static readonly ColumnRuleWidth = "column-rule-width";
    static readonly TextDecorationStyle = "text-decoration-style";
    static readonly MarginTop = "margin-top";
    static readonly GridTemplateColumns = "grid-template-columns";
    static readonly WebkitTextOrientation = "-webkit-text-orientation";
    static readonly WebkitAnimationDelay = "-webkit-animation-delay";
    static readonly ColumnGap = "column-gap";
    static readonly ListStyle = "list-style";
    static readonly Widows = "widows";
    static readonly Font = "font";
    static readonly OutlineOffset = "outline-offset";
    static readonly VerticalAlign = "vertical-align";
    static readonly WebkitLineClamp = "-webkit-line-clamp";
    static readonly WebkitBoxSizing = "-webkit-box-sizing";
    static readonly FlexGrow = "flex-grow";
    static readonly GridColumnStart = "grid-column-start";
    static readonly PaddingRight = "padding-right";
    static readonly WebkitTextEmphasisStyle = "-webkit-text-emphasis-style";
    static readonly WebkitOverflowScrolling = "-webkit-overflow-scrolling";
    static readonly WebkitColumnRuleWidth = "-webkit-column-rule-width";
    static readonly WebkitColumnSpan = "-webkit-column-span";
    static readonly FontVariant = "font-variant";
    static readonly WebkitAlignItems = "-webkit-align-items";
    static readonly GridTemplateAreas = "grid-template-areas";
    static readonly WebkitMaskRepeat = "-webkit-mask-repeat";
    static readonly Cx = "cx";
    static readonly Fill = "fill";
    static readonly TextDecorationLine = "text-decoration-line";
    static readonly WebkitAlignContent = "-webkit-align-content";
    static readonly BorderLeftColor = "border-left-color";
    static readonly FontStyle = "font-style";
    static readonly BreakInside = "break-inside";
    static readonly WebkitBorderHorizontalSpacing = "-webkit-border-horizontal-spacing";
    static readonly BorderStyle = "border-style";
    static readonly All = "all";
    static readonly BufferedRendering = "buffered-rendering";
    static readonly BorderLeftWidth = "border-left-width";
    static readonly WebkitUserSelect = "-webkit-user-select";
    static readonly TransitionProperty = "transition-property";
    static readonly BorderBottomColor = "border-bottom-color";
    static readonly BorderTopStyle = "border-top-style";
    static readonly StrokeWidth = "stroke-width";
    static readonly TextDecorationColor = "text-decoration-color";
    static readonly WordBreak = "word-break";
    static readonly WebkitTextEmphasisPosition = "-webkit-text-emphasis-position";
    static readonly WebkitTouchCallout = "-webkit-touch-callout";
    static readonly ListStylePosition = "list-style-position";
    static readonly ShapeMargin = "shape-margin";
    static readonly Size = "size";
    static readonly WebkitFlexShrink = "-webkit-flex-shrink";
    static readonly WebkitUserDrag = "-webkit-user-drag";
    static readonly ColumnRule = "column-rule";
    static readonly GridColumn = "grid-column";
    static readonly X = "x";
    static readonly WebkitTextEmphasis = "-webkit-text-emphasis";
    static readonly WebkitTextStrokeColor = "-webkit-text-stroke-color";
    static readonly AnimationName = "animation-name";
    static readonly Isolation = "isolation";
    static readonly Rx = "rx";
    static readonly MarginRight = "margin-right";
    static readonly WebkitFlex = "-webkit-flex";
    static readonly TextOverflow = "text-overflow";
    static readonly WebkitShapeMargin = "-webkit-shape-margin";
    static readonly BackgroundColor = "background-color";
    static readonly AlignmentBaseline = "alignment-baseline";
    static readonly BackdropFilter = "backdrop-filter";
    static readonly FloodOpacity = "flood-opacity";
    static readonly BorderBottomWidth = "border-bottom-width";
    static readonly GridTemplate = "grid-template";
    static readonly ColorInterpolation = "color-interpolation";
    static readonly WebkitBoxDirection = "-webkit-box-direction";
    static readonly WebkitBackgroundClip = "-webkit-background-clip";
    static readonly WebkitJustifyContent = "-webkit-justify-content";
    static readonly Clip = "clip";
    static readonly ObjectFit = "object-fit";
    static readonly BorderTopLeftRadius = "border-top-left-radius";
    static readonly WebkitMaskBoxImage = "-webkit-mask-box-image";
    static readonly WebkitMaskOrigin = "-webkit-mask-origin";
    static readonly Quotes = "quotes";
    static readonly JustifyItems = "justify-items";
    static readonly Border = "border";
    static readonly GridArea = "grid-area";
    static readonly WebkitTextSizeAdjust = "-webkit-text-size-adjust";
    static readonly WebkitBackgroundOrigin = "-webkit-background-origin";
    static readonly WebkitBorderBottomRightRadius = "-webkit-border-bottom-right-radius";
    static readonly WebkitBoxOrdinalGroup = "-webkit-box-ordinal-group";
    static readonly PaddingTop = "padding-top";
    static readonly WebkitAnimationDuration = "-webkit-animation-duration";
    static readonly WebkitFlexWrap = "-webkit-flex-wrap";
    static readonly BackgroundImage = "background-image";
    static readonly LetterSpacing = "letter-spacing";
    static readonly StrokeLinejoin = "stroke-linejoin";
    static readonly BorderRightWidth = "border-right-width";
    static readonly WebkitFontFeatureSettings = "-webkit-font-feature-settings";
    static readonly OverflowY = "overflow-y";
    static readonly Direction = "direction";
    static readonly ImageRendering = "image-rendering";
    static readonly ColorRendering = "color-rendering";
    static readonly StrokeMiterlimit = "stroke-miterlimit";
    static readonly Perspective = "perspective";
    static readonly WebkitAlignSelf = "-webkit-align-self";
    static readonly ShapeImageThreshold = "shape-image-threshold";
    static readonly CounterReset = "counter-reset";
    static readonly TextTransform = "text-transform";
    static readonly TextRendering = "text-rendering";
    static readonly CounterIncrement = "counter-increment";
    static readonly WebkitColumnCount = "-webkit-column-count";
    static readonly BaselineShift = "baseline-shift";
    static readonly WebkitTextFillColor = "-webkit-text-fill-color";
    static readonly MaxWidth = "max-width";
    static readonly BorderBottomRightRadius = "border-bottom-right-radius";
    static readonly BorderRight = "border-right";
    static readonly BoxShadow = "box-shadow";
    static readonly WebkitAnimationDirection = "-webkit-animation-direction";
    static readonly OverscrollBehavior = "overscroll-behavior";
    static readonly BackfaceVisibility = "backface-visibility";
    static readonly GridColumnGap = "grid-column-gap";
    static readonly WebkitMaskBoxImageSlice = "-webkit-mask-box-image-slice";
    static readonly BorderRightColor = "border-right-color";
    static readonly FontVariantEastAsian = "font-variant-east-asian";
    static readonly AnimationIterationCount = "animation-iteration-count";
    static readonly FillOpacity = "fill-opacity";
    static readonly WebkitBoxOrient = "-webkit-box-orient";
    static readonly WebkitBorderTopLeftRadius = "-webkit-border-top-left-radius";
    static readonly Visibility = "visibility";
    static readonly WebkitShapeOutside = "-webkit-shape-outside";
    static readonly WebkitTextStrokeWidth = "-webkit-text-stroke-width";
    static readonly LightingColor = "lighting-color";
    static readonly BorderLeft = "border-left";
    static readonly FontVariantCaps = "font-variant-caps";
    static readonly PaddingLeft = "padding-left";
    static readonly Position = "position";
    static readonly Zoom = "zoom";
    static readonly WebkitLineBreak = "-webkit-line-break";
    static readonly StrokeDashoffset = "stroke-dashoffset";
    static readonly OutlineStyle = "outline-style";
    static readonly WebkitAnimationIterationCount = "-webkit-animation-iteration-count";
    static readonly WebkitTextSecurity = "-webkit-text-security";
    static readonly OverflowX = "overflow-x";
    static readonly BackgroundPosition = "background-position";
    static readonly Mask = "mask";
    static readonly WebkitMaskImage = "-webkit-mask-image";
    static readonly Outline = "outline";
    static readonly TextSizeAdjust = "text-size-adjust";
    static readonly StopColor = "stop-color";
    static readonly TextShadow = "text-shadow";
    static readonly MixBlendMode = "mix-blend-mode";
    static readonly WillChange = "will-change";
    static readonly WebkitWritingMode = "-webkit-writing-mode";
    static readonly OutlineWidth = "outline-width";
    static readonly TransitionDelay = "transition-delay";
    static readonly JustifyContent = "justify-content";
    static readonly Y = "y";
    static readonly ListStyleType = "list-style-type";
    static readonly WebkitColumnRuleStyle = "-webkit-column-rule-style";
    static readonly TransformOrigin = "transform-origin";
    static readonly TextIndent = "text-indent";
    static readonly WebkitFilter = "-webkit-filter";
    static readonly ColumnWidth = "column-width";
    static readonly ClipRule = "clip-rule";
    static readonly BorderImage = "border-image";
    static readonly PageBreakAfter = "page-break-after";
    static readonly WebkitRubyPosition = "-webkit-ruby-position";
    static readonly WebkitTextCombine = "-webkit-text-combine";
    static readonly Ry = "ry";
}

class Conf {
    static readonly publicHomePath$ = PATH._HomeIndexHtml;
    static readonly errorPath$ = PATH._assetsTemplates500Html;
    static readonly notfoundPath$ = PATH._assetsTemplates404Html;

    static readonly input$ = "textarea";
    static readonly scheme$ = CF.SCHEME;
    static readonly hostport$ = `${CF.HOSTPORT}`;
    static readonly schemeHost$ = `${Conf.scheme$}://${Conf.hostport$}`;
    static readonly useSweep$ = true;
    static readonly selectPlaceholderOnClick$ = false;
    static readonly hasOverlayScrollbar$ = true;
    static readonly click$: EventName = "click";
    static readonly useFlash$ = true;
    static readonly useTouch$ = false;
    static readonly isMobile$ = false;
    static readonly pointerstart$: EventName = "mousedown";
    static readonly pointerend$: EventName = "mouseup";
    static readonly pointermove$: EventName = "mousemove";
}

class EventInfo {
    static of_(event: JSONObjectX): EventInfo | null {
        return event == null ? null : new EventInfo(event);
    }
    static arrayOf_(events: JSONObject): EventInfo[] {
        return Object.values<JSONObject>(events).map((event) => new EventInfo(event));
    }
    static create_(
        id: string,
        ms: Int,
        desc: string,
        color: string,
        href: string,
    ): EventInfo {
        return new EventInfo(json_(
            [EventKey.Id, id],
            [EventKey.Ms, ms],
            [EventKey.Repeat, EventRepeat.Once],
            [EventKey.Private, true],
            [EventKey.Description, desc],
            [EventKey.Color, color],
            [EventKey.Url, href],
        ));
    }
    constructor(private readonly event$: JSONObject) {
    }

    copy_(...overrides: [string, any][]): JSONObject {
        const ret = this.filter_();
        for (const [key, value] of overrides) {
            ret[key] = value;
        }
        return ret;
    }

    filter_(predicate: Fun11X<[string, any], boolean> = null): JSONObject {
        return StringMap.filter_(this.event$, ([k, v]) => {
            return (typeof (v) !== "string" || v.length > 0)
                && (typeof (v) !== "boolean" || v === true)
                && (predicate == null || predicate([k, v]));
        });
    }

    filterx_(predicate: Fun11X<[string, any], boolean> = null): JSONObject {
        return this.filter_(([k, v]) => {
            return k != EventKey.Exists
                && k != EventKey.Pending
                && (predicate == null || predicate([k, v]));
        });
    }

    createTodoItem(idoc: Document): HTMLElement {
        const xxdone = this.done$ ? ` ${XX.xxDone}` : "";
        const b = DomBuilderEx.offline_(idoc, "li", smap_(
            ["class", `${XX.xxTodo} xx-status04${xxdone}`],
            [ATTR.xInfo, JSON.stringify(this.filterx_())],
            [ATTR.xRole, EventKey.Done],
        ));
        const li = b.cursor_();
        b.push_().span1_(XX.xxStatus);
        b.pop_().span1_(XX.xxContent).indent_(
            b.push_().code_(
                ["class", `${XX.xxDate} ${XX.xxHighlight} ${CSS.xDate}`],
                [ATTR.xDateFormat, `${settings$.dateFormat_()};;${this.ms$}`],
                [ATTR.xRole, EventKey.Ms],
            ).text_(settings$.dateString_(new DateTime(this.ms$))),
            b.peek_().text_(" "),
            b.peek_().span_(
                ["class", `${XX.xxHighlight} ${CSS.xSubject}`],
                [ATTR.xRole, EventKey.Description],
            ).text_(this.desc$),
            b.pop_().ul1_(CSS.xNone, CSS.xContent).indent_(
                b.push_().li1_(CSS.xList).indent_(
                    b.push_().span_(
                        ["class", `${CSS.xBulletFa} fa-bell-o`],
                    ),
                    b.pop_().span_(
                        [ATTR.xRole, EventKey.Repeat],
                    ).text_(this.repeat$)),
                b.pop_()));
        const url = this.url$;
        const uri = An.parseUriSafe_(url, null);
        if (url.length > 0 && uri != null) {
            const label = An.labelFromBasepath_(new Basepath(...uri.pathSegments$));
            b.li1_(CSS.xList).indent_(
                b.push_().span_(
                    ["class", `${CSS.xBulletFa} fa-link`],
                ),
                b.pop_().ahref_(url,
                    [ATTR.xRole, EventKey.Url],
                ).text_(label));
        }
        return li;
    }

    get ms$(): Long {
        return this.event$[EventKey.Ms]!! as Long;
    }

    get id$(): string {
        return this.event$[EventKey.Id]!! as string;
    }

    get repeat$(): string {
        return this.event$[EventKey.Repeat] ?? EventRepeat.Once;
    }

    get desc$(): string {
        return this.event$[EventKey.Description] ?? "";
    }

    get color$(): string {
        return this.event$[EventKey.Color] ?? "";
    }

    get url$(): string {
        return this.event$[EventKey.Url] ?? "";
    }

    get done$(): boolean {
        return this.event$[EventKey.Done] === true;
    }

    get doneMs$(): LongX {
        return this.event$[EventKey.DoneMs];
    }

    get doneDesc$(): string {
        return this.event$[EventKey.DoneDesc] ?? "";
    }

    get private$(): boolean {
        return this.event$[EventKey.Private] === true;
    }

    get pending$(): boolean {
        return this.event$[EventKey.Pending] === true;
    }

    get exists$(): boolean {
        return this.event$[EventKey.Exists] === true;
    }

    get date$(): DateTime {
        return DateTime.fromMs_(this.ms$);
    }
}

class SymbolInfo {
    static create_(family: string, name: string, text: string): JSONObject {
        return smap_<any>(
            [SymbolInfoKey.family, family],
            [SymbolInfoKey.name$, name],
            [SymbolInfoKey.text, text]
        );
    }

    static family_(info: JSONObject): string {
        return info[SymbolInfoKey.family]!;
    }

    static name_(info: JSONObject): string {
        return info[SymbolInfoKey.name$]!;
    }

    static text_(info: JSONObject): string {
        return info[SymbolInfoKey.text]!;
    }
}

class EffectUtil extends Effect {
    static readonly Names: string[] = [
        "",
        "Black and white",
        "Gray (4 levels)",
        "Gray (8 levels)",
        "Gray (16 levels)",
        "Gray (256 levels)",
    ];
    static readonly _defaultAdjust: Double[][] = [
        [0.0, 1.0],
        [50.0, 1.0],
        [20.0, 0.5],
        [40.0, 0.25],
        [40.0, 0.125],
        [90.0, 1.0],
    ];

    static get_(name: string): number {
        let index = EffectUtil.Names.indexOf(name);
        return index >= 0 ? index : 0;
    }

    static getAdjust(effect: number, value: string): Double {
        const a = this._defaultAdjust[(effect < 0 || effect >= EffectUtil._defaultAdjust.length) ? 0 : effect];
        const adjust = An.clamp_(0.0, 100.0, An.parseDouble_(value, a[0]));
        return adjust * a[1];
    }

    static getDefaultAdjust_(effect: number): Double {
        if (effect < 0 || effect >= EffectUtil._defaultAdjust.length) {
            return EffectUtil._defaultAdjust[0][0];
        }
        return EffectUtil._defaultAdjust[effect][0];
    }

    static tostring_(effect: number): string {
        if (effect >= 0 && effect < EffectUtil.Names.length) {
            return EffectUtil.Names[effect];
        }
        return EffectUtil.Names[Effect.NONE];
    }
}

class BackdropFilter {
    static readonly FILTERS$ = [
        MSG.string_(RS.None),
        MSG.string_(RS.Filter_blur),
        MSG.string_(RS.Filter_brightness),
        MSG.string_(RS.Filter_contrast),
        MSG.string_(RS.Filter_grayscale),
        MSG.string_(RS.Filter_hueRotate),
        MSG.string_(RS.Filter_invert),
        MSG.string_(RS.Filter_opacity),
        MSG.string_(RS.Filter_saturate),
        MSG.string_(RS.Filter_sepia),
    ];
    static readonly DEF$ = [
        "",
        "50px",
        "1.25",
        "1.5",
        "1.0",
        "180deg",
        "1.0",
        "0.5",
        "2.0",
        "1.0",
    ];
    static readonly RANGE$ = [
        [0, 0, 0],
        [0, 100, 1],
        [0, 10.0, 0.1],
        [0, 10.0, 0.1],
        [0, 1.0, 0.01],
        [0, 360.0, 5.0],
        [0, 1.0, 0.01],
        [0, 1.0, 0.01],
        [0, 10.0, 0.1],
        [0, 1.0, 0.01],
    ];
}

class DEFUtil {
    static readonly prefixPhoto$ = "photo-";
    static readonly prefixScan$ = "scan-";
    static readonly undoHistorySize: number = 99;
    static readonly filterDelay$: number = 500;
    static readonly doubleClickDuration$ = 300;
    static readonly flashDuration = 150;
    static readonly spotlightDuration$ = 500;
    static readonly searchHighlightDuration$ = 5000;
    static readonly duration0$ = 0;
    static readonly duration1$ = 1;
    static readonly duration25$ = 25;
    static readonly durationDay$ = DateTime.DAY;
    static readonly durationTooltips$ = 2000;
    static readonly hideKeyboardDelay$ = 0;
    static readonly hideRightSidebarDuration$ = 5000;
    static readonly imageViewerTimeout$ = 5000;
    static readonly showKeyboardDelay$ = 0;
    static readonly showSpinnerDelay$ = 250;
    static readonly sidepanelTransition$ = 150;
    static readonly toggleKeyboardDelay$ = 0;
    static readonly fontSamplerList = [
        "Abel-Regular",
        "AdventPro-Bold",
        "AdventPro-ExtraLight",
        "AdventPro-Light",
        "AdventPro-Medium",
        "AdventPro-Regular",
        "AdventPro-SemiBold",
        "AdventPro-Thin",
        "Akatab-Black",
        "Akatab-Bold",
        "Akatab-ExtraBold",
        "Akatab-Medium",
        "Akatab-Regular",
        "Akatab-SemiBold",
        "Akronim-Regular",
        "Alegreya-Black",
        "Alegreya-BlackItalic",
        "Alegreya-Bold",
        "Alegreya-BoldItalic",
        "Alegreya-Italic",
        "Alegreya-Regular",
        "AlegreyaSC-Black",
        "AlegreyaSC-BlackItalic",
        "AlegreyaSC-Bold",
        "AlegreyaSC-BoldItalic",
        "AlegreyaSC-Italic",
        "AlegreyaSC-Regular",
        "AlegreyaSans-Black",
        "AlegreyaSans-BlackItalic",
        "AlegreyaSans-Bold",
        "AlegreyaSans-BoldItalic",
        "AlegreyaSans-ExtraBold",
        "AlegreyaSans-ExtraBoldItalic",
        "AlegreyaSans-Italic",
        "AlegreyaSans-Light",
        "AlegreyaSans-LightItalic",
        "AlegreyaSans-Medium",
        "AlegreyaSans-MediumItalic",
        "AlegreyaSans-Regular",
        "AlegreyaSans-Thin",
        "AlegreyaSans-ThinItalic",
        "AlegreyaSansSC-Black",
        "AlegreyaSansSC-BlackItalic",
        "AlegreyaSansSC-Bold",
        "AlegreyaSansSC-BoldItalic",
        "AlegreyaSansSC-ExtraBold",
        "AlegreyaSansSC-ExtraBoldItalic",
        "AlegreyaSansSC-Italic",
        "AlegreyaSansSC-Light",
        "AlegreyaSansSC-LightItalic",
        "AlegreyaSansSC-Medium",
        "AlegreyaSansSC-MediumItalic",
        "AlegreyaSansSC-Regular",
        "AlegreyaSansSC-Thin",
        "AlegreyaSansSC-ThinItalic",
        "Almendra-Bold",
        "Almendra-BoldItalic",
        "Almendra-Italic",
        "Almendra-Regular",
        "Antonio-Bold",
        "Antonio-Light",
        "Antonio-Regular",
        "ArchitectsDaughter",
        "AveriaLibre-Bold",
        "AveriaLibre-BoldItalic",
        "AveriaLibre-Italic",
        "AveriaLibre-Light",
        "AveriaLibre-LightItalic",
        "AveriaLibre-Regular",
        "AveriaSansLibre-Bold",
        "AveriaSansLibre-BoldItalic",
        "AveriaSansLibre-Italic",
        "AveriaSansLibre-Light",
        "AveriaSansLibre-LightItalic",
        "AveriaSansLibre-Regular",
        "BilboSwashCaps-Regular",
        "ButchermanCaps-Regular",
        "CabinSketch-Bold",
        "CabinSketch-Regular",
        "CaesarDressing-Regular",
        "Cagliostro-Regular",
        "Cambo-Regular",
        "Cantarell-Bold",
        "Cantarell-BoldOblique",
        "Cantarell-Oblique",
        "Cantarell-Regular",
        "CevicheOne-Regular",
        "Chewy",
        "Cinzel-Black",
        "Cinzel-Bold",
        "Cinzel-Regular",
        "ClearSans-Bold",
        "ClearSans-BoldItalic",
        "ClearSans-Italic",
        "ClearSans-Light",
        "ClearSans-Medium",
        "ClearSans-MediumItalic",
        "ClearSans-Regular",
        "ClearSans-Thin",
        "Coda-Heavy",
        "Combo-Regular",
        "Cousine-Bold",
        "Cousine-BoldItalic",
        "Cousine-Italic",
        "Cousine-Regular",
        "CraftyGirls",
        "CutiveMono-Regular",
        "DenkOne-Regular",
        "DigitalNumbers-Regular",
        "Diplomata-Regular",
        "DiplomataSC-Regular",
        "DroidSansMono",
        "EagleLake-Regular",
        "EaterCaps-Regular",
        "Economica-Bold",
        "Economica-BoldItalic",
        "Economica-Italic",
        "Economica-Regular",
        "Ewert-Regular",
        "Fascinate-Regular",
        "FascinateInline-Regular",
        "FasterOne-Regular",
        "FaunaOne-Regular",
        "FingerPaint-Regular",
        "FiraMono-Bold",
        "FiraMono-Medium",
        "FiraMono-Regular",
        "FiraSans-Bold",
        "FiraSans-BoldItalic",
        "FiraSans-Book",
        "FiraSans-BookItalic",
        "FiraSans-ExtraBold",
        "FiraSans-ExtraBoldItalic",
        "FiraSans-ExtraLight",
        "FiraSans-ExtraLightItalic",
        "FiraSans-Hair",
        "FiraSans-HairItalic",
        "FiraSans-Heavy",
        "FiraSans-HeavyItalic",
        "FiraSans-Italic",
        "FiraSans-Light",
        "FiraSans-LightItalic",
        "FiraSans-Medium",
        "FiraSans-MediumItalic",
        "FiraSans-Regular",
        "FiraSans-SemiBold",
        "FiraSans-SemiBoldItalic",
        "FiraSans-Thin",
        "FiraSans-ThinItalic",
        "FiraSans-Ultra",
        "FiraSans-UltraItalic",
        "FiraSans-UltraLight",
        "FiraSans-UltraLightItalic",
        "FontAwesome",
        "FrederickatheGreat-Regular",
        "Frijole-Regular",
        "GloriaHallelujah",
        "Imprima-Regular",
        "Inconsolata-Bold",
        "Inconsolata-Regular",
        "Inika-Bold",
        "Inika-Regular",
        "JotiOne-Regular",
        "Julee-Regular",
        "Kalam-Bold",
        "Kalam-Light",
        "Kalam-Regular",
        "Knewave-Regular",
        "Krub-Bold",
        "Krub-BoldItalic",
        "Krub-ExtraLight",
        "Krub-ExtraLightItalic",
        "Krub-Italic",
        "Krub-Light",
        "Krub-LightItalic",
        "Krub-Medium",
        "Krub-MediumItalic",
        "Krub-Regular",
        "Krub-SemiBold",
        "Krub-SemiBoldItalic",
        "LemonOne-Regular",
        "LibreBarcode128-Regular",
        "LibreBarcode128Text-Regular",
        "LibreBarcode39-Regular",
        "LibreBarcode39Extended-Regular",
        "LibreBarcode39ExtendedText-Regular",
        "LibreBarcode39Text-Regular",
        "LibreBarcodeEAN13Text-Regular",
        "Limelight-Regular",
        "LiuJianMaoCao-Regular",
        "Lobster-Regular",
        "LongCang-Regular",
        "Lora-Bold",
        "Lora-BoldItalic",
        "Lora-Italic",
        "Lora-Regular",
        "Macondo-Regular",
        "Martel-Bold",
        "Martel-DemiBold",
        "Martel-ExtraBold",
        "Martel-Heavy",
        "Martel-Light",
        "Martel-Regular",
        "Martel-UltraLight",
        "MartelSans-Black",
        "MartelSans-Bold",
        "MartelSans-ExtraBold",
        "MartelSans-ExtraLight",
        "MartelSans-Light",
        "MartelSans-Regular",
        "MartelSans-SemiBold",
        "Merienda-Bold",
        "Merienda-Regular",
        "Merriweather-Black",
        "Merriweather-BlackItalic",
        "Merriweather-Bold",
        "Merriweather-BoldItalic",
        "Merriweather-Italic",
        "Merriweather-Light",
        "Merriweather-LightItalic",
        "Merriweather-Regular",
        "Monda-Bold",
        "Monda-Regular",
        "Monofett",
        "Monoton-Regular",
        "Montaga-Regular",
        "NothingYouCouldDo",
        "NotoMusic-Regular",
        "NotoSans-Bold",
        "NotoSans-BoldItalic",
        "NotoSans-Italic",
        "NotoSans-Regular",
        "NotoSansSC",
        "NotoSansSymbols-Regular",
        "NotoSansSymbols2-Regular",
        "NotoSansTC",
        "NotoSerif-Bold",
        "NotoSerif-BoldItalic",
        "NotoSerif-Italic",
        "NotoSerif-Regular",
        "NovaCut",
        "NovaMono",
        "NovaOval",
        "NovaScript",
        "Offside-Regular",
        "OpenSans-Bold",
        "OpenSans-BoldItalic",
        "OpenSans-CondBold",
        "OpenSans-CondLight",
        "OpenSans-CondLightItalic",
        "OpenSans-ExtraBold",
        "OpenSans-ExtraBoldItalic",
        "OpenSans-Italic",
        "OpenSans-Light",
        "OpenSans-LightItalic",
        "OpenSans-Regular",
        "OpenSans-Semibold",
        "OpenSans-SemiboldItalic",
        "Orbitron-Black",
        "Orbitron-Bold",
        "Orbitron-Medium",
        "Orbitron-Regular",
        "OxygenMono-Regular",
        "PTM55FT",
        "PT_Sans-Web-Bold",
        "PT_Sans-Web-BoldItalic",
        "PT_Sans-Web-Italic",
        "PT_Sans-Web-Regular",
        "PT_Serif-Web-Bold",
        "PT_Serif-Web-BoldItalic",
        "PT_Serif-Web-Italic",
        "PT_Serif-Web-Regular",
        "Paprika-Regular",
        "PermanentMarker",
        "PetitFormalScript-Regular",
        "Plaster-Regular",
        "Quicksand-Bold",
        "Quicksand-BoldItalic",
        "Quicksand-Italic",
        "Quicksand-Light",
        "Quicksand-LightItalic",
        "Quicksand-Regular",
        "RammettoOne-Regular",
        "Roboto-Black",
        "Roboto-BlackItalic",
        "Roboto-Bold",
        "Roboto-BoldItalic",
        "Roboto-Italic",
        "Roboto-Light",
        "Roboto-LightItalic",
        "Roboto-Medium",
        "Roboto-MediumItalic",
        "Roboto-Regular",
        "Roboto-Thin",
        "Roboto-ThinItalic",
        "RobotoCondensed-Bold",
        "RobotoCondensed-BoldItalic",
        "RobotoCondensed-Italic",
        "RobotoCondensed-Light",
        "RobotoCondensed-LightItalic",
        "RobotoCondensed-Regular",
        "RobotoMono-Bold",
        "RobotoMono-BoldItalic",
        "RobotoMono-Italic",
        "RobotoMono-Light",
        "RobotoMono-LightItalic",
        "RobotoMono-Medium",
        "RobotoMono-MediumItalic",
        "RobotoMono-Regular",
        "RobotoMono-Thin",
        "RobotoMono-ThinItalic",
        "RobotoSlab-Bold",
        "RobotoSlab-Light",
        "RobotoSlab-Regular",
        "RobotoSlab-Thin",
        "RockSalt",
        "Ruda-Black",
        "Ruda-Bold",
        "Ruda-Regular",
        "Rye-Regular",
        "ShantellSans-Italic",
        "ShantellSans",
        "ShareTechMono-Regular",
        "SourceCodePro-Black",
        "SourceCodePro-Bold",
        "SourceCodePro-ExtraLight",
        "SourceCodePro-Light",
        "SourceCodePro-Medium",
        "SourceCodePro-Regular",
        "SourceCodePro-Semibold",
        "SourceSansPro-Black",
        "SourceSansPro-BlackItalic",
        "SourceSansPro-Bold",
        "SourceSansPro-BoldItalic",
        "SourceSansPro-ExtraLight",
        "SourceSansPro-ExtraLightItalic",
        "SourceSansPro-Italic",
        "SourceSansPro-Light",
        "SourceSansPro-LightItalic",
        "SourceSansPro-Regular",
        "SourceSansPro-Semibold",
        "SourceSansPro-SemiboldItalic",
        "SourceSerifPro-Bold",
        "SourceSerifPro-Regular",
        "SourceSerifPro-Semibold",
        "Ubuntu-Bold",
        "Ubuntu-BoldItalic",
        "Ubuntu-Italic",
        "Ubuntu-Light",
        "Ubuntu-LightItalic",
        "Ubuntu-Medium",
        "Ubuntu-MediumItalic",
        "Ubuntu-Regular",
        "UbuntuCondensed-Regular",
        "UbuntuMono-Bold",
        "UbuntuMono-BoldItalic",
        "UbuntuMono-Italic",
        "UbuntuMono-Regular",
        "UnicaOne-Regular",
        "VT323-Regular",
        "Wallpoet-Regular",
        "ZCOOLKuaiLe-Regular",
        "ZhiMangXing-Regular",

    ];
    static readonly monoSamplerList = [
        "Cousine-Bold",
        "Cousine-BoldItalic",
        "Cousine-Italic",
        "Cousine-Regular",
        "CutiveMono-Regular",
        "DigitalNumbers-Regular",
        "DroidSansMono",
        "FiraMono-Bold",
        "FiraMono-Medium",
        "FiraMono-Regular",
        "Inconsolata-Bold",
        "Inconsolata-Regular",
        "NovaMono",
        "OxygenMono-Regular",
        "PTM55FT",
        "RobotoMono-Bold",
        "RobotoMono-BoldItalic",
        "RobotoMono-Italic",
        "RobotoMono-Light",
        "RobotoMono-LightItalic",
        "RobotoMono-Medium",
        "RobotoMono-MediumItalic",
        "RobotoMono-Regular",
        "RobotoMono-Thin",
        "RobotoMono-ThinItalic",
        "ShareTechMono-Regular",
        "SourceCodePro-Black",
        "SourceCodePro-Bold",
        "SourceCodePro-ExtraLight",
        "SourceCodePro-Light",
        "SourceCodePro-Medium",
        "SourceCodePro-Regular",
        "SourceCodePro-Semibold",
        "UbuntuMono-Bold",
        "UbuntuMono-BoldItalic",
        "UbuntuMono-Italic",
        "UbuntuMono-Regular",
        "VT323-Regular",
    ];
    static dialogChromeWidth_(_buttonsize: number): number {
        return DEF.dialogBorderWidth * 2 + DEF.dialogPaddingWidth * 2;
    }

    static dialogChromeHeight_(buttonsize: number): number {
        return buttonsize /* toolbar */ + DEF.dialogBorderWidth * 2 + DEF.dialogPaddingWidth;
    }

    static dialogBottom_(): number {
        return 20
            + DEF.dialogPaddingWidth
            + DEF.dialogBorderWidth
            + 4
            ;
    }

    static dragBorder_(_buttonsize: number): number {
        return DEF.dialogPaddingWidth;
    }

    static sidepanelWidth_(buttonsize: number): number {
        return buttonsize * 7;
    }
}

class PathUtil {
    static readonly home$: string[] = [PATH._Home_, PATH.Home_];
    static readonly homePrivate$: string[] = [
        PATH._Home_,
        PATH.Home_,
    ];
    static readonly homePrivate: string[] = [
        PATH._Home,
        PATH.Home,
    ];
    static readonly internalExternal$: string[] = [
        PATH._Internal_,
        PATH.Internal_,
        PATH._External_,
        PATH.External_
    ];

    static isValidFilepath(filepath: stringX): boolean {
        if (filepath == null || filepath.length == 0) { return false; }
        return this.isValidFilepathSegments(filepath.split(FS));
    }

    static isValidFilepathSegments(segments: string[]): boolean {
        if (segments.length == 0) return false;
        for (const segment of segments) {
            if (this.isValidFilename(segment)) continue;
            return false;
        }
        return true;
    }

    static isValidFilename(filename: string): boolean {
        if (filename.startsWith(".") && filename != "." && filename != "..") return false;
        for (const c of Ut.codepoints_(filename)) {
            if (c === undefined || !An.isValidFilenameChar_(c)) {
                return false;
            }
        }
        if (filename.trim().length != filename.length) return false;
        return true;
    }

    /// @param cpath A context relative path with or without leading /.
    static isBackupsSubtree(cpath: stringX): boolean {
        return cpath != null && PathUtil._isUnder(cpath, PathUtil.internalExternal$);
    }

    /// @param cpath A context relative path with or without leading /.
    static isDocumentsSubtree(cpath: stringX): boolean {
        return cpath != null && PathUtil._isUnder(cpath, PathUtil.homePrivate$);
    }

    /// @param cpath A context relative path with or without leading /.
    static isDocumentsDir(cpath: stringX): boolean {
        return cpath != null && (PathUtil._isOneOf(cpath, PathUtil.homePrivate)
            || PathUtil._isOneOf(cpath, PathUtil.homePrivate$));
    }

    /// @param cpath A context relative path with or without leading /.
    static isDocumentsTree(cpath: stringX): boolean {
        return cpath != null &&
            (PathUtil._isUnder(cpath, PathUtil.homePrivate$) ||
                PathUtil._isOneOf(cpath, PathUtil.homePrivate$) ||
                PathUtil._isOneOf(cpath, PathUtil.homePrivate));
    }

    static isPublicDocumentsSubtree(cpath: stringX): boolean {
        return cpath != null && PathUtil._isUnder(cpath, PathUtil.home$);
    }

    static isTemplatesPath(cpath: stringX): boolean {
        return cpath != null &&
            (cpath.startsWith(PATH._assetsTemplates_) ||
                cpath.startsWith(PATH.assetsTemplates_));
    }

    static isCssPath(cpath: stringX): boolean {
        return cpath != null &&
            (cpath.startsWith(PATH._assetsCss_) ||
                cpath.startsWith(PATH.assetsCss_));
    }

    static isDefaultStylesheet(cpath: stringX): boolean {
        return cpath != null &&
            cpath.endsWith(Suffix.CSS$) &&
            (cpath.startsWith(PATH._assetsCss_) ||
                cpath.startsWith(PATH.assetsCss_));
    }

    static getIncomingDir(): string {
        return PATH._HomeIncoming_;
    }

    static getDraftsDir(): string {
        return PATH._HomeDrafts_;
    }

    static getHomeDir(): string {
        return PATH._Home_;
    }

    static publicHomePath(rpath: stringX): stringX {
        if (rpath == null) return null;
        return `${PATH._Home}/${An.removeLeadingSlashes_(rpath)}`;
    }

    static notexistsAudioPath(): string {
        return `notexists${MimeUtil.audioRecordingSuffix_()}`;
    }

    static notexistsVideoPath(): string {
        return `notexists${MimeUtil.videoRecordingSuffix_()}`;
    }

    /// Create a base name from MediaInfo.Title or MediaInfo.Uri.
    /// @return null if not found.
    static getFilenameFromMediaInfo(info: MediaInfo): stringX {
        let filename = info.title$;
        if (filename != null) { return filename; }
        let uristring = info.uri$;
        if (uristring == null) { return null; }
        try {
            let path = An.parseUri_(uristring, null).path$;
            return Basepath.filename_(path);
        } catch (e) {
        }
        return null;
    }

    static createOutputFilenameFromImageInfo(prefix: string, imageinfo: MediaInfo): string {
        let name = PathUtil.getFilenameFromMediaInfo(imageinfo);
        if (name == null) {
            name = prefix + An.simpleDateTimeString_() + ".jpg";
        } else {
            name = PathUtil.createOutputImageFilename(new Basepath(name));
        }
        return name;
    }

    static createOutputImageFilename(b: Basepath): string {
        const lcsuffix = b.lcSuffix$;
        if (MimeUtil.isWritableImageLcSuffix_(lcsuffix)) {
            return b.filename$;
        }
        return b.stem$ + ".jpg";
    }

    /// @return true If cpath is under the given roots, but not the root itself.
    static _isUnder(cpath: string, roots: string[]): boolean {
        for (let root of roots) {
            if (cpath.startsWith(root) && cpath.length > root.length) {
                return true;
            }
        }
        return false;
    }

    /// @return true If cpath is one of the given roots.
    static _isOneOf(cpath: string, roots: string[]): boolean {
        return roots.indexOf(cpath) >= 0;
    }
}

class TemplatesInfo {

    private constructor(
        private readonly _templates: Map<string, Array<TemplateInfo>>,
        private readonly _aliases: Map<string, string>,
    ) {
    }

    static of_(info: JSONObjectXX): TemplatesInfo {
        return TemplatesInfo._of(info) ?? new TemplatesInfo(new Map(), new Map());
    }

    private static _of(info: JSONObjectXX): TemplatesInfo | null {
        if (info === null || info === undefined) return null;
        const map: StringMap<Array<JSONObject>> = info[_TemplatesJSONKey.templates];
        if (map == null) return null;
        const templates = new Map<string, Array<TemplateInfo>>();
        for (const k of Object.keys(map).sort()) {
            const a = new Array<TemplateInfo>();
            map[k].map((vv) => TemplateInfo.of_(vv)).forEach(info => {
                if (info != null) a.push(info);
            });
            if (a.length > 0) templates.set(k, a);
        }
        const aliases = new Map<string, string>(Object.entries(info[_TemplatesJSONKey.aliases] ?? []));
        return new TemplatesInfo(templates, aliases);
    }

    get aliases$(): Map<string, string> {
        return this._aliases;
    }

    get templates$(): Map<string, Array<TemplateInfo>> {
        return this._templates;
    }
}

class TemplateInfo {

    private constructor(readonly info$: JSONObject) { }

    static of_(info: StringMapXX<any>): TemplateInfo | null {
        if (info === null || info === undefined) return null;
        return new TemplateInfo(info);
    }

    get template$(): stringX {
        return this.info$[_TemplatesJSONKey.template]!;
    }

    get cat$(): string {
        return this.info$[_TemplatesJSONKey.category]!;
    }

    get name$(): string {
        return this.info$[_TemplatesJSONKey.name$]!;
    }

    get label$(): string {
        return this.info$[_TemplatesJSONKey.label]!;
    }

    get classes$(): string {
        return this.info$[_TemplatesJSONKey.classes]!;
    }

    get filepath(): string {
        return this.info$[_TemplatesJSONKey.filepath]!;
    }

    get emoji$(): string {
        return this.info$[_TemplatesJSONKey.emoji]!;
    }

    get desc$(): string {
        return this.info$[_TemplatesJSONKey.desc]!;
    }

    get lcCat$(): string {
        return this.cat$.toLowerCase();
    }
}

class SK {
    static readonly Display = "display";
    static readonly Position = "position";
    static readonly Visibility = "visibility";
    static readonly Width = "width";
    static readonly Height = "height";
    static readonly Top = "top";
    static readonly Left = "left";
}

class SV {
    static readonly Hidden = "hidden";
    static readonly Visible = "visble";
    static readonly None = "none";
    static readonly Inline = "inline";
    static readonly Block = "block";
    static readonly Flex = "flex";
    static readonly InlineFlex = "inline-flex";
    static readonly Relative = "relative";
    static readonly Absolute = "absolute";
    static readonly Fixed = "fixed";
}

class CSSLength {
    static readonly PX = "px";
    static readonly PT = "pt";
    static readonly PC = "pc";
    static readonly IN = "in";
    static readonly CM = "cm";
    static readonly MM = "mm";
    static readonly REM = "rem";
    static readonly EM = "em";
    static readonly EX = "ex";
    static readonly CH = "ch";
    static readonly VW = "vw";
    static readonly VH = "vh";
    static readonly VMIN = "vmin";
    static readonly VMAX = "vmax";
    static readonly PERCENT = "%";
}

const CSSLengths = [
    CSSLength.PX,
    CSSLength.PT,
    CSSLength.PC,
    CSSLength.IN,
    CSSLength.CM,
    CSSLength.MM,
    CSSLength.REM,
    CSSLength.EM,
    CSSLength.EX,
    CSSLength.CH,
    CSSLength.VW,
    CSSLength.VH,
    CSSLength.VMIN,
    CSSLength.VMAX,
    CSSLength.PERCENT,
];

class PV {
    static readonly TextAlign: string[] = [
        "",
        "center",
        "justify",
        "start",
        "end",
        "left",
        "right",
        "inherit",
        "unset",
    ];
    static readonly VerticalAlign: string[] = [
        "",
        "middle",
        "baseline",
        "top",
        "bottom",
        "text-top",
        "text-bottom",
        "super",
        "sub",
        "inherit",
        "unset",
    ];
    static readonly Float: string[] = [
        "",
        "none",
        "left",
        "right",
        "inherit",
        "unset",
    ];
    static readonly Clear: string[] = [
        "",
        "none",
        "left",
        "right",
        "both",
        "inherit",
        "unset",
    ];
    static readonly Display: string[] = [
        "",
        "block",
        "flex",
        "inline",
        "inline-block",
        "inline-flex",
        "inline-table",
        "list-item",
        "none",
        "table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row",
        "table-row-group",
        "unset",
    ];
}

class RX {
    static readonly Comma1 = new RegExp("^\\s*,\\s*(.*)$");
    static readonly CommaSeparated = new RegExp("\\s*,\\s*");
    static readonly CommaSpace = new RegExp("[,\\s]+");
    static readonly CommaSpace_g = new RegExp("[,\\s]+", "g");
    static readonly SemicolonSpace = new RegExp("\\s*;\\s*");
    static readonly CSSValue = new RegExp("^(.*?)\\s*:\\s*(.*)$");
    static readonly CSSAngle = new RegExp(
        "^(\\d+(deg|rad|grad|turn)|to(\\s+(top|right|bottom|left))(\\s+(top|right|bottom|left))?)\$",
        "i" /* caseSensitive = false */);
    static readonly CSSColorValue = new RegExp("^(.*?)(#[0-9a-fA-f]+|rgba?\\(.*?\\))(.*)\$");
    static readonly CSSColorValue1 = new RegExp("^(#[0-9a-fA-f]+|rgba?\\(.*?\\))(.*)\$");
    static readonly CSSUrlValue = new RegExp("^(.*?)(url\\(.*?\\)\\s*)(.*)\$");
    static readonly StartsWithDigit = new RegExp("^(\\d+)");
    static readonly Decimals = new RegExp("^\\d+\$");
    static readonly EndsWithWhitespaces = new RegExp("[\\s\\r\\n\\f\\u200b]\$");
    static readonly Funcall = new RegExp("^([-\\w]+)\\s*(\\(.*?\\)).*\$");
    static readonly Gradients = new RegExp("^((repeating-)?(linear|radial)-gradient)\\(");
    static readonly HostPort = new RegExp("^.*?://[^/]*(:\\d+)?");
    static readonly HtmlMime = new RegExp(
        "^text/html(;.*)?\$",
        "i" /* caseSensitive = false */);
    static readonly HtmlAmp =
        new RegExp(
            "&(amp|lt|gt|apos|quot);",
            "i" /* caseSensitive = false */);
    static readonly HtmlEntity_G = new RegExp(
        "&(#x([0-9a-fA-F]+)|#([0-9]+)|amp|lt|gt|apos|quot);",
        "ig");
    static readonly IsWhitespaces = new RegExp("^[\\s\\r\\n\\f\\u200b]*\$");
    static readonly InvalidFilenameChars = new RegExp("[\\\\?\\#\\%;\\[\\]]");
    static readonly LabelPat = new RegExp("[-_]", "g");
    static readonly Linebreaks = new RegExp("[\\r\\n]");
    static readonly Linebreaks_g = new RegExp("(\\r\\n?|\\n)", "g");
    static readonly NonSpaces = new RegExp("(\\S+)");
    static readonly Sides2 = new RegExp(
        "^(top|right|bottom|left)(\\s+(top|right|bottom|left))?\$",
        "i");
    static readonly SizeUnit = new RegExp("^([\\d.]+)(.*)\$");
    static readonly ValueUnit = new RegExp("^([-+]?[\\d.]+)(.*)\$");
    static readonly Slashes = new RegExp("/+");
    static readonly Slashes_g = new RegExp("/+", "g");
    static readonly Space = new RegExp("\\s");
    static readonly Spaces = new RegExp("\\s+");
    static readonly Spaces_g = new RegExp("\\s+", "g");
    static readonly StartsWithWhitespaces = new RegExp("^[\\s\\r\\n\\f\\u200b]");
    static readonly Tn = new RegExp("^(.*)-tn(\\d+.*)?(\\.\\w+)\\s*\$", "i");
    static readonly UpperCaseLetter = new RegExp("([A-Z])");
    static readonly UpperCaseLetter_g = new RegExp("([A-Z])", "g");
    static readonly Word1 = new RegExp("^\\w+\$");
    static readonly Word8_g = new RegExp("(\\w{8})", "g");
    static readonly DoubleNumber = new RegExp("^.*?([-+]?\\s*("
        + "[0-9][0-9,\\s]*(\\.\\s*[0-9][0-9,\\s]*)?"
        + "|\\.\\s*[0-9][0-9,\\s]*"
        + ")([eE]\\s*[-+]?\\s*[0-9][0-9,\\s]*)?).*\$");
    static readonly _CSSUrl = new RegExp("url\\(\\s*((?![\"']).*?)\\s*\\)");
    static readonly _CSSUrlQQ = new RegExp('url\\(\\s*"([^"]+?)(")\\s*\\)');
    static readonly _CSSUrlQ = new RegExp("url\\(\\s*'([^']+?)(')\\s*\\)");
    static readonly _CSSUrlHostPort =
        new RegExp("(url\\()\\s*(?![\"'])\\w+://\\w+(:\\d+)?(.*?\\s*\\))");
    static readonly _CSSUrlHostPortQQ =
        new RegExp('(url\\(\\s*")\\w+://\\w+(:\\d+)?(.*?"\\s*\\))');
    static readonly _CSSUrlHostPortQ =
        new RegExp("(url\\(\\s*')\w+://\\w+(:\\d+)?(.*?'\\s*\\))");
    static readonly _QQ_G = new RegExp("[\u201c\u201d]", "g");
    static readonly _Q_G = new RegExp("[\u2018\u2019]", "g");
    static readonly WxH = new RegExp("\\s*(\\d*)x(\\d*)\\s*");

    static regexOrNull(pat: string, flags: string | undefined = undefined): RegExp | null {
        try {
            return RegExp(pat, flags);
        } catch (e: any) {
            return null;
        }
    }
}

/// Runtime assertion for production code.
class Assert {
    static assertion_(ok: boolean, msg: string = ""): void {
        if (!ok) {
            throw Assert._fail(msg);
        }
    }

    static assertionKey_(ok: boolean, msgid: string): void {
        if (!ok) {
            throw Assert._fail(msgid == null ? "" : MSG.string_(msgid));
        }
    }

    static fail_(msg: string = ""): never {
        throw Assert._fail(msg);
    }

    static notNull_<T>(a: T | null | undefined): T {
        if (a === null || a === undefined) {
            throw Assert._fail(MSG.string_(RS.AssertNotNull));
        }
        return a;
    }

    static notReach_(msg: stringX = null): string {
        let notreach = MSG.string_(RS.AssertNotReach);
        return Assert._fail((msg == null ? notreach : notreach + ": " + msg));
    }

    static invalidAction_(action: string): string {
        return Assert._fail(MSG.string_(RS.invalidAction_) + action);
    }

    static abstractMethod_(): string {
        return Assert._fail(MSG.string_(RS.AbstractMethodNotImplemented));
    }

    static unsupportedOperation_(msg: stringX = null): string {
        let unsupported = MSG.string_(RS.AssertUnsupportedOperation);
        return Assert._fail(msg == null ? unsupported : unsupported + ": " + msg);
    }

    private static _fail(_msg: string): string {
        let error = MSG.string_(RS.AssertFail_);
        return error;
    }
}

class Html5 {
    static readonly _EMPTY = "E";
    static readonly _XEDIT = "X";
    static readonly _SPLIT = "S";
    static readonly _tags = map_<string, Map<string, boolean> | null>(
        ["FIELDSET", null],
        ["SAMP", null],
        ["BODY", null],
        ["LI", map_([Html5._SPLIT, true],)],
        ["OL", null],
        ["NOSCRIPT", null],
        ["UL", null],
        ["HR", map_([Html5._EMPTY, true],)],
        ["DD", null],
        ["MAP", null],
        ["SUB", null],
        ["BR", map_([Html5._EMPTY, true],)],
        ["KBD", null],
        ["SMALL", null],
        ["Q", null],
        ["TIME", null],
        ["MARK", map_([Html5._EMPTY, true],)],
        ["H4", null],
        ["HEADER", null],
        ["B", null],
        ["H6", null],
        ["U", null],
        ["DATALIST", null],
        ["LEGEND", null],
        ["COL", map_([Html5._EMPTY, true],)],
        ["OPTION", null],
        ["SPAN", null],
        ["NAV", null],
        ["CANVAS", null],
        ["OUTPUT", null],
        ["S", null],
        ["ABBR", null],
        ["DATA", null],
        ["PRE", null],
        ["H5", null],
        ["H3", null],
        ["H1", null],
        ["INPUT", map_([Html5._EMPTY, true],)],
        ["KEYGEN", null],
        ["H2", null],
        ["FORM", null],
        ["TABLE", null],
        ["RP", null],
        ["SECTION", map_([Html5._SPLIT, true],)],
        ["META", map_([Html5._EMPTY, true],)],
        ["DFN", null],
        ["INS", null],
        ["PROGRESS", null],
        ["I", null],
        ["P", null],
        ["RUBY", null],
        ["HTML", null],
        ["DETAILS", null],
        ["TRACK", map_([Html5._EMPTY, true],)],
        ["ASIDE", null],
        ["MENU", null],
        ["CODE", null],
        ["METER", null],
        ["SOURCE", map_([Html5._EMPTY, true],)],
        ["FONT", null],
        ["RT", null],
        ["BLOCKQUOTE", null],
        ["STRONG", null],
        ["SELECT", null],
        ["DIALOG", null],
        ["TH", null],
        ["BDO", null],
        ["AREA", map_([Html5._EMPTY, true],)],
        ["BASE", map_([Html5._EMPTY, true],)],
        ["SUMMARY", null],
        ["FOOTER", null],
        ["ADDRESS", null],
        ["LABEL", null],
        ["CAPTION", null],
        ["THEAD", null],
        ["IMG", map_([Html5._EMPTY, true],)],
        ["TD", null],
        ["ARTICLE", map_([Html5._SPLIT, true],)],
        ["FIGURE", null],
        ["DIV", null],
        ["RB", null],
        ["EM", null],
        ["TBODY", null],
        ["RTC", null],
        ["MAIN", null],
        ["WBR", map_([Html5._EMPTY, true],)],
        ["TFOOT", null],
        ["DT", null],
        ["SUP", null],
        ["BUTTON", null],
        ["EMBED", map_([Html5._XEDIT, true], [Html5._EMPTY, true],)],
        ["VIDEO", null],
        ["TR", map_([Html5._SPLIT, true],)],
        ["TITLE", null],
        ["AUDIO", null],
        ["CITE", null],
        ["DOCTYPE", map_([Html5._EMPTY, true],)],
        ["A", null],
        ["TEXTAREA", null],
        ["PICTURE", null],
        ["LINK", map_([Html5._EMPTY, true],)],
        ["COLGROUP", null],
        ["OPTGROUP", null],
        ["MENUITEM", null],
        ["HEAD", null],
        ["VAR", null],
        ["STYLE", null],
        ["PARAM", map_([Html5._EMPTY, true],)],
        ["FIGCAPTION", null],
        ["BDI", null],
        ["DEL", null],
        ["DL", map_([Html5._SPLIT, true],)],
        ["TEMPLATE", null],
    );

    static readonly validChildren = new Map<string, Array<string>>([
        ["OL", ["LI"]],
        ["UL", ["LI"]],
        ["DL", ["DD", "DT"]],
        ["TABLE", ["TBODY", "THEAD", "TFOOT", "COLGROUP", "CAPTION", "TR"]],
        ["TBODY", ["TR"]],
        ["THEAD", ["TR"]],
        ["TFOOT", ["TR"]],
        ["TR", ["TD", "TH"]],
        ["AUDIO", ["SOURCE", "TRACK"]],
        ["VIDEO", ["SOURCE", "TRACK"]],
    ]);

    static readonly validParent = new Map<string, Array<string>>([
        ["LI", ["OL", "UL"]],
        ["DD", ["DL"]],
        ["DT", ["DL"]],
        ["TD", ["TR"]],
        ["TR", ["TABLE", "TBODY", "THEAD", "TFOOT"]],
        ["TBODY", ["TABLE"]],
        ["THEAD", ["TABLE"]],
        ["TFOOT", ["TABLE"]],
        ["COLGROUP", ["TABLE"]],
        ["CAPTION", ["TABLE"]],
        ["SOURCE", ["AUDIO", "VIDEO"]],
        ["TRACK", ["AUDIO", "VIDEO"]],
    ]);

    /// Short tag list for insert element action.

    static canEditTag(nodename: string): boolean {
        return Html5._tags.get(nodename)?.get(Html5._XEDIT) === undefined;
    }

    static canSplitTag(nodename: string): boolean {
        return Html5._tags.get(nodename)?.get(Html5._SPLIT) === true;
    }

    static isEmptyTag(nodename: string): boolean {
        return Html5._tags.get(nodename)?.get(Html5._EMPTY) === true;
    }
}

class Events {
    static readonly click: EventName = "click";
    static readonly touchstart: EventName = "touchstart";
    static readonly touchmove: EventName = "touchmove";
    static readonly touchend: EventName = "touchend";
    static readonly touchcancel: EventName = "touchcancel";
    static readonly mousedown: EventName = "mousedown";
    static readonly mousemove: EventName = "mousemove";
    static readonly mouseup: EventName = "mouseup";
    static readonly contextmenu: EventName = "contextmenu";
}

interface IGestureHandler {
    pause_(): void;
    resume_(): void;
    push_(event: string, l: IGestureListener): void;
    pop_(event: string): void;
}

////////////////////////////////////////////////////////////////////////

interface IUriParser {
    /// @return A valid Uri or null if uri is null, empty or invalid.
    parseUri_(href: stringX, baseurl: BaseUriX): UriX;
}

interface IWarner {
    /// Show a warning if msg is a String, List<String>, or Map<string, dynamic> with msg at Key.errors.
    /// @return true If a message is found.
    warn_(msg: TestResult): boolean;
}

interface IFilepathUtil {
    /// @param href An encoded/decoded absolute URI or iframe relative path, null on error.
    getContextPath(href: string): stringX;
    getFileinfoUtil(): FileInfoUtil;
}

interface IFilepickerHandler {
    /// @param path A context relative path with or without leading /, with or without trailing /.
    /// @return {
    ///     Key.fileinfo: {fileinfo}
    ///     Key.errors: Object,
    /// }
    fileInfo_(cpath: string, callback: JSONCallback): void;

    /// List directory.
    /// @since v1.7 Trailing / is valid and show the specified directory with filename as "".
    /// Before v1.7, trailing / is invalid.
    /// @param cpath is context relative path to a directory or file,
    /// with or without leading /, with or without trailing /.
    /// @return {
    ///   Key.path: String,
    ///   Key.dirpath: [fileinfo],
    ///   Key.dirtree: [fileinfo],
    ///   Key.filename: String,
    ///   Key.errors: Object
    /// }
    /// If the last segment of the path is not a directory, list directory that contain the file and return
    /// the filename. Otherwise list the directory at the given path and return filename as "".
    listDir_(cpath: string, callback: JSONCallback): void;

    /// @param path Context relative path to a file, with or without leading /.
    mkDirs_(cpath: string, callback: JSONCallback): void;

    /// @cpathorparams A string for cpath or a stringified JSONObject for params.
    delete_(cpathorparams: string, callback: JSONCallback): void;

    deleteAll_(srcpath: string, rpaths: string[], callback: JSONCallback): void;

    deleteInfo_(cpath: string, callback: JSONCallback): void;

    /// Rename file/directory at fromcpath to the given newname.
    /// If destination already exists, it returns an error.
    /// @cpathorparams A string for source cpath or a stringified JSONObject for params.
    rename_(cpathorparams: string, newname: string, fixxrefs: boolean, callback: JSONCallback): void;

    /// Copy file/files from src directory to dst directory.
    /// If destination already exists, it would be replaced.
    /// So ask for confirmation before calling this if necessary.
    /// @param rpaths If empty copy whole directory recursively, otherwise the given file/directory recursively.
    copy_(
        cut: boolean,
        preservetimestamp: boolean,
        fixxrefs: boolean,
        dst: string,
        src: string,
        rpaths: string[] | null,
        callback: JSONCallback
    ): void;

    /**
     * @return {
     *   Key.errors: Object,
     *   Key.copying: { string: boolean[] },
     *   Key.overwriting: { string: boolean[] },
     *   Key.notcopying; { string: string[] }
     * }
     * where copying and overwriting returns the rpaths,
     * notcopying returns { error : [rpaths] }
     */
    copyInfo_(cut: boolean, dst: string, src: string, callback: JSONCallback): void;

    /// @cpathorparams A string for cpath or a stringified JSONObject for params.
    /// @return { Key.errors: TestResult, }
    deleteDirSubtree_(cpathorparams: string, callback: JSONCallback): void;

    //// @return {Key.result: [MediaInfo]}
    localImageInfos_(cpath: string, callback: JSONCallback): void;

    localImageThumbnails_(size: Int, quality: Int, infos: JSONObjectX[], callback: JSONCallback): void;

    deleteEmptyDirs_(cpath: string, callback: JSONCallback): void;

    /// List directory recursively.
    /// Unlike listDir action that provide all information required to populate a Filepicker,
    /// this action only returns the rpaths of files under the given directory. It does not
    /// include directories. Currently, this is use by CreateGallery in Filepicker and
    /// HistoryFilepicker filter action in HistoryFilepicker.
    ///
    /// @cpathorparams A string for cpath or a stringified JSONObject for params.
    /// Optional Key.level with value 0 for all levels, 1 for 1 level down.
    /// @return {
    ///   Key.dirtree: [String],
    ///   Key.errors: TestResult
    /// }
    listRecursive_(params: JSONObject, callback: JSONCallback): void;

    /// Get fileinfo of a set of files.
    /// @return Only fileinfo for rpaths that exist: {
    ///     Key.result: { rpath: {fileinfo} }
    /// }
    fileInfos_(dir: string, rpaths: string[], callback: JSONCallback): void;

    /// Get info of a directory.
    /// @return { Key.result: [filecount, dircount, total_file_size, recursive_file_count, recursive_dir_count, recursive_file_size]}
    dirInfo_(cpath: string, callback: JSONCallback): void;

    /// Secure delete. Overwrite file content with random data before deleting it.
    /// @return { Key.errors: errors}
    shred_(dir: string, rpaths: string[], callback: JSONCallback): void;
}

interface IRecentsHandler {
    info_(callback: JSONCallback): void;
    sorted_(callback: JSONCallback): void;
    clean_(callback: JSONCallback): void;
    clear_(callback: JSONCallback): void;
}

interface IMediaInfoHandler {
    //// @return {Key.result: [MediaInfo]}
    infos_(callback: JSONCallback): void;

    /// @param size Thumbnail size.
    /// @param infos [{MediaInfo}]
    /// @return {Key.result: [{MediaInfo.DataUrl: dataurl, MediaInfo.Error: error}]}
    thumbnails_(size: Int, quality: Int, infos: Array<MediaInfo | null>, callback: JSONCallback): void;
}

////////////////////////////////////////////////////////////////////////

class CropInfo {
    constructor(
        public x: Int,
        public y: Int,
        public w: Int,
        public h: Int,
        public zoom: Double,
        public rotation: Int,
    ) { }
    toJSONArray(): JSONArray {
        return [this.x, this.y, this.w, this.h, this.zoom, this.rotation];
    }
}

class ImageOutputInfo {
    constructor(
        public filepath: string,
        public cpath: string,
        public width: Int,
        public height: Int,
        public rotation: Int,
        public effect: Int,
        public adjust: Double,
        public quality: Int,
    ) {
    }

    toJSONArray(): JSONArray {
        return [this.cpath, this.width, this.height, this.rotation, this.effect, this.adjust, this.quality];
    }
}

class MediaInfo {
    static readonly Private = "#XAs";
    static readonly Channels = "#XVO";
    static readonly SampleRate = "#XE7";
    static readonly Rotation = "#XFw";
    static readonly Id = "#Xcu";
    static readonly Height = "#XNV";
    static readonly Width = "#XvV";
    static readonly CreationDate = "#XZy";
    static readonly FileDate = "#X0w";
    static readonly Uri = "#XIE";
    static readonly Duration = "#X6s";
    static readonly Mime = "#XBo";
    static readonly TnInfo = "#Xu3";
    static readonly Title = "#XFE";
    static readonly StagingId = "#XHs";
    static readonly DataUrl = "#Xy5";
    static readonly Description = "#XU5";
    static readonly Bitrate = "#Xvx";
    static readonly Playable = "#X1P";
    static readonly FrameRate = "#Xs8";
    static readonly FileSize = "#Xzt";
    static readonly FileExists = "#Xob";
    static readonly Error = "#Xpv";

    private constructor(private info$: JSONObject) { }

    static of_(info: StringMapXX<any>): MediaInfo | null {
        return info === null || info === undefined ? null : new MediaInfo(info);
    }

    static arrayOf_(infos: ArrayXX<JSONObject>): MediaInfo[] | null {
        return infos === null || infos === undefined ? null : infos.map(value => new MediaInfo(value));
    }

    get json$(): JSONObject {
        return this.info$;
    }

    get id$(): string {
        return this.info$[MediaInfo.Id].toString();
    }

    get title$(): stringX {
        return this.info$[MediaInfo.Title] ?? null;
    }

    get description$(): string {
        return this.info$[MediaInfo.Description] ?? "";
    }

    get bitrate$(): numberX {
        return this.info$[MediaInfo.Bitrate] ?? null;
    }

    get channels$(): numberX {
        return this.info$[MediaInfo.Channels] ?? null;
    }

    /**
       * @return Creation date in ms since epoch in UTC.
       */
    get creationDate$(): numberX {
        return this.info$[MediaInfo.CreationDate] ?? null;
    }

    /**
       * @return @nonNull ms since epoch in local timezone.
       */
    get fileDate$(): number {
        return this.info$[MediaInfo.FileDate] ?? 0;
    }

    get fileSize$(): number {
        return this.info$[MediaInfo.FileSize] ?? 0;
    }

    /**
       * @return @nonNull false if file not exists or info == null.
       */
    get fileExists$(): boolean {
        return this.info$[MediaInfo.FileExists] === true;
    }

    get playable$(): boolean {
        return true == this.info$[MediaInfo.Playable];
    }

    get duration$(): number {
        return this.info$[MediaInfo.Duration] ?? 0;
    }

    get width$(): number {
        return this.info$[MediaInfo.Width] ?? 0;
    }

    get height$(): number {
        return this.info$[MediaInfo.Height] ?? 0;
    }

    get mime$(): stringX {
        return this.info$[MediaInfo.Mime] ?? null;
    }

    get uri$(): stringX {
        return this.info$[MediaInfo.Uri] ?? null;
    }

    get rotation$(): numberX {
        return this.info$[MediaInfo.Rotation] ?? null;
    }

    get hasStagingId$(): boolean {
        return this.stagingId$ != null;
    }

    get isPrivate$(): boolean {
        return true == this.info$[MediaInfo.Private];
    }

    get stagingId$(): stringX {
        return this.info$[MediaInfo.StagingId] ?? null;
    }

    get tnInfo$(): JSONObjectX {
        return this.info$[MediaInfo.TnInfo] ?? null;
    }

    get dataUrl$(): stringX {
        return this.info$[MediaInfo.DataUrl] ?? null;
    }

    get tnDataUrl$(): stringX {
        return this.tnInfo$?.[MediaInfo.DataUrl] ?? null;
    }

    get error$(): stringX {
        return this.info$[MediaInfo.Error] ?? null;
    }

    get isImage$(): boolean {
        return (this.mime$?.startsWith("image/")) ?? false;
    }

    get isAudio$(): boolean {
        return (this.mime$?.startsWith("audio/")) ?? false;
    }

    get isVideo$(): boolean {
        return (this.mime$?.startsWith("video/")) ?? false;
    }

    get resolution$(): stringX {
        let w = this.width$;
        let h = this.height$;
        if (w > 0 && h > 0) {
            return `${w} x ${h}`;
        }
        return null;
    }

    duration1_(def: number): number {
        return this.info$[MediaInfo.Duration] ?? def;
    }

    setTnInfo_(info: JSONObject) {
        this.info$[MediaInfo.TnInfo] = info;
    }

    tostring_<T>(key: string, def: T): string | T {
        const value = this.info$[key] ?? null;
        return value == null ? def : value.toString();
    }

    static briefMessage_(dateformat: string, info: MediaInfo): string {
        let date = info.fileDate$;
        let size = info.fileSize$;
        let modified = date == null ? "???" : DateFormat.dateStringFromMs_(dateformat, date);
        let sizeunit = size == null ? "???" : An.filesizeUnit4_(size);
        return modified +
            "\u00a0\u2022\u00a0" +
            sizeunit +
            "\u00a0\u2022\u00a0" +
            info.title$;
    }
}

class BackupFileInfo {
    private constructor(private info$: JSONObject) { }

    static of_(info: StringMapXX<any>): BackupFileInfo | null {
        return info === null || info === undefined || An.hasResult_(info) ? null : new BackupFileInfo(info);
    }

    get json$(): JSONObject {
        return this.info$;
    }

    get aliasCount$(): Int {
        return this.info$[Key.result] ?? 0;
    }

    get version$(): Int {
        return this.info$[Key.version] ?? 0;
    }

    get keyAlias$(): string {
        return this.info$[Key.key];
    }

    get keyExpire$(): string {
        return this.info$[Key.expire] ?? "";
    }
    get keyChecksum$(): string {
        return this.info$[Key.checksum] ?? "";
    }

    get warns$(): string[] {
        return this.info$[Key.warns] ?? [];
    }
}

abstract class Mime {
    static readonly JSON$ = "application/json";
    static readonly WOFF2$ = "application/font-woff2";
    static readonly WEBM$ = "video/webm";
    static readonly JS$ = "text/javascript";
    static readonly BMP$ = "image/bmp";
    static readonly BACKUP$ = "application/vnd.cplusedition.backup";
    static readonly MOV$ = "video/quicktime";
    static readonly HEIC$ = "image/heic";
    static readonly PDF$ = "application/pdf";
    static readonly ZIP$ = "application/zip";
    static readonly CSS$ = "text/css";
    static readonly WAV$ = "audio/wav";
    static readonly MP3$ = "audio/mpeg";
    static readonly WEBP$ = "image/webp";
    static readonly XML$ = "application/xml";
    static readonly IBACKUP$ = "application/vnd.cplusedition.ibackup";
    static readonly SVG$ = "image/svg+xml";
    static readonly ICO$ = "image/vnd.microsoft.icon";
    static readonly AWB$ = "audio/amr-wb";
    static readonly AUDIO$ = "audio/*";
    static readonly OGG$ = "audio/ogg";
    static readonly MP4$ = "video/mp4";
    static readonly WOFF$ = "application/font-woff";
    static readonly M4A$ = "audio/mp4";
    static readonly JPEG$ = "image/jpeg";
    static readonly TTF$ = "application/x-font-ttf";
    static readonly PEM$ = "application/pem";
    static readonly GIF$ = "image/gif";
    static readonly PNG$ = "image/png";
    static readonly OTF$ = "font/opentype";
    static readonly TXT$ = "text/plain";
    static readonly HTML$ = "text/html";
    static readonly FLAC$ = "audio/flac";
    static readonly EOT$ = "application/vnd.ms-fontobject";
    static readonly DER$ = "application/pkcs7-mime";
}

abstract class Suffix {
    static readonly SVG$ = ".svg";
    static readonly AWB$ = ".awb";
    static readonly WOFF2$ = ".woff2";
    static readonly WEBP$ = ".webp";
    static readonly MP3$ = ".mp3";
    static readonly SVGZ$ = ".svgz";
    static readonly JPEG$ = ".jpeg";
    static readonly ICO$ = ".ico";
    static readonly FLAC$ = ".flac";
    static readonly HEIC$ = ".heic";
    static readonly BMP$ = ".bmp";
    static readonly OGG$ = ".ogg";
    static readonly ZIP$ = ".zip";
    static readonly JSON$ = ".json";
    static readonly BACKUP$ = ".backup";
    static readonly MOV$ = ".mov";
    static readonly M4A$ = ".m4a";
    static readonly PDF$ = ".pdf";
    static readonly OTF$ = ".otf";
    static readonly PEM$ = ".pem";
    static readonly XML$ = ".xml";
    static readonly JPG$ = ".jpg";
    static readonly WOFF$ = ".woff";
    static readonly TTF$ = ".ttf";
    static readonly EOT$ = ".eot";
    static readonly DER$ = ".der";
    static readonly WEBM$ = ".webm";
    static readonly JS$ = ".js";
    static readonly PNG$ = ".png";
    static readonly HTML$ = ".html";
    static readonly IBACKUP$ = ".ibackup";
    static readonly CSS$ = ".css";
    static readonly WAV$ = ".wav";
    static readonly MP4$ = ".mp4";
    static readonly TXT$ = ".txt";
    static readonly GIF$ = ".gif";
}

abstract class Fontface {
    static readonly WOFF2$ = "woff2";
    static readonly EOT$ = "embeded-opentype";
    static readonly OPENTYPE$ = "opentype";
    static readonly SVG$ = "svg";
    static readonly WOFF$ = "woff";
}

abstract class MimeUtil {
    private static _mimeBySuffix = smap_(
        [Suffix.HTML$, Mime.HTML$],
        [Suffix.CSS$, Mime.CSS$],
        [Suffix.JS$, Mime.JS$],
        [Suffix.TXT$, Mime.TXT$],
        [Suffix.PDF$, Mime.PDF$],
        [Suffix.JSON$, Mime.JSON$],
        [Suffix.XML$, Mime.XML$],
        [Suffix.JPG$, Mime.JPEG$],
        [Suffix.JPEG$, Mime.JPEG$],
        [Suffix.PNG$, Mime.PNG$],
        [Suffix.GIF$, Mime.GIF$],
        [Suffix.BMP$, Mime.BMP$],
        [Suffix.ICO$, Mime.ICO$],
        [Suffix.M4A$, Mime.M4A$],
        [Suffix.MP3$, Mime.MP3$],
        [Suffix.WAV$, Mime.WAV$],
        [Suffix.OGG$, Mime.OGG$],
        [Suffix.FLAC$, Mime.FLAC$],
        [Suffix.AWB$, Mime.AWB$],
        [Suffix.MP4$, Mime.MP4$],
        [Suffix.MOV$, Mime.MOV$],
        [Suffix.WEBM$, Mime.WEBM$],
        [Suffix.WOFF2$, Mime.WOFF2$],
        [Suffix.WOFF$, Mime.WOFF$],
        [Suffix.TTF$, Mime.TTF$],
        [Suffix.OTF$, Mime.OTF$],
        [Suffix.EOT$, Mime.EOT$],
        [Suffix.DER$, Mime.DER$],
        [Suffix.PEM$, Mime.PEM$],
        [Suffix.ZIP$, Mime.ZIP$],
        [Suffix.BACKUP$, Mime.BACKUP$],
        [Suffix.IBACKUP$, Mime.IBACKUP$],
    );
    private static _suffixByMime = StringMap.putAll_(StringMap.invertStringMap_(MimeUtil._mimeBySuffix),
        [Mime.JPEG$, Suffix.JPG$],
    );
    private static _fontSuffices = [Suffix.WOFF2$, Suffix.WOFF$, Suffix.TTF$, Suffix.OTF$, Suffix.EOT$];
    private static _textViewerSuffices = [Suffix.TXT$, Suffix.JSON$, Suffix.XML$];
    private static _imageSuffices = Object.keys(MimeUtil._mimeBySuffix).filter(lcsuffix => MimeUtil.isImageLcSuffix_(lcsuffix));
    private static _writableImageSuffices = [Suffix.JPG$, Suffix.PNG$];
    private static _lossyImageSuffices = [Suffix.JPG$, Suffix.JPEG$];
    private static _audioPlaybackSuffices = [Suffix.M4A$, Suffix.MP3$, Suffix.WAV$, Suffix.OGG$, Suffix.FLAC$, Suffix.AWB$,
    ];
    private static _videoPlaybackSuffices = [Suffix.MP4$, Suffix.MOV$, Suffix.WEBM$];
    private static _defaultWritableImageFormat = Suffix.JPG$;
    static get defaultWritableImageFormat$() { return this._defaultWritableImageFormat; }
    private static _supportPdfConversion = false;
    static get supportPdfConversion$() { return this._supportPdfConversion; }

    static configExtraDesktopImageFormats_(supported: boolean) {
        this._supportPdfConversion = supported;
        if (supported) {
            this._defaultWritableImageFormat = Suffix.WEBP$;
            this._mimeBySuffix[Suffix.WEBP$] = Mime.WEBP$;
            this._mimeBySuffix[Suffix.HEIC$] = Mime.HEIC$;
            this._suffixByMime[Mime.WEBP$] = Suffix.WEBP$;
            this._suffixByMime[Mime.HEIC$] = Suffix.HEIC$;
            this._imageSuffices.push(Suffix.WEBP$);
            this._imageSuffices.push(Suffix.HEIC$);
            this._writableImageSuffices.push(Suffix.WEBP$);
            this._lossyImageSuffices.push(Suffix.WEBP$);
            this._lossyImageSuffices.push(Suffix.HEIC$);
        } else if (!supported) {
            this._defaultWritableImageFormat = Suffix.JPG$;
            delete this._mimeBySuffix[Suffix.WEBP$];
            delete this._mimeBySuffix[Suffix.HEIC$];
            delete this._suffixByMime[Mime.WEBP$];
            delete this._suffixByMime[Mime.HEIC$];
            ArrayUt.delete_(this._imageSuffices, Suffix.WEBP$);
            ArrayUt.delete_(this._imageSuffices, Suffix.HEIC$);
            ArrayUt.delete_(this._writableImageSuffices, Suffix.WEBP$);
            ArrayUt.delete_(this._lossyImageSuffices, Suffix.WEBP$);
            ArrayUt.delete_(this._lossyImageSuffices, Suffix.HEIC$);
        }
    }

    static mimeFromPath_(path: stringX): stringX {
        if (path == null) return null;
        return this._mimeBySuffix[Basepath.lcSuffix_(path)];
    }

    static mimeFromLcSuffix_(lcsuffix: string): stringX {
        return this._mimeBySuffix[lcsuffix];
    }

    static suffixFromMime_(mime: stringX): stringX {
        if (mime == null) return null;
        return this._suffixByMime[mime];
    }

    static isImageLcSuffix_(lcsuffix: string): boolean {
        return this._mimeBySuffix[lcsuffix]?.startsWith("image/") == true;
    }

    static isAudioLcSuffix_(lcsuffix: string): boolean {
        return this._mimeBySuffix[lcsuffix]?.startsWith("audio/") == true;
    }

    static isVideoLcSuffix_(lcsuffix: string): boolean {
        return this._mimeBySuffix[lcsuffix]?.startsWith("video/") == true;
    }

    static isMediaLcSuffix_(lcsuffix: string): boolean {
        if (lcsuffix == Suffix.PDF$) return true;
        const mime = this._mimeBySuffix[lcsuffix];
        if (mime == null) return false;
        return mime.startsWith("image/") || mime.startsWith("audio/") || mime.startsWith("video/");
    }

    static isTextViewerLcSuffix_(lcsuffix: string): boolean {
        return this._textViewerSuffices.includes(lcsuffix);
    }

    /// Files that can be viewed through a viewer, including text, pdf, image, audio and video, that should be reference with ?view.
    static isViewerLcSuffix_(lcsuffix: string): boolean {
        return this.isTextViewerLcSuffix_(lcsuffix) || this.isMediaLcSuffix_(lcsuffix);
    }

    static isFontLcSuffix_(lcsuffix: string): boolean {
        return this._fontSuffices.includes(lcsuffix);
    }

    static isSeekableLcSuffix_(lcsuffix: string): boolean {
        return this.isAudioLcSuffix_(lcsuffix) || this.isVideoLcSuffix_(lcsuffix) || lcsuffix == Suffix.BACKUP$ || lcsuffix == Suffix.IBACKUP$;
    }

    static imageMimeFromLcSuffix_(lcsuffix: string): stringX {
        const mime = this._mimeBySuffix[lcsuffix];
        if (mime == null) return null;
        return (mime.startsWith("image/")) ? mime : null;
    }

    static audioMimeFromLcSuffix_(lcsuffix: string): stringX {
        const mime = this._mimeBySuffix[lcsuffix];
        if (mime == null) null;
        return (mime.startsWith("audio/")) ? mime : null;
    }

    static videoMimeFromLcSuffix_(lcsuffix: string): stringX {
        const mime = this._mimeBySuffix[lcsuffix];
        if (mime == null) return null;
        return (mime.startsWith("video/")) ? mime : null;
    }

    static fontMimeFromLcSuffix_(lcsuffix: string): stringX {
        return (this._fontSuffices.includes(lcsuffix)) ? this._mimeBySuffix[lcsuffix] : null;
    }

    static imageMimeFromPath_(path: string): stringX {
        return this.imageMimeFromLcSuffix_(Basepath.lcSuffix_(path));
    }

    static imageSuffixFromMime_(mime: string): stringX {
        if (!mime.startsWith("image/")) return null;
        return this._suffixByMime[mime];
    }

    static audioRecordingSuffix_(): string {
        return Suffix.M4A$;
    }

    static videoRecordingSuffix_(): string {
        return Suffix.MP4$;
    }

    static isBackupLcSuffix_(lcsuffix: string): boolean {
        return lcsuffix == Suffix.IBACKUP$ || lcsuffix == Suffix.BACKUP$ || lcsuffix == Suffix.ZIP$;
    }

    static isWritableImageLcSuffix_(lcsuffix: string): boolean {
        return this._writableImageSuffices.includes(lcsuffix);
    }

    static isBackupKeyLcSuffix_(lcsuffix: string): boolean {
        return lcsuffix == Suffix.PEM$ || lcsuffix == Suffix.DER$ || this._writableImageSuffices.includes(lcsuffix);
    }

    static isLossyImageLcSuffix_(lcsuffix: string): boolean {
        return this._lossyImageSuffices.includes(lcsuffix);
    }

    static imageSuffices_(): string[] {
        return [...this._imageSuffices];
    }

    static writableImageSuffices_(): string[] {
        return [...this._writableImageSuffices];
    }

    static audioPlaybackSuffices_(): string[] {
        return [...this._audioPlaybackSuffices];
    }

    static videoPlaybackSuffices_(): string[] {
        return [...this._videoPlaybackSuffices];
    }

    static isImportableLcSuffix_(lcsuffix: string): boolean {
        return this._mimeBySuffix[lcsuffix] != null;
    }

    static importableSuffices_(): string[] {
        return Object.keys(this._mimeBySuffix);
    }

    static isImageDataUrl_(href: string): boolean {
        return An.dataUrlMime_(href)?.startsWith("image/") ?? false;
    }

    static fontFaceFormat_(lcsuffix: string): stringX {
        if (Suffix.WOFF$ == lcsuffix) {
            return Fontface.WOFF$;
        } else if (Suffix.WOFF2$ == lcsuffix) {
            return Fontface.WOFF2$;
        } else if (Suffix.TTF$ == lcsuffix || Suffix.OTF$ == lcsuffix) {
            return Fontface.OPENTYPE$;
        } else if (Suffix.EOT$ == lcsuffix) {
            return Fontface.EOT$;
        } else if (Suffix.SVG$ == lcsuffix || Suffix.SVGZ$ == lcsuffix) {
            return Fontface.SVG$;
        }
        return null;
    }

}

class MediaUtil {
    static thumbnailPath_(basepath: Basepath, width: number, height: number): string {
        if (width == 0 || height == 0) return basepath.toString();
        return basepath.changeStem_(basepath.stem$ + `- tn${width}x${height}`).path$;
    }

    /// Fit rectangle srcwidth x srcheight into a dstwidth x dstheight rectangle, keeping aspect ratios.
    static fit_(srcwidth: number, srcheight: number, dstwidth: number, dstheight: number): Point<number> {
        if (srcwidth == 0 || srcheight == 0) return new Point(0, 0);
        let width: number;
        let height: number;
        let srcratio = (srcwidth * 1.0 / srcheight);
        let dstratio = (dstwidth * 1.0 / dstheight);
        if (srcratio >= dstratio) {
            width = dstwidth;
            height = Math.floor(srcheight * dstwidth / srcwidth);
        } else {
            height = dstheight;
            width = Math.floor(srcwidth * dstheight / srcheight);
        }
        return new Point(width, height);
    }

    /// Zoom to fit srcwidth to dstwidth, keeping aspect ratios.
    static fitWidth_(srcwidth: number, srcheight: number, dstwidth: number): Point<number> {
        if (srcwidth == 0 || srcheight == 0) return new Point(0, 0);
        return new Point(dstwidth, Math.floor(srcheight * dstwidth / srcwidth));
    }

    /// Zoom to fit srcheight to dstheight, keeping aspect ratios.
    static fitHeight(srcwidth: number, srcheight: number, dstheight: number): Point<number> {
        if (srcwidth == 0 || srcheight == 0) return new Point(0, 0);
        return new Point(Math.floor(srcwidth * dstheight / srcheight), dstheight);
    }

    /// Zoom to fit the smaller of srcwidth or srcheight to dst, keeping aspect ratios.
    static fitMinor_(srcwidth: number, srcheight: number, dstwidth: number, dstheight: number): Point<number> {
        if (srcwidth == 0 || srcheight == 0) return new Point(0, 0);
        return srcwidth / dstwidth <= srcheight / dstheight ? this.fitWidth_(srcwidth, srcheight, dstwidth)
            : this.fitHeight(srcwidth, srcheight, dstheight);
    }

    static zoomOf_(fit: Point<number>, width: number, height: number): number {
        return fit.x > fit.y ? fit.x / width : fit.y / height;
    }

    static zoomOf2_(owidth: number, oheight: number, width: number, height: number): number {
        return owidth > oheight ? width / owidth : height / oheight;
    }

    static limitImageArea_(width: number, height: number,
        maxarea: number = DEF.maxOutputImageArea): Point<number> {
        let area = width * height;
        if (area > maxarea) {
            let scale = Math.sqrt(maxarea * 1.0 / area);
            if (width > height) {
                width = Math.floor(width * scale);
                width = width - (width % DEF.imageDimensionSnap);
                height = maxarea / width;
            } else {
                height = Math.floor(height * scale);
                height = height - (height % DEF.imageDimensionSnap);
                width = maxarea / height;
            }
        }
        return new Point(width, height);
    }

    static limitImageDimensionAndArea_(
        width: number, height: number, maxdim: number, maxarea: number = DEF.maxOutputImageArea): Point<number> {
        if (maxdim != null && maxdim > 0 && (width > maxdim || height > maxdim)) {
            let dim = MediaUtil.fit_(width, height, maxdim, maxdim);
            width = dim.x;
            height = dim.y;
        }
        return MediaUtil.limitImageArea_(width, height, maxarea);
    }

    static optionalDimensionPx_(w: string, h: string, defw: number, defh: number): Point<number> | null {
        let x = (w.length == 0 ? null : An.parseIntPx_(w, -1));
        let y = (h.length == 0 ? null : An.parseIntPx_(h, -1));
        if ((x != null && x <= 0) || (y != null && y <= 0)) {
            return null;
        }
        return MediaUtil.optionalDimension1_(x, y, defw, defh);
    }

    static optionalDimension_(w: string, h: string, defw: number, defh: number): Point<number> | null {
        let x = (w.length == 0 ? null : An.parseInt_(w, -1));
        let y = (h.length == 0 ? null : An.parseInt_(h, -1));
        if ((x != null && x <= 0) || (y != null && y <= 0)) {
            return null;
        }
        return MediaUtil.optionalDimension1_(x, y, defw, defh);
    }

    static optionalDimension0_(x: numberX, y: numberX, defw: number, defh: number): Point<number> {
        if (x != null && x <= 0) x = null;
        if (y != null && y <= 0) y = null;
        return MediaUtil.optionalDimension1_(x, y, defw, defh);
    }

    /**
       * Determine a dimension wxh.
       * If both w and h are not null, return (w, h).
       * If both w and h are null, return (defw, defh).
       * otherwise calculate the null value from aspect ratio of defw/defh.
       */
    static optionalDimension1_(x: numberX, y: numberX, defw: number, defh: number): Point<number> {
        if (x == null) {
            if (y == null) {
                x = defw;
                y = defh;
            } else {
                x = Math.round(y * 1.0 * (defw / defh));
            }
        } else if (y == null) {
            y = Math.round(x * 1.0 * (defh / defw));
        }
        return new Point(x, y);
    }

    static greaterOfWidthOrHeight_(w: number, h: number): [string, string] {
        if (w >= h) {
            return [`${w}`, ""];
        }
        return ["", `${h}`];
    }

    static isInvalidDimension_(width: numberX, height: numberX): boolean {
        return width == null || height == null || width <= 0 || height <= 0;
    }
}

class FileInfoKey {
    static readonly _checksum = "cs";
    static readonly _lastUsed = "lu";
    static readonly _name = "nm";
    static readonly _isdir = "id";
    static readonly _notexists = "ne";
    static readonly _cpath = "cp";
    static readonly _dir = "di";
    static readonly _rpath = "rp";
    static readonly _supportHistory = "hh";
    static readonly _state = "st";
    static readonly _isroot = "ir";
    static readonly _length = "sz";
    static readonly _perm = "pm";
    static readonly _notwritable = "nw";
    static readonly _isfile = "if";
    static readonly _isDeleted = "ds";
    static readonly _files = "fs";
    static readonly _notreadable = "nr";
    static readonly _flag = "fl";
    static readonly _offset = "of";
    static readonly _lastDeleted = "dl";
    static readonly _lastModified = "dt";
    static readonly _id = "dd";
}

class SymbolInfoKey {
    static readonly name$ = "n";
    static readonly text = "t";
    static readonly family = "f";
}

class FileStat {
    static readonly SIZEUNIT_EMPTY: string =
        "\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0";
    static readonly SIZEUNIT_DIR: string =
        "\u00a0\u00a0\u00a0\u00a0\u2022\u2022\u2022";
    static readonly _SIZEUNIT0 = "\u00a0\u00a0\u00a0\u00a00\u00a0B";
    static readonly _PADDING: string[] = [
        "\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0",
        "\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0",
        "\u00a0\u00a0\u00a0\u00a0\u00a0",
        "\u00a0\u00a0\u00a0\u00a0",
        "\u00a0\u00a0\u00a0",
        "\u00a0\u00a0",
        "\u00a0",
    ];

    protected constructor(protected info$: JSONObject) { }

    static arrayOf_(infos: ArrayXX<JSONObject>): FileStat[] | null {
        if (infos === null || infos === undefined) { return null; }
        return infos.map(value => new FileStat(value));
    }

    static of_(info: StringMapXX<any>): FileStat | null {
        if (info === null || info === undefined) { return null; }
        return new FileStat(info);
    }

    protected _istrue(key: string): boolean {
        return true == this.info$[key];
    }

    get isdir$(): boolean {
        return this._istrue(FileInfoKey._isdir);
    }

    get isfile$(): boolean {
        return this.exists$ && !this.isdir$;
    }

    get exists$(): boolean {
        return !this.notexists$;
    }

    get notexists$(): boolean {
        return this._istrue(FileInfoKey._notexists);
    }

    get readable$(): boolean {
        return this.exists$ && !this._istrue(FileInfoKey._notreadable);
    }

    get writable$(): boolean {
        return this.exists$ && !this._istrue(FileInfoKey._notwritable);
    }

    get perm$(): string {
        return this._perm();
    }

    get sizeunit$(): string {
        return FileInfo._sizeunit7(this.info$[FileInfoKey._length]);
    }

    get date$(): number {
        return this.info$[FileInfoKey._lastModified] ?? 0;
    }

    get size$(): number {
        return this.info$[FileInfoKey._length] ?? 0;
    }

    get state$(): JSONObjectX {
        return this.info$[FileInfoKey._state] ?? null;
    }

    get flag$(): boolean {
        return this._istrue(FileInfoKey._flag);
    }

    get files$(): JSONObjectX {
        return this.info$[FileInfoKey._files] ?? null;
    }

    get checksum$(): stringX {
        return this.info$[FileInfoKey._checksum] ?? null;
    }

    private _perm(): string {
        return (this.readable$ ? "r" : "-") + (this.writable$ ? "w" : "-");
    }

    static _padleft7(s: string): string {
        const len = s.length;
        if (len >= 7) {
            return s;
        }
        return FileInfo._PADDING[len] + s;
    }

    /// A customized version of AnUt.sizeunit().
    static _sizeunit7(value: numberX): string {
        if (value == null || value == 0) {
            return FileInfo._SIZEUNIT0;
        }
        return FileStat._padleft7(An.filesizeUnit4_(value));
    }
}

class FileInfo extends FileStat {
    static NOT_EXISTS = new FileInfo(json_(
        [FileInfoKey._name, "~NOTEXISTS~"],
        [FileInfoKey._notexists, true],
        [FileInfoKey._perm, "   "],
        [FileInfoKey._length, 0],
        [FileInfoKey._lastModified, ""],
    ));

    protected constructor(info: JSONObject) { super(info); }

    static arrayOf_(infos: ArrayXX<JSONObject>): FileInfo[] | null {
        if (infos === null || infos === undefined) { return null; }
        return infos.map(value => new FileInfo(value));
    }

    static of_(info: StringMapXX<any>): FileInfo | null {
        if (info === null || info === undefined) { return null; }
        return new FileInfo(info);
    }

    get writableFileOrNotExists$(): boolean {
        return this.notexists$ || (this.writable$ && !this.isdir$);
    }

    get writableDirOrNotExists$(): boolean {
        return this.notexists$ || (this.writable$ && this.isdir$);
    }

    get name$(): string {
        return this.info$[FileInfoKey._name] ?? "";
    }

    get supportHistory$(): boolean {
        return this.info$[FileInfoKey._supportHistory];
    }
}

class DeletedFileStat extends FileInfo {
    private constructor(info: JSONObject) {
        super(info);
    }

    static arrayOf_(infos: ArrayXX<JSONObject>): DeletedFileStat[] | null {
        if (infos === null || infos === undefined) { return null; }
        return infos.map(value => new DeletedFileStat(value));
    }

    static of_(info: StringMapXX<any>): DeletedFileStat | null {
        if (info === null || info === undefined) { return null; }
        return new DeletedFileStat(info);
    }

    id_(): Long {
        return this.info$[FileInfoKey._id];
    }
    dir_(): string {
        return this.info$[FileInfoKey._dir];
    }
    lastDeleted_(): Long {
        return this.info$[FileInfoKey._lastDeleted];
    }
    toJSON_(): JSONObject {
        return this.info$;
    }
    toJSONString_(): string {
        return JSON.stringify(this.info$);
    }
}

interface IFileinfoUtil extends IFilepickerHandler {
    fileInfo1_(warner: IWarner, path: string, callback: FileInfoCallback): void;
    fileinfo2_(cpath: string, onerror: TestResultCallback, onok: FileInfoCallback): void;
    dirAndFileInfo_(cpath: string, onerror: TestResultCallback, onok: Fun20<FileInfo, FileInfo>): void;
    checkDirWritable2_(dir: string, onerror: TestResultCallback, onok: FileInfoCallback): void;
    checkFileWritable2_(path: string, onerror: TestResultCallback, onok: FileInfoCallback): void;
}

class FileInfoUtil implements IFilepickerHandler, IFileinfoUtil {

    constructor(private handler: IFilepickerHandler) { }

    fileInfo_(path: string, callback: JSONCallback): void {
        this.handler.fileInfo_(path, callback);
    }

    listDir_(path: string, callback: JSONCallback): void {
        this.handler.listDir_(path, callback);
    }

    mkDirs_(path: string, callback: JSONCallback): void {
        this.handler.mkDirs_(path, callback);
    }

    delete_(path: string, callback: JSONCallback): void {
        this.handler.delete_(path, callback);
    }

    shred_(dir: string, rpaths: string[], callback: JSONCallback): void {
        this.handler.shred_(dir, rpaths, callback);
    }

    deleteAll_(srcpath: string, rpaths: string[], callback: JSONCallback): void {
        this.handler.deleteAll_(srcpath, rpaths, callback);
    }

    deleteInfo_(path: string, callback: JSONCallback): void {
        this.handler.deleteInfo_(path, callback);
    }

    rename_(fromcpath: string, newname: string, fixxrefs: boolean, callback: JSONCallback): void {
        this.handler.rename_(fromcpath, newname, fixxrefs, callback);
    }

    copy_(
        cut: boolean,
        preservetimestamp: boolean,
        fixxrefs: boolean,
        dst: string,
        src: string,
        rpaths: string[] | null,
        callback: JSONCallback
    ): void {
        this.handler.copy_(cut, preservetimestamp, fixxrefs, dst, src, rpaths, callback);
    }

    copyInfo_(cut: boolean, dst: string, src: string, callback: JSONCallback): void {
        this.handler.copyInfo_(cut, dst, src, callback);
    }

    deleteDirSubtree_(path: string, callback: JSONCallback): void {
        this.handler.deleteDirSubtree_(path, callback);
    }

    localImageInfos_(path: string, callback: JSONCallback): void {
        this.handler.localImageInfos_(path, callback);
    }

    localImageThumbnails_(size: Int, quality: Int, infos: (JSONObjectX)[], callback: JSONCallback): void {
        this.handler.localImageThumbnails_(size, quality, infos, callback);
    }

    deleteEmptyDirs_(path: string, callback: JSONCallback): void {
        this.handler.deleteEmptyDirs_(path, callback);
    }

    listRecursive_(params: JSONObject, callback: JSONCallback): void {
        this.handler.listRecursive_(params, callback);
    }

    fileInfos_(dir: string, rpaths: string[], callback: JSONCallback): void {
        this.handler.fileInfos_(dir, rpaths, callback);
    }

    dirInfo_(cpath: string, callback: JSONCallback): void {
        this.handler.dirInfo_(cpath, callback);
    }

    mkparent_(path: string, callback: Fun00): void {
        const dir = Basepath.dir_(path);
        if (dir == null || dir.length == 0) {
            callback();
        } else {
            this.mkDirs_(dir, callback);
        }
    }

    fileinfo2_(cpath: stringX, onerror: TestResultCallback, onok: FileInfoCallback) {
        if (cpath == null) {
            onerror(MSG.string_(RS.InvalidPath));
            return;
        }
        this.handler.fileInfo_(cpath, (ret) => {
            const msg = An.result_(ret);
            if (msg != null) {
                onerror(msg);
                return;
            }
            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
            if (fileinfo == null) {
                onerror(MSG.string_(RS.InvalidPath));
                return;
            }
            onok(fileinfo);
        });
    }

    /// @param callback(fileinfo) Show an warning and do not call callback on error.
    fileInfo1_(warner: IWarner, cpath: string, callback: FileInfoCallback): void {
        this.fileinfo2_(cpath, (msg) => {
            warner.warn_(msg);
        }, callback);
    }

    dirAndFileInfo_(cpath: string, onerror: TestResultCallback, onok: Fun20<FileInfo, FileInfo>): void {
        this.fileinfo2_(Basepath.dir_(cpath), onerror, (dirinfo) => {
            this.fileinfo2_(cpath, onerror, (fileinfo) => {
                onok(dirinfo, fileinfo);
            });
        });
    }

    checkDirWritable2_(dir: stringX, onerror: TestResultCallback, onok: FileInfoCallback): void {
        this.fileinfo2_(dir, onerror, (dirinfo) => {
            if (!dirinfo.isdir$ || !dirinfo.writable$) {
                onerror(MSG.string1_(RS.DestinationNotWritable_, dir ?? ""));
                return;
            }
            onok(dirinfo);
        });
    }

    /// Check that given path is in a writable directory and, if exists, is writable file.
    /// @param error(Object msg) This is only called when there are errors or file exists but not a writable file.
    /// @param ok(fileinfo) This is only called if file not exists or file is a writable file.
    /// @return FileInfo of file at path.
    checkFileWritable2_(path: string, onerror: TestResultCallback, onok: FileInfoCallback): void {
        this.checkDirWritable2_(Basepath.dir_(path), onerror, (_dirinfo) => {
            this.fileinfo2_(path, onerror, (fileinfo) => {
                if (!fileinfo.writableFileOrNotExists$) {
                    onerror(MSG.string1_(RS.DestinationNotWritable_, path));
                    return;
                }
                onok(fileinfo);
            });
        });
    }

}

class StyleInfo {
    constructor(private info$: JSONObject) { }
    get group$(): string {
        return this.info$[StyleKey.group];
    }
    get label$(): string {
        return this.info$[StyleKey.label];
    }
    get name$(): string {
        return this.info$[StyleKey.name$];
    }
}

class FontInfo {
    constructor(private info$: JSONObject) { }

    get fontname$(): string {
        return this.info$[FontInfoKey.fontname];
    }

    get url$(): string {
        return this.info$[FontInfoKey.url];
    }

    get fontfaceformat$(): string {
        return this.info$[FontInfoKey.fontfaceformat];
    }

    get size$(): number {
        return this.info$[FontInfoKey.size];
    }

    get license$(): string {
        return this.info$[FontInfoKey.license];
    }

    get category$(): string {
        return this.info$[FontInfoKey.category];
    }

    get subsets$(): string[] {
        return this.info$[FontInfoKey.subsets];
    }

    get glyphcount$(): number {
        return this.info$[FontInfoKey.glyphcount];
    }

    get glyphs$(): any[] {
        return this.info$[FontInfoKey.glyphs];
    }

    get glyphnames$(): string[] {
        return this.info$[FontInfoKey.glyphnames];
    }

    get styles$(): string[] {
        return this.info$[FontInfoKey.styles];
    }
}

let _MONTH_ARRAY = MSG.stringArray_(RS.Months);

let _MONTHS = new Map<string, string>([
    ["01", _MONTH_ARRAY[0]],
    ["02", _MONTH_ARRAY[1]],
    ["03", _MONTH_ARRAY[2]],
    ["04", _MONTH_ARRAY[3]],
    ["05", _MONTH_ARRAY[4]],
    ["06", _MONTH_ARRAY[5]],
    ["07", _MONTH_ARRAY[6]],
    ["08", _MONTH_ARRAY[7]],
    ["09", _MONTH_ARRAY[8]],
    ["10", _MONTH_ARRAY[9]],
    ["11", _MONTH_ARRAY[10]],
    ["12", _MONTH_ARRAY[11]],
]);

class DateFormat {
    static readonly DEF = "mm/dd/yyyy";
    static readonly SIMPLE = "yyyymmdd";
    static readonly SETTINGS_LIST: string[] = [
        "mm/dd/yyyy",
        "dd/mm/yyyy",
        "yyyy/mm/dd",
        "yyyy/dd/mm",
        "mm-dd-yyyy",
        "dd-mm-yyyy",
        "yyyy-mm-dd",
        "yyyy-dd-mm",
        "mm.dd.yyyy",
        "dd.mm.yyyy",
        "yyyy.mm.dd",
        "yyyy.dd.mm",
        "mmddyyyy",
        "ddmmyyyy",
        "yyyymmdd",
        "yyyyddmm",
    ];
    static _shortFormats = new Map<string, string>([
        ["mm/dd/yyyy", "mm/dd"],
        ["dd/mm/yyyy", "dd/mm"],
        ["yyyy/mm/dd", "mm/dd"],
        ["yyyy/dd/mm", "dd/mm"],
        ["dd-mm-yyyy", "dd-mm"],
        ["mm-dd-yyyy", "mm-dd"],
        ["yyyy-dd-mm", "dd-mm"],
        ["yyyy-mm-dd", "mm-dd"],
        ["dd.mm.yyyy", "dd.mm"],
        ["mm.dd.yyyy", "mm.dd"],
        ["yyyy.dd.mm", "dd.mm"],
        ["yyyy.mm.dd", "mm.dd"],
        ["ddmmyyyy", "ddmm"],
        ["mmddyyyy", "mmdd"],
        ["yyyyddmm", "ddmm"],
        ["yyyymmdd", "mmdd"],
    ]);
    static _monthFormats = new Map<string, string>([
        ["mm/dd/yyyy", "mm/yyyy"],
        ["dd/mm/yyyy", "mm/yyyy"],
        ["yyyy/mm/dd", "yyyy/mm"],
        ["yyyy/dd/mm", "yyyy/mm"],
        ["dd-mm-yyyy", "mm-yyyy"],
        ["mm-dd-yyyy", "mm-yyyy"],
        ["yyyy-dd-mm", "yyyy-mm"],
        ["yyyy-mm-dd", "yyyy-mm"],
        ["dd.mm.yyyy", "mm.yyyy"],
        ["mm.dd.yyyy", "mm.yyyy"],
        ["yyyy.dd.mm", "yyyy.mm"],
        ["yyyy.mm.dd", "yyyy.mm"],
        ["ddmmyyyy", "mmyyyy"],
        ["mmddyyyy", "mmyyyy"],
        ["yyyyddmm", "yyyymm"],
        ["yyyymmdd", "yyyymm"],
    ]);

        private static _formatters
        = new Map<string, DateFormatter>([
            ["mm/dd/yyyy", (year: string, month: string, day: string) => {
                return `${month}/${day}/${year}`;
            }],
            ["mm/yyyy", (year: string, month: string, _day: string) => {
                return `${month}/${year}`;
            }],
            ["yyyy/mm/dd", (year: string, month: string, day: string) => {
                return `${year}/${month}/${day}`;
            }],
            ["yyyy/mm", (year: string, month: string, _day: string) => {
                return `${year}/${month}`;
            }],
            ["mm/dd", (_year: string, month: string, day: string) => {
                return `${month}/${day}`;
            }],
            ["dd/mm/yyyy", (year: string, month: string, day: string) => {
                return `${day}/${month}/${year}`;
            }],
            ["dd/mm", (_year: string, month: string, day: string) => {
                return `${day}/${month}`;
            }],
            ["yyyy/dd/mm", (year: string, month: string, day: string) => {
                return `${year}/${day}/${month}`;
            }],
            ["dd-mm-yyyy", (year: string, month: string, day: string) => {
                return `${day}-${month}-${year}`;
            }],
            ["mm-yyyy", (year: string, month: string, _day: string) => {
                return `${month}-${year}`;
            }],
            ["yyyy-mm-dd", (year: string, month: string, day: string) => {
                return `${year}-${month}-${day}`;
            }],
            ["yyyy-mm", (year: string, month: string, _day: string) => {
                return `${year}-${month}`;
            }],
            ["dd-mm", (_year: string, month: string, day: string) => {
                return `${day}-${month}`;
            }],
            ["mm-dd-yyyy", (year: string, month: string, day: string) => {
                return `${month}-${day}-${year}`;
            }],
            ["mm-dd", (_year: string, month: string, day: string) => {
                return `${month}-${day}`;
            }],
            ["yyyy-dd-mm", (year: string, month: string, day: string) => {
                return `${year}-${day}-${month}`;
            }],
            ["dd.mm.yyyy", (year: string, month: string, day: string) => {
                return `${day}.${month}.${year}`;
            }],
            ["mm.yyyy", (year: string, month: string, _day: string) => {
                return `${month}.${year}`;
            }],
            ["yyyy.mm.dd", (year: string, month: string, day: string) => {
                return `${year}.${month}.${day}`;
            }],
            ["yyyy.mm", (year: string, month: string, _day: string) => {
                return `${year}.${month}`;
            }],
            ["dd.mm", (_year: string, month: string, day: string) => {
                return `${day}.${month}`;
            }],
            ["mm.dd.yyyy", (year: string, month: string, day: string) => {
                return `${month}.${day}.${year}`;
            }],
            ["mm.dd", (_year: string, month: string, day: string) => {
                return `${month}.${day}`;
            }],
            ["yyyy.dd.mm", (year: string, month: string, day: string) => {
                return `${year}.${day}.${month}`;
            }],
            ["mmm dd yyyy", (year: string, month: string, day: string) => {
                return `${_MONTHS.get(month) ?? "???"} ${day} ${year}`;
            }],
            ["dd mmm yyyy", (year: string, month: string, day: string) => {
                return `${day} ${_MONTHS.get(month) ?? "???"} ${year}`;
            }],
            ["mmm yyyy", (year: string, month: string, _day: string) => {
                return `${_MONTHS.get(month) ?? "???"} ${year}`;
            }],
            ["yyyy mmm dd", (year: string, month: string, day: string) => {
                return `${year} ${_MONTHS.get(month) ?? "???"} ${day}`;
            }],
            ["yyyy mmm", (year: string, month: string, _day: string) => {
                return `${year} ${_MONTHS.get(month) ?? "???"}`;
            }],
            ["mmm dd", (_year: string, month: string, day: string) => {
                return `${_MONTHS.get(month) ?? "???"} ${day}`;
            }],
            ["dd mmm", (_year: string, month: string, day: string) => {
                return `${day} ${_MONTHS.get(month) ?? "???"}`;
            }],
            ["mmddyyyy", (year: string, month: string, day: string) => {
                return `${month}${day}${year}`;
            }],
            ["ddmmyyyy", (year: string, month: string, day: string) => {
                return `${day}${month}${year}`;
            }],
            ["yyyymmdd", (year: string, month: string, day: string) => {
                return `${year}${month}${day}`;
            }],
            ["yyyyddmm", (year: string, month: string, day: string) => {
                return `${year}${day}${month}`;
            }],
            ["mmyyyy", (year: string, month: string, _day: string) => {
                return `${month}${year}`;
            }],
            ["yyyymm", (year: string, month: string, _day: string) => {
                return `${year}${month}`;
            }],
            ["mmdd", (_year: string, month: string, day: string) => {
                return `${month}${day}`;
            }],
            ["ddmm", (_year: string, month: string, day: string) => {
                return `${day}${month}`;
            }],
            ["yyyy", (year: string, _month: string, _day: string) => {
                return `${year}`;
            }],
            ["mmm", (_year: string, month: string, _day: string) => {
                return _MONTHS.get(month) ?? "???";
            }],
            ["mm", (_year: string, month: string, _day: string) => {
                return `${month}`;
            }],
            ["dd", (_year: string, _month: string, day: string) => {
                return `${day}`;
            }],
            ["", (_year: string, _month: string, _day: string) => {
                return "";
            }],
        ]);

    static formatsOf_(dateformat: string, allowauto: boolean): string[] {
        const fmt = DateFormat.getDateFormatter_(dateformat) != null ? dateformat : DateFormat.DEF;
        return [
            "auto",
            fmt,
            this._monthFormats.get(fmt) ?? "???",
            this._shortFormats.get(fmt) ?? "???",
            "yyyy",
            "mm",
            "mmm",
            "dd",
            ""
        ].filter((value) => value != "???" && (allowauto || value != "auto"));
    }

    static transform_(tofmt: string, fromfmt: string): string {
        if (fromfmt == "auto") return "auto";
        if (DateFormat.getDateFormatter_(fromfmt) == null) return tofmt;
        const hasyear = fromfmt.indexOf("y") >= 0;
        const hasmonth = fromfmt.indexOf("m") >= 0;
        const hasday = fromfmt.indexOf("d") >= 0;
        if (hasyear && !hasmonth && !hasday
            || !hasyear && hasmonth && !hasday
            || !hasyear && !hasmonth && hasday) return fromfmt;
        if (hasyear && hasmonth && !hasday) return DateFormat.monthFormat_(tofmt) ?? tofmt;
        if (!hasyear && hasmonth && hasday) return DateFormat.shortFormat_(tofmt) ?? tofmt;
        return tofmt;
    }

    static validate_(format: string, def: string): string {
        return DateFormat.getDateFormatter_(format) == null ? def : format;
    }

    private static _getdateformatter(format: string): DateFormatter | null {
        return DateFormat._formatters.get(format) ?? null;
    }

    /// @param mdate File modified date, ms since epoch.
    static dateStringFromMs_(dateformat: string, mdate: number): string {
        return (mdate == null
            ? "\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0"
            : DateFormat.dateString_(
                dateformat, DateTime.fromMs_(mdate)));
    }

    /// @return A date string, not including time, according to the dateformat.
    static dateString_(dateformat: string, date: DateTime): string {
        if (dateformat == "auto") return An.autoDateString_(DateTime.now_(), date);
        return DateFormat.format_(DateFormat.getDateFormatter_(dateformat), date);
    }

    static format_(formatter: DateFormatter, date: DateTime): string {
        let year = An.to04d_(date.year$);
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        return formatter(year, month, day);
    }

    static getDateFormatter_(dateformat: string): DateFormatter {
        let formatter: DateFormatter | null = null;
        if (dateformat != null) {
            formatter = DateFormat._getdateformatter(dateformat);
        }
        if (formatter == null) {
            
            formatter = DateFormat._getdateformatter(DateFormat.DEF)!;
        }
        return formatter;
    }

    static getShortFormatter_(dateformat: string): DateFormatter {
        let formatter: DateFormatter | null = null;
        if (dateformat != null) {
            formatter = DateFormat._short(dateformat);
        }
        if (formatter == null) {
            
            formatter = DateFormat._short(DateFormat.DEF)!;
        }
        return formatter;
    }

    static getMonthFormatter_(dateformat: string): DateFormatter {
        let formatter: DateFormatter | null = null;
        if (dateformat != null) {
            formatter = DateFormat._month(dateformat);
        }
        if (formatter == null) {
            
            formatter = DateFormat._month(DateFormat.DEF)!;
        }
        return formatter;
    }

    static shortFormat_(format: string): stringX {
        return DateFormat._shortFormats.get(format) ?? null;
    }

    static monthFormat_(format: string): stringX {
        return DateFormat._monthFormats.get(format) ?? null;
    }

    private static _short(format: string): DateFormatter | null {
        let shortformat = DateFormat.shortFormat_(format);
        return shortformat == null ? null : DateFormat.getDateFormatter_(shortformat);
    }

    private static _month(format: string): DateFormatter | null {
        let monthformat = DateFormat.monthFormat_(format);
        return monthformat == null ? null : DateFormat.getDateFormatter_(monthformat);
    }
}

class AutoDateFormatter {
    private readonly now: DateTime;
    private readonly lastyear: DateTime;
    private readonly yesterday: DateTime;

    constructor() {
        const now = DateTime.now_();
        this.now = now;
        this.lastyear = DateTime.local_(this.now.year$ - 1, now.month$, now.day$, now.hour$, now.minute$, now.second$);
        this.yesterday = DateTime.fromMs_(now.millisecondsSinceEpoch$ - 23 * DateTime.HOUR);
    }

    format(ms: Long): string {
        return An.autoFileDatetimeString2_(this.lastyear, this.yesterday, this.now, DateTime.fromMs_(ms));
    }
}

class TimeFormat {
    static readonly AM: string = MSG.string_(RS.AM);
    static readonly PM: string = MSG.string_(RS.PM);
    static readonly HH_MM = "hh:mm";
    static readonly HH = "hh";
    static readonly HH_MM_AP = "hh:mm+M";
    static readonly HH_AP = "hh+M";
    static readonly AP_HH_MM = "M+hh:mm";
    static readonly AP_HH = "M+hh";
    static readonly HHMM = "hhmm";
    static readonly DEF = "hh:mm";
    static readonly SETTINGS_LIST: string[] = [
        TimeFormat.HH_MM,
        TimeFormat.HH_MM_AP,
        TimeFormat.AP_HH_MM,
    ];
    static readonly LIST: string[] = [
        "",
        TimeFormat.HH_MM,
        TimeFormat.HH,
        TimeFormat.HH_MM_AP,
        TimeFormat.HH_AP,
        TimeFormat.AP_HH_MM,
        TimeFormat.AP_HH,
        TimeFormat.HHMM,
    ];
    static _hourFormats = new Map<string, string>([
        ["", ""],
        [TimeFormat.HH_MM, TimeFormat.HH],
        [TimeFormat.HH, TimeFormat.HH],
        [TimeFormat.HH_MM_AP, TimeFormat.HH_AP],
        [TimeFormat.HH_AP, TimeFormat.HH_AP],
        [TimeFormat.AP_HH_MM, TimeFormat.AP_HH],
        [TimeFormat.AP_HH, TimeFormat.AP_HH],
        [TimeFormat.HHMM, TimeFormat.HH],
    ]);
    static _24HoursFormats = new Map<string, string>([
        ["", ""],
        [TimeFormat.HH_MM, TimeFormat.HH_MM],
        [TimeFormat.HH, TimeFormat.HH],
        [TimeFormat.HH_MM_AP, TimeFormat.HH_MM],
        [TimeFormat.HH_AP, TimeFormat.HH],
        [TimeFormat.AP_HH_MM, TimeFormat.HH_MM],
        [TimeFormat.AP_HH, TimeFormat.HH],
        [TimeFormat.HHMM, TimeFormat.HHMM],
    ]);
    static _formatters = new Map<string, TimeFormatter>([
        ["", (_h: number, _m: string, _s: string) => {
            return "";
        }],
        [TimeFormat.HH_MM, (h: number, m: string, _s: string) => {
            return `${An.to02d_(h)}:${m}`;
        }],
        [TimeFormat.HH, (h: number, _m: string, _s: string) => {
            return An.to02d_(h);
        }],
        [TimeFormat.HH_MM_AP, (h: number, m: string, _s: string) => {
            let hh = (h > 12 ? h - 12 : h);
            let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
            return `${hh < 10 ? "\u00a0" : ""}${hh}:${m}\u00a0${pm}`;
        }],
        [TimeFormat.HH_AP, (h: number, _m: string, _s: string) => {
            let hh = (h > 12 ? h - 12 : h);
            let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
            return `${hh < 10 ? "\u00a0" : ""}${hh}\u00a0${pm}`;
        }],
        [TimeFormat.AP_HH_MM, (h: number, m: string, _s: string) => {
            let hh = (h > 12 ? h - 12 : h);
            let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
            return `${pm}\u00a0${hh < 10 ? "\u00a0" : ""}${hh}:${m}`;
        }],
        [TimeFormat.AP_HH, (h: number, _m: string, _s: string) => {
            let hh = (h > 12 ? h - 12 : h);
            let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
            return `${pm}\u00a0${hh < 10 ? "\u00a0" : ""}${hh}`;
        }],
        [TimeFormat.HHMM, (h: number, m: string, _s: string) => {
            return `${An.to02d_(h)}${m}`;
        }],
    ]);

    static formatsOf_(timeformat: string): string[] {
        const fmt = TimeFormat.getFormatter_(timeformat) != null ? timeformat : TimeFormat.DEF;
        return [
            fmt,
            this._hourFormats.get(fmt) ?? "???",
            ""
        ].filter((value) => value != "???");
    }

    static transform_(tofmt: string, fromfmt: string): string {
        if (TimeFormat.getFormatter_(fromfmt) == null) return tofmt;
        const hasmin = fromfmt.indexOf("m") >= 0;
        if (!hasmin) return TimeFormat._hourFormats.get(tofmt) ?? tofmt;
        return tofmt;
    }

    static validate_(format: string, def: string): string {
        return TimeFormat.getFormatter_(format) == null ? def : format;
    }

    static getFormatter_(format: string): TimeFormatter | null {
        return format == null ? null : (TimeFormat._formatters.get(format) ?? null);
    }

    static get24HoursFormat_(format: string): string {
        return TimeFormat._24HoursFormats.get(format) ?? TimeFormat.DEF;
    }

    static timeString_(format: string, time: DateTime): string {
        let f = TimeFormat.getFormatter_(format);
        if (f == null) {
            
            f = TimeFormat._formatters.get(TimeFormat.DEF)!;
        }
        return TimeFormat.format_(f, time);
    }

    static format_(formatter: TimeFormatter, time: DateTime): string {
        return formatter(time.hour$, An.to02d_(time.minute$), An.to02d_(time.second$));
    }

    static longString_(format: string, time: DateTime): string {
        const h = time.hour$;
        const m = An.to02d_(time.minute$);
        const s = An.to02d_(time.second$);
        switch (format) {
            case "": return "";
            case TimeFormat.HH_MM_AP: {
                let hh = h > 12 ? h - 12 : h;
                let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
                return `${hh < 10 ? "\u00a0" : ""}${hh}:${m}:${s}\u00a0${pm}`;
            }
            case TimeFormat.AP_HH_MM: {
                let hh = h > 12 ? h - 12 : h;
                let pm = (h >= 12 ? TimeFormat.PM : TimeFormat.AM);
                return `${pm}\u00a0${hh < 10 ? "\u00a0" : ""}${hh}:${m}:${s}`;
            }
            case TimeFormat.HH_MM:
            default: return `${An.to02d_(h)}:${m}:${s}`;
        }
    }

    static hourString_(format: string, h: Int): string {
        const f = TimeFormat.getFormatter_(TimeFormat._hourFormats.get(format) ?? TimeFormat.HH)!;
        return f(h, "", "");
    }

    static hms_(sec: Double): string {
        const s = (sec % 60);
        const m = Math.floor(sec / 60);
        const sstr = (s == Math.floor(s)) ? `${s}` : `${s.toFixed(2)}`;
        if (m == 0) return sstr;
        const h = Math.floor(m / 60);
        const mstr = An.to02d_(m);
        if (h == 0) return `${mstr}:${sstr}`;
        return `${An.to02d_(h)}:${mstr}:${sstr}`;
    }
}

class UISettings {

    constructor(private _settings: JSONObject) {
    }

    set_(key: string, value: any): void {
        this._settings[key] = value;
    }

    get buttonSize$(): number {
        return this._settings[SettingsKey.buttonSize];
    }

    get uiFontName$(): string {
        return this._settings[SettingsKey.uiFontName];
    }

    get uiFontStyle$(): string {
        return this._settings[SettingsKey.uiFontStyle];
    }

    get uiFontSize$(): number {
        return this._settings[SettingsKey.uiFontSize];
    }

    get fixedFontName$(): string {
        return this._settings[SettingsKey.fixedFontName];
    }

    get fixedFontStyle$(): string {
        return this._settings[SettingsKey.fixedFontStyle];
    }

    get dialogBGColor$(): string {
        return this._settings[SettingsKey.dialogBGColor];
    }

    get headingColor$(): string {
        return this._settings[SettingsKey.headingColor];
    }

    get linkColor$(): string {
        return this._settings[SettingsKey.linkColor];
    }

    get annotationColor$(): string {
        return this._settings[SettingsKey.annotationColor];
    }

    get highlightColor$(): string {
        return this._settings[SettingsKey.highlightColor];
    }

    get dateFormat$(): string {
        return this._settings[SettingsKey.dateFormat];
    }

    get timeFormat$(): string {
        return this._settings[SettingsKey.timeFormat];
    }

    get timeZone$(): string {
        return this._settings[SettingsKey.timeZone];
    }

    get imageDimension$(): number {
        let ret = this._settings[SettingsKey.imageDimension];
        return ret == null ? 0 : ret;
    }

    set buttonSize$(value: number) {
        this._settings[SettingsKey.buttonSize] = value;
    }

    set uiFontName$(value: string) {
        this._settings[SettingsKey.uiFontName] = value;
    }

    set uiFontStyle$(value: string) {
        this._settings[SettingsKey.uiFontStyle] = value;
    }

    set uiFontSize$(value: number) {
        this._settings[SettingsKey.uiFontSize] = value;
    }

    set fixedFontName$(value: string) {
        this._settings[SettingsKey.fixedFontName] = value;
    }

    set fixedFontStyle$(value: string) {
        this._settings[SettingsKey.fixedFontStyle] = value;
    }

    set dialogBGColor$(value: string) {
        this._settings[SettingsKey.dialogBGColor] = value;
    }

    set headingColor$(value: string) {
        this._settings[SettingsKey.headingColor] = value;
    }

    set linkColor$(value: string) {
        this._settings[SettingsKey.linkColor] = value;
    }

    set annotationColor$(value: string) {
        this._settings[SettingsKey.annotationColor] = value;
    }

    set highlightColor$(value: string) {
        this._settings[SettingsKey.highlightColor] = value;
    }

    set dateFormat$(value: string) {
        this._settings[SettingsKey.dateFormat] = value;
    }

    set timeFormat$(value: string) {
        this._settings[SettingsKey.timeFormat] = value;
    }

    set timeZone$(value: string) {
        this._settings[SettingsKey.timeZone] = value;
    }

    set imageDimension$(value: number) {
        this._settings[SettingsKey.imageDimension] = value;
    }

    toJSONString_(): string {
        return JSON.stringify(this._settings);
    }
}

class Settings {
    private _current: UISettings;
    private _defaults: UISettings;

    private _sortedFonts: FontInfo[];
    private _sortedSymbolFonts: FontInfo[];
    private _sortedFontFaces: string[];
    private _fontsByFontname: Map<string, FontInfo>;
    private _templates: TemplatesInfo;
    private _htmlTemplatesWithAliases: Map<string, TemplateInfo>;

    /**
       * Style info format: {
       *   group: String,
       *   name: String,
       *   label: String,
       *   tag: String,
       *   style: {},
       * }
       */
    private _builtinCharStylesByName: Map<string, StyleInfo>;
    private _builtinParaStylesByName: Map<string, StyleInfo>;
    private _highlightStylesByName: Map<string, StyleInfo>;
    private _charStylesByName: Map<string, StyleInfo>;
    private _paraStylesByName: Map<string, StyleInfo>;

    readonly timeZoneUTC$ = MSG.string_(RS.TimeZoneUTC);
    readonly timeZoneLocal$ = MSG.string_(RS.TimeZoneLocal);

    constructor(private _settings: JSONObject) {
        this._current = new UISettings(_settings[SettingsKey.current])!;
        this._defaults = new UISettings(_settings[SettingsKey.defaults])!;
        this._sortedFonts = this.sortbyfontname(this._settings[SettingsKey.fontFamilies]);
        this._sortedSymbolFonts = this.sortbyfontname(this._settings[SettingsKey.symbolFamilies]);
        this._sortedFontFaces = this.sortedfontfaces();
        this._fontsByFontname = new Map(this._sortedFonts.map((info) => [info.fontname$, info]));
        this._templates = TemplatesInfo.of_(this._settings[SettingsKey.htmlTemplates]!);
        this._htmlTemplatesWithAliases = this._htmltemplatesbyname();
        this._charStylesByName = this.sortbystylename(this._settings[SettingsKey.charStyles]);
        this._highlightStylesByName = this.sortbystylename(this._settings[SettingsKey.highlightStyles]);
        this._paraStylesByName = this.sortbystylename(this._settings[SettingsKey.paraStyles]);
        this._builtinCharStylesByName = this.sortbystylename(this._settings[SettingsKey.builtinCharStyles]);
        this._builtinParaStylesByName = this.sortbystylename(this._settings[SettingsKey.builtinParaStyles]);
    }

    private sortbyfontname(fonts: StringMap<JSONObject>): FontInfo[] {
        return Object.keys(fonts).sort().map((key) => {
            return new FontInfo(fonts[key]!);
        });
    }

    private sortbystylename(styles: JSONObject[]): Map<string, StyleInfo> {
        let ret = new Map<string, StyleInfo>();
        styles.map<[string, StyleInfo]>((style) => {
            const info = new StyleInfo(style);
            return [info.name$, info];
        }).sort((a, b) => {
            return a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;
        }).forEach((e) => {
            ret.set(e[0], e[1]);
        });
        return ret;
    }

    private sortedfontfaces(): string[] {
        let sorted = new Map<string, string>();
        for (let font of this.fontFamilies_()) {
            let name = font.fontname$ ?? null;
            let styles = font.styles$ ?? null;
            if (name != null && styles != null) {
                for (let style of styles) {
                    let fontface = An.isempty_(style) ? name : name + "-" + style;
                    sorted.set(fontface, fontface);
                }
            }
        }
        return [...sorted.keys()];
    }

    private _htmltemplatesbyname(): Map<string, TemplateInfo> {
        const ret = new Map<string, TemplateInfo>();
        const templates = this._templates.templates$;
        for (const [_key, infos] of templates.entries()) {
            for (const info of infos) {
                ret.set(info.name$, info);
            }
        }
        const aliases = this._templates.aliases$;
        for (const [key, value] of aliases.entries()) {
            const info = ret.get(value);
            if (info != undefined) {
                ret.set(key, info);
            }
        }
        return new Map(Array.from(ret.entries()).sort((a, b) => a[0].localeCompare(b[0])));
    }

    onIFrameLoad_(): void { }

    onResize_(): void { }

    port_(): numberX {
        return null;
    }

    serial_(): number {
        return this._settings[Key.serial];
    }

    current_(): UISettings {
        return this._current;
    }

    defaults_(): UISettings {
        return this._defaults;
    }

    fontCategories_(): string[] {
        return this._settings[SettingsKey.fontCategories] as Array<string>;
    }

    fontFaces_(): string[] {
        if (this._sortedFontFaces == null) {
            this._sortedFontFaces = this.sortedfontfaces();
        }
        return this._sortedFontFaces;
    }

    fontFamilies_(): FontInfo[] {
        return this._sortedFonts;
    }

    fontInfo_(name: string): FontInfo | null {
        return this._fontsByFontname.get(name) ?? null;
    }

    symbolFamilies_(): FontInfo[] {
        return this._sortedSymbolFonts;
    }

    charStyles_(): StyleInfo[] {
        return Array.from(this._charStylesByName.values());
    }

    highlightStyles_(): StyleInfo[] {
        return Array.from(this._highlightStylesByName.values());
    }

    paraStyles_(): StyleInfo[] {
        return Array.from(this._paraStylesByName.values());
    }

    builtinCharStyles_(): StyleInfo[] {
        return Array.from(this._builtinCharStylesByName.values());
    }

    builtinParaStyles_(): StyleInfo[] {
        return Array.from(this._builtinParaStylesByName.values());
    }

    charStylesByName_(): Map<string, StyleInfo> {
        return this._charStylesByName;
    }

    highlightStylesByName_(): Map<string, StyleInfo> {
        return this._highlightStylesByName;
    }

    paraStylesByName_(): Map<string, StyleInfo> {
        return this._paraStylesByName;
    }

    builtinCharStylesByName_(): Map<string, StyleInfo> {
        return this._builtinCharStylesByName;
    }

    builtinParaStylesByName_(): Map<string, StyleInfo> {
        return this._builtinParaStylesByName;
    }

    getBgImgSamples(): string[] {
        return this._settings[SettingsKey.bgImgSamples]!;
    }

    htmlTemplates_(): Map<string, Array<TemplateInfo>> {
        return this._templates.templates$;
    }

    htmlTemplatesWithAliases_(): Map<string, TemplateInfo> {
        return this._htmlTemplatesWithAliases;
    }

    dateFormat_(): string {
        return this._current.dateFormat$;
    }

    shortDateFormat_(): string {
        return DateFormat.shortFormat_(this._current.dateFormat$)!;
    }

    monthFormat_(): string {
        return DateFormat.monthFormat_(this._current.dateFormat$)!;
    }

    timeFormat_(): string {
        return this._current.timeFormat$;
    }

    get isUtc$(): boolean {
        return this._current.timeZone$ != this.timeZoneLocal$;
    }

    /// @param pathqueryfragment The tail part of an URL with leading /, eg. /Home/index.html?edit.
    getUrl_(pathqueryfragment: string): string {
        let port = this.port_();
        let portstring = (port == null || port == 0) ? "" : `:${port}`;
        return `${Conf.scheme$}://${Conf.hostport$}${portstring}${pathqueryfragment}`;
    }

    dateString_(date: DateTime): string {
        return DateFormat.dateString_(this._current.dateFormat$, date);
    }

    timeString_(date: DateTime): string {
        return TimeFormat.timeString_(this._current.timeFormat$, date);
    }

    monthString_(date: DateTime): string {
        return Settings._monthString(this._current.dateFormat$, date);
    }

    mediumDateString_(date: DateTime): string {
        return Settings._mediumDateString(this._current.dateFormat$, date);
    }

    shortDateString_(date: DateTime): string {
        return Settings._shortDateString(this._current.dateFormat$, date);
    }

    mediumDatetimeString_(date: DateTime): string {
        return this.mediumDateString_(date) + " " + this.timeString_(date);
    }

    datetimeString_(date: DateTime): string {
        return this.dateString_(date) + " " + this.timeString_(date);
    }

    shortDatetimeString_(date: DateTime): string {
        return this.shortDateString_(date) + " " + this.timeString_(date);
    }

    private static _mediumDateString(dateformat: string, date: DateTime): string {
        let year = An.to02d_(date.year$ % 100);
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        let formatter = DateFormat.getDateFormatter_(dateformat);
        return formatter(year, month, day);
    }

    private static _shortDateString(dateformat: string, date: DateTime): string {
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        let formatter = DateFormat.getShortFormatter_(dateformat);
        return formatter("", month, day);
    }

    private static _monthString(dateformat: string, date: DateTime): string {
        let year = An.to04d_(date.year$);
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        let formatter = DateFormat.getMonthFormatter_(dateformat);
        return formatter(year, month, day);
    }
}

type Pair<A, B> = [first: A, second: B];

class AnRange {
    start$: number;
    end$: number;

    constructor(start: number, end: number) {
        this.start$ = start;
        this.end$ = end;
    }
}

class MapClipboardKey {
    static readonly context = "XxXZB";
    static readonly value = "XxXlz";
    static readonly kind = "XxXb8";
}

class MapClipboardKind {
    static readonly string = "XxXFi";
    static readonly map = "XxXWf";
    static readonly dom = "XxXiv";
}

////////////////////////////////////////////////////////////////////////

class ColorUtil {
    static readonly NULL = "";
    static readonly HEX = "#";
    static readonly DEC = "@";

    static getAlphaColor_(c: ColorValue, a: number): ColorValue {
        let r0 = c.r$ / 255;
        let g0 = c.g$ / 255;
        let b0 = c.b$ / 255;
        let mina = 1 - Math.min(Math.min(r0, g0), b0);
        if (a < mina) {
            a = mina;
        }
        let r = Math.round((1 - (1 - r0) / a) * 255);
        let g = Math.round((1 - (1 - g0) / a) * 255);
        let b = Math.round((1 - (1 - b0) / a) * 255);
        return ColorValue.fromRGBA_(r, g, b, a);
    }

    static validateColor_(value: string, def: string = ""): string {
        if (An.isempty_(value)) return def;
        let info = ColorUtil.findByName_(value.toLowerCase());
        if (info != null && ColorUtil.isCSSColor_(info)) return info[0];
        let c = ColorValue.parseSafe_(value);
        if (c == null) return def;
        return value.startsWith("#")
            ? c.toHexOrRgbaString_()
            : c.toRgbOrRgbaString_();
    }

    static validateCSSColor_(value: string, def: string = ""): string {
        if (An.isempty_(value)) return def;
        let info = ColorUtil.findByName_(value.toLowerCase());
        if (info != null && ColorUtil.isCSSColor_(info)) return info[0];
        let c = ColorValue.parseSafe_(value);
        if (c == null) return def;
        return value.startsWith("#") ? c.toHexOrCSSString_() : c.toCSSString_();
    }

    static toHexOrRgbString_(color: ColorValue | null, hex: boolean): string {
        return color == null ? "" : hex
            ? "#" + color.toHex3String_()
            : color.toRgbString_();
    }

    static formatString_(format: string, c: ColorValue): string {
        if (c == null) return "";
        if (format == null) return c.toRgbOrRgbaString_();
        switch (format) {
            case ColorUtil.NULL:
                return "";
            case ColorUtil.HEX:
                return c.toHexOrRgbaString_();
            case ColorUtil.DEC:
                return c.toRgbOrRgbaString_();
            default:
                return format;
        }
    }

    static getColorValue_(value: stringX, a: number | undefined = undefined): ColorValue | null {
        if (value == null || value.length == 0) return null;
        let info = ColorUtil.findByName_(value.toLowerCase());
        if (info != null) value = info[1];
        const color = ColorValue.parseSafe_(value);
        return (a === undefined || color == null ? color : ColorValue.fromRGBA_(color.r$, color.g$, color.b$, a));
    }

    static getFormat_(value: string): string {
        if (An.isempty_(value)) return ColorUtil.NULL;
        let lcname = value.toLowerCase();
        let info = ColorUtil.findByName_(lcname);
        if (ColorUtil.isCSSColor_(info)) {
            return value;
        }
        if (value.startsWith("#") || info != null) {
            return ColorUtil.HEX;
        }
        return ColorUtil.DEC;
    }

    static findByName_(lcname: string): string[] | null {
        return x11Colors.get(lcname) ?? null;
    }

    static findByHex_(hex: string): string[] | null {
        for (const [_, a] of x11Colors) {
            if (a[1] == hex) return a;
        }
        return null;
    }

    /// @return -1 If not found.
    static findIndexByName_(name: string): number {
        {
            let i = 0;
            for (let key in x11Colors.keys()) {
                if (name == key) return i;
                ++i;
            }
        }
        {
            let i = 0;
            for (let key in x11Colors.keys()) {
                if (key.includes(name)) return i;
                ++i;
            }
        }
        return -1;
    }

    /// @return -1 If not found.
    static findIndexByHex_(hex: string): number {
        let i = 0;
        for (let [_, a] of x11Colors) {
            if (a[1] == hex) return i;
            ++i;
        }
        return -1;
    }

    static formatCSSString_(format: string, c: ColorValue | null): string {
        if (c == null) return "";
        if (format == null) return c.toCSSString_();
        switch (format) {
            case ColorUtil.NULL:
                return "";
            case ColorUtil.HEX:
                return c.toHexOrCSSString_();
            case ColorUtil.DEC:
                return c.toCSSString_();
            default:
                return format;
        }
    }

    static isCSSColor_(info: string[] | null): boolean {
        return info != null && info[2].length > 0;
    }

    static getForegroundColor_(info: string[]): stringX {
        if (info == null) return null;
        let color = info[3];
        return An.isempty_(color) ? null : color;
    }
}

////////////////////////////////////////////////////////////////////////

/// A mutable Rectangle.
class MutRect {
    constructor(public x: number, public y: number, public w: number, public h: number) {
    }

    static fromRect_(rect: MutRect) {
        return new MutRect(rect.x, rect.y, rect.w, rect.h);
    }

    set_(left: number, top: number, width: number, height: number): MutRect {
        this.x = left;
        this.y = top;
        this.w = width;
        this.h = height;
        return this;
    }

    setRect_(from: MutRect): MutRect {
        this.x = from.x;
        this.y = from.y;
        this.w = from.w;
        this.h = from.h;
        return this;
    }

    clampSize_(min: number, max: number): MutRect {
        this.x = An.clamp_(min, max, this.x);
        this.y = An.clamp_(min, max, this.y);
        this.w = An.clamp_(min, max, this.w);
        this.h = An.clamp_(min, max, this.h);
        if (this.x + this.w > max) this.w = max - this.x;
        if (this.y + this.h > max) this.h = max - this.y;
        return this;
    }

    scaledBy_(w: number, h: number): MutRect {
        return new MutRect(
            this.x * w,
            this.y * h,
            this.w * w,
            this.h * h);
    }

    rounded_(): this {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.w = Math.round(this.w);
        this.h = Math.round(this.h);
        return this;
    }

    toString(): string {
        return `[${this.x}, ${this.y}, ${this.w}, ${this.h}]`;
    }
}

////////////////////////////////////////////////////////////////////////

const x11Colors = new Map<string, Array<string>>([
    ["aliceblue", ["aliceblue", "#f0f8ff", "*", ""]],
    ["antiquewhite", ["antiquewhite", "#faebd7", "*", ""]],
    ["antiquewhite01", ["antiquewhite01", "#ffefdb", "", ""]],
    ["antiquewhite02", ["antiquewhite02", "#eedfcc", "", ""]],
    ["antiquewhite03", ["antiquewhite03", "#cdc0b0", "", ""]],
    ["antiquewhite04", ["antiquewhite04", "#8b8378", "", "#fff"]],
    ["aqua", ["aqua", "#00ffff", "*", ""]],
    ["aquamarine", ["aquamarine", "#7fffd4", "*", ""]],
    ["aquamarine02", ["aquamarine02", "#76eec6", "", ""]],
    ["aquamarine04", ["aquamarine04", "#458b74", "", "#fff"]],
    ["azure", ["azure", "#f0ffff", "*", ""]],
    ["azure02", ["azure02", "#e0eeee", "", ""]],
    ["azure03", ["azure03", "#c1cdcd", "", ""]],
    ["azure04", ["azure04", "#838b8b", "", "#fff"]],
    ["beige", ["beige", "#f5f5dc", "*", ""]],
    ["bisque", ["bisque", "#ffe4c4", "*", ""]],
    ["bisque02", ["bisque02", "#eed5b7", "", ""]],
    ["bisque03", ["bisque03", "#cdb79e", "", ""]],
    ["bisque04", ["bisque04", "#8b7d6b", "", "#fff"]],
    ["black", ["black", "#000000", "*", "#fff"]],
    ["blanchedalmond", ["blanchedalmond", "#ffebcd", "*", ""]],
    ["blue", ["blue", "#0000ff", "*", "#fff"]],
    ["blue02", ["blue02", "#0000ee", "", "#fff"]],
    ["blueviolet", ["blueviolet", "#8a2be2", "*", "#fff"]],
    ["brown", ["brown", "#a52a2a", "*", "#fff"]],
    ["brown01", ["brown01", "#ff4040", "", ""]],
    ["brown02", ["brown02", "#ee3b3b", "", ""]],
    ["brown03", ["brown03", "#cd3333", "", "#fff"]],
    ["brown04", ["brown04", "#8b2323", "", "#fff"]],
    ["burlywood", ["burlywood", "#deb887", "*", ""]],
    ["burlywood01", ["burlywood01", "#ffd39b", "", ""]],
    ["burlywood02", ["burlywood02", "#eec591", "", ""]],
    ["burlywood03", ["burlywood03", "#cdaa7d", "", ""]],
    ["burlywood04", ["burlywood04", "#8b7355", "", "#fff"]],
    ["cadetblue", ["cadetblue", "#5f9ea0", "*", "#fff"]],
    ["cadetblue01", ["cadetblue01", "#98f5ff", "", ""]],
    ["cadetblue02", ["cadetblue02", "#8ee5ee", "", ""]],
    ["cadetblue03", ["cadetblue03", "#7ac5cd", "", ""]],
    ["cadetblue04", ["cadetblue04", "#53868b", "", "#fff"]],
    ["chartreuse", ["chartreuse", "#7fff00", "*", ""]],
    ["chartreuse02", ["chartreuse02", "#76ee00", "", ""]],
    ["chartreuse03", ["chartreuse03", "#66cd00", "", ""]],
    ["chartreuse04", ["chartreuse04", "#458b00", "", "#fff"]],
    ["chocolate", ["chocolate", "#d2691e", "*", ""]],
    ["chocolate01", ["chocolate01", "#ff7f24", "", ""]],
    ["chocolate02", ["chocolate02", "#ee7621", "", ""]],
    ["chocolate03", ["chocolate03", "#cd661d", "", ""]],
    ["coral", ["coral", "#ff7f50", "*", ""]],
    ["coral01", ["coral01", "#ff7256", "", ""]],
    ["coral02", ["coral02", "#ee6a50", "", ""]],
    ["coral03", ["coral03", "#cd5b45", "", ""]],
    ["coral04", ["coral04", "#8b3e2f", "", "#fff"]],
    ["cornflowerblue", ["cornflowerblue", "#6495ed", "*", ""]],
    ["cornsilk", ["cornsilk", "#fff8dc", "*", ""]],
    ["cornsilk02", ["cornsilk02", "#eee8cd", "", ""]],
    ["cornsilk03", ["cornsilk03", "#cdc8b1", "", ""]],
    ["cornsilk04", ["cornsilk04", "#8b8878", "", "#fff"]],
    ["crimson", ["crimson", "#dc143c", "*", "#fff"]],
    ["cyan", ["cyan", "#00ffff", "*", ""]],
    ["cyan02", ["cyan02", "#00eeee", "", ""]],
    ["cyan03", ["cyan03", "#00cdcd", "", ""]],
    ["darkblue", ["darkblue", "#00008b", "*", "#fff"]],
    ["darkcyan", ["darkcyan", "#008b8b", "*", "#fff"]],
    ["darkgoldenrod", ["darkgoldenrod", "#b8860b", "*", "#fff"]],
    ["darkgoldenrod01", ["darkgoldenrod01", "#ffb90f", "", ""]],
    ["darkgoldenrod02", ["darkgoldenrod02", "#eead0e", "", ""]],
    ["darkgoldenrod03", ["darkgoldenrod03", "#cd950c", "", ""]],
    ["darkgoldenrod04", ["darkgoldenrod04", "#8b6508", "", "#fff"]],
    ["darkgray", ["darkgray", "#a9a9a9", "*", ""]],
    ["darkgreen", ["darkgreen", "#006400", "*", "#fff"]],
    ["darkgrey", ["darkgrey", "#a9a9a9", "*", ""]],
    ["darkkhaki", ["darkkhaki", "#bdb76b", "*", ""]],
    ["darkmagenta", ["darkmagenta", "#8b008b", "*", "#fff"]],
    ["darkolivegreen", ["darkolivegreen", "#556b2f", "*", "#fff"]],
    ["darkolivegreen01", ["darkolivegreen01", "#caff70", "", ""]],
    ["darkolivegreen02", ["darkolivegreen02", "#bcee68", "", ""]],
    ["darkolivegreen03", ["darkolivegreen03", "#a2cd5a", "", ""]],
    ["darkolivegreen04", ["darkolivegreen04", "#6e8b3d", "", "#fff"]],
    ["darkorange", ["darkorange", "#ff8c00", "*", ""]],
    ["darkorange01", ["darkorange01", "#ff7f00", "", ""]],
    ["darkorange02", ["darkorange02", "#ee7600", "", ""]],
    ["darkorange03", ["darkorange03", "#cd6600", "", ""]],
    ["darkorange04", ["darkorange04", "#8b4500", "", "#fff"]],
    ["darkorchid", ["darkorchid", "#9932cc", "*", "#fff"]],
    ["darkorchid01", ["darkorchid01", "#bf3eff", "", "#fff"]],
    ["darkorchid02", ["darkorchid02", "#b23aee", "", "#fff"]],
    ["darkorchid03", ["darkorchid03", "#9a32cd", "", "#fff"]],
    ["darkorchid04", ["darkorchid04", "#68228b", "", "#fff"]],
    ["darkred", ["darkred", "#8b0000", "*", "#fff"]],
    ["darksalmon", ["darksalmon", "#e9967a", "*", ""]],
    ["darkseagreen", ["darkseagreen", "#8fbc8f", "*", ""]],
    ["darkseagreen01", ["darkseagreen01", "#c1ffc1", "", ""]],
    ["darkseagreen02", ["darkseagreen02", "#b4eeb4", "", ""]],
    ["darkseagreen03", ["darkseagreen03", "#9bcd9b", "", ""]],
    ["darkseagreen04", ["darkseagreen04", "#698b69", "", "#fff"]],
    ["darkslateblue", ["darkslateblue", "#483d8b", "*", "#fff"]],
    ["darkslategray", ["darkslategray", "#2f4f4f", "*", "#fff"]],
    ["darkslategray01", ["darkslategray01", "#97ffff", "", ""]],
    ["darkslategray02", ["darkslategray02", "#8deeee", "", ""]],
    ["darkslategray03", ["darkslategray03", "#79cdcd", "", ""]],
    ["darkslategray04", ["darkslategray04", "#528b8b", "", "#fff"]],
    ["darkslategrey", ["darkslategrey", "#2f4f4f", "*", "#fff"]],
    ["darkslategrey01", ["darkslategrey01", "#97ffff", "", ""]],
    ["darkslategrey02", ["darkslategrey02", "#8deeee", "", ""]],
    ["darkslategrey03", ["darkslategrey03", "#79cdcd", "", ""]],
    ["darkslategrey04", ["darkslategrey04", "#528b8b", "", "#fff"]],
    ["darkturquoise", ["darkturquoise", "#00ced1", "*", ""]],
    ["darkviolet", ["darkviolet", "#9400d3", "*", "#fff"]],
    ["deeppink", ["deeppink", "#ff1493", "*", ""]],
    ["deeppink02", ["deeppink02", "#ee1289", "", ""]],
    ["deeppink03", ["deeppink03", "#cd1076", "", "#fff"]],
    ["deeppink04", ["deeppink04", "#8b0a50", "", "#fff"]],
    ["deepskyblue", ["deepskyblue", "#00bfff", "*", ""]],
    ["deepskyblue02", ["deepskyblue02", "#00b2ee", "", ""]],
    ["deepskyblue03", ["deepskyblue03", "#009acd", "", ""]],
    ["deepskyblue04", ["deepskyblue04", "#00688b", "", "#fff"]],
    ["dimgray", ["dimgray", "#696969", "*", "#fff"]],
    ["dimgrey", ["dimgrey", "#696969", "*", "#fff"]],
    ["dodgerblue", ["dodgerblue", "#1e90ff", "*", "#fff"]],
    ["dodgerblue02", ["dodgerblue02", "#1c86ee", "", "#fff"]],
    ["dodgerblue03", ["dodgerblue03", "#1874cd", "", "#fff"]],
    ["dodgerblue04", ["dodgerblue04", "#104e8b", "", "#fff"]],
    ["firebrick", ["firebrick", "#b22222", "*", "#fff"]],
    ["firebrick01", ["firebrick01", "#ff3030", "", ""]],
    ["firebrick02", ["firebrick02", "#ee2c2c", "", ""]],
    ["firebrick03", ["firebrick03", "#cd2626", "", "#fff"]],
    ["firebrick04", ["firebrick04", "#8b1a1a", "", "#fff"]],
    ["floralwhite", ["floralwhite", "#fffaf0", "*", ""]],
    ["forestgreen", ["forestgreen", "#228b22", "*", "#fff"]],
    ["fuchsia", ["fuchsia", "#ff00ff", "*", ""]],
    ["gainsboro", ["gainsboro", "#dcdcdc", "*", ""]],
    ["ghostwhite", ["ghostwhite", "#f8f8ff", "*", ""]],
    ["gold", ["gold", "#ffd700", "*", ""]],
    ["gold02", ["gold02", "#eec900", "", ""]],
    ["gold03", ["gold03", "#cdad00", "", ""]],
    ["gold04", ["gold04", "#8b7500", "", "#fff"]],
    ["goldenrod", ["goldenrod", "#daa520", "*", ""]],
    ["goldenrod01", ["goldenrod01", "#ffc125", "", ""]],
    ["goldenrod02", ["goldenrod02", "#eeb422", "", ""]],
    ["goldenrod03", ["goldenrod03", "#cd9b1d", "", ""]],
    ["goldenrod04", ["goldenrod04", "#8b6914", "", "#fff"]],
    ["gray", ["gray", "#808080", "*", "#fff"]],
    ["green", ["green", "#008000", "*", "#fff"]],
    ["green02", ["green02", "#00ee00", "", ""]],
    ["green03", ["green03", "#00cd00", "", ""]],
    ["green04", ["green04", "#008b00", "", "#fff"]],
    ["greenyellow", ["greenyellow", "#adff2f", "*", ""]],
    ["grey", ["grey", "#808080", "*", "#fff"]],
    ["honeydew", ["honeydew", "#f0fff0", "*", ""]],
    ["honeydew02", ["honeydew02", "#e0eee0", "", ""]],
    ["honeydew03", ["honeydew03", "#c1cdc1", "", ""]],
    ["honeydew04", ["honeydew04", "#838b83", "", "#fff"]],
    ["hotpink", ["hotpink", "#ff69b4", "*", ""]],
    ["hotpink01", ["hotpink01", "#ff6eb4", "", ""]],
    ["hotpink02", ["hotpink02", "#ee6aa7", "", ""]],
    ["hotpink03", ["hotpink03", "#cd6090", "", "#fff"]],
    ["hotpink04", ["hotpink04", "#8b3a62", "", "#fff"]],
    ["indianred", ["indianred", "#cd5c5c", "*", ""]],
    ["indianred01", ["indianred01", "#ff6a6a", "", "#fff"]],
    ["indianred02", ["indianred02", "#ee6363", "", ""]],
    ["indianred03", ["indianred03", "#cd5555", "", "#fff"]],
    ["indianred04", ["indianred04", "#8b3a3a", "", "#fff"]],
    ["indigo", ["indigo", "#4b0082", "*", "#fff"]],
    ["ivory", ["ivory", "#fffff0", "*", ""]],
    ["ivory02", ["ivory02", "#eeeee0", "", ""]],
    ["ivory03", ["ivory03", "#cdcdc1", "", ""]],
    ["ivory04", ["ivory04", "#8b8b83", "", "#fff"]],
    ["khaki", ["khaki", "#f0e68c", "*", ""]],
    ["khaki01", ["khaki01", "#fff68f", "", ""]],
    ["khaki02", ["khaki02", "#eee685", "", ""]],
    ["khaki03", ["khaki03", "#cdc673", "", ""]],
    ["khaki04", ["khaki04", "#8b864e", "", "#fff"]],
    ["lavender", ["lavender", "#e6e6fa", "*", ""]],
    ["lavenderblush", ["lavenderblush", "#fff0f5", "*", ""]],
    ["lavenderblush02", ["lavenderblush02", "#eee0e5", "", ""]],
    ["lavenderblush03", ["lavenderblush03", "#cdc1c5", "", ""]],
    ["lavenderblush04", ["lavenderblush04", "#8b8386", "", "#fff"]],
    ["lawngreen", ["lawngreen", "#7cfc00", "*", ""]],
    ["lemonchiffon", ["lemonchiffon", "#fffacd", "*", ""]],
    ["lemonchiffon02", ["lemonchiffon02", "#eee9bf", "", ""]],
    ["lemonchiffon03", ["lemonchiffon03", "#cdc9a5", "", ""]],
    ["lemonchiffon04", ["lemonchiffon04", "#8b8970", "", "#fff"]],
    ["lightblue", ["lightblue", "#add8e6", "*", ""]],
    ["lightblue01", ["lightblue01", "#bfefff", "", ""]],
    ["lightblue02", ["lightblue02", "#b2dfee", "", ""]],
    ["lightblue03", ["lightblue03", "#9ac0cd", "", ""]],
    ["lightblue04", ["lightblue04", "#68838b", "", "#fff"]],
    ["lightcoral", ["lightcoral", "#f08080", "*", ""]],
    ["lightcyan", ["lightcyan", "#e0ffff", "*", ""]],
    ["lightcyan02", ["lightcyan02", "#d1eeee", "", ""]],
    ["lightcyan03", ["lightcyan03", "#b4cdcd", "", ""]],
    ["lightcyan04", ["lightcyan04", "#7a8b8b", "", "#fff"]],
    ["lightgoldenrod", ["lightgoldenrod", "#eedd82", "", ""]],
    ["lightgoldenrod01", ["lightgoldenrod01", "#ffec8b", "", ""]],
    ["lightgoldenrod02", ["lightgoldenrod02", "#eedc82", "", ""]],
    ["lightgoldenrod03", ["lightgoldenrod03", "#cdbe70", "", ""]],
    ["lightgoldenrod04", ["lightgoldenrod04", "#8b814c", "", "#fff"]],
    ["lightgoldenrodyellow", ["lightgoldenrodyellow", "#fafad2", "*", ""]],
    ["lightgray", ["lightgray", "#d3d3d3", "*", ""]],
    ["lightgreen", ["lightgreen", "#90ee90", "*", ""]],
    ["lightgrey", ["lightgrey", "#d3d3d3", "*", ""]],
    ["lightpink", ["lightpink", "#ffb6c1", "*", ""]],
    ["lightpink01", ["lightpink01", "#ffaeb9", "", ""]],
    ["lightpink02", ["lightpink02", "#eea2ad", "", ""]],
    ["lightpink03", ["lightpink03", "#cd8c95", "", ""]],
    ["lightpink04", ["lightpink04", "#8b5f65", "", "#fff"]],
    ["lightsalmon", ["lightsalmon", "#ffa07a", "*", ""]],
    ["lightsalmon02", ["lightsalmon02", "#ee9572", "", ""]],
    ["lightsalmon03", ["lightsalmon03", "#cd8162", "", ""]],
    ["lightsalmon04", ["lightsalmon04", "#8b5742", "", "#fff"]],
    ["lightseagreen", ["lightseagreen", "#20b2aa", "*", ""]],
    ["lightskyblue", ["lightskyblue", "#87cefa", "*", ""]],
    ["lightskyblue01", ["lightskyblue01", "#b0e2ff", "", ""]],
    ["lightskyblue02", ["lightskyblue02", "#a4d3ee", "", ""]],
    ["lightskyblue03", ["lightskyblue03", "#8db6cd", "", ""]],
    ["lightskyblue04", ["lightskyblue04", "#607b8b", "", "#fff"]],
    ["lightslateblue", ["lightslateblue", "#8470ff", "", "#fff"]],
    ["lightslategray", ["lightslategray", "#778899", "*", "#fff"]],
    ["lightslategrey", ["lightslategrey", "#778899", "*", "#fff"]],
    ["lightsteelblue", ["lightsteelblue", "#b0c4de", "*", ""]],
    ["lightsteelblue01", ["lightsteelblue01", "#cae1ff", "", ""]],
    ["lightsteelblue02", ["lightsteelblue02", "#bcd2ee", "", ""]],
    ["lightsteelblue03", ["lightsteelblue03", "#a2b5cd", "", ""]],
    ["lightsteelblue04", ["lightsteelblue04", "#6e7b8b", "", "#fff"]],
    ["lightyellow", ["lightyellow", "#ffffe0", "*", ""]],
    ["lightyellow02", ["lightyellow02", "#eeeed1", "", ""]],
    ["lightyellow03", ["lightyellow03", "#cdcdb4", "", ""]],
    ["lightyellow04", ["lightyellow04", "#8b8b7a", "", "#fff"]],
    ["lime", ["lime", "#00ff00", "*", ""]],
    ["limegreen", ["limegreen", "#32cd32", "*", ""]],
    ["linen", ["linen", "#faf0e6", "*", ""]],
    ["magenta", ["magenta", "#ff00ff", "*", ""]],
    ["magenta02", ["magenta02", "#ee00ee", "", ""]],
    ["magenta03", ["magenta03", "#cd00cd", "", "#fff"]],
    ["maroon", ["maroon", "#800000", "*", "#fff"]],
    ["maroon01", ["maroon01", "#ff34b3", "", ""]],
    ["maroon02", ["maroon02", "#ee30a7", "", ""]],
    ["maroon03", ["maroon03", "#cd2990", "", "#fff"]],
    ["maroon04", ["maroon04", "#8b1c62", "", "#fff"]],
    ["mediumaquamarine", ["mediumaquamarine", "#66cdaa", "*", ""]],
    ["mediumblue", ["mediumblue", "#0000cd", "*", "#fff"]],
    ["mediumorchid", ["mediumorchid", "#ba55d3", "*", "#fff"]],
    ["mediumorchid01", ["mediumorchid01", "#e066ff", "", ""]],
    ["mediumorchid02", ["mediumorchid02", "#d15fee", "", ""]],
    ["mediumorchid03", ["mediumorchid03", "#b452cd", "", "#fff"]],
    ["mediumorchid04", ["mediumorchid04", "#7a378b", "", "#fff"]],
    ["mediumpurple", ["mediumpurple", "#9370db", "*", "#fff"]],
    ["mediumpurple01", ["mediumpurple01", "#ab82ff", "", "#fff"]],
    ["mediumpurple02", ["mediumpurple02", "#9f79ee", "", "#fff"]],
    ["mediumpurple03", ["mediumpurple03", "#8968cd", "", "#fff"]],
    ["mediumpurple04", ["mediumpurple04", "#5d478b", "", "#fff"]],
    ["mediumseagreen", ["mediumseagreen", "#3cb371", "*", ""]],
    ["mediumslateblue", ["mediumslateblue", "#7b68ee", "*", "#fff"]],
    ["mediumspringgreen", ["mediumspringgreen", "#00fa9a", "*", ""]],
    ["mediumturquoise", ["mediumturquoise", "#48d1cc", "*", ""]],
    ["mediumvioletred", ["mediumvioletred", "#c71585", "*", "#fff"]],
    ["midnightblue", ["midnightblue", "#191970", "*", "#fff"]],
    ["mintcream", ["mintcream", "#f5fffa", "*", ""]],
    ["mistyrose", ["mistyrose", "#ffe4e1", "*", ""]],
    ["mistyrose02", ["mistyrose02", "#eed5d2", "", ""]],
    ["mistyrose03", ["mistyrose03", "#cdb7b5", "", ""]],
    ["mistyrose04", ["mistyrose04", "#8b7d7b", "", "#fff"]],
    ["moccasin", ["moccasin", "#ffe4b5", "*", ""]],
    ["navajowhite", ["navajowhite", "#ffdead", "*", ""]],
    ["navajowhite02", ["navajowhite02", "#eecfa1", "", ""]],
    ["navajowhite03", ["navajowhite03", "#cdb38b", "", ""]],
    ["navajowhite04", ["navajowhite04", "#8b795e", "", "#fff"]],
    ["navy", ["navy", "#000080", "*", "#fff"]],
    ["oldlace", ["oldlace", "#fdf5e6", "*", ""]],
    ["olive", ["olive", "#808000", "*", "#fff"]],
    ["olivedrab", ["olivedrab", "#6b8e23", "*", "#fff"]],
    ["olivedrab01", ["olivedrab01", "#c0ff3e", "", ""]],
    ["olivedrab02", ["olivedrab02", "#b3ee3a", "", ""]],
    ["olivedrab04", ["olivedrab04", "#698b22", "", "#fff"]],
    ["orange", ["orange", "#ffa500", "*", ""]],
    ["orange02", ["orange02", "#ee9a00", "", ""]],
    ["orange03", ["orange03", "#cd8500", "", ""]],
    ["orange04", ["orange04", "#8b5a00", "", "#fff"]],
    ["orangered", ["orangered", "#ff4500", "*", ""]],
    ["orangered02", ["orangered02", "#ee4000", "", ""]],
    ["orangered03", ["orangered03", "#cd3700", "", "#fff"]],
    ["orangered04", ["orangered04", "#8b2500", "", "#fff"]],
    ["orchid", ["orchid", "#da70d6", "*", ""]],
    ["orchid01", ["orchid01", "#ff83fa", "", ""]],
    ["orchid02", ["orchid02", "#ee7ae9", "", ""]],
    ["orchid03", ["orchid03", "#cd69c9", "", ""]],
    ["orchid04", ["orchid04", "#8b4789", "", "#fff"]],
    ["palegoldenrod", ["palegoldenrod", "#eee8aa", "*", ""]],
    ["palegreen", ["palegreen", "#98fb98", "*", ""]],
    ["palegreen01", ["palegreen01", "#9aff9a", "", ""]],
    ["palegreen03", ["palegreen03", "#7ccd7c", "", ""]],
    ["palegreen04", ["palegreen04", "#548b54", "", "#fff"]],
    ["paleturquoise", ["paleturquoise", "#afeeee", "*", ""]],
    ["paleturquoise01", ["paleturquoise01", "#bbffff", "", ""]],
    ["paleturquoise02", ["paleturquoise02", "#aeeeee", "", ""]],
    ["paleturquoise03", ["paleturquoise03", "#96cdcd", "", ""]],
    ["paleturquoise04", ["paleturquoise04", "#668b8b", "", "#fff"]],
    ["palevioletred", ["palevioletred", "#db7093", "*", ""]],
    ["palevioletred01", ["palevioletred01", "#ff82ab", "", ""]],
    ["palevioletred02", ["palevioletred02", "#ee799f", "", ""]],
    ["palevioletred03", ["palevioletred03", "#cd6889", "", "#fff"]],
    ["palevioletred04", ["palevioletred04", "#8b475d", "", "#fff"]],
    ["papayawhip", ["papayawhip", "#ffefd5", "*", ""]],
    ["peachpuff", ["peachpuff", "#ffdab9", "*", ""]],
    ["peachpuff02", ["peachpuff02", "#eecbad", "", ""]],
    ["peachpuff03", ["peachpuff03", "#cdaf95", "", ""]],
    ["peachpuff04", ["peachpuff04", "#8b7765", "", "#fff"]],
    ["peru", ["peru", "#cd853f", "*", ""]],
    ["pink", ["pink", "#ffc0cb", "*", ""]],
    ["pink01", ["pink01", "#ffb5c5", "", ""]],
    ["pink02", ["pink02", "#eea9b8", "", ""]],
    ["pink03", ["pink03", "#cd919e", "", ""]],
    ["pink04", ["pink04", "#8b636c", "", "#fff"]],
    ["plum", ["plum", "#dda0dd", "*", ""]],
    ["plum01", ["plum01", "#ffbbff", "", ""]],
    ["plum02", ["plum02", "#eeaeee", "", ""]],
    ["plum03", ["plum03", "#cd96cd", "", ""]],
    ["plum04", ["plum04", "#8b668b", "", "#fff"]],
    ["powderblue", ["powderblue", "#b0e0e6", "*", ""]],
    ["purple", ["purple", "#800080", "*", "#fff"]],
    ["purple01", ["purple01", "#9b30ff", "", "#fff"]],
    ["purple02", ["purple02", "#912cee", "", "#fff"]],
    ["purple03", ["purple03", "#7d26cd", "", "#fff"]],
    ["purple04", ["purple04", "#551a8b", "", "#fff"]],
    ["rebeccapurple", ["rebeccapurple", "#663399", "", "#fff"]],
    ["red", ["red", "#ff0000", "*", ""]],
    ["red02", ["red02", "#ee0000", "", ""]],
    ["red03", ["red03", "#cd0000", "", "#fff"]],
    ["rosybrown", ["rosybrown", "#bc8f8f", "*", ""]],
    ["rosybrown01", ["rosybrown01", "#ffc1c1", "", ""]],
    ["rosybrown02", ["rosybrown02", "#eeb4b4", "", ""]],
    ["rosybrown03", ["rosybrown03", "#cd9b9b", "", ""]],
    ["rosybrown04", ["rosybrown04", "#8b6969", "", "#fff"]],
    ["royalblue", ["royalblue", "#4169e1", "*", "#fff"]],
    ["royalblue01", ["royalblue01", "#4876ff", "", "#fff"]],
    ["royalblue02", ["royalblue02", "#436eee", "", "#fff"]],
    ["royalblue03", ["royalblue03", "#3a5fcd", "", "#fff"]],
    ["royalblue04", ["royalblue04", "#27408b", "", "#fff"]],
    ["saddlebrown", ["saddlebrown", "#8b4513", "*", "#fff"]],
    ["salmon", ["salmon", "#fa8072", "*", ""]],
    ["salmon01", ["salmon01", "#ff8c69", "", ""]],
    ["salmon02", ["salmon02", "#ee8262", "", ""]],
    ["salmon03", ["salmon03", "#cd7054", "", ""]],
    ["salmon04", ["salmon04", "#8b4c39", "", "#fff"]],
    ["sandybrown", ["sandybrown", "#f4a460", "*", ""]],
    ["seagreen", ["seagreen", "#2e8b57", "*", "#fff"]],
    ["seagreen01", ["seagreen01", "#54ff9f", "", ""]],
    ["seagreen02", ["seagreen02", "#4eee94", "", ""]],
    ["seagreen03", ["seagreen03", "#43cd80", "", ""]],
    ["seashell", ["seashell", "#fff5ee", "*", ""]],
    ["seashell02", ["seashell02", "#eee5de", "", ""]],
    ["seashell03", ["seashell03", "#cdc5bf", "", ""]],
    ["seashell04", ["seashell04", "#8b8682", "", "#fff"]],
    ["sienna", ["sienna", "#a0522d", "*", "#fff"]],
    ["sienna01", ["sienna01", "#ff8247", "", ""]],
    ["sienna02", ["sienna02", "#ee7942", "", ""]],
    ["sienna03", ["sienna03", "#cd6839", "", ""]],
    ["sienna04", ["sienna04", "#8b4726", "", "#fff"]],
    ["silver", ["silver", "#c0c0c0", "*", ""]],
    ["skyblue", ["skyblue", "#87ceeb", "*", ""]],
    ["skyblue01", ["skyblue01", "#87ceff", "", ""]],
    ["skyblue02", ["skyblue02", "#7ec0ee", "", ""]],
    ["skyblue03", ["skyblue03", "#6ca6cd", "", ""]],
    ["skyblue04", ["skyblue04", "#4a708b", "", "#fff"]],
    ["slateblue", ["slateblue", "#6a5acd", "*", "#fff"]],
    ["slateblue01", ["slateblue01", "#836fff", "", "#fff"]],
    ["slateblue02", ["slateblue02", "#7a67ee", "", "#fff"]],
    ["slateblue03", ["slateblue03", "#6959cd", "", "#fff"]],
    ["slateblue04", ["slateblue04", "#473c8b", "", "#fff"]],
    ["slategray", ["slategray", "#708090", "*", "#fff"]],
    ["slategray01", ["slategray01", "#c6e2ff", "", ""]],
    ["slategray02", ["slategray02", "#b9d3ee", "", ""]],
    ["slategray03", ["slategray03", "#9fb6cd", "", ""]],
    ["slategray04", ["slategray04", "#6c7b8b", "", "#fff"]],
    ["slategrey", ["slategrey", "#708090", "*", "#fff"]],
    ["slategrey01", ["slategrey01", "#c6e2ff", "", ""]],
    ["slategrey02", ["slategrey02", "#b9d3ee", "", ""]],
    ["slategrey03", ["slategrey03", "#9fb6cd", "", ""]],
    ["slategrey04", ["slategrey04", "#6c7b8b", "", "#fff"]],
    ["snow", ["snow", "#fffafa", "*", ""]],
    ["snow02", ["snow02", "#eee9e9", "", ""]],
    ["snow03", ["snow03", "#cdc9c9", "", ""]],
    ["snow04", ["snow04", "#8b8989", "", "#fff"]],
    ["springgreen", ["springgreen", "#00ff7f", "*", ""]],
    ["springgreen02", ["springgreen02", "#00ee76", "", ""]],
    ["springgreen03", ["springgreen03", "#00cd66", "", ""]],
    ["springgreen04", ["springgreen04", "#008b45", "", "#fff"]],
    ["steelblue", ["steelblue", "#4682b4", "*", "#fff"]],
    ["steelblue01", ["steelblue01", "#63b8ff", "", ""]],
    ["steelblue02", ["steelblue02", "#5cacee", "", ""]],
    ["steelblue03", ["steelblue03", "#4f94cd", "", "#fff"]],
    ["steelblue04", ["steelblue04", "#36648b", "", "#fff"]],
    ["tan", ["tan", "#d2b48c", "*", ""]],
    ["tan01", ["tan01", "#ffa54f", "", ""]],
    ["tan02", ["tan02", "#ee9a49", "", ""]],
    ["tan04", ["tan04", "#8b5a2b", "", "#fff"]],
    ["teal", ["teal", "#008080", "*", "#fff"]],
    ["thistle", ["thistle", "#d8bfd8", "*", ""]],
    ["thistle01", ["thistle01", "#ffe1ff", "", ""]],
    ["thistle02", ["thistle02", "#eed2ee", "", ""]],
    ["thistle03", ["thistle03", "#cdb5cd", "", ""]],
    ["thistle04", ["thistle04", "#8b7b8b", "", "#fff"]],
    ["tomato", ["tomato", "#ff6347", "*", ""]],
    ["tomato02", ["tomato02", "#ee5c42", "", ""]],
    ["tomato03", ["tomato03", "#cd4f39", "", "#fff"]],
    ["tomato04", ["tomato04", "#8b3626", "", "#fff"]],
    ["turquoise", ["turquoise", "#40e0d0", "*", ""]],
    ["turquoise01", ["turquoise01", "#00f5ff", "", ""]],
    ["turquoise02", ["turquoise02", "#00e5ee", "", ""]],
    ["turquoise03", ["turquoise03", "#00c5cd", "", ""]],
    ["turquoise04", ["turquoise04", "#00868b", "", "#fff"]],
    ["violet", ["violet", "#ee82ee", "*", ""]],
    ["violetred", ["violetred", "#d02090", "", "#fff"]],
    ["violetred01", ["violetred01", "#ff3e96", "", ""]],
    ["violetred02", ["violetred02", "#ee3a8c", "", ""]],
    ["violetred03", ["violetred03", "#cd3278", "", "#fff"]],
    ["violetred04", ["violetred04", "#8b2252", "", "#fff"]],
    ["webgray", ["webgray", "#808080", "", "#fff"]],
    ["webgreen", ["webgreen", "#008000", "", "#fff"]],
    ["webgrey", ["webgrey", "#808080", "", "#fff"]],
    ["webmaroon", ["webmaroon", "#800000", "", "#fff"]],
    ["webpurple", ["webpurple", "#800080", "", "#fff"]],
    ["wheat", ["wheat", "#f5deb3", "*", ""]],
    ["wheat01", ["wheat01", "#ffe7ba", "", ""]],
    ["wheat02", ["wheat02", "#eed8ae", "", ""]],
    ["wheat03", ["wheat03", "#cdba96", "", ""]],
    ["wheat04", ["wheat04", "#8b7e66", "", "#fff"]],
    ["white", ["white", "#ffffff", "*", ""]],
    ["whitesmoke", ["whitesmoke", "#f5f5f5", "*", ""]],
    ["x11gray", ["x11gray", "#bebebe", "", ""]],
    ["x11green", ["x11green", "#00ff00", "", ""]],
    ["x11grey", ["x11grey", "#bebebe", "", ""]],
    ["x11maroon", ["x11maroon", "#b03060", "", "#fff"]],
    ["x11purple", ["x11purple", "#a020f0", "", "#fff"]],
    ["yellow", ["yellow", "#ffff00", "*", ""]],
    ["yellow02", ["yellow02", "#eeee00", "", ""]],
    ["yellow03", ["yellow03", "#cdcd00", "", ""]],
    ["yellow04", ["yellow04", "#8b8b00", "", "#fff"]],
    ["yellowgreen", ["yellowgreen", "#9acd32", "*", ""]],
]);

////////////////////////////////////////////////////////////////////////

class EventListenerBuilder {
    constructor(private elm: HTMLElement) { }
    add_(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) {
        this.elm.addEventListener(type, listener, options);
        return this;
    }
}

class ClasslistBuilder {
    private classlist: DOMTokenList;
    constructor(elm: HTMLElement | DOMTokenList) {
        this.classlist = (DomUt.asHTMLElement_(elm)?.classList) ?? (elm as DOMTokenList);
    }
    array_() {
        return Array.from(this.classlist);
    }
    forEach_(callback: Fun20<string, this>) {
        const self = this;
        this.array_().forEach((c) => {
            callback(c, self);
        });
    }
    contains_(c: string): boolean {
        return this.classlist.contains(c);
    }
    containsAll_(...classes: string[]): boolean {
        for (let c of classes) {
            if (!this.classlist.contains(c)) { return false; }
        }
        return true;
    }
    containsAny_(...classes: string[]): boolean {
        for (let c of classes) {
            if (this.classlist.contains(c)) { return true; }
        }
        return false;
    }
    add_(c: string): ClasslistBuilder {
        this.classlist.add(c);
        return this;
    }
    remove_(c: string): ClasslistBuilder {
        this.classlist.remove(c);
        return this;
    }
    toggle_(c: string): ClasslistBuilder {
        this.classlist.toggle(c);
        return this;
    }
    addAll_(...classses: string[]): ClasslistBuilder {
        for (let c of classses) {
            this.classlist.add(c);
        }
        return this;
    }
    removeAll_(...classses: string[]): ClasslistBuilder {
        for (let c of classses) {
            this.classlist.remove(c);
        }
        return this;
    }
    toggleAll_(...classses: string[]): ClasslistBuilder {
        for (let c of classses) {
            this.classlist.toggle(c);
        }
        return this;
    }
}

class HumanFilepath {
    static Empty$ = new HumanFilepath("");
    static fromJSON_(json: string): HumanFilepath {
        return new HumanFilepath(json);
    }
    static getValue_(input: AnInputElement): string {
        let ret = input.value;
        if (ret.startsWith(FS)) return ret;
        const ovalue = input.getAttribute(ATTR.AnText);
        if (ovalue != null) return Basepath.changeFilename_(ovalue, ret);
        return ret;
    }
    static setValue_(input: AnInputElement, value: string): void {
        new HumanFilepath(value).updateInput_(input);
    }
    constructor(private _filepath: string) { }
    get isEmpty$(): boolean {
        return this._filepath.length == 0;
    }
    get isAbsolute$(): boolean {
        return this._filepath.startsWith(FS);
    }
    get filepath$(): string {
        return this._filepath;
    }
    get human$(): string {
        return Basepath.filename_(this._filepath);
    }
    updateInput_(input: AnInputElement): void {
        input.setAttribute(ATTR.AnText, this._filepath);
        input.value = this.human$;
    }
}

class HumanLink {
    static Empty$ = new HumanLink("", "", "");
    static fromJSON_(json: stringXX): HumanLink {
        const array = An.parseJSONOrNull_(json);
        return (array == null) ? this.Empty$ : new HumanLink(array[0], array[1], array[2]);
    }
    static fromInput_(input: AnInputElement): HumanLink {
        let ret = HumanLink.fromJSON_(input.getAttribute(ATTR.AnInfo));
        return (input.value == ret.human$) ? ret : ret.changeFromInput_(input);
    }
    /// @filepath Decoded filepath.
    /// @query Human encoded query.
    /// @fragment Human encoded fragment
    static fromFilepath_(filepath: string, query: string = "", fragment: string = ""): HumanLink {
        return new HumanLink(filepath, query, fragment);
    }
    /// Unescape URI for presentation to user. In particular, it allow space.
    /// @return An partially unescaped URL with only the path, query and fragment parts.
    /// The URL should be escaped using MyUri.parse() before use.
    static fromUri_(uri: Uri): HumanLink {
        return new HumanLink(uri.pathSegments$.join(FS), this._humanSearchFromParams(uri.searchParams$), this._humanHash(uri.hash$));
    }
    /// @return HumanLink.Empty if href is empty or invalid, post warning if href is invalid.
    static fromHref_(href: string): HumanLink {
        if (An.isempty_(href)) return HumanLink.Empty$;
        const [path, search, hash] = UriUt.split_(href);
        return new HumanLink(this._decodedPath(path), this._humanSearchFromHref(search), this._humanHash(hash));
    }
    /// @return The human href.
    static getValue_(input: AnInputElement): string {
        let href = input.value;
        if (href.length == 0) return "";
        if (href.startsWith(FS)) return href;
        const ovalue = HumanLink.fromJSON_(input.getAttribute(ATTR.AnInfo));
        if (An.dataUrlScheme_(href) != null) return ovalue.humanHref$;
        if (An.dataUrlScheme_(ovalue.filepath$)) return href;
        const dir = Basepath.dir_(ovalue.filepath$);
        return Basepath.joinRpath_((dir == null ? null : this._humanPath(dir)), href);
    }
    static setHref_(input: AnInputElement, href: string): void {
        HumanLink.fromHref_(href).updateInput_(input);
    }
    static setUri_(input: AnInputElement, uri: Uri): void {
        HumanLink.fromUri_(uri).updateInput_(input);
    }
    private static _humanSearchFromParams(params: URLSearchParams): string {
        const buf = new StringBuffer();
        params.forEach((v, k) => this._humanSearchParam(buf, k, v));
        return buf.length$ == 0 ? "" : "?" + buf.toString();
    }
    private static _humanSearchFromHref(search: string): string {
        if (search.length == 0) return search;
        const buf = new StringBuffer();
        search.substring(1).split("&").forEach(s => {
            const a = s.split("=", 2);
            this._humanSearchParam(buf, decodeURIComponent(a[0]), (a.length > 1 ? decodeURIComponent(a[1]) : ""));
        });
        return buf.length$ == 0 ? "" : "?" + buf.toString();
    }
    private static _humanSearchParam(buf: StringBuffer, k: string, v: string): void {
        let key = this._humanesc(k, An._QUERY_ILLEGALS);
        let value = (v.length == 0 ? "" : this._humanesc(v, An._QUERY_ILLEGALS));
        if (buf.length$ > 0) { buf.write_("&"); }
        buf.write_(key);
        if (value.length > 0) {
            buf.write_("=");
            buf.write_(value);
        }
    }
    private static _humanHash(hash: string): string {
        return hash.length == 0 ? "" : "#" + this._humanesc(decodeURIComponent(hash.substring(1)), An._FRAGMENT_ILLEGALS);
    }
    private static _decodedPath(path: string): string {
        return (An.dataUrlScheme_(path) != null) ? path : path.split(FS).map(decodeURIComponent).join(FS);
    }
    /// @param path A decoded absolute or relative filepath.
    private static _humanPath(path: string): string {
        return this._humanesc(path, An._PATHPART_ILLEGALS);
    }
    private static _humanesc(segment: string, illegals: number[]): string {
        let b: StringBuffer | null = null;
        let start = 0;
        let len = segment.length;
        for (let i = 0; i < len; ++i) {
            let c = segment.codePointAt(i) ?? 0;
            if (illegals.includes(c) || c < 0x20 || c >= 0x7f && !An.isHuman_(c)) {
                if (b == null) {
                    b = new StringBuffer();
                }
                if (start < i) {
                    b.write_(segment.substring(start, i));
                }
                start = i + 1;
                if (c <= 0xff) {
                    b.write_("%");
                    b.write_(An.to02X_(c));
                } else {
                    for (let n of An.textEncoder$.encode(String.fromCodePoint(c))) {
                        b.write_("%");
                        b.write_(An.to02X_(n));
                    }
                }
            }
        }
        if (b == null) return segment;
        if (start < len) b.write_(segment.substring(start, len));
        return b.toString();
    }

    constructor(
        private _filepath: string,
        private _search: string,
        private _hash: string,
    ) { }
    get isEmpty$(): boolean {
        return this._filepath.length == 0 && this._search.length == 0 && this._hash.length == 0;
    }
    get isAbsolute$(): boolean {
        return this._filepath.startsWith(FS) || An.dataUrlScheme_(this._filepath) != null;
    }
    get filepath$(): string {
        return this._filepath;
    }
    /// @return The short human form with human filename, search and hash.
    get human$(): string {
        return An.dataUrlDesc_(this._filepath) ?? HumanLink._humanPath(Basepath.filename_(this._filepath)) + this._search + this._hash;
    }
    /// @return The long human form with human filepath, search and hash.
    get humanHref$(): string {
        return HumanLink._humanPath(this._filepath) + this._search + this._hash;
    }
    changeFilepath_(filepath: string): HumanLink {
        return new HumanLink(filepath, this._search, this._hash);
    }
    changeFromInput_(input: AnInputElement): HumanLink {
        const [encoded, search, hash] = UriUt.split_(input.value);
        const path = HumanLink._decodedPath(encoded);
        const ret = (path.startsWith(FS) || An.dataUrlScheme_(path) != null)
            ? new HumanLink(path, search, hash)
            : new HumanLink(Basepath.changeFilename_(this.filepath$, path), search, hash);
        ret.updateInput_(input);
        return ret;
    }
    updateInput_(input: AnInputElement): void {
        input.setAttribute(ATTR.AnInfo, this.toJSON_());
        input.value = this.human$;
    }
    toJSON_(): string {
        return JSON.stringify([this._filepath, this._search, this._hash]);
    }
    toString(): string {
        return this.humanHref$;
    }
}

class An {

    static textEncoder$ = new TextEncoder();

    private static _gradients = [
        "linear-gradient",
        "radial-gradient",
        "radial-gradient",
        "radial-gradient",
        "repeating-linear-gradient",
        "repeating-radial-gradient",
        "repeating-radial-gradient",
        "repeating-radial-gradient",
    ];

    static error_(msg: string): void {
        console.log(msg);
    }

    static notXX_(a: any | null | undefined): boolean {
        return a !== null && a !== undefined;
    }

    static parseJSONObjectOrNull_(json: stringXX): JSONObjectX {
        if (json === null || json === undefined) return null;
        try {
            return JSON.parse(json);
        } catch (e) {
            return null;
        };
    }

    static parseJSONArrayOrNull_<T>(json: stringXX): ArrayX<T> {
        if (json === null || json === undefined) return null;
        try {
            const ret = JSON.parse(json);
            return (ret instanceof Array) ? ret : null;
        } catch (e) {
            return null;
        };
    }

    static parseJSONOrNull_(json: stringXX): any | null {
        if (json === null || json === undefined) return null;
        try {
            return JSON.parse(json);
        } catch (e) {
            return null;
        };
    }

    static setDatetime(elm: HTMLElement, dateformatter: _PlaceholderDateFormatter) {
        elm.classList.add(CSS.xDate);
        elm.setAttribute(
            ATTR.xDateFormat,
            An.xDateFormatValue_(dateformatter.dateformat, dateformatter.timeformat, dateformatter.now));
        elm.textContent = dateformatter.datestring;
    }

    ///**
    ///// @return hex value of character c, eg. return 10 for "a".

    static errorResult_(callback: JSONCallback, errors: any): void {
        callback(smap1_(Key.errors, errors));
    }

    static okResult_(callback: JSONCallback): void {
        callback(smap1_(Key.result, {}));
    }

    static to02d_(n: Int): string {
        return n.toFixed(0).padStart(2, "0");
    }

    static to2d_(n: Int): string {
        return n.toFixed(0).padStart(2, "\u00a0");
    }

    static to03d_(n: Int): string {
        return n.toFixed(0).padStart(3, "0");
    }

    static to04d_(n: Int): string {
        return n.toFixed(0).padStart(4, "0");
    }

    //// NOTE that AnUri.parse() produce escapes in %XX instead of %xx.
    //// For consistency, use upper case for URI escapes.
    static to02X_(n: Int): string {
        if (n >= 0) {
            if (n < 16) {
                return _H02[n];
            }
            if (n < 256) {
                return _HEX[n >> 4] + _HEX[n & 0xf];
            }
        }
        //// Unfortunately, toString() returns lower cases.
        return n.toString(16).toUpperCase();
    }

    /// @return ms since epoch.
    static now_(): number {
        return DateTime.now_().millisecondsSinceEpoch$;
    }

    /// @return DateTime.now() with second field as 00.
    static now00_(): DateTime {
        return An.now01_(DateTime.now_());
    }

    static now01_(now: DateTime): DateTime {
        return DateTime.fromMs_(((now.millisecondsSinceEpoch$ / 60000) * 60000));
    }

    /// @return A date string in form yyyymmdd.
    static today_(): string {
        let now = DateTime.now_();
        let year = An.to04d_(now.year$);
        let month = An.to02d_(now.month$);
        let day = An.to02d_(now.day$);
        return year + month + day;
    }

    static xDateFormatValue_(dateformat: string, timeformat: string, date: DateTime): string {
        return this.xDateFormatMs_(dateformat, timeformat, date.millisecondsSinceEpoch$);
    }

    static xDateFormatMs_(dateformat: string, timeformat: string, ms: Long | null = null): string {
        return `${dateformat};${timeformat};${ms == null ? "" : ms};${settings$.dateFormat_()};${settings$.timeFormat_()}`;
    }

    static splitDatetimeXFormat_(format: stringX): string[] {
        return (format == null || format.length == 0) ? [] : format.split(";");
    }

    static replaceDatetimeString_(elm: HTMLElement, formatted: string) {
        const text = elm.textContent;
        if (text != null) {
            if (elm.classList.contains(CSS.xBulletDatetime)) {
                formatted = replaceAll_(formatted, " ", "\u00a0");
            }
            const m = new RegExp("^.*?(\\s*)\$").exec(text);
            if (m != null) {
                formatted = formatted + m[1];
            }
            elm.textContent = formatted;
        }
    }

    /// Show date in full date or short date format.
    static autoDateString_(now: DateTime, datetime: DateTime | null): string {
        const lastyear = DateTime.local_(now.year$ - 1, now.month$, now.day$, now.hour$, now.minute$, now.second$);
        return An.autoDateString2_(lastyear, now, datetime);
    }

    /// Show date in full date or short date format.
    static autoDateString2_(lastyear: DateTime, now: DateTime, datetime: DateTime | null): string {
        if (datetime == null) {
            return "";
        }
        if (!datetime.isAfter_(now) && datetime.isAfter_(lastyear)) {
            return DateFormat.dateString_(settings$.shortDateFormat_(), datetime);
        }
        return DateFormat.dateString_(settings$.dateFormat_(), datetime);
    }

    /// Show date string padded at start by \u00a0 in year, short date or time format.
    static autoFileDatetimeString2_(lastyear: DateTime, yesterday: DateTime, now: DateTime, datetime: DateTime | null = null): string {
        return (() => {
            if (datetime == null) {
                return "";
            }
            if (!datetime.isAfter_(now)) {
                if (datetime.isAfter_(yesterday)) {
                    return TimeFormat.timeString_(TimeFormat.get24HoursFormat_(settings$.timeFormat_()), datetime);
                }
                if (datetime.isAfter_(lastyear)) {
                    return DateFormat.dateString_(settings$.shortDateFormat_(), datetime);
                }
            }
            return An.to04d_(datetime.year$);
        })().padStart(6, "\u00a0");
    }

    static datetimeString_(dateformat: string, timeformat: string, date: DateTime): string {
        let datestring = DateFormat.dateString_(dateformat, date);
        if (dateformat == "auto") return datestring;
        let timestring = TimeFormat.timeString_(timeformat, date);
        return An.joinNotEmpty_(" ", [datestring, timestring]);
    }

    /// @return A date string in form yyyymmdd.
    static simpleDateString_(date?: DateTime): string {
        if (date === null || date === undefined) {
            date = DateTime.now_();
        }
        let year = An.to04d_(date.year$);
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        return year + month + day;
    }

    /// @return A date string in form yyyymmdd-hhmmss.
    static simpleDateTimeString_(date?: DateTime): string {
        if (date == undefined) {
            date = DateTime.now_();
        }
        let year = An.to04d_(date.year$);
        let month = An.to02d_(date.month$);
        let day = An.to02d_(date.day$);
        let hour = An.to02d_(date.hour$);
        let minute = An.to02d_(date.minute$);
        let second = An.to02d_(date.second$);
        return year + month + day + "-" + hour + minute + second;
    }

    static ms_(): number {
        return DateTime.now_().millisecondsSinceEpoch$;
    }

    static msString_(date: DateTime | null = null): string {
        return (date ?? DateTime.now_()).millisecondsSinceEpoch$.toString();
    }

    /// @return hhmmss.
    static simpleTimeString_(date: DateTime): string {
        let hour = An.to02d_(date.hour$);
        let minute = An.to02d_(date.minute$);
        let second = An.to02d_(date.second$);
        return `${hour}${minute}${second}`;
    }

    static isSameDay_(now: DateTime, date: DateTime): boolean {
        return (date.day$ == now.day$ &&
            date.month$ == now.month$ &&
            date.year$ == now.year$);
    }

    static tostring_<T>(a: any, def: T): T {
        return a == null ? def : a.toString();
    }

    /**
     * Simulate unix file size reporting with 1024 as divider and truncate up.
     * @return Size unit with at most 4 digits.
     */
    static filesizeUnit4_(size: number): string {
        return An._valueunit(DEF.FILESIZE_UNITS, 10000, 1024, 1023, size);
    }

    /**
     * @return Size unit with at most 4 digtis, 1000 as divider and round up, eg. 1234 k.
     */
    static decUnit4_(value: number): string {
        return An._valueunit(DEF.DECIMAL_VALUE_UNITS, 10000, 1000, 555, value);
    }

    static toCommaSeparatedString(value: Long): string {
        let v = value < 0 ? -value : value;
        let s = (v == 0 ? "0" : "");
        while (v > 0) {
            const d = v % 1000;
            v = Math.trunc(v / 1000);
            s = (v > 0 ? An.to03d_(d) : d.toString()) + (s.length > 0 ? "," : "") + s;
        }
        return value < 0 ? "-" + s : s;
    }

    private static _valueunit(units: string[], max: number, divider: number, rounding: number, value: number): string {
        const len = units.length;
        let unit = 0;
        for (; unit < len - 1; ++unit) {
            if (value < max) {
                break;
            }
            value = Math.trunc((value + rounding) / divider);
        }
        return `${value.toFixed(0)} ${units[unit]}`;
    }

    static timeStringFromSeconds_(seconds: Int): string {
        let sec = Math.round(seconds);
        if (sec < 60) {
            return `00:${An.to02d_(sec)}`;
        }
        let min = Math.floor(sec / 60);
        sec -= min * 60;
        if (min < 60) {
            return `${An.to02d_(min)}:${An.to02d_(sec)}`;
        }
        let hours = Math.floor(min / 60);
        min -= hours * 60;
        return `${hours}:${An.to02d_(min)}:${An.to02d_(sec)}`;
    }

    static timeStringFromMs_(ms: number): string {
        let time = Math.round(ms / 1000);
        let sec = time % 60;
        time = Math.floor(time / 60);
        let min = time % 60;
        let hour = Math.floor(time / 60);
        if (hour > 0) {
            return `${An.to02d_(hour)}:${An.to02d_(min)}:${An.to02d_(sec)}`;
        }
        return `${An.to02d_(min)}:${An.to02d_(sec)}`;
    }

    /// @return size in bytes, where K is1024 and k is 1000.
    static fromIntUnit_(sizeunit: IntUnit | null, def: number): number {
        if (sizeunit == null) { return def; }
        const size = sizeunit[0];
        const unit = sizeunit[1];
        switch (unit) {
            case "":
            case "b":
            case "B":
                return size;
            case "K":
            case "KB":
                return size * K;
            case "M":
            case "MB":
                return size * K * K;
            case "G":
            case "GB":
                return size * K * K * K;
            case "k":
            case "kb":
                return size * 1000;
            case "m":
            case "mb":
                return size * 1000 * 1000;
            case "g":
            case "gb":
                return size * 1000 * 1000 * 1000;
        }
        return def;
    }

    /// @return duration in ms.
    static msFromStringTimeUnit_<T>(value: string | null, def: T): Long | T {
        return this.msFromDoubleTimeUnit_(this.doubleValueUnit_(value), def);
    }

    /// @return duration in ms.
    static msFromDoubleTimeUnit_<T>(timeunit: DoubleUnit | null, def: T): Long | T {
        if (timeunit == null) return def;
        const duration = timeunit[0];
        let u = timeunit[1].toLowerCase();
        switch (u) {
            case "":
            case "ms":
                return Math.floor(duration);
            case "s":
            case "sec":
            case "sec.":
            case "second":
                return Math.floor((duration * 1000));
            case "m":
            case "min":
            case "min.":
            case "minute":
                return Math.floor((duration * 1000 * 60));
            case "h":
            case "hr":
            case "hr.":
            case "hour":
                return Math.floor((duration * 1000 * 60 * 60));
            case "d":
            case "day":
                return Math.floor((duration * 1000 * 60 * 60 * 24));
        }
        if (MSG.string_(RS.ms) == u) {
            return Math.floor(duration);
        }
        if (MSG.string_(RS.sec) == u) {
            return Math.floor((duration * 1000));
        }
        if (MSG.string_(RS.min) == u) {
            return Math.floor((duration * 1000 * 60));
        }
        if (MSG.string_(RS.hour) == u) {
            return Math.floor((duration * 1000 * 60 * 60));
        }
        if (MSG.string_(RS.day) == u) {
            return Math.floor((duration * 1000 * 60 * 60 * 24));
        }
        return def;
    }

    /// See Uri.from().
    static uriFrom_(
        baseurl: BaseUriX,
        path: UriPathPart,
        search: UriSearchPart = "",
        hash = "",
    ): Uri {
        return Uri.from_(path, search, hash, baseurl == null ? undefined : baseurl);
    }

    /// See Uri.parse().
    static parseUri_(href: string, baseurl: BaseUriX): Uri {
        return Uri.parse_(href, baseurl);
    }

    /// @return null if path is null, or Uri invalid.
    static uriFromSafe_(
        baseurl: BaseUriX,
        path: UriPathPartX,
        search: UriSearchPart = "",
        hash = "",
    ): UriX {
        if (path == null) { return null; }
        try {
            return An.uriFrom_(baseurl, path, search, hash);
        } catch (e: any) {
            
            return null;
        }
    }

    /// @return null if input is null, or invalid.
    static parseUriSafe_(href: stringXX, baseurl: BaseUriX): UriX {
        if (href === null || href === undefined) { return null; }
        try {
            //// NOTE: Uri.parse() recoganize [] as delimiter for ipv6 host.
            //// Since this app. only allow localhost as the host, there should not be any ipv6 hosts.
            return An.parseUri_(href, baseurl);
        } catch (e: any) {
            
            return null;
        }
    }

    /// Like An.parseUriSafe() but warner.warn(string) on invalid uri.
    static parseUriAndWarn_(href: stringXX, baseurl: BaseUriX, warner: IWarner): UriX {
        if (href === null || href === undefined) { return null; }
        try {
            return An.parseUri_(href, baseurl);
        } catch (e: any) {
            warner.warn_(`${e}`);
            return null;
        }
    }

    static cpathOfUri_(uri: Uri): string {
        return uri.toAbsolute_().path$;
    }

    static cdirOfUri_(uri: UriX): stringX {
        return uri == null ? null : Basepath.dir_(uri.toAbsolute_().path$);
    }

    static cpathOfHref2_(baseuri: BaseUriX, href: stringX): stringX {
        const uri = An.parseUriSafe_(href, baseuri);
        return uri == null ? null : this.cpathOfUri_(uri);
    }

    static cpathOfFilepath2_(basedir: stringX | Uri, filepath: string): string {
        let cleanpath = Basepath.cleanFilepath_(filepath);
        if (cleanpath.startsWith(FS)) { return cleanpath; }
        const basedir1 = (typeof basedir !== "string") ? (basedir == null ? null : Basepath.dir_(basedir.path$)) : basedir;
        return Basepath.cleanFilepath_(Basepath.joinPath_(basedir1, cleanpath));
    }

    static uriOfFilepath2_(baseuri: BaseUriX, filepath: string, search: UriSearchPart = "", hash: string = ""): UriX {
        return An.uriFromSafe_(baseuri, filepath.split(FS), search, hash);
    }

    /// @param basedir An absolute base directory path.
    /// @param filepath A absolute filepath, relative paths would be taken as absolute.
    /// @return A relative path relative to the base directory or the directory of the base Uri.
    static rpath2_(basedir: stringX, filepath: string): string {
        if (basedir == null) return filepath;
        return Basepath.rpath_(
            this.ensureLeadingSlash_(Basepath.cleanFilepath_(basedir)),
            this.ensureLeadingSlash_(Basepath.cleanFilepath_(filepath)));
    }

    static uriFragment_(uri: Uri): stringX {
        return An.isempty_(uri.hash$) ? null : uri.hash$;
    }

    static updateMediaParams_(elm: HTMLMediaElement) {
        const info = An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.xInfo)) ?? json_();
        info[XInfoKey.seek] = elm.currentTime;
        elm.setAttribute(ATTR.xInfo, JSON.stringify(info));
    }

    static getMediaParams_(elm: HTMLMediaElement): JSONObject {
        return An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.xInfo)) ?? json_();
    }

    static setMediaParams_(elm: HTMLMediaElement, seek: Double, poster: DoubleX = null) {
        const xinfo = An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.xInfo)) ?? json_();
        elm.currentTime = seek;
        xinfo[XInfoKey.seek] = seek;
        if (poster != null) {
            xinfo[XInfoKey.poster] = poster;
        }
        elm.setAttribute(ATTR.xInfo, JSON.stringify(xinfo));
    }

    /**
     * Escape the given filepath which may contains character that cause Uri.parse() to fail.
     * Currently this escape ?#%[];.
     */
    static escFilepathForUri_(filepath: string): string {
        let b = "";
        let start = 0;
        let len = filepath.length;
        for (let i = 0; i < len; ++i) {
            let c = filepath.codePointAt(i);
            if (c == DEF.QUERY ||
                c == DEF.FRAGMENT ||
                c == DEF.PERCENT ||
                c == DEF.LBRACKET ||
                c == DEF.RBRACKET ||
                c == DEF.SEMICOLON) {
                if (start < i) b += filepath.substring(start, i);
                start = i + 1;
                b += "%";
                b += An.to02X_(c);
            }
        }
        if (start == 0) return filepath;
        if (start < len) b += filepath.substring(start, len);
        return b;
    }

    private static _famap = new Map<string, string>([
        ["fa", CSS.Fa],
        ["fa-arrows-h", CSS.FaArrowsH],
        ["fa-arrows-v", CSS.FaArrowsV],
        ["fa-barcode", CSS.FaBarcode],
        ["fa-bell-o", CSS.FaBellO],
        ["fa-camera", CSS.FaCamera],
        ["fa-comment-o", CSS.FaCommentO],
        ["fa-cut-not-marked", CSS.FaCutNotMarked],
        ["fa-cut-marked", CSS.FaCutMarked],
        ["fa-dollar", CSS.FaDollar],
        ["fa-expand", CSS.FaExpand],
        ["fa-eye-slash", CSS.FaEyeSlash],
        ["fa-file-image-o", CSS.FaFileImageO],
        ["fa-hashtag", CSS.FaHashtag],
        ["fa-minus", CSS.FaMinus],
        ["fa-spinner", CSS.FaSpinner],
        ["fa-square", CSS.FaSquare],
        ["fa-square-o", CSS.FaSquareO],
        ["fa-times-circle", CSS.FaTimesCircle],
        ["x-fa-cut-not-marked", CSS.FaCutNotMarked],
        ["x-fa-cut-marked", CSS.FaCutMarked],
        ["x-hide-in-desktop", CSS.AnHideInDesktop],
        ["x-disabled-in-desktop", Conf.isMobile$ ? "" : CSS.AnDisabled],
    ]);

    static famap_(classes: stringX): stringX {
        return With.notnull_(classes, (c) =>
            c.split(RX.Space).map((cc) =>
                An._famap.get(cc) ?? null).filter((ccc) =>
                    ccc != null).join(" ")
        );
    }

    ///**

    static isLinebreak_(c: number | undefined): boolean {
        return c !== undefined && _LINEBREAKS.indexOf(c) >= 0;
    }

    static isWhitespace_(c: number | undefined): boolean {
        return c !== undefined && _WHITESPACES.indexOf(c) >= 0;
    }

    static isSpace_(c: number | undefined): boolean {
        return c !== undefined && _SPACES.indexOf(c) >= 0;
    }

    static skipSpaces_(value: string, start: number, end: number): number {
        while (start < end && An.isSpace_(value.codePointAt(start))) {
            ++start;
        }
        return start;
    }

    static rskipSpaces_(value: string, start: number, end: number): number {
        while (end > start && An.isSpace_(value.codePointAt(end - 1))) {
            --end;
        }
        return end;
    }

    static skipWhitespaces_(value: string, start: number, end: number): number {
        while (start < end && An.isWhitespace_(value.codePointAt(start))) {
            ++start;
        }
        return start;
    }

    static rskipWhitespaces_(value: string, start: number, end: number): number {
        while (end > start && An.isWhitespace_(value.codePointAt(end - 1))) {
            --end;
        }
        return end;
    }

    static skipNonWhitespaces_(value: string, start: number, end: number): number {
        while (start < end && !An.isWhitespace_(value.codePointAt(start))) {
            ++start;
        }
        return start;
    }

    static trimLeftSpaces_(value: string): string {
        let start = An.skipSpaces_(value, 0, value.length);
        if (start == 0) {
            return value;
        }
        return value.substring(start);
    }

    static trimQuots(value: string): string {
        if (value.startsWith("\"") && value.endsWith("\"")
            || value.startsWith("'") && value.endsWith("'")
        ) return value.substring(1, value.length - 1);
        return value;
    }

    static isXmlNameStart_(c: number, s: string): boolean {
        return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:_".includes(s) ||
            c >= 0x00C0 && c <= 0x00D6 ||
            c >= 0x00D8 && c <= 0x00F6 ||
            c >= 0x00F8 && c <= 0x02FF ||
            c >= 0x0370 && c <= 0x037D ||
            c >= 0x037F && c <= 0x1FFF ||
            c >= 0x200C && c <= 0x200D ||
            c >= 0x2070 && c <= 0x218F ||
            c >= 0x2C00 && c <= 0x2FEF ||
            c >= 0x3001 && c <= 0xD7FF ||
            c >= 0xF900 && c <= 0xFDCF ||
            c >= 0xFDF0 && c <= 0xFFFD;
    }

    static isXmlName_(c: number, s: string): boolean {
        return An.isXmlNameStart_(c, s) ||
            "0123456789-.\u00B7".includes(s) ||
            c >= 0x0300 && c <= 0x036F ||
            c >= 0x203F && c <= 0x2040;
    }

    static pathQueryFragment_(uri: Uri): Uri {
        return uri;
    }

    static _PATHPART_ILLEGALS = Ut.charcodes_("[]?#%\\") as Int[];
    static _PATH_SEGMENT_ILLEGALS = Ut.charcodes_("[]?#%/\\") as Int[];
    static _QUERY_ILLEGALS = Ut.charcodes_("[]?#%=&\\") as Int[];
    static _FRAGMENT_ILLEGALS = Ut.charcodes_("[]?#%\\") as Int[];

    static _makequery(query: Map<string, string>): string {
        let ret = new StringBuffer();
        let first = true;
        [...query].forEach((pair) => {
            if (first) {
                first = false;
            } else {
                ret.write_("&");
            }
            ret.write_(pair[0]);
            let value = pair[1];
            if (value != null && value.length > 0) {
                ret.write_("=");
                ret.write_(value);
            }
        });
        return ret.toString();
    }

    static toDataUrl_(mime: string, base64: string): string {
        return "data:" + mime + ";base64," + base64;
    }

    static toJpegDataUrl_(base64: string): string {
        return "data:image/jpeg;base64," + base64;
    }

    static dataUrlScheme_(href: string): stringX {
        if (href.startsWith("data:")) return "data:";
        return null;
    }

    static dataUrlMime_(href: string): stringX {
        if (!href.startsWith("data:")) return null;
        const index = href.indexOf(";");
        if (index <= 5) return null;
        return href.substring(5, index);
    }

    static dataUrlDesc_(href: string): stringX {
        const datascheme = An.dataUrlScheme_(href);
        if (datascheme == null) return null;
        return datascheme + " ...";
    }

    static jsonError_(id: string, ...args: string[]): StringMap<TestResult> {
        const msg = [MSG.string_(id), ...args];
        return smap1_(Key.errors, msg);
    }

    static result_(msg: TestResult): string | string[] | null {
        if (msg == null) return null;
        if (typeof (msg) === "string") return msg;
        if (msg instanceof Array) return msg.length > 0 ? msg : null;
        if (typeof (msg) === "object") return An.result_(msg[Key.errors] ?? null);
        return MSG.string_(RS.AssertExpectingStringListOrMap_);
    }

    static resultList_(msg: TestResult): string[] {
        return this.resultListOfKey_(msg, Key.errors);
    }

    static resultListOfKey_(msg: TestResult, key: string): string[] {
        if (msg === null) return [];
        if (typeof (msg) === "string") return [msg];
        if (msg instanceof Array) return msg;
        if (typeof (msg) === "object") return An.resultList_(msg[key] ?? null);
        return [];
    }

    static hasResult_(msg: TestResult): boolean {
        return this.result_(msg) != null;
    }

    static warnsList_(msg: TestResult): string[] {
        if (msg == null) return [];
        if (typeof (msg) === "string") return [msg];
        if (msg instanceof Array) return msg;
        if (typeof (msg) === "object") return An.warnsList_(msg[Key.warns] ?? null);
        return [MSG.string_(RS.AssertExpectingStringListOrMap_)];
    }

    static getBool_(jsonobject: Map<string, any>, key: string): boolean {
        let value = jsonobject.get(key);
        return value != null && value == true;
    }

    static getInt_(jsonobject: Map<string, any>, key: string, def: number): number {
        let value = jsonobject.get(key);
        return value != null ? value : def;
    }

    static isTrue_(value: boolean): boolean {
        return value != null && value == true;
    }

    static keysLength(a: JSONObject): Int {
        return Object.keys(a).length;
    }

    static rangeStart_(range: Range): Node | null {
        if (range == null) return null;
        let c = range.startContainer;
        if (c.nodeType == Node.ELEMENT_NODE) {
            return c.childNodes[range.startOffset];
        }
        return c;
    }

    static rangeEnd_(range: Range): Node | null {
        if (range == null) return null;
        let c = range.endContainer;
        if (c.nodeType == Node.ELEMENT_NODE) {
            return c.childNodes[range.endOffset];
        }
        return c;
    }

    static identityIndex_(child: Node): number {
        let children = child.parentNode?.childNodes;
        if (children != null) {
            for (let i = 0, len = children.length; i < len; ++i) {
                if (children[i] === child) { return i; }
            }
        }
        throw Assert.notReach_(`${MSG.string_(RS.AssertIndexOfNodeNotFound_)}${child}`);
    }

    static identityIndexOf_(list: Object[], needle: Object): numberX {
        for (let i = 0, len = list.length; i < len; ++i) {
            if (list[i] === needle) { return i; }
        }
        return null;
    }

    static identityContains_(list: Object[], a: Object): boolean {
        for (let i = 0, len = list.length; i < len; ++i) {
            if (list[i] === a) { return true; }
        }
        return false;
    }

    static identityRemove_(list: Object[], a: Object): boolean {
        for (let i = 0, len = list.length; i < len; ++i) {
            if (list[i] === a) {
                list.splice(i, 1);
                return true;
            }
        }
        return false;
    }

    static identityAdd_(list: Object[], a: Object): boolean {
        for (let i = 0, len = list.length; i < len; ++i) {
            if (list[i] === a) { return false; }
        }
        list.push(a);
        return true;
    }

    /*
     * Similar to node.textContent, but add spaces at node boundaries. For example: a<div>b</div> returns "a b"
     */
    static getTextContent_(ret: StringBuffer, node: Node): StringBuffer {
        for (let c = node.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType == Node.ELEMENT_NODE) {
                ret.write_(" ");
                An.getTextContent_(ret, c);
                ret.write_(" ");
            } else {
                ret.write_(c.textContent ?? "");
            }
        }
        return ret;
    }

    /// Collapse all spaces into a single space character and trim leading and trailing spaces.
    static normalizeTextContent_(text: string): string {
        return text.replace(RX.Spaces_g, " ").trim();
    }

    static createRange_(node: Node): Range {
        let doc = node.ownerDocument;
        let range = doc!.createRange();
        range.selectNode(node);
        return range;
    }

    /// Create a list of int using the given ranges [[start, end, step]...]
    static createStringList1_(ranges: Array<Array<number>>): string[] {
        return An.createStringList_([], ranges);
    }

    /// Create a list of int using the given ranges [[start, end, step]...]
    static createStringList_(ret: string[], ranges: Array<Array<number>>): string[] {
        for (let range of ranges) {
            let end = range[1];
            let step = range[2];
            for (let i = range[0]; i < end; i += step) {
                ret.push(i.toString());
            }
        }
        return ret;
    }

    /// Create a list of int using the given ranges [[start, end, step]...]
    static createIntList_(ret: number[], ranges: Array<Array<number>>): number[] {
        for (let range of ranges) {
            let end = range[1];
            let step = range[2];
            for (let i = range[0]; i < end; i += step) {
                ret.push(i);
            }
        }
        return ret;
    }

    static binarySearchInt1_(array: number[], key: number): number {
        return An.binarySearchInt_(array, 0, array.length, key);
    }

    /**
     * @return The index of the given value, -(index+1) if not found.
     */
    static binarySearchInt_(array: number[], start: number, end: number, value: number): number {
        --end;
        while (start <= end) {
            let mid = (start + end) >> 1;
            if (array[mid] < value) {
                start = mid + 1;
            } else if (array[mid] > value) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        return -(start + 1);
    }

    /**
     * Search for the given value.
     * @return The value found or the next existing value.
     */
    static binarySearchIntValue_(array: number[], start: number, end: number, value: number): number {
        let index = An.binarySearchInt_(array, start, end, value);
        if (index < 0) {
            index = -index - 1;
        }
        if (index < 0) {
            index = 0;
        }
        if (index >= array.length) {
            index = array.length - 1;
        }
        return array[index];
    }

    /**
     * @param comparator (T value) return -1 if key is less then value.
     * @return index >= 0 if found, otherwise -ret-1 would be the insertion index. ie a[ret-1] < key < a[ret]
     */
    static binarySearcher_<T>(array: T[], start: number, end: number, comparator: Function): number {
        --end;
        while (start <= end) {
            let mid = (start + end) >> 1;
            let ret = comparator(array[mid]);
            if (ret < 0) {
                start = mid + 1;
            } else if (ret > 0) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        return -(start + 1);
    }

    static compareNullable_<V>(a: V | null, b: V | null, compare: (a: V, b: V) => number) {
        if (a == null) return b == null ? 0 : -1;
        if (b == null) return 1;
        return compare(a, b);
    }

    /**
      * @param needle The filtertext characters as a list of String.
      * @return true if s contains the filtertext.
      */
    static fuzzyMatch_(needle: string, haystack: string): boolean {
        const needles = Ut.codepoints_(needle);
        return this.fuzzyMatch1_(needles, haystack);
    }

    static fuzzyMatch1_(needles: Array<number | undefined>, haystack: string): boolean {
        const haystacks = Ut.codepoints_(haystack);
        let start = 0;
        let length = haystacks.length;
        for (let c of needles) {
            if (start >= length) return false;
            let index = haystacks.indexOf(c, start);
            if (index < 0) return false;
            start = index + 1;
        }
        return true;
    }

    static intArrayCopy_(to: number[], from: number[]): number[] {
        for (let i = 0, len = from.length; i < len; ++i) {
            to.push(from[i]);
        }
        return to;
    }

    static ifnull_<T>(value: T | null, def: T): T {
        return (value == null ? def : value);
    }

    static ifempty_(value: stringX, yes: string, no: string): string {
        return An.isempty_(value) ? yes : no;
    }

    static isempty_(value: stringXX): boolean {
        return value === null || value === undefined || value.length == 0;
    }

    static notempty_(value: stringXX): boolean {
        return value !== null && value !== undefined && value.length > 0;
    }

    static isGradient_(value: string): boolean {
        return RX.Gradients.test(value);
    }

    static gradient_(index: Int): stringX {
        return (index >= 0 && index < this._gradients.length) ? this._gradients[index] : null;
    }

    static gradientKindOf(name: string, def: Int): Int {
        const ret = this._gradients.indexOf(name);
        return ret < 0 ? def : ret;
    }

    static optionalStyle_(styles: Map<string, string>, name: string, value: string): void {
        if (!An.isempty_(value)) {
            styles.set(name, value);
        }
    }

    static removeEmptyValues_(map: Map<string, string>): void {
        for (let [key, value] of map.entries()) {
            if (value == null || value.length == 0) {
                map.delete(key);
            }
        }
    }

    static removeEmptyValues1_(map: SStringMap): void {
        for (let [key, value] of Object.entries(map)) {
            if (value == null || value.length == 0) {
                delete map[key];
            }
        }
    }

    /**
     * @param def Default value on error in ms.
     * @return time in ms.
     */
    static parseTime_<T>(s: stringX, def: T): number | T {
        if (s == null || s.length == 0) {
            return def;
        }
        let ret = -1;
        if (s.endsWith("ms")) {
            ret = parseInt(s.substring(0, s.length - 2).trim(), -1);
        } else if (s.endsWith("s")) {
            ret = parseInt(s.substring(0, s.length - 1).trim(), -1) * 1000;
        }
        return ret >= 0 ? ret : def;
    }

    static parseIntPercent_<T>(s: stringXX, def: T): number | T {
        let ret = An.parseDoublePercent_(s, null);
        return (ret == null ? def : Math.floor(ret));
    }

    static parseDoublePercent_<T>(s: stringXX, def: T): number | T {
        if (s === null || s === undefined || !s.endsWith("%")) {
            return def;
        }
        return An._parseDouble1_(s.substring(0, s.length - 1), def);
    }

    static parseIntPx_<T>(s: stringXX, def: T): number | T {
        let ret = An.parseDoublePx_(s, null);
        return (ret == null ? def : Math.floor(ret));
    }

    static parseDoublePx_<T>(s: stringXX, def: T): number | T {
        if (s == null || s === undefined || !s.endsWith("px")) {
            return def;
        }
        return An.parseDouble_(s.substring(0, s.length - 2), def);
    }

    /**
     * @param value SizeUnit string. Size must be positive integer without any +/- prefix.
     * @return null if value is not in SizeUnit format.
     */
    static splitSizeUnit_(value: stringX): [size: string, unit: string] | null {
        if (value != null && value.length > 0) {
            let m = RX.SizeUnit.exec(value);
            if (m != null && m.length == 3) {
                let size = m[1];
                let unit = m[2].trim();
                return [size, unit];
            }
        }
        return null;
    }

    /**
     * @param value SizeUnit string. Size must be positive integer without any +/- prefix.
     * @return null if value is not in SizeUnit format.
     */
    static parseIntUnit_(value: stringX): IntUnit | null {
        if (value != null && value.length > 0) {
            let m = RX.ValueUnit.exec(value);
            if (m != null && m.length == 3) {
                let size = m[1];
                let unit = m[2].trim();
                let value = parseInt(size);
                if (!isNaN(value)) {
                    return [value, unit];
                }
            }
        }
        return null;
    }

    /**
     * @param value SizeUnit string. Size must be a positive double without +/- prefix.
     * @return null if value is not in SizeUnit format.
     */
    static doubleSizeUnit_(value: stringX): DoubleUnit | null {
        return An.doubleUnitMatching_(RX.SizeUnit, value);
    }

    static doubleStringSizeUnit_(value: stringX): DoubleStringUnit | null {
        const sizeunit = this.doubleSizeUnit_(value);
        if (sizeunit == null) return null;
        const size = sizeunit[0];
        const isint = size == Math.round(size);
        return [`${isint ? size.toFixed(0) : size.toFixed(2)}`, sizeunit[1]];
    }

    /**
     * @param value ValueUnit string. Value must be a double with optional +/- prefix.
     * @return null if value is not in ValueUnit format.
     */
    static doubleValueUnit_(value: stringX): DoubleUnit | null {
        return An.doubleUnitMatching_(RX.ValueUnit, value);
    }

    /// @return null if value is not in sizeunit format.
    static doubleUnitMatching_(regex: RegExp, value: stringX): DoubleUnit | null {
        if (value != null && value.length > 0) {
            let m = regex.exec(value);
            if (m != null && m.length == 3) {
                let size = m[1];
                let unit = m[2].trim();
                let value = An.parseDouble_(size, null);
                if (value != null) {
                    return [value, unit];
                }
            }
        }
        return null;
    }

    static parseInt_<T>(s: stringXX, def: T): T | number {
        if (s === null || s === undefined || s.length == 0) return def;
        return An._parseInt1(s, def);
    }

    private static _parseInt1<T>(s: string, def: T): T | number {
        try {
            let ret = Number.parseInt(s);
            return Number.isNaN(ret) ? def : ret;
        } catch (e) {
            return def;
        }
    }

    static parseWxh_(s: stringXX, def: [Int, Int]): [Int, Int] {
        if (s === null || s === undefined || s.length == 0) return def;
        return With.notnull_(RX.WxH.exec(s), (match) => {
            const w = An.parseInt_(match[1], 0);
            const h = An.parseInt_(match[2], 0);
            return [w, h];
        }) ?? def;
    }

    /// Parse a double value and round it to an integer.
    static parseRounded_(s: stringX, def: number): number {
        if (s == null || s.length == 0) return def;
        try {
            let ret = Number.parseFloat(s);
            return Number.isNaN(ret) ? def : Math.round(ret);
        } catch (e) {
            return def;
        }
    }

    static parseDouble_<T>(s: stringX, def: T): number | T {
        if (s == null || s.length == 0) {
            return def;
        }
        return An._parseDouble1_(s, def);
    }

    static _parseDouble1_<T>(s: string, def: T): number | T {
        try {
            let ret = Number.parseFloat(s);
            return Number.isNaN(ret) ? def : ret;
        } catch (e) {
            return def;
        }
    }

    static parseInt1_(s: string, onerror: IntCallback0): number {
        let ret = An._parseInt1(s, null);
        return ret == null ? onerror() : ret;
    }

    static parseDouble1_(s: string, onerror: DoubleCallback0): number {
        let ret = An._parseDouble1_(s, null);
        return ret == null ? onerror() : ret;
    }

    static pairOf_<T>(value: T): [T, T] {
        return [value, value];
    }

    static diffDouble_(a: Double, b: Double): Double {
        const d = a - b;
        return d >= 0 ? d : -d;
    }

    static onValidateRequiredIntPx_(errors: string[], key: string, value: string): numberX {
        let ret = null;
        if (value.length == 0 || (ret = An.parseIntPx_(value, null)) == null) {
            errors.push(MSG.format2_(RS.invalidNameValue, key, value));
            return null;
        }
        return ret;
    }

    static onValidateRequiredInt_(errors: string[], key: string, value: string): numberX {
        let ret = null;
        if (value.length == 0 || (ret = An.parseInt_(value, null)) == null) {
            errors.push(MSG.format2_(RS.invalidNameValue, key, value));
            return null;
        }
        return ret;
    }

    static onValidateOptionalIntPx_(errors: string[], key: string, value: string): numberX {
        let ret = null;
        if (value.length > 0 && (ret = An.parseIntPx_(value, null)) == null) {
            errors.push(MSG.format2_(RS.invalidNameValue, key, value));
            return null;
        }
        return ret;
    }

    static onValidateOptionalInt_(errors: string[], key: string, value: string): numberX {
        let ret = null;
        if (value.length > 0 && (ret = An.parseInt_(value, null)) == null) {
            errors.push(MSG.format2_(RS.invalidNameValue, key, value));
            return null;
        }
        return ret;
    }

    static onValidateOptionalPositiveInt_(errors: string[], key: string, value: string): numberX {
        if (value.length == 0) return null;
        let ret = An.parseInt_(value, null);
        if (ret == null || ret <= 0) {
            errors.push(MSG.format2_(RS.invalidNameValue, key, value));
            return null;
        }
        return ret;
    }

    static dist4_(x1: number, y1: number, x2: number, y2: number): number {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }

    static dist1_<T>(a: number[], def: T): number | T {
        return (a.length >= 4) ? An.dist4_(a[0], a[1], a[2], a[3]) : def;
    }

    static distance2_(a: number[]): number {
        if (a.length >= 4) {
            let dx = a[2] - a[0];
            let dy = a[3] - a[1];
            return dx * dx + dy * dy;
        }
        return 0;
    }

    static delta_(a: number, b: number): number {
        let d = b - a;
        return d < 0 ? -d : d;
    }

    static abs_(x: number): number {
        return x >= 0 ? x : -x;
    }

    static absd_(x: number): number {
        return x >= 0 ? x : -x;
    }

    static clamp_(min: number, max: number, value: number): number {
        return value < min
            ? min
            : value > max
                ? max
                : value;
    }

    static getBounds_(ret: number[], x: number, y: number): void {
        if (x < ret[0]) {
            ret[0] = x;
        }
        if (x > ret[2]) {
            ret[2] = x;
        }
        if (y < ret[1]) {
            ret[1] = y;
        }
        if (y > ret[3]) {
            ret[3] = y;
        }
    }

    static getRect_(path: number[]): MutRect {
        let x0 = path[0];
        let y0 = path[1];
        let x1 = path[2];
        let y1 = path[3];
        let w = x1 - x0;
        let h = y1 - y0;
        if (w < 0) {
            x0 = x1;
            w = -w;
        }
        if (h < 0) {
            y0 = y1;
            h = -h;
        }
        return new MutRect(x0, y0, w, h);
    }

    /**
     * @param zindex A raw z-index value as obtained from $(elm).css("z-index").
     * @param delta
     * @return A numeric z-index value of input zindex + delta, def on error.
     */
    static adjustZIndex_<T>(zindex: number | string, delta: number, _def: T): number | T {
        if (typeof (zindex) === "string") { zindex = parseInt(zindex); }
        if (isNaN(zindex)) { return _def; }
        return zindex + delta;
    }

    /// @return A numeric z-index value of the given DOM element + delta, def on error.
    static zindexOf_<T>(host: HTMLElement, delta: number, def: T): number | T {
        let zindex = (An.getComputedStyle_(host)?.zIndex) ?? null;
        if (zindex == null) { return def; }
        return An.adjustZIndex_(zindex, delta, def);
    }

    static above_(host: HTMLElement, delta: number = DEF.zindexAbove10): number {
        return An.zindexOf_(host, delta, DEF.zindexPrompt);
    }

    static below_(host: HTMLElement, delta: number = DEF.zindexUnder): number {
        return An.zindexOf_(host, delta, DEF.zindexPrompt);
    }

    static getComputedStyle_(elm: HTMLElement): CSSStyleDeclaration | null {
        return (elm.ownerDocument.defaultView?.getComputedStyle(elm)) ?? null;
    }

    static getComputedStyle1_(elm: HTMLElement, key: string): stringX {
        const style = this.getComputedStyle_(elm);
        return style == null ? null : (style.getPropertyValue(key) ?? null);
    }

    static getComputedStyles_(elm: HTMLElement, ...keys: string[]): Map<string, string> | null {
        const style = this.getComputedStyle_(elm);
        if (style == null) { return null; }
        return new Map(keys.map((key) => {
            return [key, style.getPropertyValue(key)];
        }));
    }

    static getComputedStylesArray_(elm: HTMLElementX, ...keys: string[]): Array<string> {
        const style = (elm == null ? null : this.getComputedStyle_(elm));
        return keys.map(key => {
            return style?.getPropertyValue(key) ?? "";
        });
    }

    static setWidthHeight_(e: HTMLElement, width: number, height: number): CSSStyleDeclaration {
        let style = e.style;
        style.width = `${width}px`;
        style.height = `${height}px`;
        return style;
    }

    static setWidthLeft_(e: HTMLElement, width: number, left: number): CSSStyleDeclaration {
        let style = e.style;
        style.width = `${width}px`;
        style.left = `${left}px`;
        return style;
    }

    static setLeftTop_(e: HTMLElement, left: number, top: number): CSSStyleDeclaration {
        let style = e.style;
        style.top = `${top}px`;
        style.left = `${left}px`;
        return style;
    }

    static setRectangle_(e: HTMLElement, x: number, y: number, width: number, height: number): CSSStyleDeclaration {
        let style = e.style;
        style.left = `${x}px`;
        style.top = `${y}px`;
        style.width = `${width}px`;
        style.height = `${height}px`;
        return style;
    }

    static focus_(elm: HTMLElementX): void {
        if (elm != null) {
            elm.focus();
        }
    }

    static focus0_(inputs: HTMLElement[]): void {
        if (inputs.length != 0) {
            An.focus_(inputs[0]);
        }
    }

    static select_(input: HTMLTextAreaElement): void {
        if (input != null) {
            input.selectionStart = 0;
            input.selectionEnd = input.value.length;
        }
    }

    /**
     * A general purpose async. list iterator.
     *
     * @param iterator(T item, int index, void next([bool terminate])) If terminate is true, returns without calling done().
     *   Otherwise if reached end of list, call done() and return.
     *   Otherwise continue to next item in the list.
     */
    static iterateList_<T>(
        list: T[], iterator: AsyncListIterator<T>, done: Fun00): void {
        if (list == null || list.length == 0) {
            done();
            return;
        }
        An._iterateList1(list, 0, list.length, iterator, done);
    }

    static _iterateList1<T>(list: T[], start: number, end: number, iterator: AsyncListIterator<T>, done: Fun00): void {
        iterator(list[start], start, (terminate: boolean) => {
            if (terminate) return;
            if (start + 1 < end) {
                An._iterateList1(list, start + 1, end, iterator, done);
            } else {
                done();
            }
        });
    }

    static busyWait_<T>(
        predicate: Fun01<T | null>, timeout: number, step: number, debugging: boolean, callback: Fun10<T | null>): void {
        let ok: T | null = null;
        try {
            ok = predicate();
        } catch (e) {
            
            ok = null;
        }
        if (ok != null) {
            callback(ok);
            return;
        }
        if (!debugging && timeout <= 0) {
            callback(null);
            return;
        }
        Timer.sleep_(step, () => {
            An.busyWait_(predicate, timeout - step, step, debugging, callback);
        });
    }

    static busyWait0_(predicate: Fun01<boolean>, timeout: number, step: number, debugging: boolean,
        callback: Fun10<boolean>): void {
        An.busyWait_<boolean>(() => {
            return predicate() ? true : null;
        },
            timeout,
            step,
            debugging,
            (ok) => {
                callback(ok != null);
            });
    }

    static asyncWait<T>(
        predicate: AsyncWaitPredicate<T | null>,
        timeout: number,
        step: number,
        debug: boolean,
        callback: BusyWaitCallback<T | null>
    ): void {
        const asyncwait1 = (timeout: number, elapsed: number) => {
            const next = (elapsed: number) => {
                if (!debug && elapsed >= timeout) {
                    callback(null);
                    return;
                }
                Timer.sleep_(step, () => {
                    asyncwait1(timeout, elapsed + step);
                });
            };
            try {
                predicate((ret) => {
                    if (ret == null) {
                        next(elapsed);
                    } else {
                        callback(ret);
                    }
                });
            } catch (e) {
                
                next(elapsed);
            }
        };
        asyncwait1(timeout, 0);
    }

    static ignoreException_(callback: Fun00): void {
        try {
            callback();
        } catch (e) {
            
        }
    }

    static show_(e: HTMLElement, display: stringX = null): HTMLElement {
        if (display != null) {
            e.style.display = display;
        } else {
            e.style.display = "";
        }
        return e;
    }

    static hide_(e: HTMLElement): HTMLElement {
        e.style.display = "none";
        return e;
    }

    static setVisible_(e: HTMLElement): HTMLElement {
        e.style.visibility = "visible";
        return e;
    }

    static setHidden_(e: HTMLElement): HTMLElement {
        e.style.visibility = "hidden";
        return e;
    }

    static showHidden_(e: HTMLElement, display: stringX = null): HTMLElement {
        e.style.visibility = "hidden";
        An.show_(e, display);
        return e;
    }

    static showVisible_(e: HTMLElement, display: stringX = null): HTMLElement {
        e.style.visibility = "visible";
        An.show_(e, display);
        return e;
    }

    static hideVisible_(e: HTMLElement, _display: stringX = null): HTMLElement {
        return An.setVisible_(An.hide_(e));
    }

    static setVisibleAt_(e: HTMLElement, x: number, y: number): HTMLElement {
        e.style.left = `${x}px`;
        e.style.top = `${y}px`;
        An.setVisible_(e);
        return e;
    }

    static toggleDisplay_(e: HTMLElement, on: string): void {
        e.style.display = (e.style.display == "none" ? on : "none");
    }

    static setTransform_(elm: HTMLElement, value: string): void {
        elm.style.transform = value;
    }

    static cancelSubscriptions_(handlers: StreamSubscription[]): void {
        while (handlers.length > 0) {
            handlers.pop()?.cancel_();
        }
    }

    static cancelSubscription_(handler: StreamSubscription | null): StreamSubscription | null {
        if (handler != null) {
            handler.cancel_();
        }
        return null;
    }

    static fireOneshotCallbacks_(callbacks: Fun00[]): void {
        while (callbacks.length > 0) {
            callbacks.pop()?.();
        }
    }

    /// Format the attributes to a string in editing format for editing in a textarea.
    static attributesToStringForEdit_(attrs: Map<string, string>, sep: string = "=", ignores: string[] | null = null): string {
        let ret = new StringBuffer();
        NEXT:
        for (let [name, value] of [...attrs]) {
            if (ignores != null) {
                for (let ignore of ignores) {
                    if (name == ignore) {
                        continue NEXT;
                    }
                }
            }
            ret.write_(name);
            ret.write_(sep);
            ret.write_(An.escAttrValue_(value));
            ret.write_(DEF.LF);
        }
        return ret.toString();
    }

    static attributesFromEditString_(attrs: string): StringMap<string> {
        const ret = smap_<string>();
        const s = attrs.trim();
        if (s.length == 0) return ret;
        const lines = s.split("\n");
        for (const line of lines) {
            const a = line.split(" ").filter((s) => s.length > 0);
            const key = a.shift() ?? null;
            if (key != null) ret[key] = a.join(" ");
        }
        return ret;
    }

    /**
     * Esc. line separators and control characters in the given attribute value for editing.
     * The element editor expect one line per attribute.
     */
    static escAttrValue_(s: string): string {
        let ret: StringBuffer | null = null;
        let start = 0;
        let end = s.length;
        for (let i = 0; i < end; ++i) {
            let c = s.codePointAt(i);
            if (c === undefined) continue;
            if (c == AMP ||
                c < 0x20 ||
                c == 0x7f ||
                c == 0xa0 ||
                c == 0x85 ||
                c == 0x2028 ||
                c == 0x200b) {
                if (ret == null) {
                    ret = new StringBuffer();
                }
                if (start < i) {
                    ret.write_(s.substring(start, i));
                }
                if (c == AMP) {
                    ret.write_("&amp;");
                } else {
                    ret.write_("&#x" + c.toString(16) + ";");
                }
                start = i + 1;
            }
        }
        if (ret == null) {
            return s;
        }
        if (start < end) {
            ret.write_(s.substring(start, end));
        }
        return ret.toString();
    }

    /// Unesc html entity in form &#xhh; &#ddd; &amp; &lt; &gt; &apos; &quot;
    static unescAttrValue_(s: string): string {
        return s.replace(RX.HtmlEntity_G, (_s, ...m) => {
            let g2 = m[1];
            if (g2 != null) {
                const value = parseInt(g2, 16);
                return isNaN(value) ? g2 : String.fromCharCode(value);
            }
            let g3 = m[2];
            if (g3 != null) {
                const value = parseInt(g3, 10);
                return isNaN(value) ? g3 : String.fromCharCode(value);
            }
            let g1 = m[0];
            switch (g1) {
                case "amp":
                    return "&";
                case "lt":
                    return "<";
                case "gt":
                    return ">";
                case "apos":
                    return "'";
                case "quot":
                    return "\"";
                default:
                    return g1;
            }
        });
    }

    /**
     * Esc. line separators and control characters in the given attribute value for editing.
     * The element editor expect one line per attribute.
     */
    static escText_(s: string): string {
        let ret: StringBuffer | null = null;
        let start = 0;
        let end = s.length;
        for (let i = 0; i < end; ++i) {
            let c = s.codePointAt(i);
            if (c === undefined) continue;
            if (c == AMP || c < 0x20 || c >= 0x7f && !An.isHuman_(c)) {
                if (ret == null) {
                    ret = new StringBuffer();
                }
                if (start < i) {
                    ret.write_(s.substring(start, i));
                }
                if (c == AMP) {
                    ret.write_("&amp;");
                } else {
                    ret.write_("&#x" + c.toString(16) + ";");
                }
                start = i + 1;
            }
        }
        if (ret == null) {
            return s;
        }
        if (start < end) {
            ret.write_(s.substring(start, end));
        }
        return ret.toString();
    }

    /**
     * Esc. unicode characters to quoted "\xxxx" format.
     * Currently, this only applies to value of the content property.
     */

    /// Unesc html entity in form &#xhh; and &#ddd;
    static unescText_(s: string): string {
        return An.unescAttrValue_(s);
    }

    static isHuman_(c: number): boolean {
        let cat = Unicode$.unicodeCat_(c);
        switch (cat) {
            case Unicode$.Cat.Ll:
            case Unicode$.Cat.Lm:
            case Unicode$.Cat.Lo:
            case Unicode$.Cat.Lt:
            case Unicode$.Cat.Lu:
            case Unicode$.Cat.Nd:
            case Unicode$.Cat.Nl:
            case Unicode$.Cat.No:
            case Unicode$.Cat.Pc:
            case Unicode$.Cat.Pd:
            case Unicode$.Cat.Pe:
            case Unicode$.Cat.Pf:
            case Unicode$.Cat.Pi:
            case Unicode$.Cat.Po:
            case Unicode$.Cat.Ps:
            case Unicode$.Cat.Sc:
                return true;
            default:
                return false;
        }
    }

    static readonly InvalidFilenameChars$ = Ut.charcodesOrFail_("\\?#%;[]");

    static isValidFilenameChar_(c: number): boolean {
        if (c < 0x20 || c >= 0x7f && c <= 0x9f || this.InvalidFilenameChars$.includes(c)) return false;
        let cat = Unicode$.unicodeCat_(c);
        switch (cat) {
            case Unicode$.Cat.Ll:
            case Unicode$.Cat.Lm:
            case Unicode$.Cat.Lo:
            case Unicode$.Cat.Lt:
            case Unicode$.Cat.Lu:
            case Unicode$.Cat.Mc:
            case Unicode$.Cat.Me:
            case Unicode$.Cat.Mn:
            case Unicode$.Cat.Nd:
            case Unicode$.Cat.Nl:
            case Unicode$.Cat.No:
            case Unicode$.Cat.Pc:
            case Unicode$.Cat.Pd:
            case Unicode$.Cat.Pe:
            case Unicode$.Cat.Pf:
            case Unicode$.Cat.Pi:
            case Unicode$.Cat.Po:
            case Unicode$.Cat.Ps:
            case Unicode$.Cat.Sc:
            case Unicode$.Cat.Sk:
            case Unicode$.Cat.Sm:
            case Unicode$.Cat.So:
            case Unicode$.Cat.Zs:
                return true;
            default:
                return false;
        }
    }

    /// @return The removed value, null if not found.
    static removeNameValue_(namevalues: Array<Array<string>> | null, name: string): stringX {
        if (namevalues == null) { return null; }
        for (let i = namevalues.length - 1; i >= 0; --i) {
            let namevalue = namevalues[i];
            if (namevalue.length == 2 && namevalue[0] == name) {
                namevalues.splice(i, 1);
                return namevalue[1];
            }
        }
        return null;
    }

    /// If name is found, replace value by the given value, otherwise add the name value pair.
    static replaceNameValue_(
        namevalues: Array<Array<string>>, name: string, value: string): void {
        if (namevalues == null) {
            return;
        }
        for (let i = namevalues.length - 1; i >= 0; --i) {
            let namevalue = namevalues[i];
            if (namevalue.length == 2 && namevalue[0] == name) {
                if (value == null || value.length == 0) {
                    namevalues.splice(i, 1);
                } else {
                    namevalue[1] = value;
                }
                return;
            }
        }
        if (value != null && value.length != 0) {
            namevalues.push([name, value]);
        }
    }

    static nameValueToStringMap_(namevalues: Array<Array<string>>): SStringMap {
        let ret = ssmap_();
        if (namevalues != null) {
            for (let namevalue of namevalues) {
                if (namevalue.length == 2) {
                    ret[namevalue[0]] = namevalue[1];
                }
            }
        }
        return ret;
    }

    static nameValueToMap_(namevalues: Array<Array<string>>): Map<string, string> {
        let ret = new Map<string, string>();
        if (namevalues != null) {
            for (let namevalue of namevalues) {
                if (namevalue.length == 2) {
                    ret.set(namevalue[0], namevalue[1]);
                }
            }
        }
        return ret;
    }

    static nameValueToMapRemovingEmptyValues_(
        namevalues: Array<Array<string>>): Map<string, string> {
        let ret = new Map<string, string>();
        if (namevalues != null) {
            for (let namevalue of namevalues) {
                if (namevalue.length == 2) {
                    let value = namevalue[1];
                    if (value == null || value.length == 0) {
                        continue;
                    }
                    ret.set(namevalue[0], value);
                }
            }
        }
        return ret;
    }

    static getValue_<T>(map: Map<string, T>, key: string, def: T): T {
        let ret = map.get(key);
        return ret == null ? def : ret;
    }

    static _stylevalue(value: stringX): stringX {
        if (value == null) { return null; }
        value = value.trim();
        return (value.length == 0 ? null : value);
    }

    static classlist_(elm: HTMLElement | DOMTokenList): ClasslistBuilder {
        return new ClasslistBuilder(elm);
    }

    static listeners_(elm: HTMLElement): EventListenerBuilder {
        return new EventListenerBuilder(elm);
    }

    static removeAddClasses_(attrs: StringMap<stringX>, removes: string[], adds: string[]): void {
        const classes = attrs["class"];
        const existings = classes?.split(RX.Spaces) ?? [];
        for (const c of removes) {
            while (true) {
                let index = existings.indexOf(c);
                if (index < 0) break;
                existings.splice(index, 1);
            }
        }
        for (const c of adds) {
            if (!existings.includes(c)) existings.push(c);
        }
        const s = existings.join(" ");
        if (s != classes) attrs["class"] = s;
    }

    static unquote_(s: string): string {
        if (s == null || s.length < 2) {
            return s;
        }
        let len = s.length;
        if (len > 2) {
            let c0 = s[0];
            let c1 = s[len - 1];
            if (('"' == c0 || "'" == c0) && c1 == c0) {
                return s.substring(1, len - 1);
            }
        }
        return s;
    }

    static truncate_(msg: stringX, len: number): string {
        if (msg == null) return "";
        if (len == null) { len = DEF.maxToastLen; }
        if (msg.length < len) { return msg; }
        if (len < 4) { return "..."; }
        return msg.substring(0, len - 4) + " ...";
    }

    static firstWord_(s: stringX): stringX {
        return s == null ? null : (RX.NonSpaces.exec(s)?.[1] ?? null);
    }

    static removeLeadingSlashes_(path: string): string {
        let len = path.length;
        let start = 0;
        while (start < len && path[start] == FS) {
            ++start;
        }
        return (start == 0 ? path : path.substring(start, len));
    }

    static removeTrailingSlashes_(path: string): string {
        let len = path.length;
        let end = len;
        while (end > 0 && path[end - 1] == FS) {
            --end;
        }
        return (end == len ? path : path.substring(0, end));
    }

    static ensureLeadingSlash_(path: string): string {
        if (path.startsWith(FS)) return path;
        return FS + path;
    }

    static ensureTrailingSlash_(path: string): string {
        if (path.endsWith(FS)) return path;
        return path + FS;
    }

    static joinNotEmpty_(sep: string, a: string[]): string {
        let ret = "";
        for (let s of a) {
            s = s.trim();
            if (s.length == 0) continue;
            if (ret.length > 0) ret += sep;
            ret += s;
        }
        return ret;
    }

    static filenameFromUri_(uri: UriX): string {
        if (uri == null) return "";
        let segments = uri.pathSegments$;
        return segments.length == 0 ? "" : segments[segments.length - 1];
    }

    static lastSegment_(segments: string[]): stringX {
        if (segments != null && segments.length > 0) {
            return segments[segments.length - 1];
        }
        return null;
    }

    static fileSuffixFromUri_(uri: Uri): stringX {
        if (uri == null) return null;
        return Basepath.ext_(uri.path$);
    }

    static isDotOnly_(s: string): boolean {
        if (s == null) {
            return false;
        }
        let len = s.length;
        if (len == 0) {
            return false;
        }
        for (let i = 0; i < len; ++i) {
            if (s[i] != ".") {
                return false;
            }
        }
        return true;
    }

    static apath_(path: string): string {
        if (path.length > 0 && path[0] != FS) {
            return FS + path;
        }
        return path;
    }

    static labelFromBasepath_(basepath: Basepath): string {
        let text = basepath.stem$;
        let name = basepath.filename$;
        if (name.length == 0 || name == "index.html") {
            const dir = basepath.dir$ == null ? null : new Basepath(basepath.dir$).filename$;
            if (dir != null && dir.length > 0 && dir != FS && dir != "." && dir != "..") text = dir;
        }
        let label = text.replace(RX.LabelPat, " ").trim();
        if (label.length == 0) label = text;
        return An.capitalize_(label);
    }

    static capitalize_(value: string): string {
        if (An.isempty_(value)) return value;
        return value.substring(0, 1).toUpperCase() + value.substring(1);
    }

    static hex_(value: number, minlength: number): string {
        let ret = value.toString(16);
        for (let i = ret.length; i < minlength; ++i) {
            ret = "0" + ret;
        }
        return ret;
    }

    static xhex_(value: number, minlength: number): string {
        return "0x" + An.hex_(value, minlength);
    }

    static splitCSVWithQuots(s: string): string[] {
        const ret = Array<string>();
        const quots = Array<number>();
        let quot: number | undefined = undefined;
        let start = 0;
        let end = -1;
        const comma = ",".charCodeAt(0);
        const doublequot = '"'.charCodeAt(0);
        const singlequot = "'".charCodeAt(0);
        const addtoken = (index: number) => {
            if (start >= index) return;
            if (end < 0) end = index;
            ret.push(s.substring(start, end).trim());
            start = index + 1;
            end = -1;
        };
        Ut.charcodesOf_(s, (c, index) => {
            if (c === undefined) return;
            if (quot !== undefined) {
                if (c != quot) return;
                quot = quots.pop();
                return;
            }
            if (c == doublequot || c == singlequot) {
                if (quot !== undefined) quots.push(quot);
                quot = c;
                return;
            }
            if (c == comma) addtoken(index);
        });
        addtoken(s.length);
        return ret;
    }

    static isBodyElement_(nodename: string): boolean {
        return nodename == "BODY" || nodename == "HTML" || nodename == "HEAD";
    }

    static isHtmlElement_(nodename: string): boolean {
        return nodename == "HTML" || nodename == "HEAD";
    }

    static isWhitespaces_(text: stringX): boolean {
        return (text == null || text.length == 0 || RX.IsWhitespaces.test(text));
    }

    static elementInfo_(elm: HTMLElement): string {
        let css = elm.getAttribute("class");
        let href = elm.getAttribute("href");
        let src = elm.getAttribute("src");
        let style = elm.getAttribute("style");
        let text = "";
        if (elm.id != null) {
            text += `id (${elm.id})`;
        }
        if (css != null) {
            text += ` class (${css})`;
        }
        if (href != null) {
            text += ` href (${href})`;
        }
        if (src != null) {
            text += ` src (${src})`;
        }
        if (style != null) {
            text += ` style (${style})`;
        }
        return text.toString();
    }

    static enableButtons_(buttons: HTMLElement[], enable: boolean): void {
        for (let button of buttons) {
            An.enableButton_(button, enable);
        }
    }

    static enableButton_(button: HTMLElement, enable: boolean): void {
        if (enable) {
            button.classList.remove(CSS.AnDisabled);
        } else {
            button.classList.add(CSS.AnDisabled);
        }
    }

    static isButtonDisabled_(button: HTMLElement): boolean {
        return button.classList.contains(CSS.AnDisabled);
    }

    static isButtonOff_(button: HTMLElement): boolean {
        return button.classList.contains(CSS.AnToggleOff);
    }

    static isButtonOn_(button: HTMLElement): boolean {
        return !button.classList.contains(CSS.AnToggleOff);
    }

    static toggleOnOffButton_(button: HTMLElement): boolean {
        return !button.classList.toggle(CSS.AnToggleOff);
    }

    static toggleButtonOn_(button: HTMLElement): void {
        button.classList.remove(CSS.AnToggleOff);
    }

    static toggleButtonOff_(button: HTMLElement): void {
        button.classList.add(CSS.AnToggleOff);
    }

    static toggleToggleButton_(button: HTMLElement): boolean {
        return An.classlist_(button)
            .toggleAll_(CSS.AnButtonFlat, CSS.AnButtonDown)
            .contains_(CSS.AnButtonDown);
    }

    static setToggleButton_(button: HTMLElement, down: boolean): boolean {
        An.classlist_(button)
            .remove_(down ? CSS.AnButtonFlat : CSS.AnButtonDown).
            add_(down ? CSS.AnButtonDown : CSS.AnButtonFlat);
        return down;
    }

    static isToggleButtonDown_(button: HTMLElement): boolean {
        return button.classList.contains(CSS.AnButtonDown);
    }

    static round_(value: numberX, def: number): number {
        return value == null ? def : Math.round(value);
    }

    static floor_(value: numberX, def: number): number {
        return value == null ? def : Math.floor(value);
    }

    static multipleOf_(m: number, value: number): number {
        return (value / m) * m;
    }

    static sinkhole_(e: Event): void {
        An.stopevent_(e);
    }

    static stopevent_(e: Event): boolean {
        try {
            if (e != null) {
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.preventDefault();
                e.cancelBubble = true;
            }
        } catch (e: any) {
        }
        return false;
    }

    static documentOffset_(elm: HTMLElement): Point<number> {
        return An.offsetOf_(elm, null);
    }

    static offsetOf_(elm: HTMLElement, root: HTMLElementX): Point<number> {
        return An.offsetOf1_(elm, root);
    }

    private static offsetOf1_(current: HTMLElementX, root: HTMLElementX): Point<number> {
        let x = 0;
        let y = 0;
        while (current != root) {
            if (current == null)
                throw new Error("Specified element is not a transitive offset parent of this element.");
            x += current.offsetLeft + current.clientLeft;
            y += current.offsetTop + current.clientTop;
            current = current.offsetParent as HTMLElementX;
        }
        return new Point(x, y);
    }

    static noop_(): void { }

    static noop1_<T>(_arg: T): void { }

    static predicate0_(): boolean { return false; }

    static predicate1_(): boolean { return true; }

    static noop1Callback0_<T>(_arg: T, callback: Fun00): void {
        callback();
    }

    static noop1Promise0_<T>(_arg: T): Promise<void> {
        return Promise.resolve();
    }

    static ignoreJSONResult_(_ret: JSONObject): void { }

    /**
     * @return A new Uri without scheme, host and port, optionally replace path too.
     */
    static cleanUri_(u: UriX, ipath: stringX = null, baseuri: BaseUriX): UriX {
        if (u == null) return null;
        let p = (ipath != null ? ipath : u.path$);
        let q = u.search$;
        let f = u.hash$;
        return An.uriFromSafe_(baseuri, p, q, f);
    }

    static addRemoveQueryParams_(u: Uri, adds: Map<string, string> | null = null, removes: string[] | null = null, baseuri: BaseUriX): UriX {
        let queries = new Map<string, string>();
        u.searchParams$.forEach((value, key) => {
            if (removes != null && removes.includes(key)) return;
            queries.set(key, value);
        });
        if (adds != null) {
            for (let [key, value] of adds) {
                queries.set(key, value);
            }
        }
        return An.uriFromSafe_(baseuri, u.path$, queries, u.hash$);
    }

    static addViewParam_(u: Uri, baseuri: BaseUriX): UriX {
        const lcsuffix = UriUt.lcSuffix_(u);
        if (MimeUtil.isViewerLcSuffix_(lcsuffix)
            && lcsuffix != Suffix.PDF$
            && !u.searchParams$.has(Param.view)) {
            return An.addRemoveQueryParams_(u, map1_(Param.view, ""), null, baseuri);
        }
        return u;
    }

    static subscriptEvent_<T extends Event>(
        elm: EventTarget,
        event: EventName,
        listener: EventCallback1<T>
    ): StreamSubscription {
        const l = (e: Event) => listener(e as T);
        elm.addEventListener(event, l);
        return new StreamSubscription(elm, event, l);
    }

    static addOneshotListener(elm: HTMLElement, event: string, listener: Fun10<Event>) {
        elm.addEventListener(event, (e) => {
            elm.removeEventListener(event, listener);
            listener(e);
        });
    }

    static onClickMatching_<T extends Event>(elm: HTMLElement, selector: string, callback: TargetEventCallback<T>): void {
        return this.onEventMatching_(elm, "click", selector, callback);
    }

    static onContextmenuMatching_<T extends Event>(elm: HTMLElement, selector: string, callback: TargetEventCallback<T>): void {
        return this.onEventMatching_(elm, "contextmenu", selector, callback);
    }

    static onEventMatching_<T extends Event>(
        elm: HTMLElement,
        event: EventName,
        selector: string,
        callback: TargetEventCallback<T>): void {
        elm.addEventListener(event, (e: Event) => {
            let matching = DomUt.matchingTarget_(e, selector);
            if (matching == null) return;
            callback(matching, e as T);
        });
    }

    static onPointerStart_(elm: EventTarget, callback: EventCallback) {
        elm.addEventListener(Conf.pointerstart$, callback);
    }

    static onPointerEnd_(elm: EventTarget, callback: EventCallback) {
        elm.addEventListener(Conf.pointerend$, callback);
    }

    static onToggleToggle_(button: HTMLElement, listener: Fun10<boolean>): void {
        An.onClick_(button, (e) => {
            An.stopevent_(e);
            listener(An.toggleToggleButton_(button));
        });
    }

    static onButtonClick_<T extends HTMLElement>(elm: T, listener: Fun10<MouseEvent>): T {
        elm.addEventListener("click", (e) => {
            if (elm.classList.contains(CSS.AnDisabled)) {
                An.stopevent_(e);
                return;
            }
            listener(e as MouseEvent);
        });
        return elm;
    }

    static onClick_<T extends HTMLElement>(elm: T, listener: Fun10<MouseEvent>): T {
        elm.addEventListener("click", (e) => { listener(e as MouseEvent); });
        return elm;
    }

    static onContextmenu_<T extends HTMLElement>(elm: T, listener: Fun10<MouseEvent>): T {
        elm.addEventListener("contextmenu", e => listener(e as MouseEvent));
        return elm;
    }

    static onFocus_<T extends HTMLElement>(elm: T, listener: Fun10<Event>): T {
        elm.addEventListener("focus", e => listener(e));
        return elm;
    }

    static onKeypress_<T extends HTMLElement | Window>(elm: T, listener: Fun10<KeyboardEvent>): T {
        elm.addEventListener("keypress", (e) => listener(e as KeyboardEvent));
        return elm;
    }

    static onKeydown_<T extends HTMLElement | Window>(elm: T, listener: Fun10<KeyboardEvent>): T {
        elm.addEventListener("keydown", (e) => listener(e as KeyboardEvent));
        return elm;
    }

    static onChange_<T extends HTMLElement>(elm: T, listener: Fun10<Event>): T {
        elm.addEventListener("change", listener);
        return elm;
    }

    static onLoad_<T extends HTMLElement>(elm: T, listener: Fun10<Event>): T {
        elm.addEventListener("load", listener);
        return elm;
    }

    static onError_<T extends HTMLElement>(elm: T, listener: Fun10<Event>): T {
        elm.addEventListener("error", listener);
        return elm;
    }

    static onInput_<T extends HTMLElement>(elm: T, listener: Fun10<InputEvent>): T {
        elm.addEventListener("input", (e) => {
            listener(e as InputEvent);
        });
        return elm;
    }

    static onInputChange_(
        input: HTMLTextAreaElement | HTMLInputElement,
        callback: EventCallback
    ): HTMLTextAreaElement | HTMLInputElement {
        input.addEventListener("change", callback);
        return input;
    }

    static onInputFocusSelect_(input: HTMLTextAreaElement): HTMLTextAreaElement {
        return input;
    }

    static onInputFocusSelectIgnoreEnterKey_(input: HTMLTextAreaElement): HTMLTextAreaElement {
        return An.onInputFocusSelect_(An.onInputEnterKeyStop_(input));
    }

    static onInputEnterKey_(
        input: HTMLTextAreaElement,
        callback: KeyboardEventCallback
    ): HTMLTextAreaElement {
        input.addEventListener("keypress", (e: KeyboardEvent) => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                callback(e);
            }
        });
        return input;
    }

    static onInputEnterKeyStop_(input: HTMLTextAreaElement): HTMLTextAreaElement {
        input.addEventListener("keypress", (e: KeyboardEvent) => {
            if (e.key == "Enter") {
                An.stopevent_(e);
            }
        });
        return input;
    }

    /// Ignore enter key in all textarea.AnPromptInput inside the panel.
    static stopAllInputEnterKey_(panel: HTMLElement): void {
        let ret = panel.querySelectorAll(`textarea.${CSS.AnPromptInput}`);
        for (let index = 0; index < ret.length; ++index) {
            An.onInputEnterKeyStop_(ret.item(index) as HTMLTextAreaElement);
        }
    }
}

////////////////////////////////////////////////////////////////////////

type AnInputElement = HTMLTextAreaElement;
type AnInputElementX = HTMLTextAreaElement | null;

////////////////////////////////////////////////////////////////////////

class DomBuilderEx extends DomBuilder {

    static offline1_(doc: Document, tag: string, ...classes: string[]) {
        return new DomBuilderEx(doc.createElement(tag)).addClasses_(classes);
    }

    /// Create a DOM root that is not attached to a parent.
    static offline_(doc: Document, tag: string, attrs: StringMap<stringX> | null = null): DomBuilderEx {
        return new DomBuilderEx(doc.createElement(tag), attrs);
    }

    /// @return The input element. Cursor is the input element.
    flexInput_(flexbasis: number, placeholder: stringX, tabindex: string = "1"): AnInputElement {
        const input = this.flexInputWithoutFocus_(flexbasis, placeholder, tabindex);
        An.onInputFocusSelect_(input);
        return input;
    }

    /// @return The input element. Cursor is the input element.
    flexInputSlider_(flexbasis: number, height: string,
        min: string, max: string, step: string, value: string,
        placeholder: string, tabindex: string = "1"
    ): HTMLInputElement {
        const attrs: SStringMap = {
            "type": "range",
            "class": CSS.AnPromptInputSlider,
            "style": `flex-basis:${flexbasis}%;height:${height};`,
            "min": min,
            "max": max,
            "step": step,
            "value": value,
            "placeholder": placeholder,
            "tabindex": tabindex,
        };
        return this.input_(attrs).cursor_() as HTMLInputElement;
    }

    /// @return The input element. Cursor is the input element.
    flexInputWithoutFocus_(flexbasis: number, placeholder: stringX, tabindex: string = "1"): AnInputElement {
        const attrs: SStringMap = {
            "rows": "1",
            "class": CSS.AnPromptInput,
            "style": `flex-basis:${flexbasis}%`,
            "tabindex": tabindex,
            "autocapitalize": "none",
            "autocomplete": "off",
            "autocorrect": "off",
            "spellcheck": "false",
        };
        if (placeholder != null && placeholder.length > 0) {
            attrs["placeholder"] = placeholder;
        }
        return this.child_(Conf.input$, attrs).cursor_() as AnInputElement;
    }

    /// @return The input element. Cursor is the input element.
    flexDivInput_(flexbasis: number): HTMLElement {
        const attrs = {
            "class": CSS.AnPromptInput,
            "style": `flex-basis:${flexbasis}%;`,
        };
        return this.div_(attrs).cursor_();
    }

    flexTextarea_(attrs: SStringMap): HTMLTextAreaElement {
        return this.push_().div1_(CSS.AnFlex).textarea_(attrs).cursorPop_() as HTMLTextAreaElement;
    }

    flexTextInput_(textbasis: number, text: string, placeholder: stringX, tabindex: string = "1"): AnInputElement {
        this.push_().div1_(CSS.AnFlex);
        const ret = this.flexTextInput1_(textbasis, text, placeholder, tabindex);
        this.pop_();
        return ret;
    }

    flexTextInput1_(textbasis: number, text: string, placeholder: stringX, tabindex: string): AnInputElement {
        this.push_();
        if (textbasis > 0) {
            this.div_({
                "class": CSS.AnRightAlignLabel,
                "style": `flex-basis:${textbasis}%`,
            }).text_(text);
        }
        const attrs: SStringMap = {
            "class": CSS.AnPromptInput,
            "style": `flex-basis:${100 - textbasis}%`,
            "rows": "1",
            "tabindex": tabindex,
            "autocapitalize": "none",
            "autocomplete": "off",
            "autocorrect": "off",
            "spellcheck": "false",
        };
        if (placeholder != null && placeholder.length > 0) {
            attrs["placeholder"] = placeholder;
        }
        return this.peek_().child_(Conf.input$, attrs).cursorPop_() as AnInputElement;
    }

    flexTextTextarea_(textbasis: number, text: string, attrs: SStringMap): HTMLTextAreaElement {
        this.push_().div1_(CSS.AnFlex);
        const ret = this.flexTextTextarea1_(textbasis, text, attrs);
        this.pop_();
        return ret;
    }

    flexTextTextarea1_(textbasis: number, text: string, attrs: SStringMap): HTMLTextAreaElement {
        this.push_();
        if (textbasis > 0) {
            this.div_({
                "class": CSS.AnRightAlignLabel,
                "style": `flex-basis:${textbasis}%`,
            }).text_(text);
        }
        attrs["style"] = `flex-basis:${100 - textbasis}%`;
        this.peek_().textarea_(attrs);
        return this.cursorPop_(1) as HTMLTextAreaElement;
    }

    flexTextDiv_(textbasis: number, text: string, classes: string = ""): DomBuilderEx {
        this.div1_(CSS.AnFlex, ...classes.split(RX.Spaces));
        this.flexTextDiv1_(textbasis, text);
        return this;
    }

    flexTextDiv1_(textbasis: number, text: string): DomBuilderEx {
        this.push_();
        if (textbasis > 0) {
            this.div_({
                "class": CSS.AnRightAlignLabel,
                "style": `flex-basis:${textbasis}%`,
            }).text_(text);
        }
        this.pop_().div_({
            "style": `flex-basis:${100 - textbasis}%`,
        });
        return this;
    }

    /**
         * Create div.AnFlex(div.AnRightAlignLabel(text), div.AnFlex).
         * @return this and this.cursor() is the innner div.AnFlex.
         */
    flexTextContainer_(textbasis: number, text: string): DomBuilderEx {
        this.div1_(CSS.AnFlex);
        this.flexTextContainer1_(textbasis, text);
        return this;
    }

    /**
         * Create div.AnRightAlignLabel(text), div.AnFlex.
         * @return this and this.cursor() is div.AnFlex.
         */
    flexTextContainer1_(textbasis: number, text: string): DomBuilderEx {
        this.push_();
        if (textbasis > 0) {
            this.div_({
                "class": CSS.AnRightAlignLabel,
                "style": `flex-basis:${textbasis}%`,
            }).text_(text);
        }
        this.pop_().div_({
            "class": CSS.AnFlex,
            "style": `flex-basis:${100 - textbasis}%;overflow:hidden`,
        });
        return this;
    }

    folderButton_(): HTMLElement {
        return this.push_().button1_(CSS.AnButton, CSS.AnMarginLeft5, CSS.Fa, CSS.FaFolderOpen).cursorPop_();
    }

    /// @return this and this.cursor() is div.AnFlex.
    textContainer_(textbasis: number, text: string): DomBuilderEx {
        return this.div1_(CSS.AnFlex, CSS.AnMarginV5).flexTextContainer1_(textbasis, text);
    }

}

class JsUtil {

    ///////////////////////////////////////////////////////////////////////
    //// Accessories

    static asHTMLDivElement_(elm: HTMLElementX): HTMLDivElement | null {
        return elm != null && elm.nodeName == "DIV" ? elm as HTMLDivElement : null;
    }

    static asHTMLImageElement_(elm: HTMLElementX): HTMLImageElement | null {
        return elm != null && elm.nodeName == "IMG" ? elm as HTMLImageElement : null;
    }

    static asHTMLAudioElement_(elm: HTMLElementX): HTMLAudioElement | null {
        return elm != null && elm.nodeName == "AUDIO" ? elm as HTMLAudioElement : null;
    }

    static asHTMLVideoElement_(elm: HTMLElementX): HTMLVideoElement | null {
        return elm != null && elm.nodeName == "VIDEO" ? elm as HTMLVideoElement : null;
    }

    static asHTMLTextAreaElement_(elm: HTMLElementX): HTMLTextAreaElement | null {
        return elm != null && elm.nodeName == "TEXTAREA" ? elm as HTMLTextAreaElement : null;
    }

    static asHTMLInputElement_(elm: HTMLElementX): HTMLInputElement | null {
        return elm != null && elm.nodeName == "INPUT" ? elm as HTMLInputElement : null;
    }

    static asHTMLIFrameElement_(elm: HTMLElementX): HTMLIFrameElement | null {
        return elm != null && elm.nodeName == "IFRAME" ? elm as HTMLIFrameElement : null;
    }

    static asValueElement_(
        node: NodeX
    ): HTMLTextAreaElement
        | HTMLInputElement
        | HTMLButtonElement
        | HTMLSelectElement
        | HTMLOptionElement
        | null {
        if (node == null) { return null; }
        const t = node.nodeName;
        return t == "TEXTAREA" ? node as HTMLTextAreaElement
            : t == "INPUT" ? node as HTMLInputElement
                : t == "BUTTON" ? node as HTMLButtonElement
                    : t == "SELECT" ? node as HTMLSelectElement
                        : t == "OPTION" ? node as HTMLOptionElement
                            : null;
    }

    static nullableItemsArrayOf_<V>(items: IndexedItems<V | null>): Array<V | null> {
        return [...new NullableItemsIterable(items)];
    }

    static itemsArrayOf_<V>(items: IndexedItems<V>): V[] {
        return [...new ItemsIterable(items)];
    }

    static lastItemOf_<V>(items: IndexedItems<V>): V | null {
        let len = items.length;
        return len > 0 ? items.item(len - 1) : null;
    }

    static isTextNode_(node: Node | null): boolean {
        return node != null && node.nodeType == Node.TEXT_NODE;
    }

    static childNodes_(elm: HTMLElement): Node[] {
        return JsUtil.itemsArrayOf_(elm.childNodes);
    }

    static nodeValue_(node: Node | null): string | null {
        if (node != null && node.nodeType == Node.TEXT_NODE) {
            return node.nodeValue;
        }
        return null;
    }

    static textContent_(node: Node): string {
        return node.textContent ?? "";
    }

    static setTextContent_(node: Node | null, text: string | null): void {
        if (node != null) {
            node.textContent = text ?? "";
        }
    }

    ///////////////////////////////////////////////////////////////////////

    /// Pre-order transversal for the node tree.
    /// @callback Returns the next sibling to transverse.
    static transverse_(node: Node, callback: (node: Node) => NodeX): void {
        JsUtil._transverse1(node, callback);
    }

    private static _transverse1(node: Node, callback: (node: Node) => NodeX): void {
        if (node == null) { return; }
        let c: Node | null = node.firstChild;
        while (c != null) {
            let iselement = c.nodeType == Node.ELEMENT_NODE;
            let n = callback(c);
            if (iselement) {
                JsUtil._transverse1(c, callback);
            }
            c = n;
        }
    }

    static elementWalker_(elm: HTMLElement, callback: Fun10<HTMLElement>): void {
        let c = elm.firstElementChild as HTMLElement;
        while (c != null) {
            let n = c.nextElementSibling as HTMLElement;
            callback(c);
            this.elementWalker_(c, callback);
            c = n;
        }
    }

    /** Depth first search for node meet the predicate. */
    static find_(elm: Node, predicate: Fun11<Node, NodeX>): NodeX {
        return this.find1_(elm, predicate);
    }

    private static find1_(elm: Node, predicate: Fun11<Node, NodeX>): NodeX {
        for (let c = elm.firstChild; c != null; c = c.nextSibling) {
            let ret = predicate(c);
            if (ret != null) return ret;
            if (c.nodeType == Node.ELEMENT_NODE) {
                ret = this.find1_(c, predicate);
                if (ret != null) return ret;
            }
        }
        return null;
    }

    /**
     *  @return A space normalized string of node.textContent
     */
    static trimmedTextContent_(node: Node): string {
        return An.normalizeTextContent_(JsUtil.textContent_(node));
    }

    static sortedAttributes_(elm: HTMLElement): Map<string, string> {
        return new Map(JsUtil.itemsArrayOf_<Attr>(elm.attributes)
            .sort((a, b) => { return a.name.localeCompare(b.name); })
            .map((a) => { return [a.name, a.value]; }));
    }

    static sortedAttributes1_(attrs: StringMap<string>): Map<string, string> {
        return new Map(Array.from(Object.entries(attrs))
            .sort((a, b) => { return a[0].localeCompare(b[0]); })
            .map((a) => { return [a[0], a[1]]; }));
    }

    static isWhitespaceNode_(text: Node): boolean {
        return text.nodeType == Node.TEXT_NODE && An.isWhitespaces_(text.textContent ?? "");
    }

    static remove_(child: Node): void {
        child.parentNode?.removeChild(child);
    }

    static childElements_(elm: Element): Element[] {
        return JsUtil.itemsArrayOf_(elm.children);
    }

    static lastElementChild_(elm: HTMLElement): HTMLElementX {
        return JsUtil.lastItemOf_(elm.children) as HTMLElement;
    }

    static findChildElement_(elm: Node, nodename: string): HTMLElementX {
        for (let c of Array.from(elm.childNodes)) {
            if (c.nodeType == Node.ELEMENT_NODE && nodename == c.nodeName) return (c as HTMLElement);
        }
        return null;
    }

    static isAll1_(nodename: string, parent: HTMLElement): boolean {
        return JsUtil.isAll_(nodename, JsUtil.itemsArrayOf_(parent.children));
    }

    static isAll_(nodename: string, nodes: Element[]): boolean {
        for (let c of nodes) {
            if (c.nodeName != nodename) { return false; }
        }
        return true;
    }

    static hasClass_(node: NodeX, c: string): boolean {
        return node != null && node.nodeType == Node.ELEMENT_NODE && (node as HTMLElement).classList.contains(c);
    }

    static hasClasses_(node: NodeX, classes: string[]): boolean {
        const classlist = DomUt.asHTMLElement_(node)?.classList ?? null;
        if (classlist != null) {
            for (let c of classes) {
                if (classlist.contains(c)) { return true; }
            }
        }
        return false;
    }

    static childElementWithClass_(elm: HTMLElement, css: string): HTMLElementX {
        for (let c of Array.from(elm.children)) {
            if (c.classList.contains(css)) { return c as HTMLElement; }
        }
        return null;
    }

    static ancestorWith_(node: Node | null, predicate: Fun11<HTMLElement, boolean>): HTMLElementX {
        for (let p = node?.parentElement; p != null; p = p.parentElement) {
            if (predicate(p)) return p;
            if (An.isBodyElement_(p.nodeName)) { return null; };
        }
        return null;
    }

    static ancestorWithClasses_(node: HTMLElement, classes: string[]): HTMLElementX {
        return this.ancestorWith_(node, (e) => JsUtil.hasClasses_(e, classes));
    }

    static ancestorOrSelfWith_(node: Node | null, predicate: Fun11<HTMLElement, boolean>): HTMLElementX {
        let p = DomUt.asHTMLElement_(node) ?? node?.parentElement ?? null;
        for (; p != null; p = p.parentElement) {
            if (predicate(p)) return p;
            if (An.isBodyElement_(p.nodeName)) { return null; };
        }
        return null;
    }

    static ancestorOrSelfWithClasses_(node: Node, classes: string[]): HTMLElementX {
        return JsUtil.ancestorOrSelfWith_(node, (p) => JsUtil.hasClasses_(p, classes));
    }

    static ancestorOrSelfWithClass_(node: Node, klass: string): HTMLElementX {
        return JsUtil.ancestorOrSelfWith_(node, (p) => p.classList.contains(klass));
    }

    static ancestorOrSelfWithId_(node: Node, id: string): HTMLElementX {
        return JsUtil.ancestorOrSelfWith_(node, (p) => p.id == id);
    }

    static ancestorOrSelfWithName_(node: Node, name: string): HTMLElementX {
        return JsUtil.ancestorOrSelfWith_(node, (p) => name == p.nodeName);
    }

    static ancestorOrSelfWithAttr_(node: Node, name: string, value: string): HTMLElementX {
        return JsUtil.ancestorOrSelfWith_(node, (p) => p.getAttribute(name) == value);
    }

    static isEmptyTextNode_(node: Node): boolean {
        let type = node.nodeType;
        if (type == Node.TEXT_NODE) {
            return An.isWhitespaces_(node.nodeValue);
        }
        return type != Node.ELEMENT_NODE;
    }

    /// @return true if given node only contains text nodes with whitespaces.
    static isEmptyNode_(node: Node): boolean {
        for (let c = node.firstChild; c != null; c = c.nextSibling) {
            let type = c.nodeType;
            if (type == Node.ELEMENT_NODE) {
                return false;
            }
            if (type == Node.TEXT_NODE) {
                if (!An.isWhitespaces_(c.nodeValue)) {
                    return false;
                }
            }
        }
        return true;
    }

    static getCssPathSegments_(docuri: Uri): string[] | null {
        let segments = docuri.pathSegments$;
        let len = segments.length;
        if (len == 0) {
            return null;
        }
        let expected = Array.from(segments);
        let name = expected[len - 1];
        if (!name.endsWith(".html")) {
            return null;
        }
        name = name.substring(0, name.length - 5) + ".css";
        expected[len - 1] = name;
        return expected;
    }

    static isElementWIthName_(node: NodeX, name: stringX = null): boolean {
        if (node == null || node.nodeType != Node.ELEMENT_NODE) {
            return false;
        }
        if (name != null && node.nodeName != name) {
            return false;
        }
        return true;
    }

    static isBody_(node: Node): boolean {
        if (node == null || node.nodeType != Node.ELEMENT_NODE) { return false; }
        return An.isBodyElement_(node.nodeName);
    }

    static setAttribute_(elm: HTMLElement, name: string, value: stringX): void {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    static setAttribute0_(elm: HTMLElement, name: string, value: stringX): void {
        if (value == null || value.length == 0 || value.trim().length == 0) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    static optAttribute_(elm: HTMLElement, name: string, def: string): string {
        return elm.getAttribute(name) ?? def;
    }

    static getAttributeNames_(elm: HTMLElement): string[] {
        return this.itemsArrayOf_<Attr>(elm.attributes).map((a) => a.name);
    }

    static getAttributes_(elm: HTMLElement): Map<string, string> {
        return new Map(this.itemsArrayOf_<Attr>(elm.attributes).map((a) => [a.name, a.value]));
    }

    static removeAttributeMatch_(elm: HTMLElement, re: RegExp): void {
        this.itemsArrayOf_<Attr>(elm.attributes).forEach((a) => {
            if (re.test(a.name)) {
                elm.removeAttribute(a.name);
            };
        });
    }

    static updateHrefOrSrc_(elm: HTMLElement, href: string, param: string) {
        if (elm.getAttribute("href") != null) {
            this.setAttribute_(elm, "href", href + param);
        } else if (elm.getAttribute("src") != null) {
            this.setAttribute_(elm, "src", href);
        } else {
            const tag = elm.tagName;
            if (tag == "A") {
                this.setAttribute_(elm, "href", href + param);
            } else if (tag == "AUDIO" || tag == "VIDEO" || tag == "SOURCE" || tag == "TRACK") {
                this.setAttribute_(elm, "src", href);
            }
        }
    }

    static wrapNode_(node: Node, tag: string, attrs: StringMapX<string> = null): HTMLElement {
        return new DomBuilderEx(node.parentElement!)
            .push_()
            .childBefore_(node, tag, attrs)
            .swap_()
            .removeChild_(node)
            .pop_()
            .appendNodes_(node)
            .cursor_();
    }

    static outerHTML_(node: Node): string {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return (node as HTMLElement).outerHTML;
        }
        let name = node.nodeName;
        switch (name) {
            case "#document":
                return (node as Document).documentElement.outerHTML;
            case "#document-fragment":
                let b = new StringBuffer();
                for (let c = node.firstChild; c != null; c = c.nextSibling) {
                    b.write_(JsUtil.outerHTML_(c));
                }
                return b.toString();
            default:
                if (name.startsWith("#")) {
                    return node.nodeValue ?? "";
                }
                return "";
        }
    }

    static getContextHtml_(parent: Node): string {
        let parents: string[] = [];
        let p: Node | null = parent;
        do {
            let name = p.nodeName;
            if (An.isBodyElement_(name)) {
                break;
            }
            parents.push(name);
            p = p.parentNode;
        } while (p != null);
        let sb = new StringBuffer();
        for (let i = parents.length - 1; i >= 0; --i) {
            sb.write_("<");
            sb.write_(parents[i]);
            sb.write_(">");
        }
        for (let i: number = 0; i < parents.length; ++i) {
            sb.write_("</");
            sb.write_(parents[i]);
            sb.write_(">");
        }
        return sb.toString();
    }

    static hide_(elm: HTMLElement): void {
        elm.style.display = "none";
    }

    static show_(elm: HTMLElement, display: string = ""): void {
        elm.style.display = display;
    }

    static showHidden_(elm: HTMLElement, display: string): void {
        elm.style.visibility = "hidden";
        JsUtil.show_(elm, display);
    }

    static showVisible_(elm: HTMLElement, display: string): void {
        elm.style.visibility = "visible";
        JsUtil.show_(elm, display);
    }

    static hideVisible_(elm: HTMLElement): void {
        JsUtil.hide_(elm);
        elm.style.visibility = "visible";
    }

    static stopevent_(e: Event): void {
        try {
            if (e != null) {
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.preventDefault();
                e.cancelBubble = true;
            }
        } catch (e: any) {
        }
    }

    static stopEventImmediately_(e: Event): void {
        try {
            if (e != null) {
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.preventDefault();
                e.cancelBubble;
            }
        } catch (e: any) {
        }
    }

    static actionWrapOK_(range: RangeX): stringX {
        if (range == null) {
            return MSG.string_(RS.ActionRequireAValidSelection);
        }
        let startcontainer = range.startContainer;
        let endcontainer = range.endContainer;
        if (startcontainer == null || endcontainer == null) {
            return MSG.string_(RS.ActionRequireAValidSelection);
        }
        let startparent: Node | null = startcontainer;
        let endparent: Node | null = endcontainer;
        if (startcontainer.nodeType == Node.TEXT_NODE) {
            startparent = startcontainer.parentNode;
        }
        if (endcontainer.nodeType == Node.TEXT_NODE) {
            endparent = endcontainer.parentNode;
        }
        if (startparent != endparent || startparent?.nodeType != Node.ELEMENT_NODE) {
            return MSG.string_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
        }
        let name: string = startparent.nodeName;
        if (An.isHtmlElement_(name)) {
            return MSG.string_(RS.ActionNotPermittedOnBodyElement);
        }
        return null;
    }

    static toggleClasses_(elm: HTMLElement, classes: string[]): void {
        if (elm == null) { return; }
        let classlist = elm.classList;
        for (let c of classes) {
            classlist.toggle(c);
        }
    }

    static getFirstWord_(node: Node): string | null {
        for (let c = node.firstChild; c != null; c = c.nextSibling) {
            let ret: string | null;
            if (c.nodeType == Node.ELEMENT_NODE) {
                ret = JsUtil.getFirstWord_(c);
            } else {
                ret = An.firstWord_(c.nodeValue);
            }
            if (!An.isempty_(ret)) {
                return ret;
            }
        }
        return null;
    }

    static isInput_(node: Node): boolean {
        let name = node.nodeName;
        return node.nodeType == Node.ELEMENT_NODE && (name == "INPUT"
            || name == "TEXTAREA"
            || name == "BUTTON"
            || name == "SELECT"
            || name == "OPTION"
        );
    }

    static setValue_(node: Node, value: string): void {
        const input = JsUtil.asValueElement_(node);
        if (input != null) {
            input.value = value;
        } else {
            node.textContent = value;
        }
    }

    static getCalcValue_(node: Node): stringX {
        let value = (JsUtil.isInput_(node) ? (node as any).value : JsUtil.getFirstWord_(node));
        return JsUtil.getCalcValue1_(value);
    }

    static getCalcValue1_(value: stringX): stringX {
        if (value == null || value.length == 0) return value;
        return value.replace(RX.DoubleNumber, (_s, ...m) => {
            return m[0];
        }).replace(RX.CommaSpace_g, "");
    }

    static getFirstTextnode_(node: Node): Node | null {
        for (let c = node.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType == Node.ELEMENT_NODE) {
                let ret = JsUtil.getFirstTextnode_(c);
                if (ret != null) {
                    return ret;
                }
            } else {
                let value = An.firstWord_(c.nodeValue);
                if (!An.isempty_(value)) {
                    return c;
                }
            }
        }
        return null;
    }

    static getXInfoNumber_(elm: HTMLElement, key: string): numberX {
        return An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.xInfo))?.[key] ?? null;
    }

    static getSplitParent_(node: Node): Node | null {
        let e: Node | null = node;
        for (; e != null; e = e.parentNode) {
            let name = e.nodeName;
            if (Html5.canSplitTag(name)) {
                return e;
            }
        }
        return null;
    }

    static getElementSelfOrParent_(node: Node): HTMLElementX {
        let e: Node | null = node;
        for (; e != null; e = e.parentNode) {
            if (e.nodeType == Node.ELEMENT_NODE) return e as HTMLElement;
        }
        return null;
    }

    static normalize_(node: Node): void {
        node.normalize();
    }

    static datetimeStringWithXFormat_(elm: HTMLElement, dateformat: string, timeformat: string, date: DateTime): string {
        let formats = An.splitDatetimeXFormat_(elm.getAttribute(ATTR.xDateFormat));
        if (formats.length >= 2) {
            dateformat = DateFormat.validate_(formats[0], dateformat);
            timeformat = TimeFormat.validate_(formats[1], timeformat);
        }
        elm.setAttribute(ATTR.xDateFormat, An.xDateFormatValue_(dateformat, timeformat, date));
        return An.datetimeString_(dateformat, timeformat, date);
    }

    static getBoundingClientRect_(node: HTMLElement): MutRect {
        let rect = node.getBoundingClientRect();
        let left = Math.round(rect.left);
        let top = Math.round(rect.top);
        let width = Math.round(rect.width);
        let height = Math.round(rect.height);
        return new MutRect(left, top, width, height);
    }

    static querySelectorAll_<T extends HTMLElement>(elm: HTMLElement, selector: string): T[] {
        return Array.from<T>(elm.querySelectorAll<T>(selector));
    }

    static scrollIntoView(viewport: HTMLElement, elm: HTMLElement, adjust: Int = 0) {
        const top = elm.offsetTop + elm.offsetHeight / 2 - viewport.offsetHeight / 2 + adjust;
        viewport.scrollTop = Math.round(Math.max(0, top));
    }

    static offsetOf_(top: HTMLElement, target: HTMLElement): Point<number> {
        let x = 0;
        let y = 0;
        for (let parent = target as HTMLElementX;
            parent != null && parent != top;
            parent = parent.offsetParent as HTMLElementX) {
            x += parent.offsetLeft;
            y += parent.offsetTop;
        }
        return new Point(x, y);
    }

    static pageLocationOf_(e: Event, viewport: HTMLElementX = null): Point<number> | null {
        const scrollleft = viewport?.scrollLeft ?? 0;
        const scrolltop = viewport?.scrollTop ?? 0;
        if (e instanceof TouchEvent) {
            const touches = e.changedTouches;
            if (touches.length > 0) {
                const touch = touches[0];
                return new Point(touch.pageX + scrollleft, touch.pageY + scrolltop);
            }
        } else if (e instanceof MouseEvent) {
            return new Point(e.pageX + scrollleft, e.pageY + scrolltop);
        }
        return null;
    }
}

///////////////////////////////////////////////////////////////////////

class RangeUtil {
    static rangeStart_(range: Range): Node {
        let c = range.startContainer;
        if (c.nodeType == Node.ELEMENT_NODE) {
            return c.childNodes[range.startOffset];
        }
        return c;
    }

    static rangeEnd_(range: Range): Node {
        let c = range.endContainer;
        if (c.nodeType == Node.ELEMENT_NODE) {
            return c.childNodes[range.endOffset];
        }
        return c;
    }

    static rangeStartElement_(range: RangeX): HTMLElementX {
        if (range == null) { return null; }
        let start = range.startContainer;
        if (start.nodeType == Node.ELEMENT_NODE) {
            let child = start.childNodes[range.startOffset];
            if (child != null) start = child;
        }
        let elm: Node | null = start;
        while (elm != null && elm.nodeType != Node.ELEMENT_NODE) {
            elm = elm.parentNode;
        }
        return elm as HTMLElement;
    }

    static rangeOwnerDocument_(range: Range): Document | null {
        return range.startContainer.ownerDocument;
    }

    static wrapRange_(tag: string, attrs: StringMapX<stringX>, range: Range): HTMLElement {
        let content = range.extractContents();
        let elm = DomBuilderEx.offline_(content.ownerDocument, tag, attrs).appendNodes_(content).cursor_();
        range.insertNode(elm);
        return elm;
    }

    static replaceRange_(range: Range, node: Node): void {
        range.deleteContents();
        range.insertNode(node);
    }

    static deleteContents_(range: Range): void {
        range.deleteContents;
    }

    static cloneContents_(range: Range): DocumentFragment {
        return range.cloneContents();
    }

    static extractContents_(range: Range): DocumentFragment {
        return range.extractContents();
    }

    static insertNode_(range: Range, node: Node): void {
        range.insertNode(node);
    }

    static insertElement_(range: Range, tag: string, attrs: StringMapX<stringX>): HTMLElementX {
        const doc = range.startContainer.ownerDocument;
        if (doc == null) return null;
        let elm = DomBuilderEx.offline_(doc, tag, attrs).cursor_();
        range.insertNode(elm);
        return elm;
    }

    static insertText_(range: Range, text: string): Text {
        let textnode = DomBuilderEx.createText_(text);
        range.insertNode(textnode);
        return textnode;
    }

    static isValidNonBodyRange_(range: Range | null): boolean {
        if (range == null) { return false; }
        let start = range.startContainer;
        return !(start.nodeType == Node.ELEMENT_NODE && An.isHtmlElement_(start.nodeName));
    }

    static normalizeRange_(range: Range): void {
        range.commonAncestorContainer.normalize();
    }

    static setEndAfter_(range: Range, node: Node): void {
        range.setEndAfter(node);
    }

    static isTextSelection_(range: Range): boolean {
        let start = range.startContainer;
        let end = range.endContainer;
        if (!start || !end || start !== end) return false;
        if (start.nodeType === Node.ELEMENT_NODE) {
            start = start.childNodes[range.startOffset];
        }
        return start.nodeType === Node.TEXT_NODE;
    }

    static getText_(range: Range): stringX {
        const content = range.cloneContents();
        let ret = "";
        for (const node of Array.from(content.childNodes)) {
            ret += node.textContent;
        }
        return ret;
    }

    static setSelection_(node: Node, start: number, end: number): Range | null {
        const doc = node.ownerDocument;
        const sel = (doc?.defaultView)?.getSelection();
        if (sel == null || doc == null) return null;
        sel.removeAllRanges();
        const range = doc.createRange();
        range.setStart(node, start);
        range.setEnd(node, end);
        sel.addRange(range);
        return range;
    }
}

///////////////////////////////////////////////////////////////////////

class ElementUtil {
    static getChildWithTagAndClass_(node: HTMLElement, tag: string, klass: string): HTMLElementX {
        for (let c of new ItemsIterable<Element>(node.children)) {
            if (tag != null && tag != c.nodeName) { continue; }
            if (klass != null && !c.classList.contains(klass)) { continue; }
            return c as HTMLElement;
        }
        return null;
    }
}

///////////////////////////////////////////////////////////////////////

class FontUtil {
    static _FONT_STYLES = new Set([
        "b",
        "bi",
        "black",
        "blackitalic",
        "bold",
        "bolditalic",
        "boldoblique",
        "boldslanted",
        "book",
        "bookbold",
        "bookitalic",
        "condbold",
        "condlight",
        "condlightitalic",
        "cursive",
        "demibold",
        "demilight",
        "eight",
        "eightitalic",
        "extrabold",
        "extrabolditalic",
        "extralight",
        "extralightit",
        "extralightitalic",
        "four",
        "fouritalic",
        "hair",
        "hairitalic",
        "hairline",
        "hairlineitalic",
        "heavy",
        "heavyitalic",
        "i",
        "it",
        "italic",
        "light",
        "lightit",
        "lightitalic",
        "medium",
        "mediumitalic",
        "normal",
        "oblique",
        "r",
        "regular",
        "semibold",
        "semiboldit",
        "semibolditalic",
        "semilight",
        "slanted",
        "thin",
        "thinitalic",
        "two",
        "twoitalic",
        "ultra",
        "ultraitalic",
        "ultralight",
        "ultralightitalic",
    ]);

    static getFontNames_(values: string[], families: FontInfo[], cat: string, selected: string): number | null {
        let selectedindex = values.indexOf(selected);
        for (let info of families) {
            if (cat != "All") {
                let category = info.category$;
                if (cat != category) { continue; }
            }
            let name = info.fontname$;
            if (!name) { continue; }
            if (selectedindex < 0 && name == selected) {
                selectedindex = values.length;
            }
            values.push(name);
        }
        if (selectedindex < 0 && selected != null) {
            selectedindex = values.length;
            values.push(selected);
        }
        return selectedindex >= 0 ? selectedindex : null;
    }

    static getFontStyles_(
        values: string[],
        info: FontInfo | null,
        fontstyle: string
    ): number {
        let selectedindex: number = -1;
        if (info != null) {
            let styles = info.styles$;
            if (styles != null) {
                for (let style of styles) {
                    if (style == fontstyle) {
                        selectedindex = values.length;
                    }
                    values.push(style);
                }
                if (selectedindex < 0) {
                    if (styles.includes("Regular")) {
                        selectedindex = styles.indexOf("Regular");
                    } else if (styles.length > 0) {
                        selectedindex = 0;
                    }
                }
            }
        }
        return selectedindex;
    }

    static fontFamilyOf_(name: string, style: stringX): string {
        if (style == null || style.length == 0) {
            return name;
        }
        return name + "-" + style;
    }

    static getFontStackNameStyle_(settings: Settings, fontstack: stringX): Pair<string, string> | null {
        if (fontstack == null) { return null; }
        fontstack = An.unquote_(fontstack).trim();
        if (fontstack.length == 0) { return null; }
        if (fontstack.indexOf(",") < 0) {
            return FontUtil.splitNameStyle_(fontstack);
        }
        let a = An.splitCSVWithQuots(fontstack);
        for (let s of a) {
            let f = An.unquote_(s.trim()).trim();
            let namestyle = FontUtil.splitNameStyle_(f);
            if (settings.fontInfo_(namestyle[0]) != null) {
                return namestyle;
            }
        }
        return null;
    }

    static splitNameStyle_(family: string): [family: string, style: string] {
        function _isFontStyle(style: string): boolean {
            return FontUtil._FONT_STYLES.has(style.toLowerCase());
        }
        let index = family.lastIndexOf("-");
        if (index < 0) {
            return [family, ""];
        }
        let style: string = family.substring(index + 1);
        if (_isFontStyle(style)) {
            return [family.substring(0, index), style];
        }
        return [family, ""];
    }
}

abstract class SelectOptionUtil {
    static readonly LABELS = "XxXSA";
    static readonly VALUES = "XxXAr";

    static setOptions_(
        input: HTMLElement,
        values: string[],
        labels: string[] | null = null,
        _selectedindex: number = 0
    ): void {
        input.setAttribute(
            ATTR.AnOptions,
            JSON.stringify(smap_(
                [SelectOptionUtil.LABELS, labels],
                [SelectOptionUtil.VALUES, values],
            )));
    }

    static getOptions_(input: HTMLDivElement): JSONObjectX {
        let value = input.getAttribute(ATTR.AnOptions);
        if (value == null || value.length < 3) { return null; }
        return An.parseJSONObjectOrNull_(value);
    }

    static getLabels_(input: HTMLDivElement): string[] | null {
        return SelectOptionUtil.labelsOf_(SelectOptionUtil.getOptions_(input));
    }

    static getValues_(input: HTMLDivElement): string[] | null {
        let options = SelectOptionUtil.getOptions_(input);
        return SelectOptionUtil.valuesOf_(options);
    }

    static labelsOf_(options: JSONObjectX): string[] | null {
        if (options == null) { return null; }
        let labels = options[SelectOptionUtil.LABELS] as Array<string>;
        if (labels == null) { labels = options[SelectOptionUtil.VALUES] as Array<string>; }
        return labels;
    }

    static valuesOf_(options: JSONObjectX): string[] | null {
        return options == null ? null : options[SelectOptionUtil.VALUES] as Array<string>;
    }
}

type CallbackTable = StringMap<Fun11<stringX, stringX> | undefined>;
type HTMLElementXCallback = (elm: HTMLElementX) => void;

const MAX_TEXT_LENGTH = 128;
const XXX = "XXX";

let LinkInfoKey_BODY = "B";
let LinkInfoKey_HEAD = "H";
let LinkInfoKey_name = "n";
let LinkInfoKey_rel = "r";
let LinkInfoKey_tag = "t";
let LinkInfoKey_targetpath = "p";
let LinkInfoKey_value = "v";

let myiframe: HTMLIFrameElement | null = null;

function truncate_(msg: string, len: number): string {
    if (msg && msg.length > len) {
        if (len < 4) {
            return " ...";
        }
        return msg.substring(0, len - 4) + " ...";
    }
    return msg;
}

function isHtmlElement_(nodename: string): boolean {
    return nodename == "HTML" || nodename == "HEAD";
}

function elementinfo_(elm: HTMLElement): string {
    let css = elm.getAttribute("class");
    let href = elm.getAttribute("href");
    let src = elm.getAttribute("src");
    let name = elm.getAttribute("name");
    let text = "";
    if (elm.id) {
        text += ` id (${elm.id})`;
    }
    if (name) {
        text += ` name (${name})`;
    }
    if (css) {
        text += " class (" + truncate_(css, MAX_TEXT_LENGTH) + ")";
    }
    if (href) {
        text += " href (" + truncate_(decodeURI(href), MAX_TEXT_LENGTH)
            + ")";
    }
    if (src) {
        text += " src (" + truncate_(decodeURI(src), MAX_TEXT_LENGTH) + ")";
    }
    return text;
}

function linkinfo_(links: JSONObject, ret: JSONObject[], elm: HTMLElement, targetpath: number[]): void {
    let href = elm.getAttribute("href");
    let src = elm.getAttribute("src");
    let name = elm.getAttribute("name");
    let rel = elm.getAttribute("rel");
    if (href) {
        links[href] = null;
        let a: JSONObject = {};
        a[LinkInfoKey_tag] = elm.nodeName;
        a[LinkInfoKey_rel] = rel;
        a[LinkInfoKey_name] = "href";
        a[LinkInfoKey_value] = href;
        a[LinkInfoKey_targetpath] = targetpath;
        ret.push(a);
    } else if (src) {
        links[src] = null;
        let a: JSONObject = {};
        a[LinkInfoKey_tag] = elm.nodeName;
        a[LinkInfoKey_rel] = rel;
        a[LinkInfoKey_name] = "src";
        a[LinkInfoKey_value] = src;
        a[LinkInfoKey_targetpath] = targetpath;
        ret.push(a);
    } else if (name) {
        let a: JSONObject = {};
        a[LinkInfoKey_tag] = elm.nodeName;
        a[LinkInfoKey_rel] = rel;
        a[LinkInfoKey_name] = "name";
        a[LinkInfoKey_value] = name;
        a[LinkInfoKey_targetpath] = targetpath;
        ret.push(a);
    }
}

function gettarget_(body: HTMLElement, path: number[]): Node | null {
    let ret: Node | null = body;
    if (path) {
        for (let i = 0; ret != null && i < path.length; ++i) {
            let index = path[i];
            let children: NodeListOf<ChildNode> = ret.childNodes;
            if (children.length <= index) {
                return null;
            }
            ret = children.item(index);
        }
    }
    return ret;
}

/// @return true If start node cannot be determined.
function isInvalidRange_(range: RangeX): boolean {
    if (!range || !range.startContainer) {
        return true;
    }
    let container = range.startContainer;
    return (container.nodeType == Node.ELEMENT_NODE && container.childNodes
        .item(range.startOffset) == null);
}

/* Perform a deep first transverse of the node tree rooted at node. */
function transverse_(node: Node | null, callback: Fun10<Node>): void {
    if (node) {
        for (let c = node.firstChild; c != null; c = c.nextSibling) {
            transverse_(c, callback);
        }
        callback(node);
    }
}

function indexof_(child: Node, parent: Node): number {
    let children = parent.childNodes;
    for (let i = 0; i < children.length; ++i) {
        if (children[i] === child) {
            return i;
        }
    }
    return -1;
}

function sanitizeClone_(node: Node): void {
    transverse_(node, function (e: Node) {
        if (e.nodeType == Node.ELEMENT_NODE) {
            let elm = e as HTMLElement;
            elm.removeAttribute("xmlns");
            elm.removeAttribute("id");
        }
    });
}
function getiframe_(): HTMLIFrameElement {
    if (myiframe == null) {
        myiframe = document.getElementById(ID.contentIFrame) as HTMLIFrameElement;
    }
    return myiframe;
}

function getiframewindow_(): Window {
    return getiframe_().contentWindow!;
}

function getiframedocument_(): Document {
    return getiframewindow_().document;
}

function getiframebody_(): HTMLElement {
    return getiframedocument_().body;
}

function getiframeselection_(): Selection | null {
    let iwin = getiframewindow_();
    return iwin ? iwin.getSelection() : null;
}

function iclearselection_<T>(callback: Fun21<Selection | null, Document | null, T>): T {
    let win = getiframewindow_();
    let doc = win ? win.document : null;
    let sel = win ? win.getSelection() : null;
    if (sel) { sel.removeAllRanges(); }
    return callback(sel, doc);
}

function icreaterange_<T>(callback: Fun21<Selection, Range, T | null>): T | null {
    return iclearselection_((sel: Selection | null, doc: Document | null) => {
        if (!sel || !doc) { return null; }
        let range = doc.createRange();
        return callback(sel, range);
    });
}

function getelementforscroll_(range: RangeX): HTMLElementX {
    if (!range || !range.startContainer) {
        return null;
    }
    let node: Node | null = range.startContainer;
    if (node.nodeType == Node.ELEMENT_NODE) {
        let child = node.childNodes.item(range.startOffset);
        if (child != null) {
            node = child;
        }
    }
    while (node != null && node.nodeType != Node.ELEMENT_NODE) {
        node = node.parentElement;
    }
    return node as HTMLElement;
}

function getElementForScrollIntoView_(range: RangeX): HTMLElementX {
    return getelementforscroll_(range);
}

function myscroll_(node: NodeX, top: booleanX = null): void {
    while (node && node.nodeType != Node.ELEMENT_NODE) {
        node = node.parentNode;
    }
    if (!node) { return; }
    let elm = node as HTMLElement;
    if (top == null) {
        (elm as any).scrollIntoViewIfNeeded(true);
    } else {
        elm.scrollIntoView(top);
    }
}

function setdisplay_(elm: HTMLElementX, display: stringX): void {
    if (!elm) {
        return;
    }
    let style = elm.style;
    if (display) {
        style.display = display;
    } else {
        style.removeProperty("display");
    }
}

function removeAllAttributes_(elm: HTMLElement, excludes: string[]): void {
    let atts = elm.attributes;
    let names = [];
    for (let i = 0; i < atts.length; ++i) {
        let name = atts[i].name;
        if (excludes.indexOf(name) >= 0) {
            continue;
        }
        names.push(name);
    }
    for (let i = 0; i < names.length; ++i) {
        elm.removeAttribute(names[i]);
    }
}

function getNearestSelectedElement1_(range: RangeX): HTMLElementX {
    if (!range) {
        return null;
    }
    let start: Node | null = range.startContainer;
    if (!start) {
        return null;
    }
    if (start.nodeType === Node.ELEMENT_NODE) {
        start = start.childNodes.item(range.startOffset);
        if (start == null) {
            start = range.startContainer;
        }
    }
    while (start != null && start.nodeType !== Node.ELEMENT_NODE) {
        start = start.parentNode;
    }
    return start as HTMLElement;
}

function fixscrolloffset_(iwin: Window, ibody: HTMLElement): void {
    let x = iwin.scrollX;
    let y = iwin.scrollY;
    let top = ibody.scrollTop;
    let left = ibody.scrollLeft;
    if (x == 0 && y == 0 && top == 0 && left == 0) {
        return;
    }
    ibody.scrollLeft = 0;
    ibody.scrollTop = 0;
}

/// A simple monotonic serial counter that wraps on overflow.
/// By default, it count from 0 inclusive to Number.MAX_SAFE_INTEGER exclusive.
class Serial {
    constructor(
        protected readonly start: Long = 0,
        protected readonly end: Long = Number.MAX_SAFE_INTEGER,
        protected serial: Long = start
    ) { }

    get_(): Long {
        if (this.serial < this.start || this.serial == this.end) this.serial = this.start;
        return this.serial++;
    }

    reset_() {
        this.serial = this.start;
    }
}

class LRU {
    private readonly _store = new Array<string>();
    private _index = -1;
    constructor(private _cap: Int) {
        this._store = new Array<string>();
    }
    put_(path: string) {
        if (this._index >= 0 && this._index < this._store.length && this._store[this._index] == path)
            return;
        this._store.splice(++this._index, 0, path);
        if (this._store.length > this._cap) {
            if (this._index == this._store.length - 1) {
                this._store.shift();
                --this._index;
            } else {
                --this._store.length;
            }
        }
    }
    backward_(): stringX {
        if (this._index <= 0) return null;
        return this._store[--this._index] ?? null;
    }
    forward_(): stringX {
        if (this._index >= this._store.length - 1) return null;
        return this._store[++this._index] ?? null;
    }
    canBackward_(): boolean {
        return this._index > 0;
    }
    canForward_(): boolean {
        return this._index < this._store.length - 1;
    }
    isEmpty_(): boolean {
        return this._store.length == 0;
    }
    clear_() {
        this._index = 0;
        this._store.length = 0;
    }
    save_(out: Fun10<string>): Int {
        this._store.forEach(e => out(e));
        return this._index;
    }
    restore(list: Array<string>, index: Int) {
        this.clear_();
        for (const s of list) {
            this.put_(s);
        }
        this._index = index < 0 ? 0
            : index > this._store.length ? this._store.length
                : index;
    }
}

////////////////////////////////////////////////////////////////////////

class NativeObject {
    private _callbacks: CallbackTable = {};
    _addCallback(event: string, callback: Fun11<stringX, stringX>): void {
        this._callbacks[event] = callback;
    }
    _removeCallback(event: string, _callback: Fun10<stringX>): void {
        this._callbacks[event] = undefined;
    }
    XxXoO
        (event: string, data: string | null): string | null {
        let a = this._callbacks[event];
        if (!a) {
            return null;
        }
        return a(data);
    }
}

class Native {
    private static readonly _eventTarget = "et";
    private static readonly _eventName = "en";
    private static readonly _eventUseCapture = "ec";
    private static readonly _eventListener = "el";

    private _iframeObject: HTMLIFrameElement | null = null;
    private readonly _iframeEvents: Array<Map<string, any>> = [];
    private readonly _fixFragmentEvents: Array<Map<string, any>> = [];
    private readonly _ajaxCallbacks = new Map<number, JSONCallback>();
    private readonly _cssProperties: Map<string, string> = new Map<string, string>();
    private _range: RangeX = null;
    private _iframeRange: RangeX = null;
    private readonly _nativeObject = new NativeObject();

    cssProperties_(): Map<string, string> {
        if (this._cssProperties.size == 0) {
            let styles = this._getStyleProperties();
            
            for (let s of styles) {
                let name: string = this._uncamel(s);
                this._cssProperties.set(name, name);
            }
        }
        return this._cssProperties;
    }

    getNativeObject_(): NativeObject {
        return this._nativeObject;
    }

    private _uncamel(s: string): string {
        let ret = s.replace(RX.UpperCaseLetter_g, (_s, ...m) => {
            return `-${m[0].toLowerCase()}`;
        });
        return ret.startsWith("webkit") ? `-${ret}` : ret;
    }

    constructor() {
        this.addCallback_(AjaxAction.ajax, (s) => { return this._ajaxCallback(s); });
    }

    onBoot_(_settings: Settings): void {
    }

    onDocumentUnload_(): void {
        this._ajaxCallbacks.clear();
    }

    onIFrameLoad_(callback: Fun00): void {
        
        if (this._iframeEvents.length > 0) {
            this._iframeEvents.length = 0;
        }
        if (this._fixFragmentEvents.length > 0) {
            this._fixFragmentEvents.length = 0;
        }
        this._iframeObject = null;
        this._onIFrameLoad(() => {
            let u = this.getIFrameUri_();
            if (u != null && u.hash$.length > 0) {
                this.scrollToFragment_(u.hash$.substring(1), (_e) => {
                    callback();
                });
            } else {
                callback();
            }
        });
    }

    private _fixIFrameHrefs(baseurl: UriX): void {
        let elms = this.iQueryAll_("a[href]");
        let len: number = elms.length;
        for (let i: number = 0; i < len; ++i) {
            let elm = elms[i];
            let href = elm.getAttribute("href");
            if (href == null) continue;
            if (href.startsWith("data:")) {
                if (!href.startsWith("data:image/")) {
                    elm.removeAttribute("href");
                }
                continue;
            }
            let u = An.parseUriSafe_(href, baseurl);
            if (u == null || !PathUtil.isValidFilepathSegments(u.pathSegments$)) {
                
                elm.removeAttribute("href");
                continue;
            }
            let uu = An.cleanUri_(An.addViewParam_(u, baseurl), null, baseurl);
            if (uu != null && !uu.equals(u)) {
                
                elm.setAttribute("href", uu.encoded$);
            }
        }
    }

    private _fixIFrameSrcs(baseurl: UriX): void {
        if (baseurl == null) { return; }
        let elms = this.iQueryAll_("[src]");
        let len: number = elms.length;
        for (let i: number = 0; i < len; ++i) {
            let elm = elms[i];
            let src = elm.getAttribute("src");
            if (src == null) continue;
            if (src.startsWith("data:")) {
                if (!src.startsWith("data:image/")) {
                    elm.removeAttribute("src");
                }
                continue;
            }
            let u = An.parseUriSafe_(src, baseurl);
            if (u == null || !PathUtil.isValidFilepathSegments(u.pathSegments$)) {
                
                elm.removeAttribute("src");
                continue;
            }
            let clean = An.cleanUri_(u, null, baseurl);
            if (clean != null && !clean.equals(u)) {
                
                elm.setAttribute("src", clean.encoded$);
            }
        }
    }

    private _fixIFrameStyles(baseurl: UriX): void {
        if (baseurl == null) { return; }
        let elms = this.iQueryAll_("[style]");
        if (elms == null) { return; }
        let len: number = elms.length;
        for (let i: number = 0; i < len; ++i) {
            let elm = elms[i];
            let style = elm.getAttribute("style");
            if (style == null) continue;
            let modified = CSSUtil.cleanupCSSUrlHostPort_(style, baseurl);
            if (modified != style) {
                
                JsUtil.setAttribute0_(elm, "style", modified);
            }
        }
    }

    private _fixIFrameMedia(): void {
        Timer.sleep0_(() => {
            const elms = this.iQueryAll_<HTMLMediaElement>(`video.${CSS.xVideo}, audio.${CSS.xAudio}`);
            Timer.sleep0_(() => {
                for (const elm of elms) {
                    elm.addEventListener("pause", () => {
                        An.updateMediaParams_(elm);
                    });
                    elm.addEventListener("seeked", () => {
                        An.updateMediaParams_(elm);
                    });
                }
            });
        });
    }

    /// @param cpath Context path with or without leading /.
    findIFrameStylesheet_(cpath: string): CSSStyleSheet | null {
        const idoc = this.getIFrameDocument_();
        if (idoc == null) return null;
        const sheets = idoc.styleSheets;
        if (sheets == null) return null;
        const baseuri = this.getIFrameUri_();
        if (!cpath.startsWith(FS)) cpath = FS + cpath;
        for (let i: number = 0, len = sheets.length; i < len; ++i) {
            let sheet = sheets[i];
            let path = An.cpathOfHref2_(baseuri, sheet.href);
            if (path == null) { continue; }
            
            if (path == cpath) return sheet;
        }
        return null;
    }

    /// @param cpath Context path with or without leading /.
    updateIFrameStylesheets_(cpath: string, callback: Fun00): void {
        
        let sheet = this.findIFrameStylesheet_(cpath);
        if (sheet == null) {
            callback();
            return;
        }
        
        let node = sheet.ownerNode;
        let parent = node?.parentNode;
        if (node != null && parent != null) {
            JsUtil.remove_(node);
            let n = node;
            let next = node.nextSibling;
            Timer.sleep0_(() => {
                parent?.insertBefore(n, next);
                callback();
            });
            return;
        }
        callback();
    }

    private _fixIFrameInputs(): void {
        let elms = this.iQueryAll_("input, textarea, select");
        let len = elms.length;
        for (let i: number = 0; i < len; ++i) {
            let elm = elms[i];
            let name = elm.nodeName;
            switch (name) {
                case "TEXTAREA": {
                    let value = (elm as HTMLTextAreaElement).value;
                    JsUtil.setTextContent_(elm, value);
                    break;
                }
                case "INPUT": {
                    let input = (elm as HTMLInputElement);
                    let type = input.type;
                    if (type != null) {
                        type = type.toLowerCase();
                        if ("checkbox" == type || "radio" == type) {
                            let checked = input.checked;
                            JsUtil.setAttribute_(input, "checked", checked ? "true" : null);
                            break;
                        }
                    }
                    let value = input.value;
                    input.setAttribute("value", value);
                    break;
                }
                case "SELECT": {
                    let select = (elm as HTMLSelectElement);
                    let selected = select.selectedOptions;
                    let options = select.options;
                    if (options != null) {
                        for (let option of new ItemsIterable(options)) {
                            option.removeAttribute("selected");
                        }
                    }
                    if (selected != null) {
                        for (let option of new ItemsIterable(selected)) {
                            option.setAttribute("selected", "true");
                        }
                    }
                    break;
                }
            }
        }
    }

    _fixIFrameDate() {
        let elms = this.iQueryAll_(`[${ATTR.xDateFormat}]`);
        if (elms == null) { return; }
        const todatefmt = settings$.dateFormat_();
        const toshortfmt = settings$.shortDateFormat_();
        const totimefmt = settings$.timeFormat_();
        for (const elm of elms) {
            let format = elm.getAttribute(ATTR.xDateFormat);
            if (format == null) continue;
            const [fromdatefmt, fromtimefmt, msstr] = An.splitDatetimeXFormat_(format);
            let datefmt = fromdatefmt;
            let timefmt = fromtimefmt;
            switch (fromdatefmt) {
                case "":
                case "auto":
                case todatefmt:
                case toshortfmt:
                    break;
                default:
                    datefmt = DateFormat.transform_(todatefmt, fromdatefmt);
            }
            switch (fromtimefmt) {
                case "":
                case totimefmt:
                    break;
                default:
                    timefmt = TimeFormat.transform_(totimefmt, fromtimefmt);
            }
            if (datefmt != fromdatefmt || timefmt != fromtimefmt) {
                const ms = An.parseInt_(msstr, 0);
                elm.setAttribute(ATTR.xDateFormat, An.xDateFormatMs_(datefmt, timefmt, ms));
                const formatted = An.datetimeString_(datefmt, timefmt, DateTime.fromMs_(ms));
                An.replaceDatetimeString_(elm, formatted);
            }
        }
    }

    fixIFrameOnLoad_() {
        const uri = this.getIFrameUri_();
        this._fixIFrameHrefs(uri);
        this._fixIFrameSrcs(uri);
        this._fixIFrameStyles(uri);
        this._fixIFrameMedia();
        this._fixIFrameDate();
    }

    fixIFrameOnSave_() {
        const uri = this.getIFrameUri_();
        this._fixIFrameHrefs(uri);
        this._fixIFrameSrcs(uri);
        this._fixIFrameStyles(uri);
        this._fixIFrameInputs();
    }

    scrollToFragment_(fragment: string, callback: HTMLElementXCallback): void {
        Timer.sleep1_(() => {
            callback(this._scrollToFragment(fragment));
        });
    }

    onIFrameUnload_(): void {
        
        this.removeEventSubscriptions_(this._iframeEvents);
        this.removeEventSubscriptions_(this._fixFragmentEvents);
        this._iframeObject = null;
    }

    removeEventSubscriptions_(events: Array<Map<string, any>>): void {
        while (events.length != 0) {
            this.iRemoveEventListener_(events.pop()!);
        }
    }

    ////////////////////////////////////////////////////////////////////////

    reloadHome_(): void {
        window.location.replace(Conf.schemeHost$ + `/?t=${An.ms_()}`);
    }

    browseHome_(): void {
        let path = /* loggedin ? Conf.privateHomePath :  */ Conf.publicHomePath$;
        let uri = An.uriFromSafe_(null, path.split(FS));
        if (uri == null) {
            throw new Error();
        }
        this.browse_(uri);
    }

    ////////////////////////////////////////////////////////////////////////

    getIFrameObject_(): HTMLIFrameElement | null {
        if (this._iframeObject == null) {
            this._iframeObject = document.getElementById(ID.contentIFrame) as HTMLIFrameElement;
        }
        return this._iframeObject;
    }

    getIFrameWindow_(): Window | null {
        return this.getIFrameObject_()?.contentWindow ?? null;
    }

    iGetElementById_(id: string): HTMLElementX {
        return this._iGetElementById(id);
    }

    getIFrameScroll_(): Point<number> | null {
        let iwin = this.getIFrameWindow_();
        return iwin == null ? null : new Point<number>(iwin.scrollX, iwin.scrollY);
    }

    iQuery(selector: string, elm: ParentNode | null = null): HTMLElementX {
        return this._iQuerySelector(selector, elm);
    }

    iQueryAll_<E extends HTMLElement = HTMLElement>(selector: string, elm: ParentNode | null = null): E[] {
        return this._iQuerySelectorAll<E>(selector, elm);
    }

    getIFrameSelectionRange_(): RangeX {
        let range = this._getIFrameSelectionRange();
        if (this._range == null) {
            return range;
        }
        if (range == null || !this._rangeEquals(this._iframeRange, range)) {
            this._range = null;
            this._iframeRange = null;
            
            return range;
        }
        
        return this._range;
    }

    private _rangeEquals(range1: RangeX, range2: RangeX): boolean {
        if (range1 == null) { return range2 == null; }
        if (range2 == null) { return false; }
        return range1.startOffset == range2.startOffset
            && range1.endOffset == range2.endOffset
            && range1.startContainer == range2.startContainer
            && range2.endContainer == range2.endContainer;
    }

    getValidIFrameSelectionRange_(): RangeX {
        return this.getValidRange_(this.getIFrameSelectionRange_());
    }

    getValidRange_(range: RangeX): RangeX {
        return this._getValidRange(range);
    }

    getSelectedNodesOfRange_(range: RangeX): Node[] | null {
        return this._getSelectedNodesOfRange(range);
    }

    getSingleSelectedNodeOfRange_(range: RangeX): Node | null {
        return this._getSingleSelectedNodeOfRange(range);
    }

    getSingleSelectedNode_(): Node | null {
        return this.getSingleSelectedNodeOfRange_(this.getIFrameSelectionRange_());
    }

    getSingleSelectedOrCollapsedElement_(): HTMLElementX {
        let range = this.getIFrameSelectionRange_();
        return this.getSingleSelectedOrCollapsedElementOfRange_(range);
    }

    getNearestSelectedElement_(): HTMLElementX {
        let range = this.getIFrameSelectionRange_();
        return this._getNearestSelectedElementOfRange(range);
    }

    getNearestSelectedElementOfRange_(range: RangeX): HTMLElementX {
        return this._getNearestSelectedElementOfRange(range);
    }

    getSingleSelectedOrCollapsedElementOfRange_(range: RangeX): HTMLElementX {
        if (range == null) { return null; }
        if (range.collapsed) {
            return getNearestSelectedElement1_(range);
        }
        let ret = this._getSingleSelectedNodeOfRange(range);
        if (ret != null && ret.nodeType == Node.ELEMENT_NODE) {
            return ret as HTMLElement;
        }
        return null;
    }

    /// @return Selected text if range is under a single text node, otherwise null
    getTextSelectionOfRange_(range: RangeX): string | null {
        if (!range) {
            return null;
        }
        let start = range.startContainer;
        let end = range.endContainer;
        if (!start || !end || start !== end) {
            return null;
        }
        if (start.nodeType == Node.ELEMENT_NODE && (range.endOffset - range.startOffset) === 1) {
            const node = start.childNodes.item(range.startOffset);
            if (node.nodeType == Node.TEXT_NODE) {
                return start.textContent ?? "";
            }
        } else if (start.nodeType === Node.TEXT_NODE) {
            return start.textContent?.substring(range.startOffset, range.endOffset) ?? "";
        }
        return null;
    }

    iframeCollapseRange_(tostart: boolean): RangeX {
        return this._iCollapseRange(tostart);
    }

    ////////////////////////////////////////////////////////////////////////

    focusIFrame_(): void {
        this.focusIFrameWindow_();
        this.focusIFrameBody_();
    }

    focusIFrameWindow_(): void {
        let a = this.getIFrameWindow_();
        if (a != null) {
            
            a.focus();
        }
    }

    focusIFrameBody_(): void {
        let body = this.getIFrameBody_();
        if (body != null) {
            
            body.focus();
        }
    }

    blurIFrame_(): void {
        let body = this.getIFrameBody_();
        if (body != null) {
            
            body.blur();
        }
        let win = this.getIFrameWindow_();
        if (win != null) {
            
            win.blur();
        }
    }

    reload_(): void {
        const iframe = this.getIFrameObject_();
        let iwin = this.getIFrameWindow_();
        if (iframe == null || iwin == null) return;
        let location = iwin.location;
        let href = location.href;
        try {
            let ouri = An.parseUriSafe_(href, null);
            if (ouri == null) {
                
                return;
            }
            let o = ouri.searchParams$;
            let q = new Map<string, string>();
            for (let key of [Param.view, Param.mime]) {
                if (o.has(key)) {
                    let value = o.get(key);
                    if (value != null) {
                        q.set(key, value);
                    }
                }
            }
            let uri = An.uriFrom_(null, ouri.path$, q);
            iframe.src = uri.href$;
        } catch (e) {
            
        }
    }

    /**
         * Browse the given filepath in content-iframe.
         * @parm uri An absolute uri.
         */
    browse_(uri: Uri): void {
        if (uri.path$.toLowerCase().endsWith(".pdf")) {
            if (host$.showPdf_(uri)) return;
        }
        const iframe = this.getIFrameObject_();
        if (iframe == null) return;
        let href = uri.href$;
        
        iframe.src = href;
    }

    _ajaxCallback(json: stringX): string | null {
        let ret = An.parseJSONObjectOrNull_(json);
        if (ret == null) {
            
            return null;
        }
        let serial = ret[Key.serial];
        if (serial == null) {
            
            return null;
        }
        let callback = this._ajaxCallbacks.get(serial);
        if (callback == null) {
            
            return null;
        }
        this._ajaxCallbacks.delete(serial);
        callback(ret);
        return null;
    }

    _setRange(range: RangeX): RangeX {
        
        let sel = this._getIFrameSelectionRange();
        if (range == null || sel == null || range.collapsed) {
            this._range = null;
            this._iframeRange = null;
        } else {
            this._range = range;
            this._iframeRange = sel;
        }
        return range;
    }

    ////////////////////////////////////////////////////////////////////////

    cssEditor_(iframe: HTMLIFrameElement, content: string, fonts: string[], callback: any): any {
        return this._cssEditor(iframe, content, fonts, callback);
    }

    iGetMetaVersion_(): number {
        let ret = this._iGetMetaVersion();
        return An.parseInt_(ret, 0);
    }

    iGetMetainfo_(): string | null {
        return this._iGetMetainfo();
    }

    iSetMetainfo_(info: string): void {
        return this._iSetMetainfo(info);
    }

    /** @return The empty Selection object. */
    iClearSelection_(): Selection | null {
        this._range = null;
        this._iframeRange = null;
        return this._iClearSelection();
    }

    iSelectMulti_(nodes: Node[] | null): number {
        this._range = null;
        this._iframeRange = null;
        return this._iSelectMulti(nodes);
    }

    /// @param top true to always scroll and align node to top of viewport.
    /// false to scroll only if node is visible and needed and do not align node to top of viewport.
    iRevealNode_(node: NodeX, top: booleanX = null): void {
        this._iRevealNode(node, top);
    }

    /// @param top true to always scroll and align node to top of viewport.
    /// false to scroll only if node is visible and needed and do not align node to top of viewport.
    iRevealSelection_(top: booleanX = null): void {
        this._iRevealSelection(this.getIFrameSelectionRange_(), top);
    }

    iSelectSelector_(selector: string, elm: ParentNode | null = null): RangeX {
        return this.iSelectNode_(this._iQuerySelector(selector, elm));
    }

    /**
         * @param collapsetostart True to collapse to start, false to collapse to end, null to not collapse.
         * @return The selection range object.
         */
    iSelectNode_(node: NodeX, collapsetostart: booleanX = null, reveal: boolean = false, top: booleanX = null): RangeX {
        return this._setRange(this._iSelectNode(node, collapsetostart, reveal, top));
    }

    /// @param top true to always scroll and align node to top of viewport.
    /// false to scroll only if node is visible and needed and do not align node to top of viewport.
    iSelectNodeByPath_(path: number[], reveal: boolean = false, top: booleanX = null): void {
        this._setRange(this._iSelectNodeByPath(path, reveal, top));
    }

    /**
         * @return The selection range object.
         */
    iSelectContents_(node: Node, collapsetostart: booleanX = null): RangeX {
        return this._setRange(this._iSelectContents(node, collapsetostart));
    }

    /**
         * Create a selection that start before startnode and end after endnode.
         */
    iSelectNodes_(startnode: Node, endnode: NodeX, reveal: boolean = false, top: booleanX = null): RangeX {
        return this._setRange(this._iSelectNodes(startnode, endnode, reveal, top));
    }

    iSelect_(node: Node, startoffset: number, endoffset: number): RangeX {
        return this._setRange(this._iSelect(node, startoffset, endoffset));
    }

    iSelectRange_(range: RangeX, reveal: boolean = false, top: booleanX = null): void {
        this._iSelectRange(range, reveal, top);
        this._setRange(range);
    }

    /// @param top true to always scroll and align node to top of viewport.
    /// false to scroll only if node is visible and needed and do not align node to top of viewport.
    iSetCaretAtStart_(node: NodeX, reveal: boolean = false, top: booleanX = null): RangeX {
        return this._setRange(this._iSetCaretAtStart(node, reveal, top));
    }

    /// @param top true to always scroll and align node to top of viewport.
    /// false to scroll only if node is visible and needed and do not align node to top of viewport.
    iSetCaretAtEnd_(node: NodeX, reveal: boolean = false, top: booleanX = null): RangeX {
        return this._setRange(this._iSetCaretAtEnd(node, reveal, top));
    }

    /**
         * Select the parent node of the current selection in the content-iframe.
         * @return The parent node of the current selection in content-iframe.
         */
    iSelectParent_(): Node | null {
        let range = this._setRange(this._iSelectParent(this.getIFrameSelectionRange_()));
        if (range == null) {
            return null;
        }
        let c = range.startContainer;
        if (c.nodeType == Node.ELEMENT_NODE) {
            return c.childNodes[range.startOffset];
        }
        return c;
    }

    /**
         * Get the ancestors of the current selection.
         * @return The ancestors list, with parent node as the first node.
         */
    iGetAncestors_(): Node[] {
        return this._iGetAncestors(this.getIFrameSelectionRange_());
    }

    iCreateDocumentFragment_(nodes: Node[]): DocumentFragment | null {
        return this._iCreateDocumentFragment(nodes);
    }

    iDrawImage_(canvas: HTMLCanvasElement, img: HTMLImageElement): void {
        return this._iDrawImage(canvas, img);
    }

    getIFrameNodePath_(node: Node): number[] | null {
        return this._getIFrameNodePath(node);
    }

    /**
         * @return The index path of the start node of the current selection in content iframe.
         */
    getIFrameSelectionPath_(): number[] | null {
        let range = this.getIFrameSelectionRange_();
        return this._getIFrameSelectionPathOfRange(range);
    }

    /**
         * @return The node at the given targetpath.
         */
    getIFrameNodeByPath_(targetpath: number[], head: boolean = false): Node | null {
        return this._getIFrameNodeByPath(targetpath, head);
    }

    /**
         * @return {head: [linkinfo, ...], body: [linkinfo, ...], links: {url: null, ...}
         * where baseurl is the context relative path of iframe, eg. /Home/index.html.
         */
    getIFrameLinks_(): JSONObject {
        let baseurl = this.getIFrameContextPath_();
        return this._getIFrameLinks(baseurl);
    }

    /**
         * @notnull keys
         */
    getInlineStyles_(elm: HTMLElement, keys: string[]): Map<string, string> {
        return this._getInlineStyles(elm, keys);
    }

    /**
         * @notnull keys
         */
    getStyleOrComputedStyle_(elm: HTMLElement, pseudoelm: stringX, keys: string[]): Map<string, string> {
        return this._getStyleOrComputedStyle(elm, pseudoelm, keys);
    }

    iGetStyleOrComputedStyle1_(elm: HTMLElement, pseudoelm: stringX, key: string): string {
        return this._iGetStyleOrComputedStyle1(elm, pseudoelm, key);
    }

    getComputedStyle1_(elm: HTMLElement, pseudoelm: stringX, key: string): string | null {
        return this._getComputedStyle1(elm, pseudoelm, key);
    }

    /**
         * @notnull keys
         */
    getComputedStylesOf_(elm: HTMLElement, pseudoelm: stringX, keys: string[]): Map<string, string> {
        return this._getComputedStyle(elm, pseudoelm, keys);
    }

    getComputedStyles_(elm: HTMLElement, pseudoelm: stringX = null): CSSStyleDeclaration {
        return this._getComputedStyles(elm, pseudoelm);
    }

    getBoundingClientRect_(a: HTMLElement): DOMRect {
        return a.getBoundingClientRect();
    }

    removeAddClasses_(elm: HTMLElementX, removes: string[] | null, adds: string[] | null): void {
        this._removeAddClasses(elm, removes, adds);
    }

    toggleClasses_(elm: HTMLElement, classes: string[]): void {
        this._toggleClasses(elm, classes);
    }

    hasClass_(elm: NodeX, name: string): boolean {
        return this._hasClass(elm, name);
    }

    hasClasses_(elm: NodeX, classes: string[]): boolean[] {
        return this._hasClasses(elm, classes);
    }

    hasAnyClass_(elm: HTMLElement, classes: string[]): boolean {
        let a = elm.classList;
        for (let c of classes) {
            if (a.contains(c)) { return true; }
        }
        return false;
    }

    hasClassParent_(elm: HTMLElement, classes: string, stops: string[]): Node | null {
        return this._hasClassParent(elm, classes, stops);
    }

    /**
         * Set style properties if value is not null,
         * remove the style property if value is null.
         */
    setStyles_(elm: HTMLElement, styles: Map<string, stringX>): void {
        this._setStyles(elm, styles);
    }

    /**
         * Set a style property and return the old value.
         * @return The old property value.
         */
    replaceStyle_(elm: HTMLElement, name: string, value: stringX): string {
        return this._replaceStyle(elm, name, value);
    }

    /** Remove attribute and return the value. */
    removeAttribute_(elm: HTMLElement, key: string): string | null {
        return this._removeAttribute(elm, key);
    }

    /** Remove all attributes. */
    removeAttributes_(elm: HTMLElement, keys: ArrayX<string> = null): void {
        this._removeAttributes(elm, keys);
    }

    iWrapRange_(tag: string, attrs: SStringMap, range: Range): HTMLElementX {
        return this._iWrapRange(tag, attrs, range);
    }

    iRemovePlaceholder_(elm: HTMLElement): void {
        this._iRemovePlaceholder(elm);
    }

    iRemoveSelections_(): void {
        this._iRemoveSelections();
    }

    setDisplayBySelectorAll_(elm: HTMLElement, selector: string, display: string): void {
        this._setDisplayBySelectorAll(elm, selector, display);
    }

    setDisplayById_(id: string, display: string): void {
        this._setDisplayById(id, display);
    }

    setDisplay_(elm: HTMLElement, display: stringX): void {
        this._setDisplay(elm, display);
    }

    iAddEventListener_(
        target: Window | Document | HTMLElementX,
        event: string,
        callback: IFrameEventCallback,
        autorelease: boolean,
        usecapture: boolean = false
    ): Map<string, any> {
        let listener = this._iAddEventListener(target, event, callback, usecapture);
        let e = new Map<string, any>([
            [Native._eventTarget, target],
            [Native._eventName, event],
            [Native._eventUseCapture, usecapture],
            [Native._eventListener, listener],
        ]);
        if (autorelease) { this._iframeEvents.push(e); }
        return e;
    }

    iRemoveEventListener_(eventinfo: Map<string, any>): void {
        this._iRemoveEventListener(
            eventinfo.get(Native._eventTarget),
            eventinfo.get(Native._eventName),
            eventinfo.get(Native._eventListener),
            eventinfo.get(Native._eventUseCapture)
        );
    }

    addCallback_(event: string, callback: Fun11<stringX, stringX>): void {
        this._nativeObject._addCallback(event, callback);
    }

    removeCallback_(event: string, callback: Fun11<stringX, stringX>): void {
        this._nativeObject._removeCallback(event, callback);
    }

    onCallback_(event: string, data: any): void {
        this._nativeObject.
            XxXoO
            (event, data);
    }

    onFontLoaded_(family: string, src: stringX, callback: any): void {
        this._onFontLoaded(family, src, callback);
    }

    getNodeInfo_(node: Node): string {
        return this._getNodeInfo(node);
    }

    cloneNode_(node: Node): Node {
        return this._cloneNode(node);
    }

    cloneRange_(range: Range): DocumentFragment {
        return this._cloneRange(range);
    }

    cloneTemplate_(template: Node): DocumentFragment | null {
        return this._cloneTemplate(template);
    }

    cloneClipboard_(content: Map<string, string> | null): Node | null {
        const idoc = this.getIFrameDocument_();
        if (idoc == null || content == null) { return null; }
        let value = content.get(MapClipboardKey.value) ?? null;
        if (value == null) return null;
        let kind = content.get(MapClipboardKey.kind) ?? null;
        switch (kind) {
            case MapClipboardKind.dom:
                let context = content.get(MapClipboardKey.context) ?? null;
                return this._cloneClipboard(value, context);
            case MapClipboardKind.string:
                return idoc.createTextNode(value);
            default:
                throw Assert.notReach_(kind);
        }
    }

    getClipboardText_(content: Map<string, string>): string | null {
        let value = content.get(MapClipboardKey.value) ?? null;
        if (value == null) { return value; }
        let kind = content.get(MapClipboardKey.kind) ?? null;
        switch (kind) {
            case MapClipboardKind.dom:
                return this._getClipboardText(value);
            case MapClipboardKind.string:
                return value;
            default:
                throw Assert.notReach_(kind);
        }
    }

    serializeClone_(node: Node): string {
        return this._serializeClone(node);
    }

    serializeCutAll_(context: string, nodes: Node[]): string {
        return this._serializeCutAll(context, nodes);
    }

    createMutationObserver_(callback: MutationCallback): MutationObserver {
        return new MutationObserver(callback);
    }

    /**
         * Get the nearest enclosing element with the given marker.
         * return null if not found.
         */
    getTemplateMarker_(range: RangeX, context: stringX, markers: string[]): HTMLElementX {
        if (range == null) { return null; }
        let ret = this._getTemplateMarker(range, context, markers);
        
        return ret;
    }

    getIndexOf_(node: Node): number {
        return this._getIndexOf(node);
    }

    stringify_(a: object): string {
        return this._stringify(a);
    }

    keys_(a: object): string[] {
        return this._keys(a);
    }

    serializeToString_(node: Node): string {
        return new XMLSerializer().serializeToString(node);
    }

    serializeIFrameDocument_(): string {
        return this._serializeIFrameDocument();
    }

    ////////////////////////////////////////////////////////////////////////

    toggleFullscreen_(): void {
        this._toggleFullscreen();
    }

    isFullscreen_(): boolean {
        return this._isFullscreen();
    }

    isVisible_(node: Node): boolean {
        return this._isVisible(node);
    }

    isVisible1_(node: Node): boolean {
        return this._isVisible1(node);
    }

    getSettings_(): JSONObjectX {
        return An.parseJSONObjectOrNull_(this._getSettings());
    }

    audioPlayer_(elm: HTMLMediaElement) {
        this._audioPlayer(elm);
    }

    ////////////////////////////////////////////////////////////////////////

    getIFrameDocument_(): Document | null {
        return this.getIFrameWindow_()?.document ?? null;
    }

    getIFrameBody_(): HTMLElementX {
        return this.getIFrameDocument_()?.body ?? null;
    }

    getIFrameHead_(): HTMLElementX {
        return this.getIFrameDocument_()?.head ?? null;
    }

    /// @return The absolute iframe URI href.
    getIFrameHref_(): stringX {
        try {
            const location = this.getIFrameDocument_()?.location ?? null;
            return location == null ? null : location.href;
        } catch (e) {
            
        }
        return null;
    }

    private iframeUriCache: [string, UriX] | null = null;

    getIFrameUri_(): UriX {
        const href = this.getIFrameHref_();
        if (href == null) { return null; }
        if (this.iframeUriCache != null && this.iframeUriCache[0] === href) {
            return this.iframeUriCache[1];
        }
        const uri = An.parseUriSafe_(href, null);
        this.iframeUriCache = uri == null ? null : [href, uri];
        return uri;
    }

    /**
     * @return The decoded iframe document path relative to CONTEXT_PATH, with leading /
     * and excluding any query string and fragment identifier, eg. /Home/images/1.html.
     * Returns null if current document is not under CONTEXT_PATH/.
     */
    getIFrameContextPath_(): string | null {
        const uri = this.getIFrameUri_();
        return uri == null ? null : An.cpathOfUri_(uri);
    }

    getIFrameDir_(): stringX {
        const cpath = this.getIFrameContextPath_();
        return cpath == null ? null : Basepath.dir_(cpath);
    }

    asPathQuery_(uri: UriX): string {
        if (uri == null) { return "?path="; }
        return "?path=" + encodeURIComponent(uri.toAbsolute_().path$);
    }

    filenameFromURL_(url: string, baseurl: BaseUriX): string {
        return An.filenameFromUri_(An.parseUriSafe_(url, baseurl));
    }

    filenameFromCSSURL_(cssurl: string, baseurl: BaseUriX): string {
        let m = new RegExp("^url\\((.*)\\)\$").exec(cssurl);
        return this.filenameFromURL_(m != null ? m[1].trim() : cssurl, baseurl);
    }

    /**
      * Format the styles in a format suitable for editing in a textarea.
      */
    formatStylesForEditing_(styles: Array<Array<string>>, indent: stringX = null, baseurl: BaseUriX): string {
        let ret = new StringBuffer();
        for (let namevalue of styles) {
            if (namevalue.length != 2) {
                
                continue;
            }
            if (indent != null) {
                ret.write_(indent);
            }
            let key = namevalue[0];
            let value = CSSUtil.humanCSSUrls_(namevalue[1], baseurl);
            let esc = CSSUtil.escCSSValue_(key, value);
            ret.write_(key);
            ret.write_(" ");
            ret.write_(esc);
            ret.write_(DEF.LF);
        }
        return ret.toString();
    }

    getStylesheet_(expected: string[], idoc: Document): CSSStyleSheet | null {
        let sheets = idoc.styleSheets;
        const baseuri = native$.getIFrameUri_();
        if (baseuri != null) {
            for (let sheet of new ItemsIterable<CSSStyleSheet>(sheets)) {
                if (this.acceptStylesheet_(expected, sheet, baseuri)) {
                    return sheet;
                }
            }
        }
        return null;
    }

    acceptStylesheet_(expected: string[], sheet: CSSStyleSheet, baseuri: BaseUri): boolean {
        let href = sheet.href;
        let ret: boolean = this.acceptStylesheet1_(expected, href, baseuri);
        
        return ret;
    }

    acceptStylesheet1_(expected: string[], href: stringX, baseuri: BaseUri): boolean {
        if (href == null) { return false; }
        let uri = An.parseUriSafe_(href, baseuri);
        if (uri == null) { return false; }
        let path = uri.pathSegments$;
        if (expected.length != path.length) { return false; }
        for (let i = 0, len = expected.length; i < len; ++i) {
            if (expected[i] != path[i]) {
                return false;
            }
        }
        return true;
    }

    ////////////////////////////////////////////////////////////////////////

    private _cssEditor(iframe: HTMLIFrameElement, content: string, fonts: any, callback: any): any {
        const win = iframe.contentWindow;
        if (!win)
            return null;
        const editor = (win as any).
            XxXXC;
        editor.
            XxXCy
            (content, fonts, callback);
        return editor;
    }
    private _iGetMetaVersion(): string | null {
        let idoc = getiframedocument_();
        let head = idoc ? idoc.head : null;
        if (!head) { return null; }
        let e = head.querySelector("meta[name=version]");
        if (e) {
            return e.getAttribute("content");
        }
        return null;
    }
    private _iGetMetainfo(): string | null {
        let idoc = getiframedocument_();
        let head = idoc ? idoc.head : null;
        if (!head) { return null; }
        let e = head.querySelector("meta[name=metainfo]");
        if (e) {
            return e.getAttribute("content");
        }
        return null;
    }
    private _iSetMetainfo(value: string): void {
        let idoc = getiframedocument_();
        let head = idoc ? idoc.head : null;
        if (!head || !idoc) { return; }
        let e = head.querySelector("meta[name=metainfo]");
        if (!e) {
            e = idoc.createElement("meta");
            e.setAttribute("name", "metainfo");
            idoc.head.appendChild(e);
        }
        e.setAttribute("content", value);
    }
    private _scrollToFragment(fragment: string): HTMLElementX {
        let doc = getiframedocument_();
        if (!doc) return null;
        let decoded = decodeURIComponent(fragment);
        let e = doc.getElementById(decoded);
        if (e == null) {
            let list = doc.getElementsByName(decoded);
            if (list.length > 0) {
                e = list[0];
            }
        }
        if (e != null && e.nodeType == Node.ELEMENT_NODE) {
            myscroll_(e, true);
        }
        return e;
    }
    private _onIFrameLoad(callback: Fun00): void {
        let iwin = getiframewindow_();
        let idoc = iwin ? iwin.document : null;
        let ibody = idoc ? idoc.body : null;
        if (!ibody || !idoc || !iwin) {
            callback();
            return;
        }
        idoc.execCommand("insertBrOnReturn", true, "true");
        ibody.setAttribute(ATTR.autocomplete, "on");
        ibody.setAttribute(ATTR.autocorrect, "on");
        ibody.setAttribute(ATTR.spellcheck, "true");
        fixscrolloffset_(iwin, ibody);
        callback();
    }
    private _getIFrameSelectionRange(index?: number): RangeX {
        index = index || 0;
        let sel = getiframeselection_();
        return (sel && sel.rangeCount > index) ? sel.getRangeAt(index) : null;
    }
    private _getValidRange(range: RangeX): RangeX {
        return isInvalidRange_(range) ? null : range;
    }
    private _getSelectedNodesOfRange(range: RangeX): Node[] | null {
        if (!range) {
            return null;
        }
        let start = range.startContainer;
        let end = range.endContainer;
        if (!start || !end || start !== end) {
            return null;
        }
        if (start.nodeType !== Node.ELEMENT_NODE) {
            return null;
        }
        let children = start.childNodes;
        let ret = [];
        for (let i = range.startOffset, len = children.length; i < len
            && i < range.endOffset; ++i) {
            ret.push(children[i]);
        }
        return ret;
    }
    /**
     * @return The start element or parent element of the current selection,
     *         return null if there is no valid selection.
     */
    private _getNearestSelectedElementOfRange(range: RangeX): HTMLElementX {
        return getNearestSelectedElement1_(range);
    }
    /**
     * @return The single text or element node selected by the range or null if
     *         the range do not select a single node.
     */
    private _getSingleSelectedNodeOfRange(range: RangeX): Node | null {
        if (!range) {
            return null;
        }
        let start = range.startContainer;
        let end = range.endContainer;
        if (!start || !end || start !== end) {
            return null;
        }
        if (start.nodeType === Node.ELEMENT_NODE
            && (range.endOffset - range.startOffset) === 1) {
            return start.childNodes.item(range.startOffset);
        } else if (start.nodeType === Node.TEXT_NODE && range.startOffset === 0
            && start.textContent && range.endOffset === start.textContent.length) {
            return start;
        }
        return null;
    }
    /**
     * @return [int] The path from body to the start node of the selection
     *         range. eg. [] for the body element, [0, 1] for the second child
     *         of the first child of body. Return null if there is no valid
     *         selection.
     */
    private _getIFrameSelectionPathOfRange(range: RangeX): number[] | null {
        if (!range || !range.startContainer) {
            return null;
        }
        let start = range.startContainer;
        if (start.nodeType === Node.ELEMENT_NODE) {
            let node = start.childNodes.item(range.startOffset);
            if (node != null) {
                start = node;
            }
        }
        return this._getIFrameNodePath(start);
    }
    private _getIFrameNodePath(node: Node | null): number[] | null {
        let ret = [];
        while (node != null && node.nodeName != "BODY"
            && node.nodeName != "HEAD") {
            let parent = node.parentNode;
            if (parent == null) {
                return null;
            }
            let index = indexof_(node, parent);
            if (index < 0) {
                return null;
            }
            ret.unshift(index);
            node = parent;
        }
        return ret;
    }
    private _getIFrameNodeByPath(targetpath: number[], head: boolean): Node | null {
        if (targetpath == null) return null;
        let idoc = getiframedocument_();
        if (!idoc) return null;
        let parent: Node = (head ? idoc.head : idoc.body);
        if (!parent) {
            return null;
        }
        for (let i = 0; i < targetpath.length; ++i) {
            let index = targetpath[i];
            let children = parent.childNodes;
            if (!children || index >= children.length) {
                return null;
            }
            parent = children[index];
        }
        return parent;
    }
    private _iCreateDocumentFragment(nodes: Node[]): DocumentFragment | null {
        let doc = getiframedocument_();
        if (doc == null) {
            return null;
        }
        let fragment = doc.createDocumentFragment();
        for (let i = 0; i < nodes.length; ++i) {
            fragment.appendChild(nodes[i].cloneNode(true));
        }
        return fragment;
    }
    private _iDrawImage(canvas: HTMLCanvasElement, img: HTMLImageElement): void {
        let context = canvas.getContext("2d");
        if (context) context.drawImage(img, 0, 0);
    }
    private _iGetElementById(id: string): HTMLElementX {
        let doc = getiframedocument_();
        return doc ? doc.getElementById(id) as HTMLElement : null;
    }
    private _iQuerySelector(selector: string, elm: ParentNode | null = null): HTMLElementX {
        if (!elm) { elm = getiframebody_(); }
        return elm ? elm.querySelector(selector) : null;
    }
    _iQuerySelectorAll<E extends HTMLElement = HTMLElement>(selector: string, elm: ParentNode | null = null): E[] {
        if (!elm) { elm = getiframebody_(); }
        return DomUt.queryAll_<E>(elm, selector);
    }
    private _getStyleProperties(): string[] {
        return Object.keys(document.body.style);
    }
    private _getInlineStyles(elm: HTMLElement, keys: string[]): Map<string, string> {
        let ret = new Map<string, string>();
        let style = elm.style;
        for (let i = 0; i < keys.length; ++i) {
            let name = keys[i];
            let value = style.getPropertyValue(name);
            if (typeof (value) === "undefined"
                || value === null
                || (typeof (value) === "string") && (value.length == 0 || value == "auto")) {
                continue;
            }
            ret.set(name, value);
        }
        return ret;
    }
    private _getStyleOrComputedStyle(elm: HTMLElement, pseudoelm: string | null, keys: string[]): Map<string, string> {
        let ret = new Map<string, string>();
        let win = getiframewindow_();
        if (win == null) return ret;
        let style = elm.style;
        let compute = [];
        for (const key of keys) {
            let value = style.getPropertyValue(key);
            if (typeof (value) === "string" && value.length > 0 && value != "auto") {
                ret.set(key, value);
            } else {
                compute.push(key);
            }
        }
        if (compute.length > 0) {
            let styles = win.getComputedStyle(elm, pseudoelm);
            for (const name of compute) {
                ret.set(name, styles.getPropertyValue(name));
            }
        }
        return ret;
    }
    private _iGetStyleOrComputedStyle1(elm: HTMLElement, pseudoelm: string | null, name: string): string {
        let win = getiframewindow_() as Window;
        let style = elm.style;
        let value = style.getPropertyValue(name);
        if (typeof (value) === "string" && value.length > 0 && value != "auto") {
            return value;
        }
        const styles = win.getComputedStyle(elm, pseudoelm);
        return styles.getPropertyValue(name);
    }
    private _getComputedStyles(elm: HTMLElement, pseudoelm: stringX = null): CSSStyleDeclaration {
        let win = getiframewindow_();
        return win.getComputedStyle(elm, pseudoelm);
    }
    private _getComputedStyle1(elm: HTMLElement, pseudoelm: string | null, key: string): stringX {
        let win = getiframewindow_();
        if (!win) { return null; }
        let styles = win.getComputedStyle(elm, pseudoelm);
        return styles.getPropertyValue(key);
    }
    private _getComputedStyle(
        elm: HTMLElement,
        pseudoelm: string | null,
        keys: string[],
    ): Map<string, string> {
        let ret = new Map<string, string>();
        let win = getiframewindow_();
        if (!win) { return ret; }
        let styles = win.getComputedStyle(elm, pseudoelm);
        for (let i = 0; i < keys.length; ++i) {
            let name = keys[i];
            ret.set(name, styles.getPropertyValue(name));
        }
        return ret;
    }
    private _replaceStyle(elm: HTMLElement, name: string, value: stringX): string {
        let ovalue = elm.style.getPropertyValue(name);
        let newvalue = null;
        elm.style.removeProperty(name);
        let cvalue = "";
        if (value != null && value.length > 0) {
            cvalue = this._getComputedStyle1(elm, null, name) ?? "";
            if (value != cvalue) {
                newvalue = name + ": " + value + ";";
            }
        }
        let style = elm.getAttribute("style");
        if (newvalue != null) {
            style = newvalue + (style == null ? "" : style);
        }
        if (style == null || style.length == 0) {
            elm.removeAttribute("style");
        } else {
            elm.setAttribute("style", style);
        }
        return ovalue;
    }
    private _removeAddClasses(elm: HTMLElementX, removes: string[] | null, adds: string[] | null): void {
        if (!elm) return;
        let classes = elm.classList;
        if (removes) {
            for (const c of removes) {
                classes.remove(c);
            }
        }
        if (adds) {
            for (const c of adds) {
                if (!classes.contains(c)) {
                    classes.add(c);
                }
            }
        }
    }
    private _toggleClasses(elm: HTMLElement, classes: string[]): void {
        if (!elm || !classes) {
            return;
        }
        let classlist = elm.classList;
        for (let i = 0, len = classes.length; i < len; ++i) {
            classlist.toggle(classes[i]);
        }
    }
    private _setStyles(elm: HTMLElement, styles?: Map<string, stringX>): void {
        if (styles === undefined || styles.size == 0) {
            return;
        }
        let style = elm.style;
        for (const [key, value] of styles.entries()) {
            if (value == null || value.length == 0) {
                style.removeProperty(key);
            } else {
                style.setProperty(key, value);
            }
        }
        {
            let style = elm.getAttribute("style");
            if (style == null || style.length == 0) {
                elm.removeAttribute("style");
            } else {
                elm.setAttribute("style", style);
            }
        }
    }
    private _hasClass(elm: NodeX, c: string): boolean {
        if (elm == null || elm.nodeType != Node.ELEMENT_NODE) { return false; }
        const classlist = (elm as HTMLElement).classList;
        return classlist.contains(c);
    }
    private _hasClasses(elm: NodeX, classes: string[]): boolean[] {
        const iselm = (elm != null && elm.nodeType == Node.ELEMENT_NODE);
        const classlist = iselm ? (elm as HTMLElement).classList : null;
        return classes.map(c => classlist != null && classlist.contains(c));
    }
    private _hasClassParent(elm: Node | null, classes: string, stops: string[]): Node | null {
        while (elm) {
            if (elm.nodeType === Node.ELEMENT_NODE) {
                let list = (elm as HTMLElement).classList;
                if (list.contains(classes)) {
                    return elm;
                } else if (stops) {
                    for (let i = 0, len = stops.length; i < len; ++i) {
                        if (list.contains(stops[i])) {
                            return null;
                        }
                    }
                }
            }
            elm = elm.parentNode;
        }
        return null;
    }
    private _removeAttribute(elm: HTMLElement, name: string): string | null {
        let ret = null;
        if (elm) {
            ret = elm.getAttribute(name);
            elm.removeAttribute(name);
        }
        return ret;
    }
    private _removeAttributes(elm: HTMLElement, names: ArrayX<string>): void {
        if (elm) {
            let attrs = elm.attributes;
            let copy = [];
            for (let i = 0; i < attrs.length; ++i) {
                if (names == null) {
                    copy.push(attrs[i]);
                } else {
                    let a = attrs[i];
                    let name = a.name;
                    if (names.indexOf(name) >= 0) {
                        copy.push(a);
                    }
                }
            }
            for (let i = 0; i < copy.length; ++i) {
                elm.removeAttributeNode(copy[i]);
            }
        }
    }
    ///// IFrame update methods

    private _iClearSelection(): Selection | null {
        let sel = getiframeselection_();
        sel && sel.removeAllRanges();
        return sel;
    }
    private _iCollapseRange(tostart?: boolean): RangeX {
        let range = this._getIFrameSelectionRange();
        if (!range) { return null; }
        if (!range.collapsed) {
            let sel = getiframeselection_();
            if (!sel) { return null; }
            range.collapse(tostart);
            sel.removeAllRanges();
            sel.addRange(range);
        }
        return range;
    }
    /**
     * Add the given nodes to the current selection. Note that this do not clear
     * the current selection first.
     *
     * @return The number of selected ranges.
     */
    private _iSelectMulti(nodes: Node[] | null): number {
        if (nodes == null) { return 0; }
        return iclearselection_((sel: Selection | null, doc: Document | null) => {
            if (sel == null || doc == null) { return 0; }
            let len = nodes.length;
            for (let i = 0; i < len; ++i) {
                let node = nodes[i];
                let range = doc.createRange();
                range.selectNode(node);
                sel.addRange(range);
            }
            return len;
        });
    }
    private _iSelectRange(range: RangeX, reveal?: boolean, top: booleanX = null): RangeX {
        if (!range) { return null; }
        return iclearselection_((sel: Selection | null, doc: Document | null) => {
            if (sel == null || doc == null) { return null; }
            if (reveal == true) {
                let elm = getelementforscroll_(range);
                myscroll_(elm, top);
            }
            sel.addRange(range);
            return range;
        });
    }
    /** @return The range object. */
    private _iSelectNode(node: Node | null | undefined, collapse?: booleanX, reveal?: booleanX, top?: booleanX): RangeX {
        if (!node) { return null; }
        return icreaterange_((sel: Selection, range: Range) => {
            if (reveal == true) { myscroll_(node, top); }
            range.selectNode(node);
            if (collapse != null) { range.collapse(collapse); }
            sel.addRange(range);
            return range;
        });
    }
    /** @return The range object. */
    private _iSelectContents(node: Node | null | undefined, collapse: booleanX = null): RangeX {
        if (!node) { return null; }
        return icreaterange_((sel, range) => {
            range.selectNodeContents(node);
            if (collapse != null) { range.collapse(collapse); }
            sel.addRange(range);
            return range;
        });
    }
    /**
     * Select from startnode inclusive to endnode inclusive.
     * @param startnode must not be null.
     * @param endnode may be null.
     */
    private _iSelectNodes(startnode: Node, endnode?: NodeX, reveal: boolean = false, top: booleanX = null): RangeX {
        return icreaterange_((sel, range) => {
            if (reveal == true) { myscroll_(startnode, top); }
            range.setStartBefore(startnode);
            if (endnode) {
                range.setEndAfter(endnode);
            } else {
                let parent = startnode.parentNode;
                let lastchild = (parent) ? parent.lastChild : null;
                if (lastchild) range.setEndAfter(lastchild);
            }
            sel.addRange(range);
            return range;
        });
    }
    private _iSelect(node: Node | null, startoffset: number, endoffset: number): RangeX {
        if (!node) { return null; }
        return icreaterange_((sel: Selection, range: Range) => {
            range.setStart(node, startoffset);
            range.setEnd(node, endoffset);
            sel.addRange(range);
            return range;
        });
    }
    private _iSetCaretAtStart(node: NodeX, reveal?: boolean, top: booleanX = null): RangeX {
        if (!node) { return null; }
        return icreaterange_((sel: Selection, range: Range) => {
            if (reveal == true) { myscroll_(node, top); }
            range.setStartBefore(node);
            range.setEndBefore(node);
            range.collapse(true);
            sel.addRange(range);
            return range;
        });
    }
    private _iSetCaretAtEnd(node: NodeX, reveal?: boolean, top: booleanX = null): RangeX {
        if (!node) { return null; }
        return icreaterange_((sel, range) => {
            if (reveal == true) { myscroll_(node, top); }
            range.setStartAfter(node);
            range.setEndAfter(node);
            range.collapse();
            sel.addRange(range);
            return range;
        });
    }
    private _iSelectNodeByPath(path: number[], reveal: boolean = false, top: booleanX = null): RangeX {
        let ibody = getiframebody_();
        if (!ibody) return null;
        let target = gettarget_(ibody, path);
        return this._iSelectNode(target, null, reveal, top);
    }
    private _iRevealNode(node: NodeX, top: booleanX = null): void {
        myscroll_(node, top);
    }
    private _iRevealSelection(range: RangeX, top: booleanX = null): void {
        let elm = getElementForScrollIntoView_(range);
        myscroll_(elm, top);
    }
    private _iSelectParent(range: RangeX): RangeX {
        let win = getiframewindow_();
        let doc = win ? win.document : null;
        if (!doc) { return null; }
        let node = null;
        if (range == null) {
            range = doc.createRange();
            node = doc.body;
        } else {
            node = range.collapsed ? range.startContainer
                : range.commonAncestorContainer;
            let type = node.nodeType;
            if (type == Node.TEXT_NODE || type == Node.COMMENT_NODE
                || type == Node.CDATA_SECTION_NODE) {
                if (!range.collapsed) {
                    node = node.parentNode;
                }
            } else if (type != Node.ELEMENT_NODE
                || isHtmlElement_(node.nodeName)) {
                node = doc.body;
            }
        }
        if (!node) { return null; }
        return this._iSelectNode(node);
    }
    private _iGetAncestors(range: RangeX): Node[] {
        if (range == null) {
            return [];
        }
        let node = null;
        let body = getiframebody_();
        if (body == null) {
            return [];
        }
        let start = range.startContainer;
        let end = range.endContainer;
        if (!start || !end || start !== end) {
            return [];
        }
        if (start.nodeType === Node.ELEMENT_NODE) {
            node = start.childNodes.item(range.startOffset);
            if (node == null) node = start;
        } else {
            node = start;
        }
        let type = node.nodeType;
        if (type == Node.ELEMENT_NODE && isHtmlElement_(node.nodeName)) {
            return [body];
        }
        let ret: Node[] = [];
        do {
            ret.push(node);
            node = node.parentNode;
        } while (node != null && !isHtmlElement_(node.nodeName));
        return ret;
    }
    /// Wrap content of given range in an element and select the element.
    /// @return The created element, null if range is invalid.
    private _iWrapRange(tag: string, attrs: SStringMap, range: Range): HTMLElementX {
        let doc = range.startContainer.ownerDocument;
        if (!doc) return null;
        let content = range.extractContents();
        let elm = DomBuilderEx.offline_(doc, tag, attrs).cursor_();
        elm.append(content);
        range.insertNode(elm);
        return elm;
    }
    private _iRemovePlaceholder(elm: HTMLElement): void {
        let classlist = elm.classList;
        classlist.remove("x-placeholder");
        if (classlist.length == 0) {
            elm.removeAttribute("class");
        }
        for (let child = elm.firstChild; child != null; child = elm.firstChild) {
            child.remove();
        }
        elm.textContent = XXX;
        this._iSelectNode(elm.firstChild);
    }
    private _iRemoveSelections(): void {
        getiframebody_()?.blur();
        getiframeselection_()?.removeAllRanges();
    }
    private _setDisplay(elm: HTMLElement, display: stringX): void {
        setdisplay_(elm, display);
    }
    private _setDisplayBySelectorAll(elm: HTMLElementX, sel: string, display: string): void {
        elm = elm || getiframebody_();
        let elms = elm ? elm.querySelectorAll(sel) : null;
        if (elms) {
            for (let i = 0, len = elms.length; i < len; ++i) {
                setdisplay_(elms[i] as HTMLElement, display);
            }
        }
    }
    private _setDisplayById(id: string, display: string): void {
        let elm = this._iGetElementById(id);
        setdisplay_(elm, display);
    }
    private _iAddEventListener(
        elm: Window | Document | HTMLElementX,
        event: string, listener:
            Fun10<Event>,
        usecapture?: boolean
    ): Fun10<Event> {
        if (elm == null) {
            elm = getiframewindow_();
        }
        elm.addEventListener(event, listener, usecapture);
        return listener;
    }
    private _iRemoveEventListener(
        elm: HTMLElement,
        event: string,
        listener: Fun10<Event>,
        usecapture?: boolean
    ) {
        if (elm) {
            elm.removeEventListener(event, listener, usecapture);
        } else {
            getiframewindow_()?.removeEventListener(event, listener, usecapture);
        }
    }
    private _cloneNode(node: Node): Node {
        let clone = node.cloneNode(true);
        clone.normalize();
        sanitizeClone_(clone);
        return clone;
    }
    private _cloneRange(range: Range): DocumentFragment {
        let clone = range.cloneContents();
        clone.normalize();
        return clone;
    }
    private _serializeCutAll(context: string, nodes: Node[]): string {
        let idoc = getiframedocument_();
        if (!idoc) return "";
        let body = idoc.createElement("body");
        if (context != null) {
            body.innerHTML = context;
        }
        let parent: Node = body;
        for (let c; (c = parent.firstChild) != null;) {
            if (c.nodeType != Node.ELEMENT_NODE) {
                break;
            }
            parent = c;
        }
        for (let i = 0; i < nodes.length; ++i) {
            let node = nodes[i];
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
            parent.appendChild(node);
        }
        sanitizeClone_(parent);
        return this._serializeClone(parent);
    }
    private _cloneClipboard(html: string, context: string | null): Node | null {
        let idoc = getiframedocument_();
        if (!idoc) return null;
        let body = idoc.createElement("body");
        if (context != null) {
            body.innerHTML = context;
        }
        let parent: HTMLElement = body;
        for (let c; (c = parent.firstChild) != null;) {
            if (c.nodeType != Node.ELEMENT_NODE) {
                break;
            }
            parent = c as HTMLElement;
        }
        parent.innerHTML = html;
        sanitizeClone_(parent);
        return parent;
    }
    private _getClipboardText(html: string): string | null {
        let idoc = getiframedocument_();
        let parent = idoc.createElement("div");
        parent.innerHTML = html;
        return parent.textContent;
    }
    private _cloneTemplate(template: Node): DocumentFragment | null {
        let ret = getiframedocument_()?.createDocumentFragment();
        if (!ret) return null;
        let children = template.childNodes;
        for (let i = 0, len = children.length; i < len; ++i) {
            let c = children[i];
            let clone = c.cloneNode(true);
            clone.normalize();
            sanitizeClone_(clone);
            ret.appendChild(clone);
        }
        return ret;
    }
    private _getTemplateMarker(range: RangeX, context: stringX, markers: string[]): HTMLElementX {
        let node = getNearestSelectedElement1_(range);
        let ret = null;
        if (!Array.isArray(markers)) {
            markers = [markers];
        }
        let iwin = getiframewindow_();
        if (!iwin) { return null; }
        for (; node !== null; node = node.parentElement) {
            let classlist = node.classList;
            let len = classlist ? classlist.length : 0;
            for (let i = 0; i < len; ++i) {
                let c = classlist[i];
                if (c == "x-rsb-content") {
                    return null;
                }
                if (ret != null) {
                    continue;
                }
                if (markers.indexOf(c) >= 0 || !An.isempty_(context) && c == context) {
                    if (this._isVisible(node.parentNode)) {
                        ret = node;
                    }
                }
                if (node.nodeName == "BODY") {
                    break;
                }
            }
        }
        return ret;
    }
    private _getIndexOf(child: Node): number {
        let parent = child.parentElement;
        if (parent != null) {
            let children = parent.childNodes;
            let len = children.length;
            for (let i = 0; i < len; ++i) {
                if (children[i] === child) {
                    return i;
                }
            }
        }
        return -1;
    }
    private _getNodeInfo(node: Node): string {
        let type = node.nodeType;
        if (type == Node.ELEMENT_NODE) {
            return elementinfo_(node as HTMLElement);
        } else if (type == Node.TEXT_NODE) {
            return truncate_(node.textContent || "", MAX_TEXT_LENGTH);
        } else if (type == Node.CDATA_SECTION_NODE) {
            return node.nodeName + "#" + truncate_(node.textContent || "", MAX_TEXT_LENGTH);
        } else {
            return node.nodeName;
        }
    }
    /**
     * @param baseurl The full iframe url.
     * @return {head: [linkinfo, ...], body: [linkinfo, ...], links: {url: null, ...}, baseurl: stringX }
     */
    private _getIFrameLinks(baseurl: string | null): JSONObject {
        let ret = json_();
        let links = json_();
        let head: JSONObject[] = [];
        let body: JSONObject[] = [];
        ret[LinkInfoKey_HEAD] = head;
        ret[LinkInfoKey_BODY] = body;
        let idoc = getiframedocument_();
        if (idoc) {
            let headlinks = DomUt.queryAll_(idoc.head, "[href], [src]");
            for (let i = 0; i < headlinks.length; ++i) {
                let elm = headlinks[i];
                let targetpath = this._getIFrameNodePath(elm);
                if (targetpath) {
                    linkinfo_(links, head, elm, targetpath);
                }
            }
            let bodylinks = DomUt.queryAll_(idoc.body, "[href], [src], a[name]");
            for (let i = 0; i < bodylinks.length; ++i) {
                let elm = bodylinks[i];
                let targetpath = this._getIFrameNodePath(elm);
                if (targetpath) {
                    linkinfo_(links, body, elm, targetpath);
                }
            }
            ret[Key.baseurl] = baseurl;
            ret[Key.links] = links;
        }
        return ret;
    }
    private _stringify(a: object): string {
        return JSON.stringify(a);
    }
    private _keys(a: {}): string[] {
        return Object.keys(a);
    }
    private _serializeIFrameDocument(): string {
        let idoc = getiframedocument_();
        if (!idoc) return "";
        return this.serializeDocument_(idoc);
    }
    serializeDocument_(idoc: Document): string {
        let clone: Document = idoc.cloneNode(true) as Document;
        let html = clone.querySelector("html");
        if (html) { html.removeAttribute("style"); }
        let body = clone.querySelector("body");
        if (body) {
            removeAllAttributes_(body, ["class"]);
        }
        let iterator = clone.createNodeIterator(clone, NodeFilter.SHOW_ELEMENT);
        for (let n; (n = iterator.nextNode()) != null;) {
            DomUt.asHTMLElement_(n)?.removeAttribute("xmlns");
        }
        return new XMLSerializer().serializeToString(clone);
    }
    private _serializeClone(node: Node): string {
        sanitizeClone_(node);
        return new XMLSerializer().serializeToString(node);
    }
    private _toggleFullscreen(): void {
    }
    private _isFullscreen(): boolean {
        return false;
    }
    private _isVisible(node: Node | null): boolean {
        if (!node) {
            return false;
        }
        let iwin = getiframewindow_();
        if (!iwin) { return false; }
        for (; node != null; node = node.parentNode) {
            if (node.nodeType != Node.ELEMENT_NODE) {
                continue;
            }
            let cstyle = iwin.getComputedStyle(node as HTMLElement, null);
            if (cstyle.display == "none" || cstyle.visibility == "hidden") {
                return false;
            }
            let name = node.nodeName;
            if (name == "BODY" || name == "HTML") {
                break;
            }
        }
        return true;
    }
    private _isVisible1(node?: Node): boolean {
        if (!node || node.nodeType != Node.ELEMENT_NODE) {
            return false;
        }
        let iwin = getiframewindow_();
        if (!iwin) { return false; }
        let cstyle = iwin.getComputedStyle(node as HTMLElement, null);
        if (cstyle.display == "none" || cstyle.visibility == "hidden") {
            return false;
        }
        return true;
    }
    private _onFontLoaded(font: string, src: stringX, callback: Fun00) {
        (document as any).fonts.load(font, src).then(function () {
            callback();
        });
    };
    private _getSettings(): stringX {
        const ret = (window as any).AnSettings;
        delete (window as any).AnSettings;
        const children = document.head.children;
        for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            if ("SCRIPT" == child.nodeName
                && "settings" == child.getAttribute("title")) {
                child.remove();
                break;
            }
        }
        return An.notXX_(ret) ? JSON.stringify(ret) : null;
    }
    private _audioPlayer(elm: HTMLMediaElement) {
        let acontext = new AudioContext();
        let src = acontext.createMediaElementSource(elm);
        src.connect(acontext.destination);
    }

}

const native$ = new Native();
(window as any).
    XxXjg
    = native$.getNativeObject_();

class SearchMatch {
    start: number = 0;
    end: number = 0;
}

class _SearchContext {
    _offsets: number[] = [];
    _nodes: Node[] = [];
    _matches: SearchMatch[] = [];
    _text = "";
    _lowercaseText: string | null = null;

    constructor(node: Node) {
        this._getsearchcontext(node);
    }

    private _getsearchcontext(node: Node): void {
        const type = node.nodeType;
        if (type == Node.TEXT_NODE) {
            const text = node.textContent;
            if (text != null && text.length > 0) {
                this._offsets.push(this._text.length);
                this._nodes.push(node);
                this._text += text;
            }
        } else if (type == Node.ELEMENT_NODE) {
            for (const child of new ItemsIterable(node.childNodes)) {
                this._getsearchcontext(child);
            }
        }
    }

    getLowerCaseText_(): string {
        if (this._lowercaseText == null) {
            this._lowercaseText = this._text.toLowerCase();
        }
        return this._lowercaseText;
    }
}

class SearchContext {
    _node: Node;
    context: _SearchContext | null = null;

    /**
         * SearchContext constructor.
         * @param node The top node.
         */
    constructor(node: Node) {
        this._node = node;
    }

    private _getcontext(): _SearchContext {
        if (this.context == null) {
            this.context = new _SearchContext(this._node);
        }
        return this.context;
    }

    /**
         * @param matches An array of match object {start: startoffset, end: endoffset,}.
         */
    setMatches(matches: SearchMatch[]): void {
        this._getcontext()._matches = matches;
    }

    getText(): string {
        return this._getcontext()._text;
    }

    getLowerCaseText(): string {
        return this._getcontext().getLowerCaseText_();
    }

    next(range: Range): Range | null {
        let offset = 0;
        if (range != null) {
            const ret = this._getendoffset(range);
            if (ret == null) {
                return null;
            }
            offset = ret;
        }
        return this.nextAt(offset);
    }

    nextAt(offset: number): Range | null {
        const a = this._getcontext()._matches;
        if (a == null) {
            return null;
        }
        const n = An.binarySearcher_(a, 0, a.length, (m: SearchMatch) => {
            return (m.start > offset) ? 1 : (m.start < offset) ? -1 : 0;
        });
        if (n >= 0) {
            const m = a[n];
            return this._rangeof(m.start, m.end);
        }
        if (-n - 1 < a.length) {
            const m = a[-n - 1];
            return this._rangeof(m.start, m.end);
        }
        return null;
    }

    prev(range: Range): Range | null {
        let offset = 0;
        if (range != null) {
            const ret = this._getstartoffset(range);
            if (ret == null) {
                return null;
            }
            offset = ret;
        }
        return this.prevAt(offset);
    }

    prevAt(offset: number): Range | null {
        const a = this._getcontext()._matches;
        if (a == null) {
            return null;
        }
        const n = An.binarySearcher_(a, 0, a.length, (m: SearchMatch) => {
            return (m.start > offset) ? 1 : (m.start < offset) ? -1 : 0;
        });
        if (n > 0) {
            const m = a[n - 1];
            return this._rangeof(m.start, m.end);
        }
        if ((-n - 2) >= 0) {
            const m = a[-n - 2];
            return this._rangeof(m.start, m.end);
        }
        return null;
    }

    getStartOffset(range: Range): number | null {
        return this._getstartoffset(range);
    }

    getEndOffset(range: Range): number | null {
        return this._getendoffset(range);
    }

    getRangeOf(start: number, end: number): Range | null {
        return this._rangeof(start, end);
    }

    ////////////////////////////////////////////////////////////////////////

    private _getfirsttextnode(node: Node | null): Node | null {
        if (node == null) { return null; }
        const ret = this._getchildtextnode(node);
        if (ret != null) { return ret; }
        let next = node.nextSibling;
        while (next == null && node != null) {
            node = node?.parentElement ?? null;
            next = node?.nextSibling ?? null;
        }
        return this._getfirsttextnode(next);
    }

    private _getchildtextnode(elm: Node): Node | null {
        for (const child of new ItemsIterable(elm.childNodes)) {
            const type = child.nodeType;
            if (type == Node.TEXT_NODE) {
                const text = child.nodeValue;
                if (text != null && text.length > 0) {
                    return child;
                }
            } else if (type == Node.ELEMENT_NODE) {
                const ret = this._getchildtextnode(child);
                if (ret != null) {
                    return ret;
                }
            }
        }
        return null;
    }

    private _getoffset1(textnode: Node | null, offset: number): number | null {
        const context = this._getcontext();
        if (textnode != null) {
            for (let i = 0, len = context._nodes.length; i < len; ++i) {
                const node = context._nodes[i];
                if (node == textnode) {
                    return context._offsets[i] + offset;
                }
            }
        }
        return null;
    }

    private _getstartoffset(range: Range): number | null {
        let container = range.startContainer;
        const offset = range.startOffset;
        let type = container.nodeType;
        if (type == Node.TEXT_NODE) {
            return this._getoffset1(container, offset);
        }
        if (container.nodeType == Node.ELEMENT_NODE) {
            container = container.childNodes[offset];
            if (container == null) {
                
                return null;
            }
            type = container.nodeType;
            if (type == Node.TEXT_NODE) {
                return this._getoffset1(container, 0);
            } else if (type == Node.ELEMENT_NODE) {
                return this._getoffset1(this._getfirsttextnode(container), 0);
            }
        }
        return null;
    }

    private _getendoffset(range: Range): number | null {
        let container = range.endContainer;
        const offset = range.endOffset;
        let type = container.nodeType;
        if (type == Node.TEXT_NODE) {
            return this._getoffset1(container, offset);
        }
        if (container.nodeType == Node.ELEMENT_NODE) {
            container = container.childNodes[offset];
            if (container == null) {
                let elm: Node | null = range.endContainer;
                let next = elm.nextSibling;
                while (next == null && elm != null) {
                    elm = elm?.parentNode ?? null;
                    next = elm?.nextSibling ?? null;
                }
                return this._getoffset1(this._getfirsttextnode(next), 0);
            }
            type = container.nodeType;
            if (type == Node.TEXT_NODE) {
                return this._getoffset1(container, 0);
            } else if (type == Node.ELEMENT_NODE) {
                return this._getoffset1(this._getfirsttextnode(container), 0);
            }
        }
        return null;
    }

    private _rangeof(start: number, end: number): Range | null {
        const context = this._getcontext();
        const offsets = context._offsets;
        const nodes = context._nodes;
        let startnode: Node | null = null;
        let endnode: Node | null = null;
        let startoffset = 0;
        let endoffset = 0;
        const si = An.binarySearchInt_(offsets, 0, offsets.length, start);
        const ei = An.binarySearchInt_(offsets, 0, offsets.length, end);
        if (si >= 0) {
            startnode = nodes[si];
            startoffset = 0;
        } else {
            startnode = nodes[-si - 2];
            startoffset = start - offsets[-si - 2];
        }
        if (ei >= 0) {
            endnode = nodes[ei];
            endoffset = 0;
        } else {
            endnode = nodes[-ei - 2];
            endoffset = end - offsets[-ei - 2];
        }
        const range = startnode.ownerDocument?.createRange() ?? null;
        if (range == null) { return null; }
        range.setStart(startnode, startoffset);
        range.setEnd(endnode, endoffset);
        return range;
    }
}

////////////////////////////////////////////////////////////////////////

class SearchMatcher {
    _context: SearchContext;
    _anchorRange: Range | null;

    constructor(node: Node, range: Range | null) {
        this._context = new SearchContext(node);
        this._anchorRange = range;
    }

    getAnchor(): Range | null {
        return this._anchorRange;
    }

    setAnchor(range: Range | null): void {
        this._anchorRange = range;
    }

    getText(): string {
        return this._context.getText();
    }

    getLowerCaseText(): string {
        return this._context.getLowerCaseText();
    }

    /// @return The text offset for the anchor range, null if anchor range does not exists.
    getAnchorOffset(backward: boolean): number | null {
        const range = this._anchorRange;
        if (range == null) { return null; }
        return backward ? this._context.getStartOffset(range) : this._context.getEndOffset(range);
    }

    getRangeOf(start: number, end: number): Range | null {
        return this._context.getRangeOf(start, end);
    }
}

class OutlineSearchMatcher {
    _tree: OutlineTree;
    _nodes: OutlineTreenode[];
    _index: number = 0;

    constructor(tree: OutlineTree) {
        this._tree = tree;
        this._nodes = new Array<OutlineTreenode>();
        this._add(this._nodes, this._tree.root_());
        this.resetAnchor_();
    }

    private _add(ret: OutlineTreenode[], parent: OutlineTreenode): void {
        for (let c = parent.firstChild_(); c != null; c = c.nextSibling_()) {
            ret.push(c);
            this._add(ret, c);
        }
    }

    resetAnchor_(): void {
        this._index = -1;
        const sel = this._tree.getSelection_();
        if (sel != null && sel.length > 0) {
            const _anchor = sel[0];
            for (let i = 0, len = this._nodes.length; i < len; ++i) {
                if (_anchor === this._nodes[i]) {
                    this._index = i;
                    return;
                }
            }
        }
    }

    private _match(content: stringX, needle: string, ignorecase: boolean): boolean {
        if (content == null) return false;
        if (ignorecase) {
            return content.toLowerCase().includes(needle);
        }
        return content.includes(needle);
    }

    next_(s: string, ignorecase: boolean, matchself: boolean): OutlineTreenode | null {
        let start: number;
        if (this._index < 0) {
            start = 0;
        } else if (matchself) {
            start = this._index;
        } else {
            start = this._index + 1;
        }
        for (let i = start, len = this._nodes.length; i < len; ++i) {
            const node = this._nodes[i];
            if (this._match(node.content_()?.textContent ?? null, s, ignorecase)) {
                this._index = i;
                return node;
            }
        }
        this._index = -1;
        return null;
    }

    prev_(s: string, ignorecase: boolean, matchself: boolean): OutlineTreenode | null {
        let start = matchself ? this._index : this._index - 1;
        if (start < 0) {
            start = this._nodes.length - 1;
        }
        for (let i = start; i >= 0; --i) {
            const node = this._nodes[i];
            if (this._match(node.content_()?.textContent ?? null, s, ignorecase)) {
                this._index = i;
                return node;
            }
        }
        this._index = -1;
        return null;
    }

    incrementalSearch_(value: string, ignorecase: boolean, matchself: boolean, backward: boolean): boolean {
        const length = value.length;
        if (length == 0) {
            return true;
        }
        if (ignorecase) {
            value = value.toLowerCase();
        }
        const ret = backward ? this.prev_(value, ignorecase, matchself) : this.next_(value, ignorecase, matchself);
        if (ret != null) {
            ret.revealSelect_();
            ret.scrollIntoView_();
            return true;
        }
        this._tree.deselectAll_();
        return false;
    }
}

////////////////////////////////////////////////////////////////////////

class StepTimer {
    private _start: number;
    private _prev: number;

    constructor(_label: string = "") {
        this._start = An.now_();
        this._prev = this._start;
    }

    /// @return The number of ms elapsed since start.
    elapsed_(): number {
        const now = An.now_();
        return now - this._start;
    }

    delta_(): number {
        return An.now_() - this._prev;
    }

    /// Restart timer.
    restart_(): StepTimer {
        this._start = An.now_();
        this._prev = this._start;
        return this;
    }

    debug_(_msg: string = ""): StepTimer {
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

class FireLimiter {
    _timer: Timer | null = null;

    /// @param _delay in ms.
    constructor(private _delay: number) { }

    destroy_(): void {
        if (this._timer != null) {
            this._timer.cancel_();
            this._timer = null;
        }
    }

    queue_(callback: Fun00): void {
        if (this._timer != null) {
            this._timer.cancel_();
        }
        this._timer = new Timer(this._delay, () => {
            this._timer = null;
            callback();
        });
    }

    cancel_(): void {
        if (this._timer != null) {
            this._timer.cancel_();
        }
    }
}

////////////////////////////////////////////////////////////////////////

type RateLimiterCallback = (elapsed: number, immediate: boolean) => void;

abstract class IRateLimiter {
    abstract queue_(callback: RateLimiterCallback, start?: number): void;

    abstract flush_(): void;

    abstract cancel_(): void;
}

class RateLimiter implements IRateLimiter {
    private _start: number = 0;
    private _timer: Timer | null = null;
    private _callback: RateLimiterCallback | null = null;

    /// @param ms Limit rate to once every given ms.
    constructor(private _ms: number) {
    }

    queue_(callback: RateLimiterCallback, start: numberX = null): void {
        if (start != null) this._start = start;
        this._callback = callback;
        const now = An.now_();
        const elapsed = now - this._start;
        if (elapsed >= this._ms) {
            if (this._timer != null) {
                this._timer.cancel_();
                this._timer = null;
            }
            this._run(now, true);
            return;
        }
        if (this._timer == null) {
            this._timer = new Timer(this._ms - elapsed, () => this._fire());
        }
    }

    flush_(): void {
        if (this._timer != null) {
            this._timer.cancel_();
            this._timer = null;
            this._run(An.now_(), true);
        }
    }

    cancel_(): void {
        if (this._timer != null) {
            this._timer.cancel_();
            this._timer = null;
            this._callback = null;
        }
    }

    private _fire(): void {
        this._timer = null;
        this._run(An.now_(), false);
    }

    private _run(now: number, immediate: boolean): void {
        if (this._callback != null) {
            this._callback(now - this._start, immediate);
            this._callback = null;
        }
        this._start = now;
    }
}

////////////////////////////////////////////////////////////////////////

class NoLimiter implements IRateLimiter {
    static readonly singleton = new NoLimiter();
    constructor() { }
    queue_(callback: RateLimiterCallback, _start: numberX = null): void {
        callback(0, true);
    }
    flush_(): void { }
    cancel_(): void { }
}

////////////////////////////////////////////////////////////////////////

class FrameLimiter implements IRateLimiter {
    private _id: numberX = null;
    private _callback: RateLimiterCallback | null = null;
    private _n: number = 0;
    private _start: number = 0;

    static requestAnimationFrame(frames: number, callback: Fun10<FrameLimiter>): void {
        const f = new FrameLimiter(frames);
        f.queue_(() => {
            callback(f);
        });
    }

    /**
         * @param divider Frame rate divider, default is 1.
         * To run callback at half the frame rate, ie, once every 2 frames, use divider=2;
         */
    constructor(private _divider: number = 1) { }

    queue_(callback: RateLimiterCallback, start: numberX = null): void {
        if (start != null) {
            this._start = start;
        }
        this._callback = callback;
        if (this._id == null) {
            this._id = window.requestAnimationFrame(() => this._handler());
        }
    }

    private _handler(): void {
        if (++this._n >= this._divider) {
            this._n = 0;
            this._id = null;
            this._run(false);
        } else {
            this._id = window.requestAnimationFrame(() => this._handler());
        }
    }

    flush_(): void {
        if (this._id != null) {
            window.cancelAnimationFrame(this._id);
            this._id = null;
            this._run(true);
        }
    }

    cancel_(): void {
        if (this._id != null) {
            window.cancelAnimationFrame(this._id);
            this._callback = null;
            this._id = null;
        }
    }

    private _run(immediate: boolean): void {
        const now = An.now_();
        if (this._callback != null) {
            this._callback(now - this._start, immediate);
            this._callback = null;
        }
        this._start = now;
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

type OutlineContent = string | Fun01<HTMLElement> | Node | Array<Node> | null;
type OutlineChildren = OutlineTreenode | OutlineContent;

class OutlineTreenode {
    static readonly SELECTED: string = CSS.AnTreeSelected;
    static readonly EXPANDED: string = CSS.AnTreeExpanded;
    static readonly COLLAPSED: string = CSS.AnTreeCollapsed;
    static readonly LEAF: string = CSS.AnTreeLeaf;
    #tree: OutlineTree;
    #element: HTMLElement;
    #indent: Int = 0;
    #populated: boolean = false;
    #data: number | number[] | null = null;

    /**
         * Treenode constructor
         * Overloads:
         * () Create an empty Treenode in the current document.
         * (String) Create a Treenode with a text node as content.
         * (Function()) Call the given function to create Treenode._element.
         * (List<Node>) Create a Treenode with the given nodes as content.
         * (Node) Create a Treenode with the given node as content.
         */
    constructor(tree: OutlineTree, indent: Int, content: OutlineContent = null) {
        this.#tree = tree;
        this.#indent = indent;
        if (typeof (content) === "string") {
            this.#element = OutlineTreenode.create_(new Text(content));
        } else if (content instanceof Function) {
            this.#element = content();
        } else {
            this.#element = OutlineTreenode.create_(content);
        }
        this.#tree.setNode_(this.#element, this);
    }

    tree_(): OutlineTree {
        return this.#tree;
    }

    root_(): OutlineTreenode {
        return this.#tree.root_();
    }

    parent_(): OutlineTreenode | null {
        return this.#tree.getTreenode_(this.#element.parentElement);
    }

    element_(): HTMLElement {
        return this.#element;
    }

    isSelected_(): boolean {
        return this.#element.classList.contains(OutlineTreenode.SELECTED);
    }

    isTreenode_(): boolean {
        return true;
    }

    isRoot_(): boolean {
        return false;
    }

    /**
         * @return The DOM element corresponding to the expand/collapse
         * control of this Treenode.
         */
    control_(): HTMLElementX {
        const control = OutlineTreenode.getcontrol_(this.#element);
        if (control == null) {
            
            return null;
        }
        return control;
    }

    /**
         * Return the DOM element holding content for this Treenode,
         * after optionally append the given DOM element to the content.
         * @return The DOM element that holds the Treenode content or null.
         */
    content_(elm: Node | Array<Node> | null = null): HTMLElementX {
        const ret = (this.control_()?.nextElementSibling as HTMLElement) ?? null;
        if (ret == null) return null;
        if (elm !== null) {
            if (elm instanceof Array) {
                ret.append(...elm);
            } else {
                ret.append(elm);
            }
        }
        return ret;
    }

    isPopulated_(): boolean {
        return this.#populated;
    }

    setPopulated_(b: boolean): void {
        this.#populated = b;
    }

    /// Set the given Treenode to the given kind (expanded, collapsed, leaf).
    setKind_(kind: string): void {
        const classes = this.control_()?.classList;
        classes?.remove(OutlineTreenode.EXPANDED, OutlineTreenode.COLLAPSED, OutlineTreenode.LEAF);
        classes?.add(kind);
    }

    /// @return The next sibling Treenode, null if there are none.
    nextSibling_(): OutlineTreenode | null {
        for (let n = this.#element.nextElementSibling; n != null; n = n.nextElementSibling) {
            if (OutlineTreenode.istreenode_(n)) {
                return this.#tree.getTreenode_(n as HTMLElement);
            }
        }
        return null;
    }

    /// @return The previous sibling Treenode, null if there are none.
    previousSibling_(): OutlineTreenode | null {
        for (let n = this.#element.previousElementSibling; n != null; n = n.previousElementSibling) {
            if (OutlineTreenode.istreenode_(n)) {
                return this.#tree.getTreenode_(n as HTMLElement);
            }
        }
        return null;
    }

    /// @return The first child Treenode, null if there are none.
    firstChild_(): OutlineTreenode | null {
        for (let n = this.#element.firstChild; n != null; n = n.nextSibling) {
            if (OutlineTreenode.istreenode_(n)) {
                return this.#tree.getTreenode_(n as HTMLElement);
            }
        }
        return null;
    }

    /// @return The last child Treenode, null if there are none.
    lastChild_(): OutlineTreenode | null {
        for (let n = this.#element.lastChild; n != null; n = n.previousSibling) {
            if (OutlineTreenode.istreenode_(n)) {
                return this.#tree.getTreenode_(n as HTMLElement);
            }
        }
        return null;
    }

    get_(i: number): OutlineTreenode | null {
        if (i < 0) {
            
            return null;
        }
        for (let c = this.#element.firstChild; c != null; c = c.nextSibling) {
            if (OutlineTreenode.istreenode_(c)) {
                if (i == 0) {
                    return this.#tree.getTreenode_(c as HTMLElement);
                }
                --i;
            }
        }
        return null;
    }

    indexOf_(child: OutlineTreenode): number {
        let index = 0;
        for (let c = this.firstChild_(); c != null; c = c.nextSibling_(), ++index) {
            if (c === child) {
                return index;
            }
        }
        return -1;
    }

    childCount_(): number {
        let index = 0;
        for (let c = this.firstChild_(); c != null; c = c.nextSibling_()) {
            ++index;
        }
        return index;
    }

    /// Destroy and release resources of this Treenode.
    destroy_(): void {
        this.#tree.deselect1_(this);
        this.#tree.removeNode_(this.#element);
        this.#element.remove();
    }

    /**
         * Append a Treenode.
         * Overloads:
         * (Treenode)
         * ()
         * (String)
         * (Function())
         * (List<Node>)
         * (Node)
         */
    append_(node: OutlineChildren = null): OutlineTreenode {
        const child = OutlineTreenode.setupchild_(this, node);
        const count = this.#element.childNodes.length;
        this.#element.append(child.#element);
        if (this.#element.childNodes.length != count + 1) {
            
        }
        return child;
    }

    /**
         * Insert the given Treenode before the given existing child.
         * Overloads:
         * (Treenode, Treenode)
         * (Treenode)
         * (String, Treenode)
         * (Function(), Treenode)
         * (List<Node>, Treenode)
         * (Node, Treenode)
         */
    insertBefore_(next: OutlineTreenode, node: OutlineChildren = null): OutlineTreenode {
        const child = OutlineTreenode.setupchild_(this, node);
        const count = this.#element.childNodes.length;
        if (next == null) {
            this.#element.append(child.#element);
        } else {
            this.#element.insertBefore(child.#element, next.#element);
        }
        if (this.#element.childNodes.length != count + 1) {
            
        }
        return child;
    }

    /// Remove the given child of this Treenode.
    removeChild_(node: OutlineTreenode): void {
        node.destroy_();
        if (!OutlineTreenode.hastreenode_(this)) {
            this.setKind_(OutlineTreenode.LEAF);
        }
    }

    /// Remove this treenode from its parent.
    remove_(): void {
        this.parent_()?.removeChild_(this);
    }

    /// Remove all descendants of the give Treenode.
    removeDescendants_(): void {
        for (let c = this.firstChild_(); c != null;) {
            const n = c.nextSibling_();
            c.removeDescendants_();
            c.destroy_();
            c = n;
        }
        this.setKind_(OutlineTreenode.LEAF);
    }

    /// Remove the child at the given 0-based index of this Treenode.
    removeChildAt_(i: number): void {
        const node = this.get_(i);
        if (node != null) {
            this.removeChild_(node);
        }
    }

    /**
         * Append children of the given Treenode and insert as children of
         * cursor before the given next node.
         */
    moveChildrenBefore_(next: OutlineTreenode, treenode: OutlineTreenode, start: OutlineTreenode | null, end: OutlineTreenode | null): void {
        if (start == null) {
            start = treenode.firstChild_();
        }
        if (end == null) {
            end = null;
        }
        for (let c = start; c != null && c != end;) {
            const n = c.nextSibling_();
            treenode.removeChild_(c);
            this.insertBefore_(next, c);
            c = n;
        }
    }

    /// @param multi If true, keep current selected nodes.
    select_(multi: boolean = false): void {
        this.#tree.select_(this, multi);
    }

    /// Select all children of this node, implies multi=true.
    selectChildren_(): void {
        for (let c = this.firstChild_(); c != null; c = c.nextSibling_()) {
            this.#tree.select_(c, true);
        }
    }

    /// @param multi If true, keep other selected nodes.
    deselect_(multi: boolean = false): void {
        this.#tree.deselect_(this, multi);
    }

    /**
         * @param e The event that trigger selection changes.
         * @return An array of Treenode that are selected.
         */
    toggleSelection_(): boolean {
        return this.#tree.toggleSelection_(this);
    }

    expand_(): void {
        if (OutlineTreenode.expand1_(this)) {
            for (let c = this.firstChild_(); c != null; c = c.nextSibling_()) {
                OutlineTreenode.show_(c);
            }
        }
    }

    expandAll_(): void {
        OutlineTreenode.expand1_(this);
        OutlineTreenode.expandtree_(this);
    }

    collapse_(): void {
        if (OutlineTreenode.collapse1_(this)) {
            OutlineTreenode.hidetree_(this);
        }
    }

    collapseAll_(): void {
        OutlineTreenode.hidetree_(this);
        OutlineTreenode.collapse1_(this);
    }

    reveal_(): void {
        for (let p = this.parent_(); p != null; p = p.parent_()) {
            p.expand_();
        }
    }

    revealExpand_(): void {
        this.reveal_();
        this.expand_();
    }

    revealSelect_(multi: boolean = false): void {
        this.reveal_();
        this.select_(multi);
    }

    revealExpandSelect_(multi: boolean = false): void {
        this.reveal_();
        this.expand_();
        this.select_(multi);
    }

    scrollIntoView_(): void {
        this.#element.scrollIntoView({ inline: "center" });
    }

    depthFirst_(callback: TreenodeCallback): void {
        for (let c = this.firstChild_(); c != null;) {
            const n = c.nextSibling_();
            c.depthFirst_(callback);
            c = n;
        }
        callback(this);
    }

    breadthFirst_(callback: TreenodeCallback): void {
        callback(this);
        for (let c = this.firstChild_(); c != null;) {
            const n = c.nextSibling_();
            c.breadthFirst_(callback);
            c = n;
        }
    }

    find_<T extends HTMLElement>(sel: string): T | null {
        return this.#element.querySelector<T>(sel);
    }

    findAll_<T extends HTMLElement>(sel: string): NodeListOf<T> {
        return this.#element.querySelectorAll<T>(sel);
    }

    getTargetPath_(): number[] | null {
        if (this.#data instanceof Array) {
            return Array.from(this.#data);
        }
        const ret = new Array<number>();
        if (this.#data == null) { return null; }
        ret.unshift(this.#data);
        for (let p = this.parent_(); p != null && !p.isRoot_(); p = p.parent_()) {
            if (p.#data == null) { return null; }
            if (p.#data instanceof Array) {
                ret.unshift(...p.#data);
                return ret;
            }
            ret.unshift(p.#data);
        }
        return ret;
    }

    setData_(data: number | number[] | null): void {
        this.#data = data;
    }

    getData_(): number | number[] | null {
        return this.#data;
    }

    ////////////////////////////////////////////////////////////////////////

    private static create1_(doc: Document, content: Node[] | Node | null = null): HTMLElement {
        const b = DomBuilderEx.offline1_(doc, "div", CSS.AnTreeNode)
            .push_()
            .div1_(CSS.AnTreeContent)
            .span1_(CSS.AnTreeControl, CSS.AnTreeLeaf)
            .siblingAfter_("span", { "class": CSS.AnTreeContent });
        if (content != null) {
            if (content instanceof Array) {
                b.appendNodes_(...content);
            } else {
                b.appendNodes_(content);
            }
        }
        return b.pop_().cursor_();
    }

    /// @return true if the given DOM element is an element for a Treenode.
    private static istreenode_(node: Node): boolean {
        return (node as HTMLElement).classList.contains(CSS.AnTreeNode);
    }

    /// Get the control element of the given Treenode._element.
    private static getcontrol_(elm: HTMLElement): HTMLElementX {
        const ret = elm?.firstChild?.firstChild ?? null;
        if (ret != null && ret.nodeType == Node.ELEMENT_NODE) {
            return ret as HTMLElement;
        }
        return null;
    }

    private static adjustIndent_(node: OutlineTreenode): void {
        const indent = node.#indent + node.#tree.tab_();
        for (let c = node.firstChild_(); c != null; c = c.nextSibling_()) {
            if (c.#indent != indent) {
                c.#indent = indent;
                const control = OutlineTreenode.getcontrol_(c.#element);
                if (control != null) {
                    control.style.marginLeft = `${indent}px`;
                }
                OutlineTreenode.adjustIndent_(c);
            }
        }
    }

    private static create_(content: Node | Array<Node> | null = null): HTMLElement {
        if (content === null) {
            return OutlineTreenode.create1_(document, null);
        } else if (content instanceof Array) {
            if (content.length == 0) {
                return OutlineTreenode.create1_(document, null);
            } else {
                return OutlineTreenode.create1_(content[0].ownerDocument!, content);
            }
        } else {
            return OutlineTreenode.create1_(content.ownerDocument!, content);
        }
    }

    private static show_(node: OutlineTreenode): void {
        const cc = node.#element;
        if (OutlineTree.UseVisibilityCollapse) {
            if (cc.style.visibility != "visible") {
                cc.style.visibility = "visible";
            }
        } else {
            if (cc.style.display != "block") {
                cc.style.display = "block";
            }
        }
    }

    private static hide_(node: OutlineTreenode): void {
        const cc = node.#element;
        if (OutlineTree.UseVisibilityCollapse) {
            if (cc.style.visibility != "collapse") {
                cc.style.visibility = "collapse";
            }
        } else {
            if (cc.style.display != "none") {
                cc.style.display = "none";
            }
        }
    }

    /// Hide the descendants of the given DOM element.
    private static hidetree_(node: OutlineTreenode): void {
        for (let c = node.firstChild_(); c != null; c = c.nextSibling_()) {
            OutlineTreenode.hidetree_(c);
            OutlineTreenode.collapse1_(c);
            c.#element.classList.remove(OutlineTreenode.SELECTED);
            OutlineTreenode.hide_(c);
        }
    }

    /// Mark the Treenode for the given element as collapsed without hiding it.
    private static collapse1_(node: OutlineTreenode): boolean {
        const control = node.control_();
        if (control != null) {
            const classes = control.classList;
            if (classes.contains(OutlineTreenode.EXPANDED)) {
                [OutlineTreenode.EXPANDED, OutlineTreenode.COLLAPSED].forEach((c) => classes.toggle(c));
            }
            return true;
        }
        return false;
    }

    private static expandtree_(node: OutlineTreenode): void {
        for (let c = node.firstChild_(); c != null; c = c.nextSibling_()) {
            OutlineTreenode.show_(c);
            OutlineTreenode.expand1_(c);
            OutlineTreenode.expandtree_(c);
        }
    }

    /// Mark the Treenode for the given element as expanded without showing it.
    private static expand1_(node: OutlineTreenode): boolean {
        const control = node.control_();
        if (control != null) {
            const classes = control.classList;
            if (classes.contains(OutlineTreenode.COLLAPSED)) {
                for (const l of node.#tree.listeners_()) {
                    l.onExpand_(node);
                }
                [OutlineTreenode.EXPANDED, OutlineTreenode.COLLAPSED].forEach((c) => classes.toggle(c));
                return true;
            }
        }
        return false;
    }

    /// @return true if the given Treenode has child Treenodes.
    private static hastreenode_(treenode: OutlineTreenode): boolean {
        for (let c = treenode.#element.firstChild; c != null; c = c.nextSibling) {
            if (OutlineTreenode.istreenode_(c)) {
                return true;
            }
        }
        return false;
    }

    /// @param parent The parent Treenode
    /// @param node Either a Treenode or a valid parameter for new Treenode(content).
    /// NOTE: child._treeIndex is not initialized here.
    private static setupchild_(
        parent: OutlineTreenode,
        node: OutlineChildren = null): OutlineTreenode {
        const child = (node instanceof OutlineTreenode) ? node : new OutlineTreenode(parent.#tree, 0, node);
        child.#tree = parent.#tree;
        const indent = parent.#indent + parent.#tree.tab_();
        if (child.#indent != indent) {
            child.#indent = indent;
            const control = OutlineTreenode.getcontrol_(child.#element);
            if (control != null) {
                control.style.marginLeft = `${child.#indent}px`;
            }
            OutlineTreenode.adjustIndent_(child);
        }
        const control = parent.control_();
        if (control != null) {
            const classes = control.classList;
            if (classes.contains(OutlineTreenode.LEAF)) {
                classes.toggle(OutlineTreenode.LEAF);
                classes.toggle(OutlineTreenode.COLLAPSED);
                OutlineTreenode.hide_(child);
            } else if (classes.contains(OutlineTreenode.COLLAPSED)) {
                OutlineTreenode.hide_(child);
            } else if (classes.contains(OutlineTreenode.EXPANDED)) {
                OutlineTreenode.show_(child);
            }
        }
        return child;
    }
}

////////////////////////////////////////////////////////////////////////

type TreenodeCallback = (node: OutlineTreenode) => void;

interface ITreeListener {
    onDblClick_(node: OutlineTreenode): void;
    onExpand_(node: OutlineTreenode): void;
    onSelectionChanged_(node: OutlineTreenode, isselected: boolean): void;
}

////////////////////////////////////////////////////////////////////////

class _Treeroot extends OutlineTreenode {
    constructor(tree: OutlineTree, indent: Int, content: OutlineContent = null) {
        super(tree, indent, content);
    }

    isRoot_(): boolean {
        return true;
    }
}

class OutlineTree {
    private static readonly LONG_PRESS_TIMEOUT: number = 1000;
    static readonly UseVisibilityCollapse: boolean = false;

    #root: OutlineTreenode;
    #tab: Int;
    #listeners: ITreeListener[] = [];
    #selection: OutlineTreenode[] = [];
    #data = new Map<string, any>();
    #nodes = new Map<HTMLElement, OutlineTreenode>();
    #touchTimer: Timer | null = null;

    /// Tree constructor.
    constructor(private _container: HTMLElement, tab: Int, indent: Int | null = null) {
        const td = new DomBuilderEx(this._container).table1_(CSS.AnTreeTable).tr_().td_().cursor_();
        this.#root = new _Treeroot(this, (indent == null ? -(tab >> 1) : indent), () => {
            return new DomBuilderEx(td)
                .div1_(CSS.AnTreeRoot)
                .push_()
                .div_({ "class": CSS.AnTreeContent, "style": "display:none;" })
                .span1_(CSS.AnTreeControl, CSS.AnTreeLeaf)
                .siblingAfter_("span", { "class": CSS.AnTreeContent })
                .pop_()
                .cursor_();
        });
        this.#tab = tab;
        this.#root.element_().classList.add(CSS.AnTreeContainer);
        this.#root.element_().addEventListener("click", (e: MouseEvent) => {
            if (e.button != 0) { return; }
            const c = DomUt.asHTMLElement_(e.target);
            if (c == null) { return; }
            const classes = c.classList;
            if (classes.contains(CSS.AnTreeControl)) {
                const grandparent = c.parentElement?.parentElement;
                if (grandparent != null) {
                    const treenode = this.getTreenode_(grandparent);
                    if (treenode != null) {
                        if (classes.contains(OutlineTreenode.EXPANDED)) {
                            treenode.collapse_();
                        } else if (classes.contains(OutlineTreenode.COLLAPSED)) {
                            treenode.expand_();
                        }
                    }
                }
            } else {
                const matchingtarget = DomUt.matchingTarget_(e, `div.${CSS.AnTreeNode}`);
                const node = this.getTreenode_(matchingtarget);
                if (node != null) {
                    const isselected = node.toggleSelection_();
                    node.tree_().fireOnSelectionChanged_(node, isselected);
                }
            }
            An.stopevent_(e);
        });
        An.onPointerStart_(this.#root.element_(), (e) => {
            const target = DomUt.matchingTarget_(e, `div.${CSS.AnTreeNode}`);
            if (target == null) { return; };
            if (this.#touchTimer != null) {
                this.#touchTimer.cancel_();
            }
            this.#touchTimer = new Timer(OutlineTree.LONG_PRESS_TIMEOUT, () => {
                An.stopevent_(e);
                if (target != null) {
                    this.fireOnDblClick_(target);
                }
            });
        });
        An.onPointerEnd_(this.#root.element_(), (e) => {
            const target = DomUt.matchingTarget_(e, `div.${CSS.AnTreeNode}`);
            if (target == null) { return; }
            if (this.#touchTimer != null) {
                if (this.#touchTimer.isActive_()) {
                    this.#touchTimer.cancel_();
                } else {
                    An.stopevent_(e);
                }
                this.#touchTimer = null;
            }
        });
    }

    destroy_(): void {
        
        if (this.#root != null) {
            this.#root.destroy_();
            this.#data.clear();
            this.#nodes.clear();
        }
    }

    /// Add a ITreeListener.
    addListener_(listener: ITreeListener): void {
        this.#listeners.push(listener);
    }

    /// Remove a ITreeListener.
    removeListener_(listener: ITreeListener): void {
        const index = this.#listeners.indexOf(listener);
        if (index >= 0) { this.#listeners.splice(index, 1); }
    }

    root_(): OutlineTreenode {
        return this.#root;
    }

    tab_(): Int {
        return this.#tab;
    }

    listeners_(): ITreeListener[] {
        return this.#listeners;
    }

    setWidth_(width: number): void {
        
        if (this._container != null) {
            const td = this._container.querySelector<HTMLTableCellElement>(`table.${CSS.AnTreeTable} td`);
            if (td != null) {
                td.style.minWidth = `${width}px`;
            }
        }
    }

    getSelection_(): OutlineTreenode[] {
        return this.#selection;
    }

    select_(node: OutlineTreenode, multi: boolean = false): void {
        if (!multi) {
            this.deselectAll_();
        }
        node.element_().classList.add(OutlineTreenode.SELECTED);
        this.#selection.push(node);
    }

    deselect_(node: OutlineTreenode, multi: boolean = false): boolean {
        if (!multi) {
            this.deselectAll_();
            return true;
        }
        return this.deselect1_(node);
    }

    deselect1_(node: OutlineTreenode): boolean {
        const classlist = node.element_().classList;
        if (classlist.contains(OutlineTreenode.SELECTED)) {
            classlist.remove(OutlineTreenode.SELECTED);
            An.identityRemove_(this.#selection, node);
            return true;
        }
        return false;
    }

    toggleSelection_(node: OutlineTreenode): boolean {
        const classes = node.element_().classList;
        const isselected = classes.contains(OutlineTreenode.SELECTED);
        this.deselectAll_();
        if (isselected) {
            classes.remove(OutlineTreenode.SELECTED);
        } else {
            classes.add(OutlineTreenode.SELECTED);
            this.#selection.push(node);
        }
        return !isselected;
    }

    deselectAll_(): void {
        while (this.#selection.length != 0) {
            this.#selection.pop()?.element_().classList.remove(OutlineTreenode.SELECTED);
        }
    }

    removeNode_(elm: HTMLElement): void {
        this.#nodes.delete(elm);
    }

    setNode_(elm: HTMLElement, node: OutlineTreenode): void {
        this.#nodes.set(elm, node);
    }

    getData_(key: string): any {
        return this.#data.get(key);
    }

    setData_(key: string, value: any): void {
        this.#data.set(key, value);
    }

    ////////////////////////////////////////////////////////////////////////

    getTreenode_(elm: HTMLElementX): OutlineTreenode | null {
        return elm == null ? null : this.#nodes.get(elm) ?? null;
    }

    private fireOnDblClick_(elm: HTMLElement): void {
        for (const l of this.#listeners) {
            const treenode = this.getTreenode_(elm);
            if (treenode != null) {
                l.onDblClick_(treenode);
            }
        }
    }

    /// @param treenode The treenode.
    /// @param bool true if treenode is now selected.
    private fireOnSelectionChanged_(treenode: OutlineTreenode, isselected: boolean): void {
        for (const l of this.#listeners) {
            l.onSelectionChanged_(treenode, isselected);
        }
    }

    static lastDescendant_(node: OutlineTreenode): OutlineTreenode {
        const child = node.lastChild_();
        if (child != null) {
            return OutlineTree.lastDescendant_(child);
        }
        return node;
    }
}

type ToasterCallback = (toaster: Toaster, b: DomBuilderEx) => void;
type ActionMouseEventCallback = (action: string, e: MouseEvent) => void;
type ActionMouseEventTargetCallback = (action: string, e: MouseEvent, target: HTMLElement) => void;
type ActionTargetMouseEventCallback = (action: string, target: HTMLElement, e: MouseEvent) => void;

type PromptInputImageCallback = (cpath: string, uri: Uri, width: string, height: string, rotation: number) => void;
type PromptOutputImageCallback = (outputinfo: ImageOutputInfo) => void;
type DimensionConverter = (width: string, height: string, defwidth: number, defheight: number) => Point<number> | null;

///////////////////////////////////////////////////////////////////////

interface IUIPanel {
    element_(): HTMLElement;
    show_(): void;
    hide_(): void;
    showContextmenu_(e: MouseEvent): void;
    hideContextmenu_(): void;
    resizeContent_(_containerheight: number): void;
    onWindowSizeChanged_(): void;
}

abstract class UIPanelBase implements IUIPanel {
    protected _shown = false;
    abstract element_(): HTMLElement;
    show_(): void {
        if (!this._shown) {
            this._shown = true;
            An.showVisible_(this.element_());
        }
    }
    hide_(): void {
        if (this._shown) {
            this._shown = false;
            An.hide_(this.element_());
        }
    }
    showContextmenu_(e: MouseEvent): void {
        An.stopevent_(e);
    }
    hideContextmenu_(): void { }
    resizeContent_(_containerheight: number): void { }
    onWindowSizeChanged_(): void { }
}

class _ToasterState {
    showTimer$: Timer | null = null;
    hideTimer$: Timer | null = null;
    tips$: HTMLElementX = null;
    holding$: boolean = false;
    attop$: boolean = false;
    #hideCallback: Fun00X = null;

    constructor(attop: boolean = false) {
        this.attop$ = attop;
    }

    tips(): HTMLElementX {
        return this.tips$;
    }

    hide(): boolean {
        if (this.holding$) return false;
        return this._hide1();
    }

    onHide_(callback: Fun00X): this {
        this.#hideCallback = callback;
        return this;
    }

    private _hide1(): boolean {
        if (this.showTimer$ != null) {
            this.showTimer$.cancel_();
            this.showTimer$ = null;
        }
        if (this.hideTimer$ != null) {
            this.hideTimer$.cancel_();
            this.hideTimer$ = null;
        }
        if (this.tips$ != null) {
            this.tips$.remove();
            this.tips$ = null;
        }
        this.#hideCallback?.();
        return true;
    }
}

interface IToasterOptions {
    attop?: boolean;
    nowrap?: boolean;
    hold?: boolean;
    onHide?: Fun00;
}

interface _ToasterOptions {
    attop: boolean;
    nowrap: boolean;
    hold: boolean;
    onhide: Fun00X;
    hints: boolean;
}

/// Default to show at top.
type ToasterAtTopOption = IToasterOptions;
/// Defaul to show at bottom.
type ToasterAtBottomOption = IToasterOptions;

interface IToasters {
    onTooltipsKey_: (target: HTMLElement, e: Event) => void;

    infoKey_(msgkey: StringId, options?: ToasterAtBottomOption): void;

    okKey_(msgkey: StringId, options?: ToasterAtBottomOption): void;

    warnKey_(msgkey: StringId, options?: ToasterAtTopOption): void;

    errorKey_(msg: TestResult, options?: ToasterAtTopOption): void;

    info_(msg: TestResult, options?: ToasterAtBottomOption): boolean;

    ok_(msg: TestResult, options?: ToasterAtBottomOption): boolean;

    warn_(msg: TestResult, options?: ToasterAtTopOption): boolean;

    error_(msg: TestResult, options?: ToasterAtTopOption): boolean;

    warnAll_(msgs: TestResult[], options?: ToasterAtTopOption): boolean;
}

class Toaster implements IWarner {
    #container: HTMLElement;
    #showDelay: number;
    #hideDelay: number;
    #state: _ToasterState | null = null;

    /// @param container A DOM element that host the toaster.
    /// @param showdelay Number of ms before showing message.
    /// @param hidedelay Number of ms before hiding message.
    /// eg. new An.Toaster("#warnToaster", 0, 5000);
    constructor(container: HTMLElement, showdelay: number, hidedelay: number) {
        this.#container = container;
        this.#showDelay = showdelay;
        this.#hideDelay = hidedelay;
    }

    static optionsOf_(attop: boolean, hints?: boolean, options?: IToasterOptions): _ToasterOptions {
        return {
            attop: options?.attop ?? attop,
            nowrap: options?.nowrap ?? false,
            hold: options?.hold ?? false,
            onhide: options?.onHide ?? null,
            hints: hints ?? false,
        };
    }

    /// @param msgkey @notnull The string resource key for the message.
    infoKey_(msgkey: StringId, options?: ToasterAtTopOption): void {
        this.show1_(
            CSS.AnToasterInfo,
            MSG.string_(msgkey),
            Toaster.optionsOf_(true, false, options),
        );
    }

    /// Show an info message if msg != null.
    /// Overloads:
    /// (String)
    /// (List<String>)
    info_(result: TestResult, options?: ToasterAtTopOption): boolean {
        const msg = An.result_(result);
        if (msg == null) { return false; };
        this.show1_(CSS.AnToasterInfo, msg, Toaster.optionsOf_(true, false, options));
        return true;
    }

    /// @param msgkey @notnull The string resource key for the message.
    okKey_(msgkey: any, options?: ToasterAtTopOption): void {
        this.show1_(CSS.AnToasterOK, MSG.string_(msgkey), Toaster.optionsOf_(true, false, options));
    }

    /// Show an info message if msg != null.
    /// Overloads:
    /// (String)
    /// (List<String>)
    ok_(result: TestResult, options?: ToasterAtTopOption): boolean {
        const msg = An.result_(result);
        if (msg == null) { return false; }
        this.show1_(CSS.AnToasterOK, msg, Toaster.optionsOf_(true, false, options));
        return true;
    }

    /// @param msgkey @notnull The string resource key for the message.
    warnKey_(msgkey: StringId, options?: ToasterAtTopOption): void {
        this.show1_(CSS.AnToasterWarn, MSG.string_(msgkey), Toaster.optionsOf_(true, true, options));
    }

    /// Show a warning message, if any.
    /// Overloads:
    /// (String)
    /// (List<String>)
    /// {Key.errors: Object}
    warn_(result: TestResult, options?: ToasterAtTopOption): boolean {
        const msg = An.result_(result);
        if (msg == null) { return false; }
        this.show1_(CSS.AnToasterWarn, msg, Toaster.optionsOf_(true, true, options));
        return true;
    }

    /// Post a warning message, if any, at end of the event loop.
    warn0_(result: TestResult): boolean {
        const msg = An.result_(result);
        if (msg == null) { return false; }
        Timer.sleep0_(() => {
            this.show_(CSS.AnToasterWarn, Toaster.optionsOf_(true), (_toaster, b) => {
                if (msg == null) return;
                this.text_(b, false, msg);
                b.push_().div1_(CSS.AnHint).text_(MSG.string_(RS.ToasterHint)).pop_();
            });
        });
        return true;
    }

    errorKey_(msgkey: StringId, options?: ToasterAtTopOption): void {
        this.show1_(CSS.AnToasterError, MSG.string_(msgkey), Toaster.optionsOf_(true, false, options));
    }

    /// Show an error message, if any.
    /// Overloads:
    /// (String)
    /// (List<String>)
    /// {Key.errors: Object}
    error_(result: TestResult, options?: ToasterAtTopOption): boolean {
        const msg = An.result_(result);
        if (msg == null) { return false; }
        this.show1_(CSS.AnToasterError, msg, Toaster.optionsOf_(true, true, options));
        return true;
    }

    private text_(b: DomBuilderEx, nowrap: boolean, msg: string | string[]): void {
        if (msg instanceof Array) {
            b.push_().ul_({
                "class": CSS.AnNone,
                "style": (nowrap ? "overflow:auto;" : ""),
            }).push_();
            for (let i = 0; i < msg.length; ++i) {
                b.peek_().li_({
                    "style": (nowrap ? "overflow:auto;width:max-content;" : ""),
                }).text_(msg[i]);
            }
            b.pop_(2);
        } else {
            this.textText_(b, nowrap, msg.toString());
        }
    }

    private textText_(b: DomBuilderEx, nowrap: boolean, msg: string): void {
        b.push_().div_({
            "style": (nowrap ? "overflow:auto;width:max-content;" : ""),
        }).text_(msg).pop_();
    }

    showInfo_(callback: ToasterCallback, attop: boolean = true): void {
        this.show_(CSS.AnToasterInfo, Toaster.optionsOf_(attop), callback);
    }

    showWarn_(callback: ToasterCallback, attop: boolean = true): void {
        this.show_(CSS.AnToasterWarn, Toaster.optionsOf_(attop), callback);
    }

    showError_(callback: ToasterCallback, attop: boolean = true): void {
        this.show_(CSS.AnToasterError, Toaster.optionsOf_(attop), callback);
    }

    private show1_(style: string, msg: string | string[], options: _ToasterOptions) {
        this.show_(style, options, (_toaster, b) => {
            this.text_(b, options.nowrap, msg);
            if (options.hints) {
                let hintstyles: SStringMap = (style == CSS.AnToasterError
                    ? {
                        "class": CSS.AnHint,
                        "style": "color:#eee;"
                    } : {
                        "class": CSS.AnHint,
                    });
                b.push_().div_(hintstyles).text_(MSG.string_(RS.ToasterHint)).pop_();
            }
        });
    }

    /**
     * Show the toaster.
     * @param callback (DomBuilder) To populate the toast message.
     */
    show_(style: string, options: _ToasterOptions, callback: ToasterCallback): void {
        let prevstate = this.#state;
        let state: _ToasterState | null = new _ToasterState(options.attop);
        state.showTimer$ = new Timer(this.#showDelay, () => {
            if (prevstate != null) {
                prevstate.hide();
                prevstate = null;
            }
            if (state == null) { return; }
            const b = new DomBuilderEx(this.#container);
            const tips = b.div1_(
                CSS.AnToaster,
                style,
                (options.attop ? CSS.AnToasterTop : CSS.AnToasterBottom)
            ).cursor_();
            state.tips$ = tips;
            tips.style.visibility = "hidden";
            tips.style.display = "block";
            if (callback != null) {
                callback(this, b);
            }
            const state1 = state;
            Timer.sleep0_(() => {
                Toaster.resize_(state1, tips);
                state1.onHide_(options.onhide);
                if (options.hold) Toaster.onhold1_(state1);
                tips.style.visibility = "visible";
                tips.addEventListener("click", (e: MouseEvent) => {
                    An.stopevent_(e);
                    if (state != null) {
                        if (!state.holding$) {
                            Toaster.onhold1_(state);
                        } else {
                            Toaster.unhold1_(state);
                        }
                    }
                });
                if (this.#hideDelay > 0) {
                    state1.hideTimer$ = new Timer(this.#hideDelay, () => {
                        if (state != null && state.hide()) {
                            state = null;
                        }
                    });
                }
            });
        });
        this.#state = state;
    }

    unhold_(): void {
        if (this.#state != null) {
            Toaster.unhold1_(this.#state);
        }
    }

    private static unhold1_(state: _ToasterState): void {
        state.holding$ = false;
        state.hide();
    }

    onhold_(): void {
        if (this.#state != null) {
            Toaster.onhold1_(this.#state);
        }
    }

    private static onhold1_(state: _ToasterState): void {
        state.holding$ = true;
        const tips = state.tips$;
        if (tips != null) {
            let e = tips.querySelector(`.${CSS.AnHint}`) ??
                new DomBuilderEx(tips).div_({
                    "class": CSS.AnHint,
                }).cursor_();
            e.textContent = MSG.string_(RS.ToasterHolding);
            Toaster.resize_(state, tips);
        }
    }

    private static resize_(_state: _ToasterState, tips: HTMLElement): void {
        const box = tips.getBoundingClientRect();
        const left = (window.innerWidth - Math.round(box.width)) / 2;
        tips.style.left = `${left}px`;
        const top = (window.innerHeight - Math.round(box.height)) / 2;
        tips.style.top = `${top}px`;
    }

    hide_(): void {
        if (this.#state != null) {
            if (this.#state.hide()) {
                this.#state = null;
            }
        }
    }

    tips_(): HTMLElementX {
        if (this.#state != null) {
            return this.#state.tips();
        }
        return null;
    }

    onResize_(): void {
        if (this.#state != null) {
            const tips = this.#state.tips();
            if (tips != null) {
                Toaster.resize_(this.#state, tips);
            }
        }
    }
}

/**
 * Toaster manager that hosts an infoToaster, warnToaster, errorToaster and propertyToaster.
 */
class Toasters implements IToasters, IWarner {
    #infoToaster: Toaster;
    #warnToaster: Toaster;
    #errorToaster: Toaster;
    #modalToaster: Toaster;

    constructor(container: HTMLElement) {
        this.#infoToaster = new Toaster(container, 0, 5000);
        this.#warnToaster = new Toaster(container, 0, 7500);
        this.#errorToaster = new Toaster(container, 0, 30000);
        this.#modalToaster = new Toaster(container, 0, 0);
    }

    unholdAll_(): void {
        this.#infoToaster.unhold_();
        this.#warnToaster.unhold_();
        this.#errorToaster.unhold_();
        this.#modalToaster.unhold_();
    }

    hideAll_(): void {
        this.#infoToaster.hide_();
        this.#warnToaster.hide_();
        this.#errorToaster.hide_();
        this.#modalToaster.unhold_();
    }

    onResize_(): void {
        this.#infoToaster.onResize_();
        this.#warnToaster.onResize_();
        this.#errorToaster.onResize_();
        this.#modalToaster.onResize_();
    }

    hideModal_(): void {
        this.#modalToaster.unhold_();
    }

    hideInfo_(): void {
        this.#infoToaster.hide_();
    }

    hideWarn_(): void {
        this.#warnToaster.hide_();
    }

    toastElement_(node: HTMLElement, maxwidth: number): void {
        if (node != null) {
            const name = node.nodeName;
            if (An.isBodyElement_(name)) {
                this.info_("<" + name + ">");
            } else {
                if (maxwidth == null) {
                    maxwidth = DEF.maxToastLen;
                }
                this.info_(An.truncate_("<" + name + An.elementInfo_(node) + "...>", maxwidth));
            }
        }
    }

    toastNode_(node: Node, maxwidth: number): void {
        if (node != null) {
            const type = node.nodeType;
            if (type == Node.ELEMENT_NODE) {
                this.toastElement_(node as HTMLElement, maxwidth);
            } else {
                if (maxwidth == null) {
                    maxwidth = DEF.maxToastLen;
                }
                this.info_(An.truncate_(node.textContent, maxwidth));
            }
        }
    }

    /// @return false if there are errors.
    toastResult_(ret: JSONObject): boolean {
        if (this.error_(ret)) {
            return false;
        }
        const msg = ret[Key.result];
        if (msg != null) {
            this.ok_(msg);
        }
        return true;
    }

    /// Like warnErrors() but with signature for JSONCallback.
    toastErrors_(ret: JSONObject): void {
        this.warn_(ret[Key.errors]);
    }

    //// Use onTooltipsKey instead.

    //// but onhold by default.
    modal_(callback: ToasterCallback): void {
        this.#modalToaster.unhold_();
        const sm = new Smokescreen(document.body, DEF.zindexToaster - 1).on_("click", (e) => {
            An.stopevent_(e);
            sm.destroy_();
            this.#modalToaster.unhold_();
        });
        this.#modalToaster.show_(CSS.AnToasterModal, {
            attop: true,
            nowrap: false,
            hold: true,
            hints: true,
            onhide: () => sm.destroy_(),
        }, (toaster: Toaster, b: DomBuilderEx) => {
            sm.show_();
            callback(toaster, b);
        });
    }

    show_(style: string, attop: boolean, callback: ToasterCallback): Toaster {
        this.#infoToaster.show_(style, Toaster.optionsOf_(attop), callback);
        return this.#infoToaster;
    }

    onTooltipsKey_ = (target: HTMLElement, e: Event) => {
        An.stopevent_(e);
        const key = target.getAttribute(ATTR.xTooltips);
        if (key == null) { return; }
        if (key.startsWith("X")) {
            this.infoKey_(key, { attop: true });
        } else {
        }
    };

    infoKey_(msgkey: StringId, options?: ToasterAtBottomOption): Toaster {
        this.#infoToaster.infoKey_(msgkey, options);
        return this.#infoToaster;
    }

    info_(msg: TestResult, options?: ToasterAtBottomOption): boolean {
        return this.#infoToaster.info_(msg, options);
    }

    okKey_(msgkey: StringId, options?: ToasterAtBottomOption): Toaster {
        this.#infoToaster.okKey_(msgkey, options);
        return this.#infoToaster;
    }

    ok_(msg: TestResult, options?: ToasterAtBottomOption): boolean {
        return this.#infoToaster.ok_(msg, options);
    }

    warnKey_(msgkey: StringId, options?: ToasterAtTopOption): Toaster {
        this.#warnToaster.warnKey_(msgkey, options);
        return this.#warnToaster;
    }

    warn_(msg: TestResult, options?: ToasterAtTopOption): boolean {
        return this.#warnToaster.warn_(msg, options);
    }

    warn0_(msg: TestResult, options?: ToasterAtTopOption): boolean {
        msg = An.result_(msg);
        if (msg == null) { return false; }
        Timer.sleep0_(() => {
            this.#warnToaster.warn_(msg, options);
        });
        return true;
    }

    warnAll_(msgs: any[] | null, options?: ToasterAtTopOption): boolean {
        if (msgs == null) { return false; }
        let ret = false;
        for (const msg of msgs) {
            if (this.warn_(msg, options)) {
                ret = true;
            }
        }
        return ret;
    }

    errorKey_(msg: string, options?: ToasterAtTopOption): void {
        this.#errorToaster.errorKey_(msg, options);
    }

    error_(msg: TestResult, options?: ToasterAtTopOption): boolean {
        return this.#errorToaster.error_(msg, options);
    }

    warnErrorsOrOKKey_(ret: JSONObject, okkey: string): void {
        if (!this.warn_(ret)) {
            this.okKey_(okkey, { attop: true });
        }
    }

    warnErrorsOrOK_(ret: JSONObject, okmsg: string, hold: boolean = false): void {
        if (!this.warn_(ret)) {
            this.ok_(okmsg, { attop: true, hold });
        }
    }

    warnErrorsOrResult_(ret: JSONObject, defkey: stringX = null, hold: boolean = false): void {
        if (!this.warn_(ret, { attop: true, hold: hold })) {
            if (!this.ok_(ret[Key.result], { attop: true, hold: hold })) {
                if (defkey != null) {
                    this.okKey_(defkey, { attop: true, hold: hold });
                }
            }
        }
    }
}

class ToasterInfoBuilder {
    constructor(protected _toaster: Toaster, protected _b: DomBuilderEx) { }
    build_(content: Fun10<ToasterInfoBuilder>) {
        this._b.push_().div1_(CSS.AnViewport).table1_(CSS.AnToaster).push_();
        content(this);
        this._b.pop_().up_().div1_(CSS.AnHint).pop_();
    }
    trKey_(key: StringId, value: stringX): void {
        if (value != null) {
            this._b.peek_().tr_().push_().td_().text_(MSG.string_(key)).pop_().td_().text_("" + value);
        }
    }
    tr_(label: string, value: stringX): void {
        if (value != null) {
            this._b.peek_().tr_().push_().td_().text_(label).pop_().td_().text_("" + value);
        }
    }
    tr1_(value: string, ...attrs: SStringMap[]): void {
        this._b.peek_().tr_().td_(...attrs).text_(value);
    }
    tra1_(value: string, ...attrs: SStringMap[]): void {
        this._b.peek_().tr_().td_(...attrs).ahref1_("").text_(value);
    }
    trb1_(value: string, ...attrs: SStringMap[]): void {
        this._b.peek_().tr_().td_(...attrs).b_().text_(value);
    }
    trAction_(key: StringId, value: stringX, callback: Fun10<MouseEvent>): void {
        if (value != null) {
            this._b.peek_().tr_().push_().td_().ahref1_("").onclick_(callback).text_(MSG.string_(key)).pop_().td_().text_("" + value);
        }
    }
    tn_(dataurl: stringXX): void {
        if (!dataurl) return;
        this._b.peek_().tr_().td_({ "colspan": "2" }).div1_(CSS.AnFlex).img_({
            "src": dataurl,
            "style": "max-width:240px;max-height:240px;margin:10px 0;",
        });
    }
}

class ImageInfoBuilder extends ToasterInfoBuilder {

    #dateFormat: string;
    #timeFormat: string;
    #info: MediaInfo;

    constructor(
        toaster: Toaster,
        b: DomBuilderEx,
        dateFormat: string,
        timeFormat: string,
        info: MediaInfo
    ) {
        super(toaster, b);
        this.#dateFormat = dateFormat;
        this.#timeFormat = timeFormat;
        this.#info = info;
    }

    private _fmt(date: DateTime): string {
        return DateFormat.dateString_(this.#dateFormat, date)
            + " " + TimeFormat.timeString_(this.#timeFormat, date);
    }

    build_(): void {
        const w = this.#info.width$;
        const h = this.#info.height$;
        const rotation = this.#info.rotation$;
        const isvideo = this.#info.isVideo$;
        const creation = this.#info.creationDate$;
        const duration = this.#info.duration1_(0.0);
        let createdate = (creation != null) ? this._fmt(DateTime.fromMs_(creation, true)) : null;
        let filedate = this._fmt(DateTime.fromMs_(this.#info.fileDate$));
        super.build_(() => {
            this.trKey_(RS.Title, this.#info.title$ ?? "");
            this.trKey_(RS.Mime, this.#info.mime$ ?? "");
            if (createdate != null) this.trKey_(RS.CreationDate, createdate);
            this.trKey_(RS.Size, `${this.#info.fileSize$ ?? 0}`);
            this.trKey_(RS.Date, filedate);
            this.trKey_(RS.WxH, `${w}x${h}`);
            if (isvideo) {
                this.trKey_(RS.Duration, `${duration}s`);
            }
            if (rotation != null) {
                this.trKey_(RS.Orientation, `${rotation}`);
            }
            const dataurl = this.#info.tnDataUrl$;
            if (dataurl != null) {
                this.tn_(dataurl);
            }
        });
    }
}

type SmokescreenCallback = (sm: Smokescreen) => void;

class Smokescreen {
    static _liveCount = 0;

    static liveCount(): number {
        return Smokescreen._liveCount;
    }

    #container: HTMLElementX = null;
    #zindex: number;
    #opacity: number;
    #bgColor: ColorValue | null = null;
    #element: HTMLElementX = null;
    #handlers = new Map<keyof HTMLElementEventMap, EventCallback>();
    #subscriptions: StreamSubscription[] = [];
    #isShown: boolean = false;

    /// Overloads:
    /// (HTMLElement container)
    /// (HTMLElement container, int zindex)
    /// (HTMLElement container, int zindex, double opacity)
    ///         /// @param container A DOM element that host the smokescreen.
    /// @param zindex Optional, the zindex of the the smokescreen.
    /// @param opacity Optional.
    constructor(
        container: HTMLElement,
        zindex: numberX = null,
        opacity: numberX = null) {
        this.#container = container;
        this.#zindex = (zindex != null ? zindex : An.zindexOf_(container, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
        this.#opacity = (opacity != null ? opacity : 0.0);
    }

    container_(): HTMLElementX {
        return this.#container;
    }

    zindex_(zindex: number): number {
        if (zindex != null) {
            this.#zindex = zindex;
        }
        return this.#zindex;
    }

    above_(host: HTMLElement, delta: number = DEF.zindexAbove10): void {
        this.zindex_(An.zindexOf_(host, delta, DEF.zindexPrompt + delta));
    }

    opacity_(opacity: number): number {
        if (opacity != null) {
            this.#opacity = opacity;
        }
        return this.#opacity;
    }

    bgcolor_(color: ColorValue): void {
        this.#bgColor = color;
    }

    /// Queue event handler to be added on show.
    on_(event: EventName, eventhandler: EventCallback): this {
        this.#handlers.set(event, eventhandler);
        return this;
    }

    trap_(event: string): void {
        this.#element?.addEventListener(event, (e) => {
            An.stopevent_(e);
        });
    }

    element_(): HTMLElementX {
        return this.#element;
    }

    show_(callback: SmokescreenCallback | null = null): this {
        //// should take care of the window size changes.
        //// The hack for desktop is no longer neccessary.
        this._showitnow(callback);
        return this;
    }

    hide_(): boolean {
        return this._hide();
    }

    private _hide(): boolean {
        if (!this.#isShown) {
            return false;
        }
        this.#isShown = false;
        --Smokescreen._liveCount;
        An.cancelSubscriptions_(this.#subscriptions);
        this.#element?.remove();
        this.#element = null;
        return true;
    }

    /// Hide and release all resources.
    destroy_(): void {
        if (this.#container != null) {
            this._hide();
            this.#handlers.clear();
            this.#container = null;
        }
    }

    private _showitnow(callback: SmokescreenCallback | null = null): boolean {
        if (this.#isShown || this.#container == null) {
            return false;
        }
        this.#isShown = true;
        this.#element = new DomBuilderEx(this.#container).div1_(CSS.AnSmokescreen).cursor_();
        ++Smokescreen._liveCount;
        const style = this.#element.style;
        style.zIndex = `${this.#zindex}`;
        style.opacity = `${this.#opacity}`;
        if (this.#bgColor != null) {
            style.backgroundColor = this.#bgColor.toCSSString_();
        }
        if (callback != null) {
            callback(this);
        }
        for (const event of this.#handlers.keys()) {
            const listener = this.#handlers.get(event) ?? null;
            if (listener != null) {
                this.#subscriptions.push(An.subscriptEvent_(this.#element, event, (e) => listener(e)));
            }
        }
        style.display = "block";
        style.pointerEvents = "auto";
        return true;
    }
}

class Spinner extends Smokescreen {
    #count: number = 0;
    #showTimer: Timer | null = null;

    constructor(container: HTMLElement) {
        super(container, DEF.zindexMax, DEF.opacitySpinner);
    }

    show_(callback: SmokescreenCallback | null = null): this {
        ++this.#count;
        
        if (this.#count == 1) {
                DateTime.now_().millisecondsSinceEpoch$;
            if (this.#showTimer != null) { return this; }
            this.#showTimer = new Timer(DEFUtil.showSpinnerDelay$, () => {
                this.#showTimer = null;
                super.show_((sm) => {
                    const elm = sm?.element_();
                    if (elm == null) { return; }
                    elm.style.display = "flex";
                    new DomBuilderEx(elm).child1_("div", CSS.AnSpinner).text_(MSG.string_(RS.PleaseWait));
                });
            });
        }
        callback?.(this);
        return this;
    }

    hide_(): boolean {
        if (this.#count > 0) --this.#count;
        
        if (this.#count == 0) {
            if (this.#showTimer != null) {
                this.#showTimer.cancel_();
                this.#showTimer = null;
            }
            super.hide_();
            return true;
        }
        return false;
    }

    destroy_(): void {
        if (this.container_() != null) {
            super.destroy_();
        }
    }
}

////////////////////////////////////////////////////////////////////////

class Flash {
    #element: HTMLElement;
    #selector: string;
    #style: string;
    #duration: number;
    #subscription: StreamSubscription | null;
    #onCallback: Fun10<HTMLElement> | null = null;
    #offCallback: Fun10<HTMLElement> | null = null;
    #timer: Timer | null = null;

    /// @param style The CSS class for the splotlight
    /// @param duration in ms.
    constructor(
        element: HTMLElement,
        selector: string,
        style: string,
        duration: number,
    ) {
        this.#element = element;
        this.#selector = selector;
        this.#style = style;
        this.#duration = duration;
        this.#subscription = An.subscriptEvent_(element, Conf.pointerstart$, (e) => this.handler_(e));
    }

    private flashOn_(elm: HTMLElement): void {
        elm.classList.add(this.#style);
        if (this.#onCallback != null) {
            this.#onCallback(elm);
        }
        this.#element = elm;
        this.#timer = new Timer(this.#duration, () => {
            this.flashOff_();
        });
    }

    private flashOff_(): void {
        this.#element.classList.remove(this.#style);
        if (this.#offCallback != null) {
            this.#offCallback(this.#element);
        }
        this.#timer = null;
    }

    onOn_(callback: Fun10<HTMLElement>): void {
        this.#onCallback = callback;
    }

    onOff_(callback: Fun10<HTMLElement>): void {
        this.#offCallback = callback;
    }

    private handler_(e: Event): void {
        const elm = DomUt.asHTMLElement_(
            this.#selector != null
                ? DomUt.matchingTarget_(e, this.#selector)
                : e.target);
        if (elm != null && !elm.classList.contains(CSS.AnDisabled)) {
            if (this.#timer != null) {
                this.#timer.cancel_();
                this.flashOff_();
            }
            this.flashOn_(elm);
        }
    }

    destroy_(): void {
        if (this.#timer != null) {
            this.#timer.cancel_();
            this.flashOff_();
            this.#timer = null;
        }
        if (this.#subscription != null) {
            this.#subscription.cancel_();
            this.#subscription = null;
            this.#onCallback = null;
            this.#offCallback = null;
        }
    }
}

class Spotlight {
    #container: HTMLElement;
    #duration = DEFUtil.spotlightDuration$;
    #color: string | null = null;
    #spotlight: HTMLElement;
    #timer: Timer | null = null;

    constructor(
        container: HTMLElement,
        duration = DEFUtil.spotlightDuration$,
        color: string | null = null
    ) {
        this.#container = container;
        this.#duration = duration;
        this.#color = color;
        this.#spotlight = new DomBuilderEx(this.#container).div1_(CSS.AnSpotlight).cursor_();
        this.#spotlight.style.display = "none";
    }

    show_(x: number, y: number, width: number, height: number, offcallback: Fun00 | null = null): void {
        if (this.#timer != null) {
            this.#timer.cancel_();
            this.#timer = null;
        }
        const style = this.#spotlight.style;
        style.left = `${x}px`;
        style.top = `${y}px`;
        style.width = `${width}px`;
        style.height = `${height}px`;
        if (this.#color != null) {
            style.backgroundColor = this.#color;
        }
        style.display = "block";
        this.#timer = new Timer(this.#duration, () => {
            offcallback != null ? offcallback() : this.destroy_();
        });
    }

    hide_(): void {
        if (this.#timer != null) {
            this.#timer.cancel_();
            this.#timer = null;
        }
        this.#spotlight.style.display = "none";
    }

    destroy_(): void {
        this.hide_();
        this.#spotlight.remove();
    }
}

type TabPanelCreator = (container: HTMLElement) => IUIPanel;

class _TabInfo {
    constructor(
        public tab: HTMLElement,
        public panel: HTMLElement,
        public panelObject: IUIPanel,
        public enabled: boolean = true,
    ) { }
}

class TabPanel {
    private _tabBar: HTMLElement;
    private _tabContainer: HTMLElement;
    private _activeInfo: _TabInfo | null;
    private _tabs: HTMLElement[] = [];
    private _infos = new Map<HTMLElement, _TabInfo>();
    private _tooltipsCallback: TargetEventCallback | null = null;
    private _onTabChangedCallback: Fun20<HTMLElement, number> | null = null;
    private _onTabClickedCallback: Fun20<HTMLElement, number> | null = null;
    private _tooltipsTimer: Timer | null = null;
    private _tooltipsShown: boolean = false;

    /**
         * TabPanel constructor
         * @param container The DOM element to host the tab panel.
         */
    constructor(
        protected _container: HTMLElement,
        atbottom: boolean = false
    ) {
        this._activeInfo = null;
        const b = new DomBuilderEx(this._container).push_();
        if (atbottom) {
            this._tabContainer = b.peek_().div1_(CSS.AnTabPanelContainer).cursor_();
            this._tabBar = b.peek_().div1_(CSS.AnTabbarAtBottom).cursor_();
        } else {
            this._tabBar = b.peek_().div1_(CSS.AnTabbar).cursor_();
            this._tabContainer = b.peek_().div1_(CSS.AnTabPanelContainer).cursor_();
        }
        An.onClickMatching_(this._tabBar, `div.${CSS.AnTab}`, (elm, e) => {
            const tab = elm as HTMLElement;
            if (this._onTabClickedCallback != null) {
                const info = this._infos.get(tab) ?? null;
                if (info?.enabled ?? false) {
                    this._onTabClickedCallback(tab, this._tabs.indexOf(tab));
                }
            }
            this.selectTab(tab);
            An.stopevent_(e);
        });
        An.onPointerStart_(this._tabBar, (e) => {
            const matchingtarget = DomUt.matchingTarget_(e, `span[${ATTR.xTooltips}]`);
            if (matchingtarget == null) return;
            this._stopTooltipsTimer();
            this._tooltipsShown = false;
            this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                this._tooltipsTimer = null;
                this._tooltipsShown = true;
                if (this._tooltipsCallback != null) {
                    this._tooltipsCallback(matchingtarget, e);
                }
            });
        });
        An.onPointerEnd_(this._tabBar, (e) => {
            this._stopTooltipsTimer();
            if (this._tooltipsShown) {
                this._tooltipsShown = false;
                An.stopevent_(e);
            }
        });
        if (Conf.useFlash$) {
            new Flash(this._tabBar, `div.${CSS.AnTab}`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
    }

    onWindowSizeChanged(): void {
        for (const info of this._infos.values()) {
            info.panelObject.onWindowSizeChanged_();
        }
    }

    /**
         * @param tab If not given, return the active tab. Otherwise,
         * set active tab to the given tab without showing/hiding panels.
         */
    activeTab(tab: HTMLElementX = null): HTMLElementX {
        if (tab == null) {
            return this._activeInfo == null ? null : this._activeInfo.tab;
        }
        const info = this._infos.get(tab) ?? null;
        Assert.assertion_(info != null, tab.id);
        if (this._activeInfo != null) {
            this._activeInfo.tab.classList.remove(CSS.AnSelected);
        }
        tab.classList.add(CSS.AnSelected);
        this._activeInfo = info;
        return tab;
    }

    tabBar(): HTMLElement {
        return this._tabBar;
    }

    private _stopTooltipsTimer(): void {
        if (this._tooltipsTimer != null) {
            this._tooltipsTimer.cancel_();
            this._tooltipsTimer = null;
        }
    }

    onTooltips(callback: TargetEventCallback): void {
        this._tooltipsCallback = callback;
    }

    onTabChanged(callback: Fun20<HTMLElement, number>): void {
        this._onTabChangedCallback = callback;
    }

    onTabClicked(callback: Fun20<HTMLElement, number>): void {
        this._onTabClickedCallback = callback;
    }

    activePanel(): IUIPanel | null {
        return this._activeInfo == null ? null : this._activeInfo.panelObject;
    }

    /**
         * Add a tab.
         * @param tabcreator (HTMLElement tab) A function to populate the tab label with a span element.
         * eg. new DomBuilder(tab).append("span", "fa fa-close");
         * @param panelcreator (HTMLElement panel)->UIObject A function to populate a new tab panel.
         * @return The DOM element of the new tab.
         */
    private _addtab(labelcreator: Fun10<HTMLElement>, panelcreator: TabPanelCreator): HTMLElement {
        const tab = new DomBuilderEx(this._tabBar)
            .div_({
                "class": CSS.AnTab,
            }).cursor_();
        const panel = new DomBuilderEx(this._tabContainer)
            .div_({
                "style": "display: none; overflow: hidden;",
            }).cursor_();
        labelcreator(tab);
        const info = new _TabInfo(tab, panel, panelcreator(panel));
        this._infos.set(tab, info);
        this._tabs.push(tab);
        return tab;
    }

    addTab(tooltips: string, classes: string, panelcreator: TabPanelCreator): HTMLElement {
        return this._addtab((e) => {
            new DomBuilderEx(e).append_("span", smap_(
                ["class", classes],
                [ATTR.xTooltips, tooltips],
            ));
        }, panelcreator);
    }

    selectTabAt(index: number): IUIPanel | null {
        if (index >= 0 && index < this._tabs.length) {
            return this.selectTab(this._tabs[index]);
        }
        return null;
    }

    /**
         * @param tab The DOM element for the tab.
         * @return The UIObject of the selected panel.
         */
    selectTab(tab: HTMLElementX): IUIPanel | null {
        const info = (tab == null ? null : this._infos.get(tab));
        if (info == null) {
            
        } else {
            this._selecttab(info);
        }
        return this._activeInfo?.panelObject ?? null;
    }

    /// @return true if enable state is changed.
    enableTab(tab: HTMLElement): boolean {
        const info = this._infos.get(tab);
        if (info == null || info.enabled) {
            return false;
        }
        info.enabled = false;
        info.tab.classList.remove("disabled");
        return true;
    }

    enableTabAt(index: Int): boolean {
        const tab = this.getTabAt(index);
        return tab != null ? this.enableTab(tab) : false;
    }

    /// @return true if enable state is changed.
    disableTab(tab: HTMLElement): boolean {
        const info = this._infos.get(tab);
        if (info == null || !info.enabled) { return false; }
        info.enabled = false;
        info.tab.classList.add("disabled");
        return true;
    }

    disableTabAt(index: Int): boolean {
        const tab = this.getTabAt(index);
        return tab != null ? this.disableTab(tab) : false;
    }

    getTabs(): IterableIterator<HTMLElement> {
        return this._infos.keys();
    }

    getPanel(tab: HTMLElement): IUIPanel | null {
        const info = this._infos.get(tab);
        return info?.panelObject ?? null;
    }

    getTabAt(index: Int): HTMLElementX {
        if (index < 0 || index >= this._infos.size) return null;
        return new Array(...this.getTabs())[index];
    }

    getPanelAt(index: Int): IUIPanel | null {
        const tab = this.getTabAt(index);
        return tab == null ? null : this.getPanel(tab);
    }

    resizeContent1(containerheight: number, tabbarheight: number): void {
        if (containerheight == null) {
            
        }
        
        const h = containerheight - tabbarheight;
        for (const info of this._infos.values()) {
            info.panel.style.height = `${h}px`;
            info.panelObject.resizeContent_(h);
        }
    }

    private _selecttab(info: _TabInfo): void {
        if (info == null || !info.enabled) { return; }
        const changed = (this._activeInfo == null || this._activeInfo.tab !== info.tab);
        if (this._activeInfo != null && this._activeInfo.tab !== info.tab) {
            this._activeInfo.tab.classList.remove(CSS.AnSelected);
            this._activeInfo.panel.style.display = "none";
            this._activeInfo.panelObject.hide_();
        }
        this._activeInfo = info;
        this._activeInfo.tab.classList.add(CSS.AnSelected);
        this._activeInfo.panelObject.show_();
        this._activeInfo.panel.style.display = "block";
        if (this._onTabChangedCallback != null && changed) {
            this._onTabChangedCallback(info.tab, this._tabs.indexOf(info.tab));
        }
    }
}

////////////////////////////////////////////////////////////////////////

class DraggerState {
    active: boolean = false;
    moved: boolean = false;
    serial: number = 0;
    id: number = 0;
    pageX: number = 0;
    pageY: number = 0;
    screenX: number = 0;
    screenY: number = 0;
    cx: number = 0;
    cy: number = 0;
    touches: number = 0;
    pointers: number[] = [];
    onstart_(pagex: number, pagey: number, screenx: number, screeny: number) {
        this.serial = 0;
        this.cx = 0;
        this.cy = 0;
        this.moved = false;
        this.active = true;
        this._set(pagex, pagey, screenx, screeny);
    }
    onend_(pagex: number, pagey: number, screenx: number, screeny: number) {
        this.active = false;
        this._set(pagex, pagey, screenx, screeny);
    }
    update_(pagex: number, pagey: number, screenx: number, screeny: number) {
        const dx = pagex - this.pageX;
        const dy = pagey - this.pageY;
        this.cx += dx;
        this.cy += dy;
        this._set(pagex, pagey, screenx, screeny);
    }
    private _set(pagex: number, pagey: number, screenx: number, screeny: number) {
        this.pageX = pagex;
        this.pageY = pagey;
        this.screenX = screenx;
        this.screenY = screeny;
    }
}

type DragstartCallback = (dragger: Dragger, target: EventTarget, pagex: number, pagey: number, screenx: number, screeny: number) => boolean;

interface IDraggerHandler {
    onDragstart_(dragger: Dragger, target: EventTarget, pagex: number, pagey: number, screenx: number, screeny: number): boolean;

    onDragmove_(dragger: Dragger): void;

    onDragend_(dragger: Dragger, e: UIEvent): void;
}

class DumbDraggerHandler implements IDraggerHandler {
    static readonly singleton = new DumbDraggerHandler();
    onDragstart_(dragger: Dragger, target: EventTarget, _x: number, _y: number): boolean {
        return dragger.element_() === target;
    }

    onDragmove_(_dragger: Dragger): void { }

    onDragend_(_dragger: Dragger, _e: UIEvent): void { }
}

class DefaultDraggerHandler implements IDraggerHandler {
    _left = 0;
    _top = 0;
    _dragstartCallback: DragstartCallback;

    constructor(dragstartcallback: DragstartCallback | null = null) {
        this._dragstartCallback = (dragstartcallback != null) ? dragstartcallback : (dragger, target) => {
            return dragger.element_() === target;
        };
    }

    onDragstart_(dragger: Dragger, target: EventTarget, pagex: number, pagey: number): boolean {
        const ok = this._dragstartCallback(dragger, target, pagex, pagey, 0, 0);
        const elm = DomUt.asHTMLElement_(target);
        if (elm == null) { return false; }
        if (ok) {
            const offset = An.documentOffset_(elm);
            this._left = offset.x;
            this._top = offset.y;
        }
        return ok;
    }

    onDragmove_(dragger: Dragger): void {
        const state = dragger.state_();
        const style = dragger.target_().style;
        style.left = `${this._left + state.cx}px`;
        style.top = `${this._top + state.cy}px`;
    }

    onDragend_(_dragger: Dragger, _e: UIEvent): void { }

    destroy() {
        this._dragstartCallback = An.predicate0_;
    }
}

class VerticalDraggerHandler implements IDraggerHandler {
    _top = 0;
    _dragstartCallback: DragstartCallback;

    constructor(dragstartcallback: DragstartCallback | null = null) {
        this._dragstartCallback = (dragstartcallback != null) ? dragstartcallback : (dragger, target) => {
            return dragger.element_() === target;
        };
    }

    onDragstart_(dragger: Dragger, target: EventTarget, pagex: number, pagey: number): boolean {
        const ok = this._dragstartCallback(dragger, target, pagex, pagey, 0, 0);
        const elm = DomUt.asHTMLElement_(target);
        if (elm == null) return false;
        if (ok) {
            const offset = An.documentOffset_(elm);
            this._top = offset.y;
        }
        return ok;
    }

    onDragmove_(dragger: Dragger): void {
        dragger.target_().style.top = `${this._top + dragger
            .state_()
            .cy}px`;
    }

    onDragend_(_dragger: Dragger, _e: UIEvent): void { }

    destroy() {
        this._dragstartCallback = An.predicate0_;
    }
}

/**
 * BUG: For now, Dragger do not works correctly for _container element with margin.
 * Apparently, HTMLElement.documentOffset() return coordinate of the border box.
 * However, setting style.left and style.top works on the margin box.
 */
class Dragger {
    static readonly THRESHOLD = 3;
    static readonly SCROLL_THRESHOLD = 5;

    _rateLimiter: IRateLimiter;
    _state: DraggerState = new DraggerState();
    _startHandler: StreamSubscription | null = null;
    _dragStartCallback: Fun00 | null = null;
    _dragmoveHandlers: StreamSubscription[] = [];
    _dragcancelHandlers: StreamSubscription[] = [];
    _threshold = Dragger.THRESHOLD;

    /**
         * Dragger constructor.
         * @param target The target element to be dragged.
         * @param handler IDraggerHandler.
         */
    constructor(private _target: HTMLElement, private _handler: IDraggerHandler, ratelimiter: IRateLimiter | null = null) {
        Assert.assertion_(_handler != null);
        if (ratelimiter == null) {
            ratelimiter = new FrameLimiter(2);
        }
        this._rateLimiter = ratelimiter;
    }

    onDragStart_(callback: Fun00): void {
        this._dragStartCallback = callback;
    }

    element_(): HTMLElement {
        return this._target;
    }

    state_(): DraggerState {
        return this._state;
    }

    target_(): HTMLElement {
        return this._target;
    }

    rateLimit_(limiter: IRateLimiter): this {
        this._rateLimiter = limiter;
        return this;
    }

    threshold_(n: number): this {
        this._threshold = n;
        return this;
    }

    bind_(): this {
        if (Conf.useTouch$) {
            this._installTouchHandlers();
        } else {
            this._installMouseHandlers();
        }
        return this;
    }

    unbind_(): void {
        if (this._startHandler != null) {
            An.cancelSubscriptions_(this._dragcancelHandlers);
            An.cancelSubscriptions_(this._dragmoveHandlers);
            this._startHandler.cancel_();
            this._startHandler = null;
        }
    }

    destroy_(): void {
        this.unbind_();
        this._dragStartCallback = null;
        this._handler = DumbDraggerHandler.singleton;
        this._rateLimiter = NoLimiter.singleton;
    }

    private _installTouchHandlers(): void {
        this._startHandler = An.subscriptEvent_(this._target, Events.touchstart, (event) => {
            const e = event as TouchEvent;
            const touches = e.changedTouches;
            const len = touches.length;
            if (len > 0) {
                this._state.touches = e.touches.length;
                this._state.pointers = [];
                for (const t of new ItemsIterable(e.touches)) {
                    this._state.pointers.push(t.pageX);
                    this._state.pointers.push(t.pageY);
                }
                const touch = touches[0];
                if (!this._dragstart(touch.target, touch.pageX, touch.pageY, touch.screenX, touch.screenY)) {
                    return;
                }
                An.stopevent_(e);
                this._state.id = touch.identifier;
                this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.touchmove, (e) => {
                    this._touchmove(e as TouchEvent);
                }));
                this._dragcancelHandlers.push(An.subscriptEvent_(this._target, Events.touchend, (e) => {
                    this._touchcancel(e as TouchEvent);
                }));
                this._dragcancelHandlers.push(An.subscriptEvent_(this._target, Events.touchcancel, (e) => {
                    this._touchcancel(e as TouchEvent);
                }));
                this._dragStartCallback?.();
            }
        });
    }

    private _touchmove(e: TouchEvent): void {
        if (e.touches.length == 2) {
            An.stopevent_(e);
            this._state.touches = e.touches.length;
            this._state.pointers = [];
            for (const t of new ItemsIterable(e.touches)) {
                this._state.pointers.push(t.pageX);
                this._state.pointers.push(t.pageY);
            }
            for (const touch of new ItemsIterable(e.changedTouches)) {
                if (touch != null && touch.identifier == this._state.id) {
                    An.stopevent_(e);
                    this._state.update_(touch.pageX, touch.pageY, touch.screenX, touch.screenY);
                    break;
                }
            }
            if (!this._state.moved) {
                this._state.moved = true;
                An.cancelSubscriptions_(this._dragcancelHandlers);
                this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.touchend, (e) => {
                    this._touchend(e as TouchEvent);
                }));
                this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.touchcancel, (e) => {
                    this._touchcancel(e as TouchEvent);
                }));
            }
            this._onmove();
        } else {
            for (const touch of new ItemsIterable(e.changedTouches)) {
                if (touch != null && touch.identifier == this._state.id) {
                    An.stopevent_(e);
                    const x = touch.pageX;
                    const y = touch.pageY;
                    const dx = x - this._state.pageX;
                    const dy = y - this._state.pageY;
                    if ((y != 0 && (dy > this._threshold || dy < -this._threshold))
                        ||
                        (x != 0 && (dx > this._threshold || dx < -this._threshold))) {
                        if (!this._state.moved) {
                            this._state.moved = true;
                            An.cancelSubscriptions_(this._dragcancelHandlers);
                            this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.touchend, (e) => {
                                this._touchend(e as TouchEvent);
                            }));
                            this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.touchcancel, (e) => {
                                this._touchend(e as TouchEvent);
                            }));
                        }
                        this._state.update_(x, y, touch.screenX, touch.screenY);
                        this._onmove();
                    }
                    break;
                }
            }
        }
    }

    private _touchcancel(e: TouchEvent): void {
        for (const touch of new ItemsIterable(e.changedTouches)) {
            if (touch != null && touch.identifier == this._state.id) {
                if (this._state.active && !this._state.moved) {
                    An.stopevent_(e);
                    this._state.onend_(touch.pageX, touch.pageY, touch.screenX, touch.screenY);
                    this._cancel(e);
                }
                break;
            }
        }
    }

    private _touchend(e: TouchEvent): void {
        for (const touch of new ItemsIterable(e.changedTouches)) {
            if (touch != null && touch.identifier == this._state.id) {
                
                An.stopevent_(e);
                An.cancelSubscriptions_(this._dragmoveHandlers);
                An.cancelSubscriptions_(this._dragcancelHandlers);
                this._state.onend_(touch.pageX, touch.pageY, touch.screenX, touch.screenY);
                this._onend(e);
                break;
            }
        }
    }

    private _installMouseHandlers(): void {
        this._startHandler = An.subscriptEvent_(this._target, Events.mousedown, (event) => {
            const e = event as MouseEvent;
            const x = Math.round(e.pageX);
            const y = Math.round(e.pageY);
            if (e.shiftKey) {
                this._state.touches = 3;
                this._state.pointers = [x, y, x, y, x, y];
            } else if (e.ctrlKey) {
                this._state.touches = 2;
                this._state.pointers = [x, y, x, y];
            } else {
                this._state.touches = 1;
                this._state.pointers = [x, y];
            }
            if (e.target == null || !this._dragstart(e.target, x, y, e.screenX, e.screenY)) {
                return;
            }
            An.stopevent_(e);
            this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.mousemove, (e) => {
                this._mousemove(e as MouseEvent);
            }));
            this._dragcancelHandlers.push(An.subscriptEvent_(document, Events.mouseup, (e) => {
                this._mousecancel(e as MouseEvent);
            }));
        });
    }

    private _mousemove(e: MouseEvent): void {
        An.stopevent_(e);
        const x = Math.round(e.pageX);
        const y = Math.round(e.pageY);
        const dx = x - this._state.pageX;
        const dy = y - this._state.pageY;
        if ((y != 0 && (dy > this._threshold || dy < -this._threshold))
            ||
            (x != 0 && (dx > this._threshold || dx < -this._threshold))) {
            if (!this._state.moved) {
                this._state.moved = true;
                An.cancelSubscriptions_(this._dragcancelHandlers);
                this._dragmoveHandlers.push(An.subscriptEvent_(document, Events.mouseup, (e) => {
                    this._mouseup(e as MouseEvent);
                }));
            }
            if (e.shiftKey) {
                this._state.touches = 3;
                this._state.pointers = [x, y, x, y, x, y];
            } else if (e.ctrlKey) {
                this._state.touches = 2;
                if (this._state.pointers.length >= 2) {
                    this._state.pointers = [this._state.pointers[0], this._state.pointers[1], x, y];
                } else {
                    this._state.pointers = [x, y, x, y];
                }
            } else {
                this._state.touches = 1;
                this._state.pointers = [x, y];
            }
            this._state.update_(x, y, e.screenX, e.screenY);
            this._onmove();
        }
    }

    private _mousecancel(e: MouseEvent): void {
        if (this._state.active && !this._state.moved) {
            An.stopevent_(e);
            this._state.onend_(Math.round(e.pageX), Math.round(e.pageY), e.screenX, e.screenY);
            this._cancel(e);
        }
    }

    private _mouseup(e: MouseEvent): void {
        
        An.stopevent_(e);
        An.cancelSubscriptions_(this._dragcancelHandlers);
        An.cancelSubscriptions_(this._dragmoveHandlers);
        this._state.onend_(Math.round(e.pageX), Math.round(e.pageY), e.screenX, e.screenY);
        this._onend(e);
    }

    private _onmove(): void {
        this._rateLimiter.queue_((_elapsed, _immediate: boolean) => {
            if (this._handler != null) {
                this._handler.onDragmove_(this);
            }
        });
    }

    private _onend(e: UIEvent): void {
        if (this._handler != null) {
            this._handler.onDragend_(this, e);
        }
    }

    private _dragstart(target: EventTarget, pagex: number, pagey: number, screenx: number, screeny: number): boolean {
        const ok = this._handler.onDragstart_(this, target, pagex, pagey, screenx, screeny);
        
        if (!ok) {
            return false;
        }
        this._state.onstart_(pagex, pagey, screenx, screeny);
        return true;
    }

    private _cancel(e: UIEvent): void {
        
        An.cancelSubscriptions_(this._dragcancelHandlers);
        An.cancelSubscriptions_(this._dragmoveHandlers);
        this._onend(e);
    }
}

//////////////////////////////////////////////////////////////////////

type SliderDragCallback = (delta: number) => void;
type SliderClickCallback = (y: number) => void;

class SliderDragger implements IDraggerHandler {
    _dh = 0;
    _h = 0;
    _dragger: Dragger;
    _dragCallback: SliderDragCallback | null = null;
    _clickCallback: SliderClickCallback | null = null;

    /**
         * @param slider
         * @param handle
         * @param rangepx The number of px that cover the range.
         * @param steppx The number of px for each value step.
         */
    constructor(
        private _slider: HTMLElement,
        private _handle: HTMLElement,
        private _rangepx: number,
        private _step: number,
        private _handleOffset: number,
        private _vertical: boolean) {
        this._dragger = new Dragger(_slider, this).bind_();
    }

    onDragstart_(_dragger: Dragger, target: EventTarget, _x: number, _y: number): boolean {
        const ret = (this._slider === target || this._handle === target);
        
        return ret;
    }

    onDragmove_(dragger: Dragger): void {
        const state = dragger.state_();
        const h = (this._vertical ? state.cy : state.cx);
        const d = h - this._h;
        if (this._dh > 0 && d < 0 || this._dh < 0 && d > 0) {
            this._dh = 0;
        }
        this._dh += d;
        let delta = 0;
        if (this._dh > this._step) {
            delta = 1;
            this._dh = this._dh - this._step;
        } else if (this._dh < -this._step) {
            delta = -1;
            this._dh = this._dh + this._step;
        }
        
        if (delta != 0 && this._dragCallback != null) {
            this._h = h;
            this._dragCallback(delta);
        }
    }

    onDragend_(dragger: Dragger, e: UIEvent): void {
        
        this._h = 0;
        const state = dragger.state_();
        if (!state.moved && this._clickCallback != null) {
            const offset = An.documentOffset_(this._slider);
            const d = Math.floor((this._vertical
                ? (state.pageY - offset.y - this._handleOffset)
                : (state.pageX - offset.x - this._handleOffset)));
            const y = Math.floor(Math.max(0, Math.min(this._rangepx, d)));
            
            if (this._clickCallback != null) {
                An.stopevent_(e);
                this._clickCallback(y);
            }
        }
    }

    /// @param callback int callback(int delta) where delta is the value delta.
    onDrag_(callback: SliderDragCallback): void {
        this._dragCallback = callback;
    }

    /// @param callback int callback(int y) where y is the handle position in px.
    onClick_(callback: SliderClickCallback): void {
        this._clickCallback = callback;
    }

    destroy_(): void {
        this._dragger.destroy_();
    }
}

////////////////////////////////////////////////////////////////////////

class Slider {
    _top: HTMLElement;
    _slider: HTMLElement;
    _handle: HTMLElement;
    _dragger: SliderDragger;

    constructor(
        private _container: HTMLElement,
        private _major: number,
        private _halfMinor: number,
        private _step: number,
        private _handleOffset: number,
        private _vertical: boolean) {
        const b = new DomBuilderEx(this._container).push_();
        const d2 = this._halfMinor;
        const minor = d2 * 2;
        let width: number;
        let height: number;
        let left = "left";
        let top = "top";
        //// FIXME Hack
        let adjust = 0;
        if (this._vertical) {
            width = minor;
            height = this._major;
        } else {
            width = this._major;
            height = minor;
            left = "top";
            top = "left";
            adjust = 0;
        }
        this._top = b
            .peek_()
            .div_({
                "class": CSS.AnSlider,
                "style": `flex:0 0 ${width}px;height:${height}px;border-radius:${d2}px;`,
            })
            .push_()
            .cursor_();
        this._slider = this._top;
        this._handle = b.pop_().div_({
            //// NOTE: The static position of the handle is inside the slider border, so top/left is -1px.
            "class": CSS.AnSliderHandle,
            "style": `${left}:${adjust}px;${top}:${adjust}px;` +
                `width:${minor}px;height:${minor}px;border-radius:${d2}px;`,
        }).cursor_();
        this._dragger = new SliderDragger(this._slider, this._handle, this.range_(), this._step, this._handleOffset, this._vertical);
    }

    onDrag_(callback: SliderDragCallback): void {
        this._dragger.onDrag_(callback);
    }

    onClick_(callback: SliderClickCallback): void {
        this._dragger.onClick_(callback);
    }

    element_(): HTMLElement {
        return this._top;
    }

    slider_(): HTMLElement {
        return this._slider;
    }

    handle_(): HTMLElement {
        return this._handle;
    }

    range_(): number {
        return this._major + 1 - this._halfMinor * 2;
    }

    setPosition_(y: number): void {
        const max = this.range_();
        if (y > max) {
            y = max;
        } else if (y < 0) {
            y = 0;
        }
        const position = `${y}px`;
        this._vertical ? this._handle.style.top = position : this._handle.style.left = position;
    }

    destroy_(): void {
        this._dragger.destroy_();
    }
}

//////////////////////////////////////////////////////////////////////

type ScribblerHistoryListener = (history: ScribblerHistory) => void;

class ScribblerAction {
    static readonly BG = "b";
    static readonly CURVE = "c";
    static readonly ELLIPSE = "o";
    static readonly EMBEDED_IMAGE = "e";
    static readonly IMAGE = "i";
    static readonly POLYCURVE = "p";
    static readonly POLYGON = "g";
    static readonly RECTANGLE = "r";
    static readonly TEXT = "t";
    static readonly history = "E";
    static readonly export = "X";
    static readonly more = "M";
    static readonly move = "V";
    static readonly shift = "H";
    static readonly _NAMES = new Map<string, string>([
        [ScribblerAction.BG, RS.ScribblerBackground],
        [ScribblerAction.CURVE, RS.ScribblerCurve],
        [ScribblerAction.ELLIPSE, RS.ScribblerEllipse],
        [ScribblerAction.EMBEDED_IMAGE, RS.ScribblerEmbeddedImage],
        [ScribblerAction.IMAGE, RS.ScribblerImage],
        [ScribblerAction.POLYCURVE, RS.ScribblerPolycurve],
        [ScribblerAction.POLYGON, RS.ScribblerPolygon],
        [ScribblerAction.RECTANGLE, RS.ScribblerRectangle],
        [ScribblerAction.TEXT, RS.ScribblerText],
        [ScribblerAction.history, RS.ScribblerEdit],
        [ScribblerAction.export, RS.ScribblerExport],
        [ScribblerAction.more, RS.ScribblerMore],
        [ScribblerAction.move, RS.ScribblerMove],
        [ScribblerAction.shift, RS.ScribblerShift],
    ]);

    static describe(action: string): string {
        const key = ScribblerAction._NAMES.get(action);
        return key === undefined ? "" : MSG.string_(key);
    }
}

class ScribblerLineStyle {
    static readonly SOLID = "solid";
    static readonly DASH = "dash";
    static readonly DOTTED = "dotted";

    static readonly MASQUEE: number[] = [1, 3];
    static readonly BUTT_DASH: number[] = [6, 2];
    static readonly BUTT_DOTTED: number[] = [1, 1];
    static readonly SQUARE_DASH: number[] = [5, 2];
    static readonly SQUARE_DOTTED: number[] = [1, 2];

    static dash_(w: number): number[] {
        if (w > 10) {
            return [40, w + 20];
        }
        return [w * ScribblerLineStyle.SQUARE_DASH[0], w * ScribblerLineStyle.SQUARE_DASH[1]];
    }

    static dotted_(w: number): number[] {
        if (w > 10) {
            return [1, w + 20];
        }
        return [1, w * ScribblerLineStyle.SQUARE_DOTTED[1] + 1];
    }
}

class ScribblerDefault {
    static readonly _SQUARE = "square";
    static readonly _ROUND = "round";
    static readonly _LEFT = "Left";
    static readonly _CENTER = "Center";
    static readonly _RIGHT = "Right";

    static readonly COLOR_WHITE = ColorValue.fromRGBA_(255, 255, 255, 1.0);
    static readonly ACTION = ScribblerAction.CURVE;
    static readonly TEXTING = true;
    static readonly FILL = true;
    static readonly STROKE = true;
    static readonly GRID_S = 1;
    static readonly GRID_L = 10;
    static readonly GRID_X = 16;
    static readonly SHAPE = ScribblerAction.ELLIPSE;
    static readonly LINE_CAP: CanvasLineCap = ScribblerDefault._SQUARE;
    static readonly LINE_JOIN: CanvasLineJoin = ScribblerDefault._ROUND;
    static readonly TEXT_ALIGN = ScribblerDefault._CENTER;
    static readonly LINE_WIDTH = 1.05;
    static readonly LINE_HEIGHT = 1.15;
    static readonly LINE_STYLE = ScribblerLineStyle.SOLID;
    static readonly FONT_FAMILY = "NotoSans-Regular";
    static readonly FONT_SIZE = 16;
    static readonly CORNERING = 0.5;
    static readonly CORNER_RADIUS = 5;
    static readonly ROTATION = 0;
    static readonly DATA: string | null = null;
    static readonly STROKE_COLOR = ColorValue.fromRGBA_(0, 0, 0, 1.0);
    static readonly FILL_COLOR = ColorValue.fromRGBA_(30, 144, 255, 0.5);
    static readonly TEXT_COLOR = ColorValue.fromRGBA_(0, 0, 0, 1.0);
    static readonly BG_COLOR = ColorValue.fromRGBA_(255, 255, 255, 1.0);
    static readonly HIGHLIGHT_COLOR = ColorValue.fromRGBA_(0, 0, 0, 0.5);
}

interface IScribblerHandler extends IWarner, IFilepathUtil {
    showKeyboard_(): void;

    hideKeyboard_(callback: Fun00): void;

    loadFont_(family: string, callback: Fun00): void;

    ok_(msg: TestResult, options?: ToasterAtBottomOption): void;

    info_(msg: TestResult, options?: ToasterAtBottomOption): void;

    warn_(msg: TestResult, options?: ToasterAtTopOption): boolean;

    /// @param callback(uri, linkstatus, ...) where uri can be used directly for img.src.
    promptImportImage_(
        width: number,
        height: number,
        zindex: number,
        callback: PromptInputImageCallback
    ): void;

    promptExportImage_(
        filepath: string,
        frompath: stringX,
        width: number,
        height: number,
        zindex: number,
        callback: PromptOutputImageCallback
    ): void;

    getSettings_(): Settings;

    saveImage_(path: string, dataurl: string, callback: JSONCallback): void;
}

//////////////////////////////////////////////////////////////////////

class ScribblerOptions {
    x_texting?: boolean;
    x_shape?: string;
    x_grid?: number;
    x_lineHeight?: number;
    x_textAlign?: string;
    x_stroke?: boolean;
    x_fill?: boolean;
    x_strokeColor?: ColorValue;
    x_fillColor?: ColorValue;
    x_textColor?: ColorValue;
    x_lineWidth?: number;
    x_lineStyle?: string;
    x_fontFamily?: string;
    x_fontSize?: number;
    x_cornering?: number;
    x_cornerRadius?: number;
    x_rotation?: number;
    x_data?: string | null;
}

class ScribblerSetting {
    static readonly STROKE = "s";
    static readonly FILL = "f";
    static readonly STROKE_COLOR = "sc";
    static readonly FILL_COLOR = "fc";
    static readonly TEXT_COLOR = "tc";
    static readonly LINE_WIDTH = "lw";
    static readonly LINE_STYLE = "ls";
    static readonly FONT_FAMILY = "ff";
    static readonly FONT_SIZE = "fs";
    static readonly CORNERING = "ci";
    static readonly CORNER_RADIUS = "cr";
    static readonly ROTATION = "ro";
    static readonly DATA = "d";

    x_texting: boolean = ScribblerDefault.TEXTING;
    x_shape: string = ScribblerDefault.SHAPE;
    x_grid: number = ScribblerDefault.GRID_S;
    x_lineHeight: number = ScribblerDefault.LINE_HEIGHT;
    x_textAlign: string = ScribblerDefault.TEXT_ALIGN;
    x_stroke: boolean = ScribblerDefault.STROKE;
    x_fill: boolean = ScribblerDefault.FILL;
    x_strokeColor: ColorValue = ScribblerDefault.STROKE_COLOR;
    x_fillColor: ColorValue = ScribblerDefault.FILL_COLOR;
    x_textColor: ColorValue = ScribblerDefault.TEXT_COLOR;
    x_lineWidth: number = ScribblerDefault.LINE_WIDTH;
    x_lineStyle: string = ScribblerDefault.LINE_STYLE;
    x_fontFamily: string = ScribblerDefault.FONT_FAMILY;
    x_fontSize: number = ScribblerDefault.FONT_SIZE;
    x_cornering: number = ScribblerDefault.CORNERING;
    x_cornerRadius: number = ScribblerDefault.CORNER_RADIUS;
    x_rotation: number = ScribblerDefault.ROTATION;
    x_data: string | null = ScribblerDefault.DATA;

    constructor(options?: ScribblerOptions) {
        if (options) {
            for (const [key, value] of Object.entries(options)) {
                (this as any)[key] = value;
            }
        }
    }

    clone(): ScribblerSetting {
        return new ScribblerSetting({
            x_texting: this.x_texting,
            x_shape: this.x_shape,
            x_grid: this.x_grid,
            x_lineHeight: this.x_lineHeight,
            x_textAlign: this.x_textAlign,
            x_stroke: this.x_stroke,
            x_fill: this.x_fill,
            x_strokeColor: this.x_strokeColor,
            x_fillColor: this.x_fillColor,
            x_textColor: this.x_textColor,
            x_lineWidth: this.x_lineWidth,
            x_lineStyle: this.x_lineStyle,
            x_fontFamily: this.x_fontFamily,
            x_fontSize: this.x_fontSize,
            x_cornering: this.x_cornering,
            x_cornerRadius: this.x_cornerRadius,
            x_rotation: this.x_rotation,
            x_data: this.x_data,
        });
    }

    apply(context: CanvasRenderingContext2D, handler: IScribblerHandler, callback: Fun00): void {
        if (this.x_strokeColor != null) {
            Scribbler.setStrokeColor_(context, this.x_strokeColor);
        }
        if (this.x_fillColor != null) {
            Scribbler.setFillColor_(context, this.x_fillColor);
        }
        if (this.x_lineWidth != null) {
            context.lineWidth = this.x_lineWidth;
        }
        if (this.x_lineStyle != null && this.x_lineWidth != null) {
            Scribbler._setLineStyle_(context, this.x_lineStyle);
        }
        if (this.x_fontFamily != null && this.x_fontSize != null) {
            const font = `${this.x_fontSize}px ${this.x_fontFamily}`;
            Scribbler.setFont_(context, handler, font, callback);
            return;
        }
        callback();
    }

    toJson(action: string): JSONObject {
        switch (action) {
            case ScribblerAction.BG:
                return StringMap.from_<any>(
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                );
            case ScribblerAction.CURVE:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                    [ScribblerSetting.CORNERING, this.x_cornering],
                );
            case ScribblerAction.POLYCURVE:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE, this.x_stroke],
                    [ScribblerSetting.FILL, this.x_fill],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                    [ScribblerSetting.CORNERING, this.x_cornering],
                );
            case ScribblerAction.POLYGON:
            case ScribblerAction.ELLIPSE:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE, this.x_stroke],
                    [ScribblerSetting.FILL, this.x_fill],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                );
            case ScribblerAction.RECTANGLE:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE, this.x_stroke],
                    [ScribblerSetting.FILL, this.x_fill],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                    [ScribblerSetting.CORNER_RADIUS, this.x_cornerRadius],
                );
            case ScribblerAction.TEXT:
                return StringMap.from_<any>(
                    [ScribblerSetting.TEXT_COLOR, this.x_textColor.toRgbaString_()],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.FONT_FAMILY, this.x_fontFamily],
                    [ScribblerSetting.FONT_SIZE, this.x_fontSize],
                    [ScribblerSetting.DATA, this.x_data],
                );
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE, this.x_stroke],
                    [ScribblerSetting.FILL, this.x_fill],
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                    [ScribblerSetting.ROTATION, this.x_rotation],
                    [ScribblerSetting.DATA, this.x_data],
                );
            default:
                return StringMap.from_<any>(
                    [ScribblerSetting.STROKE, this.x_stroke],
                    [ScribblerSetting.FILL, this.x_fill],
                    [ScribblerSetting.STROKE_COLOR, this.x_strokeColor.toRgbaString_()],
                    [ScribblerSetting.FILL_COLOR, this.x_fillColor.toRgbaString_()],
                    [ScribblerSetting.LINE_WIDTH, this.x_lineWidth],
                    [ScribblerSetting.LINE_STYLE, this.x_lineStyle],
                    [ScribblerSetting.FONT_FAMILY, this.x_fontFamily],
                    [ScribblerSetting.FONT_SIZE, this.x_fontSize],
                );
        }
    }

    static fromJson(json: JSONObject): ScribblerSetting {
        const strokecolor = json[ScribblerSetting.STROKE_COLOR];
        const fillcolor = json[ScribblerSetting.FILL_COLOR];
        const textcolor = json[ScribblerSetting.TEXT_COLOR];
        return new ScribblerSetting({
            x_stroke: json[ScribblerSetting.STROKE],
            x_fill: json[ScribblerSetting.FILL],
            x_strokeColor: ColorValue.from_(strokecolor) ?? undefined,
            x_fillColor: ColorValue.from_(fillcolor) ?? undefined,
            x_textColor: ColorValue.from_(textcolor) ?? undefined,
            x_lineWidth: json[ScribblerSetting.LINE_WIDTH],
            x_lineStyle: json[ScribblerSetting.LINE_STYLE],
            x_fontFamily: json[ScribblerSetting.FONT_FAMILY],
            x_fontSize: json[ScribblerSetting.FONT_SIZE],
            x_cornering: json[ScribblerSetting.CORNERING],
            x_cornerRadius: json[ScribblerSetting.CORNER_RADIUS],
            x_rotation: json[ScribblerSetting.ROTATION],
            x_data: json[ScribblerSetting.DATA],
        });
    }
}

//////////////////////////////////////////////////////////////////////

class ScribblerCmd {
    constructor(
        public readonly action$: string,
        public readonly setting$: ScribblerSetting,
        public path$: number[],
        public imageData$: ImageData | null = null
    ) { }

    clone_(): ScribblerCmd {
        return new ScribblerCmd(this.action$, this.setting$.clone(), Array.from(this.path$), this.imageData$);
    }

    exec_(context: CanvasRenderingContext2D, handler: IScribblerHandler, ondone: StringListXCallback | null = null): void {
        context.save();
        this.setting$.apply(context, handler, () => {
            switch (this.action$) {
                case ScribblerAction.BG:
                    const canvas = context.canvas;
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    break;
                case ScribblerAction.CURVE:
                    Scribbler.drawCurve_(context, this.setting$.x_cornering, this.path$, false);
                    context.stroke();
                    break;
                case ScribblerAction.POLYCURVE: {
                    if (this.setting$.x_cornering == 0) {
                        if (Scribbler.drawPath1_(context, this.path$, this.setting$.x_fill) > 0) {
                            if (this.setting$.x_stroke) {
                                context.stroke();
                            }
                        }
                    } else {
                        Scribbler.drawCurve_(context, this.setting$.x_cornering, this.path$, false);
                        if (this.setting$.x_fill) {
                            context.closePath();
                            context.fill();
                        }
                        if (this.setting$.x_stroke) {
                            context.stroke();
                        }
                    }
                    break;
                }
                case ScribblerAction.POLYGON: {
                    Scribbler.drawPath1_(context, this.path$, this.setting$.x_fill);
                    if (this.setting$.x_fill) {
                        context.fill();
                    }
                    if (this.setting$.x_stroke) {
                        context.stroke();
                    }
                    break;
                }
                case ScribblerAction.RECTANGLE:
                    this._drawRect(context);
                    break;
                case ScribblerAction.ELLIPSE: {
                    const x0 = this.path$[0];
                    const y0 = this.path$[1];
                    const x1 = this.path$[2];
                    const y1 = this.path$[3];
                    context.beginPath();
                    context.ellipse(
                        x0 + x1,
                        y0 + y1,
                        (x1 < 0 ? -x1 : x1),
                        (y1 < 0 ? -y1 : y1),
                        0,
                        0,
                        360,
                        false);
                    if (this.setting$.x_fill) {
                        context.fill();
                    }
                    if (this.setting$.x_stroke) {
                        context.stroke();
                    }
                    break;
                }
                case ScribblerAction.TEXT: {
                    const text = this.setting$.x_data;
                    text?.split("\n").forEach((line, i) => {
                        const x = this.path$[i * 4];
                        const y = this.path$[i * 4 + 1];
                        context.fillText(line, x, y);
                    });
                    break;
                }
                case ScribblerAction.IMAGE: {
                    if (this.imageData$ != null) {
                        Scribbler.putImage_(context, this.setting$.x_stroke, this.setting$.x_fill, this.path$, this.imageData$);
                        break;
                    }
                    /* An decoded filepath, either absolute or relative to iframe document. */
                    const fliepath = this.setting$.x_data;
                    if (fliepath != null) {
                        const href = An.uriOfFilepath2_(native$.getIFrameUri_(), fliepath)?.encoded$;
                        if (href != null) {
                            const rotation = this.setting$.x_rotation;
                            Scribbler._drawImageFromUri(
                                context,
                                this,
                                this.setting$.x_stroke,
                                this.setting$.x_fill,
                                this.path$,
                                href,
                                rotation,
                                ondone);
                        }
                        return;
                    }
                    break;
                }
                case ScribblerAction.EMBEDED_IMAGE: {
                    if (this.imageData$ != null) {
                        Scribbler.putImage_(context, this.setting$.x_stroke, this.setting$.x_fill, this.path$, this.imageData$);
                        break;
                    }
                    /* A datauri. */
                    const dataurl = this.setting$.x_data;
                    if (dataurl != null) {
                        const rotation = this.setting$.x_rotation;
                        Scribbler._drawImageFromUri(
                            context,
                            this,
                            this.setting$.x_stroke,
                            this.setting$.x_fill,
                            this.path$,
                            dataurl,
                            rotation,
                            ondone);
                        return;
                    }
                    break;
                }
                default:
                    throw Assert.notReach_(this.action$);
            }
            context.restore();
            ondone?.(null);
        });
    }

    static describeRect_(path: number[] | null): string {
        if (path == null || path.length < 4) return "";
        const r = An.getRect_(path);
        return `@${r.x},${r.y} ${r.w}x${r.h}`;
    }

    describe_(): string {
        let ret = ScribblerAction.describe(this.action$);
        switch (this.action$) {
            case ScribblerAction.IMAGE:
            case ScribblerAction.TEXT: {
                let bound = ScribblerCmd.describeRect_(this.getBoundingRect_());
                if (!An.isempty_(bound)) bound = " " + bound;
                ret = An.truncate_(ret + ` \"${this.setting$.x_data}\"` + bound, DEF.historyTextLength);
                break;
            }
            case ScribblerAction.EMBEDED_IMAGE:
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON:
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.ELLIPSE: {
                let bound = ScribblerCmd.describeRect_(this.getBoundingRect_());
                if (!An.isempty_(bound)) bound = " " + bound;
                ret = An.truncate_(ret + bound, DEF.historyTextLength);
                break;
            }
            case ScribblerAction.history:
            case ScribblerAction.export:
            case ScribblerAction.BG:
                break;
            default:
                throw Assert.notReach_(this.action$);
        }
        return ret;
    }

    shift_(dx: number, dy: number): void {
        switch (this.action$) {
            case ScribblerAction.BG:
                break;
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON:
            case ScribblerAction.RECTANGLE:
                for (let i = 0, len = this.path$.length; i < len;) {
                    this.path$[i++] += dx;
                    this.path$[i++] += dy;
                }
                break;
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                this.path$[0] += dx;
                this.path$[1] += dy;
                break;
            case ScribblerAction.ELLIPSE:
                this.path$[0] += dx;
                this.path$[1] += dy;
                break;
            case ScribblerAction.TEXT:
                for (let i = 0, len = this.path$.length; i < len;) {
                    this.path$[i++] += dx;
                    this.path$[i++] += dy;
                    i += 2;
                }
                break;
            default:
                throw Assert.notReach_(this.action$);
        }
    }

    private _dec(value: number, delta: number): number {
        value -= delta;
        return value <= 0 ? 0 : value;
    }

    getBoundingRect_(): number[] | null {
        const ret = this._getboundingrect1();
        if (ret != null) {
            if (ret[2] == ret[0]) ret[2] = ret[0] + 1;
            if (ret[3] == ret[1]) ret[3] = ret[1] + 1;
        }
        return ret;
    }

    private _getboundingrect1(): number[] | null {
        switch (this.action$) {
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON: {
                const ret = this._getBoundingRect(this.path$);
                if (this.setting$ != null && this.setting$.x_lineWidth >= 2) {
                    const w = Math.round(this.setting$.x_lineWidth / 2);
                    ret[0] = this._dec(ret[0], w);
                    ret[1] = this._dec(ret[1], w);
                    ret[2] = ret[2] + w;
                    ret[3] = ret[3] + w;
                }
                return ret;
            }
            case ScribblerAction.RECTANGLE: {
                const a = this.path$;
                return [a[0], a[1], a[2], a[3]];
            }
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE: {
                const a = this.path$;
                return [a[0], a[1], a[0] + a[2], a[1] + a[3]];
            }
            case ScribblerAction.ELLIPSE: {
                const a = this.path$;
                return [a[0], a[1], a[0] + a[2] * 2, a[1] + a[3] * 2];
            }
            case ScribblerAction.TEXT: {
                const a = this.path$;
                const ret = [999999, 999999, 0, 0];
                for (let i = 0, len = a.length; i < len;) {
                    const x = a[i++];
                    const y = a[i++];
                    const w = a[i++];
                    const h = a[i++];
                    An.getBounds_(ret, x, y);
                    An.getBounds_(ret, x + w, y + h);
                }
                return ret;
            }
        }
        return null;
    }

    private _getBoundingRect(path: number[]): number[] {
        const ret = [999999, 999999, 0, 0];
        for (let i = 0, len = this.path$.length; i < len;) {
            An.getBounds_(ret, path[i++], path[i++]);
        }
        return ret;
    }

    private _drawRect(context: CanvasRenderingContext2D): void {
        const radius = this.setting$.x_cornerRadius;
        Scribbler.drawRect_(context, radius, this.path$);
        if (this.setting$.x_fill) {
            context.fill();
        }
        if (this.setting$.x_stroke) {
            context.stroke();
        }
    }

    static readonly _ACTION = "a";
    static readonly _CONTEXT = "c";
    static readonly _PATH = "p";

    toJson_(): JSONObject {
        return StringMap.from_<any>(
            [ScribblerCmd._ACTION, this.action$],
            [ScribblerCmd._CONTEXT, this.setting$.toJson(this.action$)],
            [ScribblerCmd._PATH, this.path$],
        );
    }

    static setBG_(context: CanvasRenderingContext2D, c: ColorValue): void {
        const canvas = context.canvas;
        const w = canvas.width;
        const h = canvas.height;
        context.save();
        context.resetTransform();
        context.clearRect(0, 0, w, h);
        Scribbler.setFillColor_(context, c);
        context.fillRect(0, 0, w, h);
        context.restore();
    }

    static fromJson_(json: JSONObject): ScribblerCmd {
        const action = json[ScribblerCmd._ACTION] as string;
        const context = ScribblerSetting.fromJson(json[ScribblerCmd._CONTEXT] as Map<string, any>);
        const path = json[ScribblerCmd._PATH] as Array<number>;
        return new ScribblerCmd(action, context, path);
    }
}

//////////////////////////////////////////////////////////////////////

class ScribblerHistory {
    static readonly BG = "B";
    static readonly HISTORY = "H";
    static readonly WIDTH = "w";
    static readonly HEIGHT = "h";
    _bgColor: ColorValue = ScribblerDefault.BG_COLOR;
    _width = 0;
    _height = 0;
    _bgImageCallback: CanvasCallback | null = null;
    _history: ScribblerCmd[] = [];
    _redoList: ScribblerCmd[] = [];
    _listeners: ScribblerHistoryListener[] = [];

    constructor() { }

    static fromJson_(json: JSONObject): ScribblerHistory {
        const ret = new ScribblerHistory();
        const bg = json[ScribblerHistory.BG] as string;
        const history = json[ScribblerHistory.HISTORY] as Array<Map<string, any>>;
        ret._width = json[ScribblerHistory.WIDTH] as number;
        ret._height = json[ScribblerHistory.HEIGHT] as number;
        if (bg) {
            ret._bgColor = ColorValue.parseSafe_(bg) ?? ScribblerDefault.BG_COLOR;
        }
        if (history != null) {
            for (const item of history) {
                ret._history.push(ScribblerCmd.fromJson_(item));
            }
        }
        return ret;
    }

    add_(cmd: ScribblerCmd): boolean {
        if (cmd != null) {
            this._history.push(cmd);
            this._redoList.length = 0;
            this._fire();
            return true;
        }
        return false;
    }

    insert_(index: number, cmd: ScribblerCmd): boolean {
        if (cmd != null) {
            this._history.splice(index, 0, cmd);
            this._redoList.length = 0;
            this._fire();
            return true;
        }
        return false;
    }

    addAll_(cmds: ScribblerCmd[]): boolean {
        if (cmds != null && cmds.length > 0) {
            for (const value of cmds) {
                this._history.push(value);
            };
            this._redoList.length = 0;
            this._fire();
            return true;
        }
        return false;
    }

    undo_(): boolean {
        const cmd = this._history.pop();
        if (cmd !== undefined) {
            this._redoList.push(cmd);
            this._fire();
            return true;
        }
        return false;
    }

    redo_(): ScribblerCmd | null {
        const ret = this._redoList.pop();
        if (ret !== undefined) {
            this._history.push(ret);
            this._fire();
            return ret;
        }
        return null;
    }

    undoOK_(): boolean {
        return this._history.length > 0;
    }

    redoOK_(): boolean {
        return this._redoList.length > 0;
    }

    history_(): ScribblerCmd[] {
        return this._history;
    }

    isEmpty_(): boolean {
        return this._history.length == 0;
    }

    length_(): number {
        return this._history.length;
    }

    get_(i: number): ScribblerCmd | null {
        return (i < this._history.length) ? this._history[i] : null;
    }

    remove_(i: number): ScribblerCmd | null {
        return (i < this._history.length) ? this._history.splice(i, 1)[0] : null;
    }

    down_(i: number): number {
        const len = this._history.length;
        if (len < 0 || i >= len) return i;
        const cmd = this._history.splice(i, 1);
        const newpos = (i >= len - 1) ? 0 : i + 1;
        this._history.splice(newpos, 0, cmd[0]);
        return newpos;
    }

    up_(i: number): number {
        const len = this._history.length;
        if (len < 0 || i >= len) return i;
        const cmd = this._history.splice(i, 1);
        const newpos = (i == 0 ? len - 1 : i - 1);
        this._history.splice(newpos, 0, cmd[0]);
        return newpos;
    }

    getBoundingRect_(): MutRect {
        const ret = [999999, 999999, 0, 0];
        for (const cmd of this._history) {
            const b = cmd.getBoundingRect_();
            if (b != null) {
                An.getBounds_(ret, b[0], b[1]);
                An.getBounds_(ret, b[2], b[3]);
            }
        }
        return An.getRect_(ret);
    }

    shift_(dx: number, dy: number): void {
        this._redoList.length = 0;
        for (const cmd of this._history) {
            cmd.shift_(dx, dy);
        }
    }

    addListener_(l: ScribblerHistoryListener): void {
        this._listeners.push(l);
    }

    clear_(): void {
        this._history.length = 0;
        this._redoList.length = 0;
        this._fire();
    }

    getBGColor_(): ColorValue {
        return this._bgColor;
    }

    setBGColor_(c: ColorValue | null): void {
        if (c == null) {
            c = ScribblerDefault.BG_COLOR;
        }
        this._bgColor = c;
    }

    setBGImage_(callback: CanvasCallback | null): void {
        this._bgImageCallback = callback;
    }

    getWidth_(): number {
        return this._width;
    }

    getHeight_(): number {
        return this._height;
    }

    exec_(
        context: CanvasRenderingContext2D,
        handler: IScribblerHandler,
        ondone: StringListCallback
    ): void {
        ScribblerCmd.setBG_(context, this._bgColor);
        if (this._bgImageCallback != null) {
            this._bgImageCallback(context.canvas);
        }
        let errors: string[] = [];
        An.iterateList_(this._history, (cmd: ScribblerCmd, _index: number, next: BoolCallback) => {
            this._exec(context, handler, cmd, errors, next);
        }, () => {
            ondone(errors);
        });
    }

    private _exec(
        context: CanvasRenderingContext2D,
        handler: IScribblerHandler,
        cmd: ScribblerCmd,
        errors: string[],
        next: BoolCallback): void {
        cmd.exec_(context, handler, (errs) => {
            if (errs != null) {
                for (const err of errs) {
                    errors.push(err);
                }
            }
            next(false);
        });
    }

    populate_(b: DomBuilderEx): void {
        for (let i = this._history.length - 1; i >= 0; --i) {
            const cmd = this._history[i];
            b.div_(
                [ATTR.AnInfo, `${i}`],
            ).text_(cmd.describe_())
                .up_();
        }
    }

    destroy_(): void {
        if (this._redoList != null) {
            this._history.length = 0;
            this._redoList.length = 0;
            this._listeners.length = 0;
        }
    }

    private _fire(): void {
        if (this._listeners != null) {
            for (const listener of this._listeners) {
                listener(this);
            }
        }
    }

    toJson_(w: number, h: number): JSONObject {
        return StringMap.from_<any>(
            [ScribblerHistory.BG, this._bgColor.toRgbaString_()],
            [ScribblerHistory.HISTORY, this._history.map(h => h.toJson_())],
            [ScribblerHistory.WIDTH, w],
            [ScribblerHistory.HEIGHT, h],
        );
    }
}

//////////////////////////////////////////////////////////////////////

class ScribblerGesture {
    static readonly SCROLL = "S";
    static readonly ZOOM = "Z";
    private _action: stringX = null;
    private _path: number[] = [];

    constructor(pts: number[] = []) {
        if (pts != null && pts.length == 6) {
            const a1 = ScribblerGesture._angle(pts[0], pts[1], pts[2], pts[3]);
            const a2 = ScribblerGesture._angle(pts[2], pts[3], pts[4], pts[5]);
            const a3 = ScribblerGesture._angle(pts[4], pts[5], pts[0], pts[1]);
            const a12 = ScribblerGesture._abs(a2 - a1);
            const a23 = ScribblerGesture._abs(a3 - a2);
            const a31 = ScribblerGesture._abs(a1 - a3);
            const pi = Math.PI;
            const pi8 = pi / 8;
            const pi2 = pi / 2;
            if (ScribblerGesture._abs(a12 - pi2) < pi8) {
                this._action = ScribblerAction.RECTANGLE;
                this._path = [pts[0], pts[1], pts[4], pts[5]];
            } else if (ScribblerGesture._abs(a23 - pi2) < pi8) {
                this._action = ScribblerAction.RECTANGLE;
                this._path = [pts[2], pts[3], pts[0], pts[1]];
            } else if (ScribblerGesture._abs(a31 - pi2) < pi8) {
                this._action = ScribblerAction.RECTANGLE;
                this._path = [pts[4], pts[5], pts[2], pts[3]];
            }
            
        }
    }

    get action$(): stringX {
        return this._action;
    }

    get path$(): number[] {
        return this._path;
    }

    private static _abs(v: number): number {
        return v < 0 ? -v : v;
    }

    private static _angle(x1: number, y1: number, x2: number, y2: number): number {
        return Math.atan2(x2 - x1, y2 - y1);
    }

}

//////////////////////////////////////////////////////////////////////

class ScribblerTextOverlayHandler implements IDraggerHandler {
    scrollX: number = 0;
    scrollY: number = 0;
    left: number = 0;
    top: number = 0;

    constructor(
        private _canvas: HTMLCanvasElement,
        private _textOverlay: HTMLTextAreaElement,
        private _callback: StringCallback
    ) {
    }

    onDragstart_(_dragger: Dragger, target: EventTarget, _x: number, _y: number): boolean {
        const elm = DomUt.asHTMLElement_(target);
        const yes = elm != null &&
            "DIV" == elm.nodeName &&
            elm.classList.contains(CSS.AnSmokescreen);
        if (yes) {
            this.scrollX = this._canvas.parentElement!.scrollLeft;
            this.scrollY = this._canvas.parentElement!.scrollTop;
        }
        return yes;
    }

    onDragmove_(dragger: Dragger): void {
        const state = dragger.state_();
        const ox = this._canvas.parentElement!.scrollLeft;
        const oy = this._canvas.parentElement!.scrollTop;
        this._canvas.parentElement!.scrollLeft = this.scrollX - state.cx;
        this._canvas.parentElement!.scrollTop = this.scrollY - state.cy;
        const ddx = this._canvas.parentElement!.scrollLeft - ox;
        const ddy = this._canvas.parentElement!.scrollTop - oy;
        if (this._textOverlay != null) {
            const style = this._textOverlay.style;
            const left = An.parseIntPx_(style.left, 0);
            const top = An.parseIntPx_(style.top, 0);
            style.left = `${left - ddx}px`;
            style.top = `${top - ddy}px`;
        }
    }

    onDragend_(dragger: Dragger, e: Event): void {
        if (!dragger
            .state_()
            .moved) {
            An.stopevent_(e);
            if (this._textOverlay != null) {
                const text = this._textOverlay.value;
                this._callback(text);
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////

abstract class ScribblerState {
    static readonly IDLE = 0;
    static readonly MOVE = 1;
    static readonly TEXT = 2;
}

class _EditState {
    constructor(
        public _action: string,
        public _cmd: ScribblerCmd | null,
        public _bounds: MutRect,
        public _doneCallback: Fun00 | null = null
    ) { }
}

type ScribblerSelectionCallback = (cmd: string, rect: MutRect) => void;

class Scribbler implements IDraggerHandler {
    static readonly _DELAY = 500;
    _canvasOffset: Point<number>;
    _context: CanvasRenderingContext2D;
    _overlay: HTMLCanvasElement;
    _overlayContext: CanvasRenderingContext2D;
    _dragger: Dragger;
    _action!: string;
    _setting!: ScribblerSetting;
    _textSetting: ScribblerSetting;

    _rect: MutRect = new MutRect(0, 0, 0, 0);
    _scrollX: number = 0;
    _scrollY: number = 0;

    _textOverlaySmokescreen: Smokescreen | null = null;
    _textOverlayDragger: Dragger | null = null;
    _stateChangeListener: IntCallback | null = null;
    _onExportCallback: ScribblerSelectionCallback | null = null;
    _gesture2: string = ScribblerGesture.SCROLL;
    _timer: Timer | null = null;
    _overlayQueue: IRateLimiter = new FrameLimiter(1);
    _path: number[] = [0, 0, 0, 0];
    _savedPath: number[] = [0, 0, 0, 0];
    /* The locations at touchstart. */
    _path0: number[] = [];
    _history: ScribblerHistory = new ScribblerHistory();
    _overlayShown: boolean = false;
    _editState: _EditState | null = null;
    _gesture: stringX = null;
    _positioning: boolean = false;
    _textOverlay: HTMLTextAreaElement | null = null;
    #destroyed = false;

    _settings = smap_(
        [ScribblerAction.CURVE, new ScribblerSetting({ x_texting: true, x_fill: true, x_stroke: true, x_grid: ScribblerDefault.GRID_S })],
        [ScribblerAction.POLYCURVE, new ScribblerSetting({ x_texting: false, x_fill: false, x_stroke: true, x_grid: ScribblerDefault.GRID_S })],
        [ScribblerAction.POLYGON, new ScribblerSetting({ x_texting: false, x_fill: false, x_stroke: true, x_grid: ScribblerDefault.GRID_S })],
        [ScribblerAction.IMAGE, new ScribblerSetting({ x_texting: false, x_fill: false, x_stroke: true, x_grid: ScribblerDefault.GRID_L })],
        [ScribblerAction.EMBEDED_IMAGE, new ScribblerSetting({ x_texting: false, x_fill: false, x_stroke: true, x_grid: ScribblerDefault.GRID_L })],
        [ScribblerAction.RECTANGLE, new ScribblerSetting({ x_texting: true, x_fill: true, x_stroke: true, x_grid: ScribblerDefault.GRID_L })],
        [ScribblerAction.ELLIPSE, new ScribblerSetting({ x_texting: true, x_fill: true, x_stroke: true, x_grid: ScribblerDefault.GRID_L })],
        [ScribblerAction.TEXT, new ScribblerSetting({
            x_texting: true,
            x_fill: false,
            x_stroke: false,
            x_grid: ScribblerDefault.GRID_L,
            x_textAlign: MSG.string_(RS.Left)
        })],
        [ScribblerAction.more, new ScribblerSetting({ x_texting: false, x_fill: true, x_stroke: false, x_grid: ScribblerDefault.GRID_S })],
        [ScribblerAction.export, new ScribblerSetting({ x_texting: false, x_fill: true, x_stroke: false, x_grid: ScribblerDefault.GRID_X })],
    );

    constructor(
        private _canvas: HTMLCanvasElement,
        private _origin: Point<number>,
        private _handler: IScribblerHandler
    ) {
        this._canvasOffset = An.documentOffset_(this._canvas);
        this._context = _canvas.getContext("2d")!;
        this._context.lineCap = ScribblerDefault.LINE_CAP;
        this._context.lineJoin = ScribblerDefault.LINE_JOIN;
        const settings = _handler.getSettings_();
        const fontfamily = FontUtil.fontFamilyOf_(settings.current_().uiFontName$, settings.current_().uiFontStyle$);
        const fontsize = settings.current_().uiFontSize$ * 2;
        this._settings[ScribblerAction.history] = this._settings[ScribblerAction.more];
        this._settings[ScribblerAction.shift] = this._settings[ScribblerAction.more];
        this._textSetting = this._settings[ScribblerAction.TEXT];
        this._textSetting.x_fontFamily = fontfamily;
        this._textSetting.x_fontSize = fontsize;
        const width = _canvas.width;
        const height = _canvas.height;
        this._overlay = _canvas.ownerDocument.createElement("canvas");
        this._overlay.width = width;
        this._overlay.height = height;
        this._overlay.classList.add(CSS.AnOverlayCanvas);
        _canvas.parentElement!.append(this._overlay);
        this._overlayContext = this._overlay.getContext("2d")!;
        this._overlayContext.lineCap = ScribblerDefault.LINE_CAP;
        this._overlayContext.lineJoin = ScribblerDefault.LINE_JOIN;
        An.showHidden_(this._overlay);
        this._relocateOverlay();
        An.hideVisible_(this._overlay);
        this._overlayShown = false;
        this.setAction_(ScribblerDefault.ACTION);
        this._dragger = new Dragger(this._overlay, this, new NoLimiter()).bind_();
    }

    private _relocateOverlay() {
        const style = this._overlay.style;
        style.backgroundColor = "rgba(255,255,255,0)";
        style.zIndex = `${DEF.zindexImageAnnotator + 10}`;
        style.position = "relative";
        style.float = "left";
        style.clear = "both";
        style.top = `${this._origin.y}px`;
        style.left = `${this._origin.x}px`;
        
    }

    setStateChangeListener_(callback: IntCallback): void {
        this._stateChangeListener = callback;
    }

    onExport_(callback: ScribblerSelectionCallback): void {
        this._onExportCallback = callback;
    }

    onDragstart_(dragger: Dragger, target: EventTarget, x: number, y: number): boolean {
        if (dragger.element_() !== target) {
            return false;
        }
        this._rect = new MutRect(
            Math.round(this._canvasOffset.x),
            Math.round(this._canvasOffset.y),
            this._canvas.width,
            this._canvas.height);
        this._path = this._canvasloc1([], x, y);
        this._gesture = null;
        const state = dragger.state_();
        if (state.touches == 2) {
            this._path0 = An.intArrayCopy_([], state.pointers);
        }
        
        return true;
    }

    onDragmove_(dragger: Dragger): void {
        const state = dragger.state_();
        const cx = Math.max(0, Math.min(this._rect.w, this._snap(state.pageX - this._rect.x + this._scrollX)));
        const cy = Math.max(0, Math.min(this._rect.h, this._snap(state.pageY - this._rect.y + this._scrollY)));

        ///#NOTE: Three finger gesture do not work well, it often result in 2 finger gesture instead.
        if (state.touches == 3) {
            this._gesture = ScribblerGesture.SCROLL;
        } else if (state.touches == 2) {
            this._gesture = this._gesture2;
        } else {
            this._gesture = null;
        }
        if (this._gesture == ScribblerGesture.SCROLL) {
            this._scroll(cx, cy);
            return;
        }
        if (this._positioning) {
            switch (this._action) {
                case ScribblerAction.CURVE: {
                    const snap = this._edit(state, cx, cy);
                    this._drawShapeOverlay(snap);
                    break;
                }
                case ScribblerAction.RECTANGLE:
                case ScribblerAction.TEXT:
                case ScribblerAction.IMAGE:
                case ScribblerAction.EMBEDED_IMAGE: {
                    const snap = this._edit(state, cx, cy);
                    this._drawRectOverlay(snap);
                    break;
                }
                case ScribblerAction.ELLIPSE: {
                    const snap = this._edit(state, cx, cy);
                    this._drawEllipseOverlay(snap);
                    break;
                }
                case ScribblerAction.history:
                case ScribblerAction.export: {
                    const snap = this._edit(state, cx, cy);
                    this._drawHighlightOverlay(snap);
                    break;
                }
                case ScribblerAction.shift: {
                    this._translate(cx, cy);
                    const snap = this._snapTopLeft(this._savedPath);
                    this._drawHighlightOverlay(snap);
                    break;
                }
            }
            return;
        }
        switch (this._action) {
            case ScribblerAction.CURVE:
                if (this._gesture == ScribblerGesture.ZOOM) {
                    const p = this._canvaslocs([], state.pointers);
                    this._drawShapeOverlay(p);
                } else if (this._setting.x_cornering == 0) {
                    this._path.push(cx);
                    this._path.push(cy);
                    this._redrawOverlayPath();
                } else {
                    this._path.push(cx);
                    this._path.push(cy);
                    this._redrawOverlayCurve(true);
                }
                break;
            case ScribblerAction.POLYCURVE:
                this._redrawOverlayCurve(false, cx, cy);
                if (this._timer != null) {
                    this._timer.cancel_();
                }
                this._timer = new Timer(Scribbler._DELAY, () => {
                    this._path.push(cx);
                    this._path.push(cy);
                    this._redrawOverlayCurve(false);
                });
                break;
            case ScribblerAction.POLYGON:
                this._redrawOverlayPath(cx, cy);
                if (this._timer != null) {
                    this._timer.cancel_();
                }
                this._timer = new Timer(Scribbler._DELAY, () => {
                    this._path.push(cx);
                    this._path.push(cy);
                    this._redrawOverlayPath();
                });
                break;
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.TEXT:
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                if (this._gesture == ScribblerGesture.ZOOM) {
                    const p = this._canvaslocs([], state.pointers);
                    this._drawRectOverlay(p);
                } else {
                    this._drawRectOverlay([this._path[0], this._path[1], cx, cy]);
                }
                break;
            case ScribblerAction.ELLIPSE:
                if (this._gesture == ScribblerGesture.ZOOM) {
                    const p = this._canvaslocs([], state.pointers);
                    this._drawEllipseOverlay(p);
                } else {
                    this._drawEllipseOverlay([this._path[0], this._path[1], cx, cy]);
                }
                break;
            case ScribblerAction.history:
            case ScribblerAction.more:
            case ScribblerAction.shift:
                this._scroll(cx, cy);
                break;
            case ScribblerAction.export:
                if (this._gesture == ScribblerGesture.ZOOM) {
                    const p = this._canvaslocs([], state.pointers);
                    this._drawHighlightOverlay(p);
                } else {
                    this._drawHighlightOverlay([this._path[0], this._path[1], cx, cy]);
                }
                break;
        }
    }

    highlight_(index: number): void {
        const cmd = this._history.get_(index);
        if (cmd == null) return;
        const len = this._history
            .history_()
            .length;
        this._drawHighlightOverlay(cmd.getBoundingRect_(), `${index + 1}/${len}`);
    }

    move_(index: number): void {
        const cmd = this._history.get_(index);
        if (cmd == null) return;
        switch (cmd.action$) {
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON:
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.ELLIPSE:
            case ScribblerAction.TEXT:
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                break;
            default:
                return;
        }
        this._move(cmd);
    }

    private _move(cmd: ScribblerCmd): void {
        const bounds = cmd.getBoundingRect_();
        if (bounds == null) {
            this._handler.warn_(MSG.string_(RS.ContentNotMovable));
            return;
        }
        const rect = An.getRect_(bounds);
        this._editState = new _EditState(this._action, cmd, rect, null);
        this._setaction1(ScribblerAction.history);
        this._path = bounds;
        this._startPositioning();
    }

    cloneObject_(index: number): void {
        const cmd = this._history.get_(index);
        if (cmd == null) return;
        switch (cmd.action$) {
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON:
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.ELLIPSE:
            case ScribblerAction.TEXT:
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                break;
            default:
                return;
        }
        const clone = cmd.clone_();
        if (this._history.insert_(index + 1, clone)) {
            this._move(clone);
        }
    }

    down_(index: number): number {
        const newpos = this._history.down_(index);
        this.refresh_();
        return newpos;
    }

    up_(index: number): number {
        const newpos = this._history.up_(index);
        this.refresh_();
        return newpos;
    }

    shift_(callback: Fun00): void {
        const rect = this._history.getBoundingRect_();
        if (rect == null) {
            this._handler.warn_(MSG.string_(RS.ContentNotMovable));
            return;
        }
        this._editState = new _EditState(this._action, null, rect, callback);
        this._setaction1(ScribblerAction.shift);
        this._path = [rect.x, rect.y, rect.x + rect.w, rect.y + rect.h];
        this._startPositioning();
        const snap = this._snapTopLeft(this._savedPath);
        this._drawHighlightOverlay(snap);
    }

    resize_(): void {
        this._overlay.width = this._canvas.width;
        this._overlay.height = this._canvas.height;
    }

    private _edit(state: DraggerState, cx: number, cy: number): number[] {
        let scalable = this._gesture == ScribblerGesture.ZOOM;
        if (scalable && this._editState != null) {
            switch (this._editState._cmd?.action$) {
                case ScribblerAction.CURVE:
                case ScribblerAction.POLYCURVE:
                case ScribblerAction.POLYGON:
                case ScribblerAction.RECTANGLE:
                case ScribblerAction.ELLIPSE:
                    break;
                default:
                    scalable = false;
            }
        }
        if (scalable) {
            this._scale(state);
        } else {
            this._translate(cx, cy);
        }
        return this._snapTopLeft(this._savedPath);
    }

    private _scale(state: DraggerState): void {
        
        const dx0 = this._path0[2] - this._path0[0];
        const dy0 = this._path0[3] - this._path0[1];
        const a = An.intArrayCopy_([], state.pointers);
        
        const dx1 = a[2] - a[0];
        const dy1 = a[3] - a[1];
        if (dx1 != dx0 || dy1 != dy0) {
            const ddx = dx1 - dx0;
            const ddy = dy1 - dy0;
            if (ddy > Dragger.THRESHOLD || ddy < -Dragger.THRESHOLD
                || ddx > Dragger.THRESHOLD || ddx < -Dragger.THRESHOLD) {
                this._path0 = a;
                this._savedPath[2] += this._threshold(ddx, Dragger.THRESHOLD);
                this._savedPath[3] += this._threshold(ddy, Dragger.THRESHOLD);
                this._floor(this._savedPath, 2, 0);
                this._floor(this._savedPath, 3, 1);
            }
        }
    }

    private _translate(cx: number, cy: number): void {
        let dx = cx - this._path[0];
        let dy = cy - this._path[1];
        this._path[0] = cx;
        this._path[1] = cy;
        dx = this._threshold(dx, 3);
        dy = this._threshold(dy, 3);
        this._savedPath[0] += dx;
        this._savedPath[1] += dy;
        this._savedPath[2] += dx;
        this._savedPath[3] += dy;
    }

    private _floor(a: number[], i2: number, i1: number): void {
        if (a[i2] < a[i1]) {
            a[i2] = a[i1];
        }
    }

    private _scroll(cx: number, cy: number): void {
        const dx = this._path[0] - cx;
        const dy = this._path[1] - cy;
        this._canvas.parentElement!.scrollLeft += dx;
        this._canvas.parentElement!.scrollTop += dy;
        this._path[0] = cx;
        this._path[1] = cy;
    }

    private _threshold(dx: number, delta: number): number {
        return dx > 0 ? Math.max(0, dx - delta) : (dx < 0 ? Math.min(0, dx + delta) : 0);
    }

    onDragend_(dragger: Dragger, _e: UIEvent): void {
        if (this._timer != null) {
            this._timer.cancel_();
        }
        const state = dragger.state_();
        if (this._gesture == ScribblerGesture.SCROLL) {
            return;
        }
        const cx = Math.max(0, Math.min(this._rect.w, this._snap(state.pageX - this._rect.x + this._scrollX)));
        const cy = Math.max(0, Math.min(this._rect.h, this._snap(state.pageY - this._rect.y + this._scrollY)));
        if (!this._positioning) {
            switch (this._action) {
                case ScribblerAction.CURVE:
                    if (this._gesture == ScribblerGesture.ZOOM) {
                        this._path = this._canvaslocs([], state.pointers);
                        this._startPositioning();
                        return;
                    }
                    break;
                case ScribblerAction.RECTANGLE:
                case ScribblerAction.IMAGE:
                case ScribblerAction.EMBEDED_IMAGE:
                    this._updatepath(state, cx, cy);
                    const r = An.getRect_(this._path);
                    if (r.w == 0 || r.h == 0) {
                        this._endPositioning();
                    } else {
                        this._startPositioning();
                    }
                    return;
                case ScribblerAction.ELLIPSE:
                    this._updatepath(state, cx, cy);
                    this._startPositioning();
                    return;
                case ScribblerAction.TEXT:
                    this._updatepath(state, cx, cy);
                    this._startPositioning();
                    return;
                case ScribblerAction.export:
                    if (state.moved) {
                        this._updatepath(state, cx, cy);
                        this._startPositioning();
                        return;
                    } else {
                        this._updatepath(state, cx, cy);
                        this._savedPath = this._path;
                        this._normalize(this._savedPath);
                        this._path = [];
                    }
                    break;
            }
        } else if (this._positioning && state.moved) {
            return;
        } else if (this._positioning) {
            this._path = this._snapTopLeft(this._savedPath);
        }
        switch (this._action) {
            case ScribblerAction.history:
                this._updatepath(state, cx, cy);
                if (this._editState == null || this._editState._cmd == null) break;
                const cmd = this._editState._cmd;
                switch (cmd.action$) {
                    case ScribblerAction.CURVE:
                    case ScribblerAction.POLYCURVE:
                    case ScribblerAction.POLYGON: {
                        const bounds = this._editState._bounds;
                        const newbounds = An.getRect_(this._path);
                        const sx = bounds.w == 0 ? 1.0 : newbounds.w / bounds.w;
                        const sy = bounds.h == 0 ? 1.0 : newbounds.h / bounds.h;
                        const a = cmd.path$;
                        for (let i = 0, len = a.length; i < len;) {
                            const ox = a[i] - bounds.x;
                            const oy = a[i + 1] - bounds.y;
                            a[i++] = Math.round(newbounds.x + ox * sx);
                            a[i++] = Math.round(newbounds.y + oy * sy);
                        }
                        break;
                    }
                    case ScribblerAction.RECTANGLE: {
                        cmd.path$ = this._path;
                        break;
                    }
                    case ScribblerAction.ELLIPSE: {
                        const x0 = this._path[0];
                        const y0 = this._path[1];
                        const x1 = this._path[2];
                        const y1 = this._path[3];
                        const rx = (x1 - x0) / 2;
                        const ry = (y1 - y0) / 2;
                        cmd.path$ = [x0, y0, rx, ry];
                        break;
                    }
                    case ScribblerAction.TEXT: {
                        const bounds = this._editState._bounds;
                        const newbounds = An.getRect_(this._path);
                        const a = cmd.path$;
                        for (let i = 0, len = a.length; i < len; i += 2) {
                            const ox = a[i] - bounds.x;
                            const oy = a[i + 1] - bounds.y;
                            a[i++] = newbounds.x + ox;
                            a[i++] = newbounds.y + oy;
                        }
                        break;
                    }
                    case ScribblerAction.IMAGE:
                    case ScribblerAction.EMBEDED_IMAGE: {
                        const r = An.getRect_(this._path);
                        let w;
                        let h;
                        w = cmd.path$[2];
                        h = cmd.path$[3];
                        cmd.path$ = [r.x, r.y, w, h];
                        break;
                    }
                }
                this._endEdit();
                break;
            case ScribblerAction.shift:
                this._updatepath(state, cx, cy);
                if (this._editState != null) {
                    const bounds = this._editState._bounds;
                    const newbounds = An.getRect_(this._path);
                    const dx = newbounds.x - bounds.x;
                    const dy = newbounds.y - bounds.y;
                    this._history.shift_(dx, dy);
                }
                this._endEdit();
                break;
            case ScribblerAction.export:
                this._path = An.intArrayCopy_([], this._savedPath);
                if (this._onExportCallback != null) {
                    let rect = An.getRect_(this._path);
                    if (rect.w == 0 || rect.h == 0) {
                        this._handler.warn_(MSG.string_(RS.ExportingWholeCanvas));
                        rect = new MutRect(0, 0, this._canvas.width, this._canvas.height);
                    }
                    this._onExportCallback(ScribblerAction.export, rect);
                }
                this._endPositioning();
                break;
            case ScribblerAction.CURVE:
                if (this._positioning) {
                    this._actionShape(this._path);
                } else {
                    this._path = Scribbler.drawCurve_(this._context, this._setting.x_cornering, this._path, true);
                    this._context.stroke();
                    this.clearOverlay_();
                    if (this._path.length > 2) {
                        this._history.add_(new ScribblerCmd(this._action, this._cloneSetting(), this._path));
                    }
                }
                break;
            case ScribblerAction.POLYCURVE:
                Scribbler.drawCurve_(this._context, this._setting.x_cornering, this._path, false);
                if (this._setting.x_fill) {
                    this._context.closePath();
                    this._context.fill();
                }
                if (this._setting.x_stroke) {
                    this._context.stroke();
                }
                this.clearOverlay_();
                if (this._path.length > 2) {
                    this._history.add_(new ScribblerCmd(this._action, this._cloneSetting(), this._path));
                }
                break;
            case ScribblerAction.POLYGON:
                if (Scribbler.drawPath1_(this._context, this._path, this._setting.x_fill) > 0) {
                    this.clearOverlay_();
                    if (this._setting.x_fill) {
                        this._context.fill();
                    }
                    if (this._setting.x_stroke) {
                        this._context.stroke();
                    }
                }
                if (this._path.length > 2) {
                    this._history.add_(new ScribblerCmd(this._action, this._cloneSetting(), this._path));
                }
                break;
            case ScribblerAction.RECTANGLE:
                this._updatepath(state, cx, cy);
                this._actionRect(this._path);
                break;
            case ScribblerAction.ELLIPSE:
                this._updatepath(state, cx, cy);
                this._actionEllipse(this._path);
                break;
            case ScribblerAction.TEXT:
                this._updatepath(state, cx, cy);
                this._actionText(this._path);
                break;
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                this._updatepath(state, cx, cy);
                const r = An.getRect_(this._path);
                this._endPositioning();
                if (r.w == 0 || r.h == 0) {
                    break;
                }
                this._handler.promptImportImage_(r.w, r.h, DEF.zindexImageAnnotator + 100,
                    (cpath: string, uri: Uri, width: string, height: string, rotation: number) => {
                        const elm = this._canvas.ownerDocument.createElement("img");
                        elm.addEventListener("load", (_e) => {
                            let iwidth = elm.naturalWidth;
                            let iheight = elm.naturalHeight;
                            let w = An.parseInt_(width, -1);
                            let h = An.parseInt_(height, -1);
                            if (rotation != 0 && rotation != 180) {
                                const t = iwidth;
                                iwidth = iheight;
                                iheight = t;
                            }
                            if (w >= 0 && h < 0) {
                                h = Math.round(w * iheight / iwidth);
                            } else if (w < 0 && h >= 0) {
                                w = Math.round(h * iwidth / iheight);
                            } else if (w < 0 && h < 0) {
                                const p = MediaUtil.fit_(iwidth, iheight, r.w, r.h);
                                w = p.x;
                                h = p.y;
                            }
                            if (w > 0 && h > 0) {
                                const action = this._action;
                                const clone = this._cloneSetting();
                                const path = [r.x, r.y, w, h];
                                Scribbler._drawImage(this._context, clone.x_stroke, clone.x_fill, path, rotation, elm);
                                const data = this._context.getImageData(r.x, r.y, w, h);
                                if (action == ScribblerAction.IMAGE) {
                                    clone.x_data = uri.encoded$;
                                } else {
                                    const c = this._canvas.ownerDocument.createElement("canvas");
                                    c.width = w;
                                    c.height = h;
                                    const ctx = c.getContext("2d");
                                    if (ctx != null) {
                                        ctx.putImageData(data, 0, 0);
                                    }
                                    clone.x_data = c.toDataURL("image/jpeg");
                                }
                                this._history.add_(new ScribblerCmd(action, clone, path, data));
                            }
                        });
                        elm.addEventListener("error", (_e) => {
                            this._handler.warn_([MSG.string_(RS.ErrorLoading), cpath]);
                        });
                        elm.src = uri.toAbsolute_().toString();
                    });
                break;
        }
        this._gesture2 = ScribblerGesture.SCROLL;
        this._positioning = false;
    }

    private _endEdit(): void {
        if (this._editState != null) {
            let callback: Fun00 | null = this._editState._doneCallback ?? null;
            this.setAction_(this._editState._action);
            this._editState = null;
            this._gesture2 = ScribblerGesture.SCROLL;
            this.refresh_();
            this._changeState(ScribblerState.IDLE);
            callback?.();
        }
    }

    private _endPositioning(): void {
        this.clearOverlay_();
        this._editState = null;
        this._gesture2 = ScribblerGesture.SCROLL;
        this._changeState(ScribblerState.IDLE);
    }

    private _startPositioning(): void {
        this._savedPath = this._path;
        this._normalize(this._savedPath);
        this._path = [];
        this._positioning = true;
        this._changeState(ScribblerState.MOVE);
        this._handler.info_(MSG.string_(RS.DragPinchClick), { attop: false });
        this._gesture2 = ScribblerGesture.ZOOM;
    }

    private _normalize(a: number[]): void {
        if (a[2] < a[0]) {
            this._swap(a, 0, 2);
        }
        if (a[3] < a[1]) {
            this._swap(a, 1, 3);
        }
    }

    private _swap(a: number[], i0: number, i1: number): void {
        const t = a[i1];
        a[i1] = a[i0];
        a[i0] = t;
    }

    private _updatepath(state: DraggerState, cx: number, cy: number): void {
        if (this._gesture == ScribblerGesture.ZOOM) {
            this._path = this._canvaslocs([], state.pointers);
        } else {
            this._path.push(cx);
            this._path.push(cy);
        }
    }

    private _actionShape(path: number[]): void {
        switch (this._setting.x_shape) {
            case ScribblerAction.ELLIPSE:
                this._actionEllipse(path);
                break;
            case ScribblerAction.RECTANGLE:
                this._actionRect(path);
                break;
            case ScribblerAction.TEXT:
                this._actionText(path);
                break;
            default:
                throw Assert.notReach_(this._setting.x_shape);
        }
    }

    private _actionRect(path: number[]): void {
        Scribbler.drawRect_(this._context, this._setting.x_cornerRadius, path);
        this.clearOverlay_();
        if (this._setting.x_fill) {
            this._context.fill();
        }
        if (this._setting.x_stroke) {
            this._context.stroke();
        }
        if (path[0] != path[2] || path[1] != path[3]) {
            this._history.add_(new ScribblerCmd(this._action, this._cloneSetting(), path));
            if (this._setting.x_texting) {
                this._showCenterTextOverlay(path);
                return;
            }
        }
        this._changeState(ScribblerState.IDLE);
    }

    private _changeState(state: number): void {
        switch (state) {
            case ScribblerState.IDLE:
                this._overlay.style.cursor = "default";
                if (this._stateChangeListener != null) {
                    this._stateChangeListener(ScribblerState.IDLE);
                }
                break;
            case ScribblerState.MOVE:
                this._overlay.style.cursor = "move";
                if (this._stateChangeListener != null) {
                    this._stateChangeListener(ScribblerState.MOVE);
                }
                break;
            case ScribblerState.TEXT:
                if (this._stateChangeListener != null) {
                    this._stateChangeListener(ScribblerState.TEXT);
                }
                break;
            default:
        }
    }

    private _actionEllipse(path: number[]): void {
        const x0 = path[0];
        const y0 = path[1];
        const x1 = path[2];
        const y1 = path[3];
        const rx = (x1 - x0) / 2;
        const ry = (y1 - y0) / 2;
        this._context.beginPath();
        this._context.ellipse(
            x0 + rx,
            y0 + ry,
            (rx < 0 ? -rx : rx),
            (ry < 0 ? -ry : ry),
            0,
            0,
            360,
            false);
        this.clearOverlay_();
        if (this._setting.x_fill) {
            this._context.fill();
        }
        if (this._setting.x_stroke) {
            this._context.stroke();
        }
        if (rx != 0 || ry != 0) {
            this._history.add_(new ScribblerCmd(ScribblerAction.ELLIPSE, this._cloneSetting(), [x0, y0, rx, ry]));
            if (this._setting.x_texting) {
                this._showCenterTextOverlay(path);
                return;
            }
        }
        this._changeState(ScribblerState.IDLE);
    }

    private _actionText(path: number[]): void {
        const x0 = path[0];
        const y0 = path[1];
        const x1 = path[2];
        const y1 = path[3];
        this.clearOverlay_();
        this._hideOverlay();
        this._showTextOverlay(x0, y0, x1 - x0, y1 - y0);
        this._changeState(ScribblerState.TEXT);
    }

    destroy_(): void {
        if (!this.#destroyed) {
            this._dragger.destroy_();
            this._overlayQueue.cancel_();
            this._overlay.remove();
            this._hideTextOverlay();
            this._timer = null;
            this._history.destroy_();
            this.#destroyed = true;
        }
    }

    history_(): ScribblerHistory {
        return this._history;
    }

    addHistory_(cmds: ScribblerCmd[]): boolean {
        if (cmds != null) {
            return this._history.addAll_(cmds);
        }
        return false;
    }

    addHistoryListener_(l: ScribblerHistoryListener): void {
        this._history.addListener_(l);
    }

    setAction_(action: string): boolean {
        if (action == this._action) {
            return false;
        }
        return this._setaction1(action);
    }

    private _setaction1(action: string): boolean {
        this._action = action;
        this._setting = this._settings[this._action];
        this.setStrokeColor_(this._setting.x_strokeColor);
        this.setFillColor_(this._setting.x_fillColor);
        this.setLineWidth_(this._setting.x_lineWidth);
        this.setLineStyle_(this._setting.x_lineStyle);
        this.setFont_(this._textSetting.x_fontFamily, this._textSetting.x_fontSize);
        this.setTextColor_(this._textSetting.x_textColor);
        this._path = [];
        if (this._action != ScribblerAction.TEXT && this._textOverlay != null) {
            this._hideOverlay();
            this._hideTextOverlay();
        }
        this._showOverlay();
        return true;
    }

    undo_(): void {
        if (this._history.undo_()) {
            this._path = [];
            this.refresh_();
        }
    }

    redo_(): void {
        const cmd = this._history.redo_();
        if (cmd != null) {
            cmd.exec_(this._context, this._handler, null);
        }
    }

    getAction_(): string {
        return this._action;
    }

    getScribblerSetting_(): ScribblerSetting {
        return this._setting;
    }

    getTextSetting_(): ScribblerSetting {
        return this._textSetting;
    }

    setLineStyle_(style: string): void {
        this._setting.x_lineStyle = style;
        Scribbler._setLineStyle_(this._context, style);
        Scribbler._setLineStyle_(this._overlayContext, style);
    }

    setCornering_(cornering: number): void {
        this._setting.x_cornering = cornering;
    }

    setCornerRadius_(radius: number): void {
        this._setting.x_cornerRadius = radius;
    }

    setFont_(family: string, size: number, callback: Fun00 | null = null): void {
        this._textSetting.x_fontFamily = family;
        this._textSetting.x_fontSize = size;
        const font = `${size}px ${family}`;
        Scribbler.setFont_(this._context, this._handler, font, callback);
    }

    setTextAlign_(align: string): void {
        this._setting.x_textAlign = align;
    }

    setLineWidth_(width: number): void {
        this._setting.x_lineWidth = width;
        this._context.lineWidth = width;
        this.setLineStyle_(this._setting.x_lineStyle);
        if (this._overlay != null) {
            this._overlayContext.lineWidth = width;
            this.setLineStyle_(this._setting.x_lineStyle);
        }
    }

    setStrokeColor_(color: ColorValue): void {
        if (color != null) {
            this._setting.x_strokeColor = color;
            Scribbler.setStrokeColor_(this._context, color);
            if (this._overlay != null) {
                Scribbler.setStrokeColor_(this._overlayContext, color);
            }
        }
    }

    setFillColor_(color: ColorValue): void {
        if (color != null) {
            this._setting.x_fillColor = color;
            Scribbler.setFillColor_(this._context, color);
            if (this._overlay != null) {
                Scribbler.setFillColor_(this._overlayContext, color);
            }
        }
    }

    setTextColor_(color: ColorValue): void {
        if (color != null) {
            this._textSetting.x_textColor = color;
        }
    }

    enableStroke_(enable: boolean): void {
        this._setting.x_stroke = enable;
    }

    enableFill_(enable: boolean): void {
        this._setting.x_fill = enable;
    }

    enableText_(enable: boolean): void {
        this._setting.x_texting = enable;
    }

    getGrid_(): number {
        return this._setting.x_grid;
    }

    setGrid_(grid: number): void {
        this._setting.x_grid = grid;
    }

    setLineHeight_(value: number): void {
        this._setting.x_lineHeight = value;
    }

    getBGColor_(): ColorValue {
        return this._history.getBGColor_();
    }

    setBGColor_(c: ColorValue | null): void {
        this._history.setBGColor_(c);
    }

    setBGImage_(callback: CanvasCallback | null): void {
        this._history.setBGImage_(callback);
    }

    clear_(): void {
        this._history.clear_();
        this.refresh_();
    }

    onresize_(origin: Point<number>): void {
        this._origin = origin;
        if (!this._overlayShown) {
            An.showVisible_(this._overlay);
            this._relocateOverlay();
            An.hideVisible_(this._overlay);
        } else {
            this._relocateOverlay();
        }
        this.refresh_();
    }

    refresh_(): void {
        this.clearOverlay_();
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
        const baseuri = native$.getIFrameUri_();
        this._history.exec_(this._context, this._handler, (errs: string[]) => {
            if (errs != null && errs.length > 0) {
                const errors = [MSG.string_(RS.ErrorLoading)];
                for (const err of errs) {
                    if (err.startsWith("#")) {
                        errors.push(err);
                        continue;
                    }
                    const cpath = An.cpathOfHref2_(baseuri, err);
                    if (cpath != null) {
                        errors.push("# " + MSG.string_(RS.ErrorLoading) + ": " + cpath);
                        continue;
                    }
                    errors.push(MSG.string_(RS.Scribbler_MissingImageURI));
                }
                this._handler.warn_(errors);
            }
        });
    }

    private _canvasloc1(ret: number[], x: number, y: number): number[] {
        const parent = this._canvas.parentElement!;
        this._scrollX = parent.scrollLeft;
        this._scrollY = parent.scrollTop;
        const cx = Math.max(0, Math.min(this._rect.w, this._snap(x - this._rect.x + this._scrollX)));
        const cy = Math.max(0, Math.min(this._rect.h, this._snap(y - this._rect.y + this._scrollY)));
        ret.push(cx);
        ret.push(cy);
        return ret;
    }

    private _canvaslocs(ret: number[], p: number[]): number[] {
        const parent = this._canvas.parentElement!;
        this._scrollX = parent.scrollLeft;
        this._scrollY = parent.scrollTop;
        for (let i = 0; i < p.length; i += 2) {
            const cx = Math.max(0, Math.min(this._rect.w, this._snap(p[i] - this._rect.x + this._scrollX)));
            const cy = Math.max(0, Math.min(this._rect.h, this._snap(p[i + 1] - this._rect.y + this._scrollY)));
            ret.push(cx);
            ret.push(cy);
        }
        return ret;
    }

    private _snap(x: number): number {
        const g = this._setting.x_grid;
        return (g > 1) ? Math.round(x / g) * g : x;
    }

    private _snapTopLeft(path: number[]): number[] {
        const left = this._snap(path[0]);
        const top = this._snap(path[1]);
        const right = left + path[2] - path[0];
        const bottom = top + path[3] - path[1];
        return [left, top, right, bottom];
    }

    clearOverlay_(): void {
        if (this._overlayQueue != null) {
            this._overlayQueue.queue_((_elapsed, _immediate) => {
                this._overlayContext.clearRect(0, 0, this._canvas.width, this._canvas.height);
            });
        }
    }

    private _showOverlay(): void {
        switch (this._action) {
            case ScribblerAction.CURVE:
            case ScribblerAction.POLYCURVE:
            case ScribblerAction.POLYGON:
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.ELLIPSE:
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                if (this._setting.x_stroke) {
                    this._showoverlay1(this._setting.x_lineWidth, this._setting.x_lineStyle, this._setting.x_strokeColor);
                } else if (this._setting.x_fill) {
                    this._showoverlay1(ScribblerDefault.LINE_WIDTH, ScribblerLineStyle.SOLID, this._setting.x_fillColor);
                } else {
                    this._showoverlay1(ScribblerDefault.LINE_WIDTH, ScribblerLineStyle.SOLID, ScribblerDefault.STROKE_COLOR);
                }
                break;
            case ScribblerAction.TEXT:
                this._showoverlay1(ScribblerDefault.LINE_WIDTH, ScribblerLineStyle.SOLID, this._textSetting.x_textColor);
                break;
            case ScribblerAction.history:
            case ScribblerAction.export:
            case ScribblerAction.more:
            case ScribblerAction.shift:
                this._showoverlay1(ScribblerDefault.LINE_WIDTH, ScribblerLineStyle.SOLID, this._setting.x_fillColor);
                break;
            default:
                throw Assert.notReach_(this._action);
        }
    }

    private _showoverlay1(linewidth: number, linestyle: string, color: ColorValue): void {
        const context = this._overlayContext;
        context.lineWidth = linewidth;
        Scribbler._setLineStyle_(context, linestyle);
        Scribbler.setStrokeColor_(context, color);
        if (this._overlayShown) {
            return;
        }
        this._overlayShown = true;
        this._handler.hideKeyboard_(() => {
            An.showVisible_(this._overlay, "block");
        });
    }

    private _hideOverlay(): void {
        if (this._overlayShown) {
            this._overlayShown = false;
            this._overlayQueue.cancel_();
            this._overlayContext.clearRect(0, 0, this._overlay.width, this._overlay.height);
            An.hide_(this._overlay);
        }
    }

    private _showTextOverlay(x: number, y: number, width: number, height: number): void {
        this._hideOverlay();
        this._changeState(ScribblerState.TEXT);
        const box = this._canvasOffset;
        const parent = this._canvas.parentElement!;
        const scrollx = parent.scrollLeft;
        const scrolly = parent.scrollTop;
        const left = Math.floor(box.x) - scrollx;
        const top = Math.floor(box.y) - scrolly;
        if (width < 0) {
            width = -width;
            x -= width;
        }
        if (height < 0) {
            height = -height;
            y -= height;
        }
        const textoverlay = this._canvas.ownerDocument.createElement("textarea");
        this._textOverlay = textoverlay;
        textoverlay.style.cursor = "text";
        this._canvas.parentElement!.append(textoverlay);
        textoverlay?.classList.add(CSS.AnTextOverlay);
        const style = textoverlay.style;
        style.backgroundColor = "rgba(255,255,255,0.25)";
        style.color = this._textSetting.x_textColor.toCSSString_();
        style.fontFamily = this._textSetting.x_fontFamily;
        style.fontSize = `${this._textSetting.x_fontSize}px`;
        style.left = `${left + x}px`;
        style.top = `${top + y}px`;
        style.width = `${width}px`;
        style.height = `${height}px`;
        style.lineHeight = `${this._textSetting.x_lineHeight}`;
        style.padding = "0px";
        style.margin = "0px";
        style.border = "0px";
        style.resize = "both";
        style.zIndex = `${DEF.zindexImageAnnotator + 2}`;
        this._showTextOverlaySmokescreen((text: string) => {
            const style = An.getComputedStyle_(textoverlay);
            const lineheight = An.parseDoublePx_(style?.lineHeight ?? null, this._textSetting.x_lineHeight);
            this._drawText(text, lineheight);
            this._hideTextOverlay();
            this._showOverlay();
        });
        textoverlay.focus();
    }

    private _showCenterTextOverlay(path: number[]): void {
        this._hideOverlay();
        this._changeState(ScribblerState.TEXT);
        let x = path[0];
        let y = path[1];
        let width = path[2] - x;
        let height = path[3] - y;
        const box = this._canvasOffset;
        const scrollx = this._canvas.parentElement!.scrollLeft;
        const scrolly = this._canvas.parentElement!.scrollTop;
        const left = Math.floor(box.x) - scrollx;
        const top = Math.floor(box.y) - scrolly;
        if (width < 0) {
            width = -width;
            x -= width;
        }
        if (height < 0) {
            height = -height;
            y -= height;
        }
        const textoverlay = this._canvas.ownerDocument.createElement("textarea");
        this._textOverlay = textoverlay;
        textoverlay.style.cursor = "text";
        this._canvas.parentElement!.append(textoverlay);
        textoverlay?.classList.add(CSS.AnTextOverlay);
        const style = textoverlay.style;
        style.backgroundColor = "rgba(255,255,255,0.25)";
        style.color = this._textSetting.x_textColor.toCSSString_();
        style.fontFamily = this._textSetting.x_fontFamily;
        style.fontSize = `${this._textSetting.x_fontSize}px`;
        style.lineHeight = `${this._textSetting.x_lineHeight}`;
        style.padding = "4px 0px";
        style.margin = "0px";
        style.border = "0px";
        style.resize = "both";
        style.verticalAlign = "middle";
        style.textAlign = "center";
        style.zIndex = `${DEF.zindexImageAnnotator + 2}`;
        const cstyle = An.getComputedStyle_(textoverlay);
        const lineheight = An.parseDoublePx_(cstyle?.lineHeight ?? null, this._textSetting.x_lineHeight);
        style.left = `${left + x}px`;
        style.top = `${top + y + (height - lineheight - 8) / 2}px`;
        style.width = `${width}px`;
        style.height = `${lineheight}px`;
        this._showTextOverlaySmokescreen((text: string) => {
            this._drawCenterText(text, x, y, width, height, lineheight);
            this._hideTextOverlay();
            this._showOverlay();
        });
        textoverlay.focus();
    }

    private _hideTextOverlay(): void {
        if (this._textOverlay != null) {
            this._textOverlay.remove();
            this._textOverlay = null;
            this._hideTextOverlaySmokescreen();
            this._changeState(ScribblerState.IDLE);
        }
    }

    private _showTextOverlaySmokescreen(callback: StringCallback): void {
        this._textOverlaySmokescreen = new Smokescreen(
            this._canvas.parentElement!,
            DEF.zindexImageAnnotator + 1,
            DEF.opacityTransparent);
        this._textOverlaySmokescreen.show_((sm: Smokescreen) => {
            const elm = sm.element_();
            if (elm == null || this._textOverlay == null) return;
            elm.style.cursor = "text";
            this._textOverlayDragger =
                new Dragger(elm, new ScribblerTextOverlayHandler(this._canvas, this._textOverlay, callback), new FrameLimiter(2))
                    .threshold_(Dragger.SCROLL_THRESHOLD)
                    .bind_();
        });
    }

    private _hideTextOverlaySmokescreen(): void {
        if (this._textOverlaySmokescreen != null) {
            this._textOverlayDragger?.destroy_();
            this._textOverlayDragger = null;
            this._textOverlaySmokescreen.destroy_();
            this._textOverlaySmokescreen = null;
        }
    }

    private _drawText(text: string, lineheight: number): void {
        if (text.length > 0) {
            const lines = text.split("\n");
            const px = this._path[0];
            const py = this._path[1];
            const cx = this._path[2];
            const cy = this._path[3];
            const x0 = Math.min(px, cx);
            const x1 = Math.max(px, cx);
            let y = Math.min(py, cy);
            let c = this._textSetting.x_textColor;
            Scribbler.setFillColor_(this._context, c);
            this._path = [];
            const lh = Math.round(lineheight);
            for (const line of lines) {
                let x = x0;
                const tm = this._context.measureText(line);
                const w = tm.width;
                switch (this._setting.x_textAlign) {
                    case ScribblerDefault._LEFT:
                        break;
                    case ScribblerDefault._CENTER:
                        x = Math.round((x0 + x1 - w) / 2);
                        break;
                    case ScribblerDefault._RIGHT:
                        x = Math.round(x1 - w);
                        break;
                    default:
                        
                        continue;
                }
                this._path.push(x);
                this._path.push(y);
                this._path.push(Math.round(w));
                this._path.push(lh);
                this._context.fillText(line, x, y);
                y += lh;
            }
            if (text.length > 0) {
                const clone = this._cloneSetting();
                clone.x_data = text;
                clone.x_fillColor = clone.x_textColor;
                this._history.add_(new ScribblerCmd(ScribblerAction.TEXT, clone, this._path));
            }
            c = this._setting.x_fillColor;
            Scribbler.setFillColor_(this._context, c);
        }
        this._path = [];
    }

    private _drawCenterText(text: string, left: number, top: number, width: number, height: number, lineheight: number): void {
        if (text.length > 0) {
            const lines = text.split("\n");
            const h = lineheight * lines.length;
            let y = top + (height - h) / 2;
            let c = this._textSetting.x_textColor;
            Scribbler.setFillColor_(this._context, c);
            this._path = [];
            const lh = Math.round(lineheight);
            for (const line of lines) {
                const tm = this._context.measureText(line);
                const w = tm.width;
                const x = left + (width - w) / 2;
                
                this._path.push(x);
                this._path.push(y);
                this._path.push(Math.round(w));
                this._path.push(lh);
                this._context.fillText(line, x, y);
                y += lh;
            }
            if (text.length > 0) {
                const clone = this._cloneSetting();
                clone.x_data = text;
                clone.x_fillColor = clone.x_textColor;
                this._history.add_(new ScribblerCmd(ScribblerAction.TEXT, clone, this._path));
            }
            c = this._setting.x_fillColor;
            Scribbler.setFillColor_(this._context, c);
        }
        this._path = [];
    }

    private _redrawOverlayPath(cx?: number, cy?: number): void {
        this._overlayQueue.queue_((_elapsed, _immediate) => {
            const ctx = this._overlayContext;
            ctx.clearRect(0, 0, this._rect.w, this._rect.h);
            if (Scribbler.drawPath1_(ctx, this._path, false) > 0) {
                ctx.stroke();
                if (cx !== undefined && cy != undefined) {
                    ctx.save();
                    ctx.lineWidth = 1;
                    ctx.setLineDash(ScribblerLineStyle.MASQUEE);
                    ctx.beginPath();
                    const len = this._path.length;
                    const px = this._path[len - 2];
                    const py = this._path[len - 1];
                    ctx.moveTo(px, py);
                    ctx.lineTo(cx, cy);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        });
    }

    private _redrawOverlayCurve(smoothing: boolean, cx?: number, cy?: number): void {
        this._overlayQueue.queue_((_elapsed, _immediate) => {
            const ctx = this._overlayContext;
            ctx.clearRect(0, 0, this._rect.w, this._rect.h);
            if (cx !== undefined && cy != undefined) {
                const len = this._path.length;
                this._path.push(cx);
                this._path.push(cy);
                ctx.save();
                ctx.lineWidth = ScribblerDefault.LINE_WIDTH;
                ctx.setLineDash(ScribblerLineStyle.MASQUEE);
                this._path = Scribbler.drawCurve_(ctx, this._setting.x_cornering, this._path, smoothing);
                ctx.stroke();
                ctx.restore();
                this._path.length = len;
            } else {
                this._path = Scribbler.drawCurve_(ctx, this._setting.x_cornering, this._path, smoothing);
                ctx.stroke();
            }
        });
    }

    private _drawShapeOverlay(path: number[]): void {
        switch (this._setting.x_shape) {
            case ScribblerAction.ELLIPSE:
                this._drawEllipseOverlay(path);
                break;
            case ScribblerAction.RECTANGLE:
            case ScribblerAction.TEXT:
                this._drawRectOverlay(path);
                break;
            default:
                throw Assert.notReach_(this._setting.x_shape);
        }
    }

    private _drawRectOverlay(path: number[]): void {
        this._overlayQueue.queue_((_elapsed, _immediate) => {
            const ctx = this._overlayContext;
            ctx.clearRect(0, 0, this._overlay.width, this._overlay.height);
            Scribbler.drawRect_(ctx, this._setting.x_cornerRadius, path);
            ctx.stroke();
            this._showOverlayDimension(path);
        });
    }

    private _drawEllipseOverlay(path: number[]): void {
        this._overlayQueue.queue_((_elapsed, _immediate) => {
            if (this._overlay == null) return;
            const ctx = this._overlayContext;
            ctx.clearRect(0, 0, this._overlay.width, this._overlay.height);
            Scribbler._drawEllipse(ctx, path);
            ctx.stroke();
            this._showOverlayDimension(path);
        });
    }

    private _drawHighlightOverlay(path: number[] | null, msg: string = ""): void {
        this._overlayQueue.queue_((_elapsed, _immediate) => {
            const ctx = this._overlayContext;
            ctx.clearRect(0, 0, this._overlay.width, this._overlay.height);
            if (path != null && path.length == 4) {
                ctx.save();
                Scribbler.setFillColor_(ctx, ScribblerDefault.HIGHLIGHT_COLOR);
                Scribbler.drawRect_(ctx, 0, path);
                ctx.fill();
                ctx.restore();
                this._showOverlayDimension(path, msg);
            } else if (!An.isempty_(msg)) {
                this._handler.info_(msg);
            }
        });
    }

    private _showOverlayDimension(_path: number[] | null, _msg: string = ""): void {
    }

    private _cloneSetting(): ScribblerSetting {
        const ret = this._setting.clone();
        ret.x_fontFamily = this._textSetting.x_fontFamily;
        ret.x_fontSize = this._textSetting.x_fontSize;
        ret.x_textColor = this._textSetting.x_textColor;
        return ret;
    }

    static _setLineStyle_(context: CanvasRenderingContext2D, style: string): void {
        let a: number[] | null = null;
        const linewidth = Math.round(context.lineWidth);
        if (ScribblerLineStyle.SOLID == style) {
            a = [];
        } else if (ScribblerLineStyle.DASH == style) {
            const w = Math.max(2, linewidth);
            a = ScribblerLineStyle.dash_(w);
        } else if (ScribblerLineStyle.DOTTED == style) {
            const w = Math.max(2, linewidth);
            a = ScribblerLineStyle.dotted_(w);
        }
        if (a != null) {
            context.setLineDash(a);
        }
    }

    static setStrokeColor_(ctx: CanvasRenderingContext2D, color: ColorValue): void {
        ctx.strokeStyle = color.toCSSString_();
    }

    static setFillColor_(ctx: CanvasRenderingContext2D, color: ColorValue): void {
        ctx.fillStyle = color.toCSSString_();
    }

    static setFont_(ctx: CanvasRenderingContext2D, handler: IScribblerHandler, font: string, callback: Fun00 | null = null): void {
        handler.loadFont_(font, () => {
            ctx.font = font;
            ctx.textBaseline = "hanging";
            callback?.();
        });
    }

    static drawPath1_(ctx: CanvasRenderingContext2D, path: number[], close: boolean): number {
        const len = path.length;
        if (len > 0) {
            const x0 = path[0];
            const y0 = path[1];
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            for (let i = 2; i < len; i += 2) {
                const px = path[i];
                const py = path[i + 1];
                ctx.lineTo(px, py);
            }
            if (close) {
                ctx.closePath();
            }
        }
        return len;
    }

    static drawCurve_(
        ctx: CanvasRenderingContext2D,
        cornering: number,
        path: number[],
        _smoothing: boolean
    ): number[] {
        const len = path.length / 2;
        if (cornering > 0) {
            let cps: number[] = [];
            if (len >= 3) {
                for (let i = 0; i < len - 2; ++i) {
                    const ii = i * 2;
                    Scribbler._controls(
                        cps,
                        cornering,
                        path[ii],
                        path[ii + 1],
                        path[ii + 2],
                        path[ii + 3],
                        path[ii + 4],
                        path[ii + 5]);
                }
            }
            Scribbler._drawCurve1(ctx, cps, path);
        } else {
            Scribbler.drawPath1_(ctx, path, false);
        }
        return path;
    }

    static drawRect_(context: CanvasRenderingContext2D, radius: number, path: number[]): void {
        const x0 = path[0];
        const y0 = path[1];
        const x1 = path[2];
        const y1 = path[3];
        if (radius == 0) {
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y0);
            context.lineTo(x1, y1);
            context.lineTo(x0, y1);
            context.closePath();
        } else {
            Scribbler._drawRoundRect1(context, radius, x0, y0, x1, y1);
        }
    }

    static putImage_(context: CanvasRenderingContext2D, stroke: boolean, fill: boolean, path: number[], data: ImageData): void {
        const x = path[0];
        const y = path[1];
        if (stroke || fill) {
            const w = path[2];
            const h = path[3];
            Scribbler.drawRect_(context, 0, [x, y, x + w, y + h]);
        }
        if (fill) {
            context.fill();
        }
        context.putImageData(data, x, y);
        if (stroke) {
            context.stroke();
        }
    }

    private static _controls(ret: number[], cornering: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void {
        const d12 = An.dist4_(x1, y1, x2, y2);
        const d23 = An.dist4_(x2, y2, x3, y3);
        const t = d12 / (d12 + d23);
        const t1 = 1 - t;
        const dx = (x3 - x1) * cornering;
        const dy = (y3 - y1) * cornering;
        ret.push(x2 - dx * t);
        ret.push(y2 - dy * t);
        ret.push(x2 + dx * t1);
        ret.push(y2 + dy * t1);
    }

    private static _drawCurve1(ctx: CanvasRenderingContext2D, controls: number[], path: number[]): number {
        const len = path.length / 2;
        if (len == 0) {
        } else if (len == 1) {
            ctx.beginPath();
            ctx.moveTo(path[0], path[1]);
        } else if (len == 2) {
            ctx.beginPath();
            ctx.moveTo(path[0], path[1]);
            ctx.lineTo(path[2], path[3]);
        } else {
            ctx.beginPath();
            ctx.moveTo(path[0], path[1]);
            ctx.quadraticCurveTo(controls[0], controls[1], path[2], path[3]);
            let i = 2;
            for (; i < len - 1; i += 1) {
                ctx.bezierCurveTo(
                    controls[(2 * (i - 1) - 1) * 2],
                    controls[(2 * (i - 1) - 1) * 2 + 1],
                    controls[(2 * (i - 1)) * 2],
                    controls[(2 * (i - 1)) * 2 + 1],
                    path[i * 2],
                    path[i * 2 + 1]);
            }
            ctx.quadraticCurveTo(
                controls[
                (2 * (i - 1) - 1) * 2],
                controls[(2 * (i - 1) - 1) * 2 + 1],
                path[i * 2],
                path[i * 2 + 1]);
        }
        return len;
    }

    private static _drawRoundRect1(context: CanvasRenderingContext2D, radius: number, x0: number, y0: number, x1: number, y1: number): void {
        const dx = x1 - x0;
        const dy = y1 - y0;
        const rx = Math.min((dx < 0 ? -dx : dx) / 2, radius) as number;
        const ry = Math.min((dy < 0 ? -dy : dy) / 2, radius) as number;
        const r = Math.min(rx, ry);
        const x = (x1 + x0) / 2;
        context.beginPath();
        context.moveTo(x, y0);
        context.arcTo(x1, y0, x1, y1, r);
        context.arcTo(x1, y1, x0, y1, r);
        context.arcTo(x0, y1, x0, y0, r);
        context.arcTo(x0, y0, x, y0, r);
        context.closePath();
    }

    private static _drawImage(context: CanvasRenderingContext2D, stroke: boolean, fill: boolean, rect: number[], rotation: number,
        src: CanvasImageSource): void {
        const x = rect[0];
        const y = rect[1];
        const w = rect[2];
        const h = rect[3];
        if (fill) {
            Scribbler.drawRect_(context, 0, [x, y, x + w, y + h]);
            context.fill();
        }
        switch (rotation) {
            case 0:
                context.drawImage(src, x, y, w, h);
                break;
            case 90:
                context.save();
                context.translate(x + w, y);
                context.rotate(Math.PI / 2);
                context.drawImage(src, 0, 0, h, w);
                context.restore();
                break;
            case 180:
                context.save();
                context.translate(x + w, y + h);
                context.rotate(Math.PI);
                context.drawImage(src, 0, 0, w, h);
                context.restore();
                break;
            case 270:
                context.save();
                context.translate(x, y + h);
                context.rotate(Math.PI * 3 / 2);
                context.drawImage(src, 0, 0, h, w);
                context.restore();
                break;
            default:
                
        }
        if (stroke) {
            Scribbler.drawRect_(context, 0, [x, y, x + w, y + h]);
            context.stroke();
        }
    }

    /**
         * @parma uri An decoded absolute context path.
         */
    static _drawImageFromUri(
        context: CanvasRenderingContext2D,
        cmd: ScribblerCmd,
        stroke: boolean,
        fill: boolean,
        rect: number[],
        href: string,
        rotation: number,
        ondone: StringListXCallback | null): void {
        const elm = context.canvas.ownerDocument.createElement("img");
        elm.addEventListener("load", (_e) => {
            Scribbler._drawImage(context, stroke, fill, rect, rotation, elm);
            cmd.imageData$ = context.getImageData(rect[0], rect[1], rect[2], rect[3]);
            context.restore();
            if (ondone != null) {
                ondone(null);
            }
        });
        elm.addEventListener("error", (_e) => {
            if (ondone != null) {
                if (href == null) {
                    href = "# " + (cmd.action$ == ScribblerAction.IMAGE)
                        ? MSG.string_(RS.Scribbler_MissingURIForImageAction)
                        : MSG.string_(RS.Scribbler_MissingDataForEmbeddedImageAction);
                }
                ondone([href]);
            }
        });
        elm.src = href;
    }

    private static _drawEllipse(context: CanvasRenderingContext2D, path: number[]): void {
        const x0 = path[0];
        const y0 = path[1];
        const x1 = path[2];
        const y1 = path[3];
        const rx = (x1 - x0) / 2;
        const ry = (y1 - y0) / 2;
        context.beginPath();
        context.ellipse(
            x0 + rx,
            y0 + ry,
            (rx < 0 ? -rx : rx),
            (ry < 0 ? -ry : ry),
            0,
            0,
            360,
            false);
    }
}

//////////////////////////////////////////////////////////////////////

abstract class IContextmenu {
    abstract show_(e: MouseEvent): void;

    abstract hide_(): void;

    abstract destroy_(): void;

    abstract onDrag_(callback: DragstartCallback): void;

    abstract onAction_(callback: ActionMouseEventCallback): void;

    abstract onShow_(callback: Fun00): void;

    abstract onTooltips_(callback: TargetEventCallback): void;

    abstract button_(action: string): HTMLElement;

    abstract self_(): IContextmenu;
}

////////////////////////////////////////////////////////////////////////

abstract class PopupBase {
    protected _contextmenu!: HTMLElement;
    protected _smokescreen!: Smokescreen;
    protected _dragger: Dragger | null = null;
    protected _dragstartCallback: DragstartCallback | null = null;
    protected _actionCallback: ActionMouseEventTargetCallback | null = null;
    protected _tooltipsCallback: TargetEventCallback | null = null;
    protected _showCallback: Fun00 | null = null;
    protected _cancelCallback: Fun00 | null = null;
    protected _tooltipsTimer: Timer | null = null;
    protected _tooltipsShown: boolean = false;
    protected _disabled: boolean = false;
    #shown: boolean = false;
    #destroyed: boolean = false;

    /**
         * @param Container The DOM element that host the contextmenu.
         */
    constructor() { }

    init_(contextmenu: HTMLElement, smokescreen: Smokescreen): void {
        this._contextmenu = contextmenu;
        this._smokescreen = smokescreen;
    }

    setupHandlers_(menu: HTMLElement, actionSelector: string, tooltipsSelector: string): void {
        this._contextmenu.style.pointerEvents = "auto";
        if (Conf.useFlash$) {
            new Flash(menu, actionSelector, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        An.onClickMatching_(menu, actionSelector, (elm, e: MouseEvent) => {
            An.stopevent_(e);
            if (!this._disabled) {
                if (elm != null && !elm.classList.contains(CSS.AnDisabled)) {
                    const action = elm.getAttribute(ATTR.AnAction);
                    if (action != null && action.length > 0) {
                        try {
                            this._actionCallback?.(action, e, elm);
                        } catch (ex: any) {
                            
                        }
                    }
                }
            }
        });
        An.onEventMatching_(menu, Conf.pointerstart$, tooltipsSelector, (target, e) => {
            this._stopTooltipsTimer();
            this._tooltipsShown = false;
            this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                An.stopevent_(e);
                this._tooltipsTimer = null;
                this._tooltipsShown = true;
                if (this._tooltipsCallback != null) {
                    this._tooltipsCallback(target, e);
                }
            });
        });
        An.onPointerEnd_(this._contextmenu, (e) => {
            this._stopTooltipsTimer();
            if (this._tooltipsShown) {
                An.stopevent_(e);
                this._tooltipsShown = false;
            }
        });
    }

    private _stopTooltipsTimer(): void {
        if (this._tooltipsTimer != null) {
            this._tooltipsTimer.cancel_();
            this._tooltipsTimer = null;
        }
    }

    createSmokescreen_(container: HTMLElement, zindex: number = DEF.zindexContextmenu + DEF.zindexUnder): Smokescreen {
        const sm = new Smokescreen(container, zindex);
        sm.on_("click", (e) => {
            An.stopevent_(e);
            if (this._cancelCallback != null) {
                this._cancelCallback();
            } else {
                this.hide_();
            }
        });
        return sm;
    }

    onTooltips_(callback: TargetEventCallback): this {
        this._tooltipsCallback = callback;
        return this;
    }

    onDrag_(callback: DragstartCallback): this {
        this._dragstartCallback = callback;
        return this;
    }

    onAction_(callback: ActionMouseEventTargetCallback): this {
        this._actionCallback = callback;
        return this;
    }

    onCancel_(callback: Fun00): this {
        this._cancelCallback = callback;
        return this;
    }

    onShow_(callback: Fun00): this {
        this._showCallback = callback;
        return this;
    }

    element_(): HTMLElement {
        return this._contextmenu;
    }

    isShown_(): boolean {
        return this.#shown;
    }

    getSmokescreen_(): Smokescreen {
        return this._smokescreen;
    }

    show_(e: MouseEvent): this {
        this.showAt_(e.pageX, e.pageY);
        return this;
    }

    showAt_(x: number, y: number): void {
        if (this.#shown || this._contextmenu == null) { return; }
        this.#shown = true;
        An.showHidden_(this._contextmenu);
        if (this._showCallback != null) {
            this._showCallback();
        }
        const table = this._contextmenu.children.item(0) as HTMLElementX;
        if (table != null) {
            //// HACK Use ceil() here because using the raw double value sometimes cause contextmenu rows to overflow.
            const w = Math.ceil(table.getBoundingClientRect().width);
            table.style.width = `${w}px`;
        }
        //// This works for sidepanel contextmenus since they are position:fixed at 0, 0.
        //// Contextmenu that is not fixed at 0, 0 should override this method and do the adjustment.
        const bound = this._contextmenu.getBoundingClientRect();
        let top = y /*  - 5.0 */;
        let left = x - (bound.width / 2) /* + 5.0 */;
        const dy = top + bound.height - window.innerHeight;
        if (dy > 0) {
            top -= dy;
        }
        if (top < 0) {
            top = 0.0;
        }
        const right = window.innerWidth - bound.width;
        if (left > right) {
            left = right;
        }
        if (left < 0) {
            left = 0.0;
        }
        this._smokescreen?.show_();
        if (this._dragger == null && this._dragstartCallback != null) {
            this._dragger = new Dragger(this._contextmenu, new DefaultDraggerHandler(this._dragstartCallback))
                .bind_();
        }
        An.setVisibleAt_(this._contextmenu, Math.round(left), Math.round(top));
    }

    hide_(): void {
        if (this.#shown) {
            this.#shown = false;
            this._stopTooltipsTimer();
            this._smokescreen?.hide_();
            if (this._contextmenu != null) {
                An.hide_(this._contextmenu);
            }
        }
    }

    destroy_(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this.hide_();
        if (this._dragger != null) {
            this._dragger.destroy_();
            this._dragger = null;
        }
        if (this._smokescreen != null) {
            this._smokescreen.destroy_();
        }
        if (this._contextmenu != null) {
            this._contextmenu.remove();
        }
        this._dragstartCallback = null;
        this._actionCallback = null;
        this._tooltipsCallback = null;
    }
}

////////////////////////////////////////////////////////////////////////

class ContextmenuBase {
    protected _smokescreen: Smokescreen | null = null;
    protected _cancelCallback: Fun00 | null = null;
    protected _tooltipsKeyCallback: TargetEventCallback | null = null;
    protected _onShowCallback: Fun00 | null = null;
    protected _dragger: Dragger | null = null;
    protected _tooltipsTimer: Timer | null = null;
    protected _tooltipsShown: boolean = false;
    protected _shown: boolean = false;

    get smokescreen$(): Smokescreen | null {
        return this._smokescreen;
    }

    set smokescreen$(value: Smokescreen | null) {
        this._smokescreen = value;
    }

    get element$(): HTMLElement {
        return this._contextmenu;
    }

    /**
         * @param Container The DOM element that host the contextmenu.
         */
    constructor(protected _contextmenu: HTMLElement) { }

    setupHandlers_(menu: HTMLElement, actionSelector: string): void {
        this._contextmenu.style.pointerEvents = "auto";

        An.onEventMatching_(menu, Conf.pointerstart$, `[${ATTR.xTooltips}]`, (target, e) => {
            this._stopTooltipsTimer();
            this._tooltipsShown = false;
            this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                this._tooltipsTimer = null;
                this._tooltipsShown = true;
                if (this._tooltipsKeyCallback != null) {
                    this._tooltipsKeyCallback(target, e);
                }
            });
        });
        An.onPointerEnd_(menu, (e) => {
            this._stopTooltipsTimer();
            if (this._tooltipsShown) {
                this._tooltipsShown = false;
                An.stopevent_(e);
            }
        });
        if (Conf.useFlash$ && actionSelector != null) {
            new Flash(menu, actionSelector, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
    }

    onTooltipsKey_(callback: TargetEventCallback): this {
        this._tooltipsKeyCallback = callback;
        return this;
    }

    onShow_(callback: Fun00): this {
        this._onShowCallback = callback;
        return this;
    }

    private _stopTooltipsTimer(): void {
        if (this._tooltipsTimer != null) {
            this._tooltipsTimer.cancel_();
            this._tooltipsTimer = null;
        }
    }

    above_(elm: HTMLElement): this {
        if (this._contextmenu == null) return this;
        this._contextmenu.style.zIndex = An.above_(elm).toString();
        return this;
    }

    onCancel_(callback: Fun00): this {
        this._cancelCallback = callback;
        return this;
    }

    onAction_(callback: ActionTargetMouseEventCallback): this {
        if (this._contextmenu == null) { return this; }
        An.onClickMatching_<MouseEvent>(this._contextmenu, `[${ATTR.AnAction}]`, (elm, e) => {
            An.stopevent_(e);
            if (elm == null || elm.classList.contains(CSS.AnDisabled)) {
                return;
            }
            const action = elm.getAttribute(ATTR.AnAction);
            if (action != null && action.length > 0) {
                callback(action, elm as HTMLElement, e);
            }
        });
        return this;
    }

    onContextmenu_(listener: Fun20<HTMLElement, Event>): this {
        An.onContextmenuMatching_(this._contextmenu, `[${ATTR.xTooltips}]`, listener);
        return this;
    }

    /// @param pagex The page offset with respect to the top level document, ie. not iframe.
    /// @param pagey The page offset with respect to the top level document, ie. not iframe.
    show_(pagex: number, pagey: number, ymiddle: boolean = true, xmiddle: boolean = true): this {
        if (this._shown || this._contextmenu == null) {
            return this;
        }
        this._shown = true;
        An.showHidden_(this._contextmenu /* , "block" */);
        let table = ElementUtil.getChildWithTagAndClass_(this._contextmenu, "TABLE", CSS.AnContextmenu);
        if (table != null) {
            (table as HTMLElement).style.width = `${table
                .getBoundingClientRect()
                .width}px`;
        }
        const buttonsize = cache$.ui$.buttonSize_();
        const bound = this._contextmenu.getBoundingClientRect();
        const width = Math.round(bound.width);
        let height = Math.round(bound.height);
        const margin = (DEF.contextmenuMargin / 2);
        let top = Math.round(pagey) - DEF.contextmenuMargin;
        if (ymiddle) {
            top -= height / 2;
            top = Math.round(Math.max(top, buttonsize * 3 / 2));
        }
        let left = xmiddle ? Math.round(pagex - (width / 2) + margin)
            : Math.round(pagex - DEF.contextmenuMargin);
        const right = window.innerWidth - width;
        if (left > right) {
            left = right;
        }
        if (left < 0) {
            left = 0;
        }
        const winheight = window.innerHeight;
        const bottom = top + height;
        if (bottom >= winheight) {
            top = winheight - height - margin;
        }
        if (top < margin) {
            top = margin;
        }
        this._onShowCallback?.();
        if (this._smokescreen != null) {
            this._smokescreen.show_();
        }
        An.setVisibleAt_(this._contextmenu, left, top);
        if (this._dragger == null) {
            this._dragger = new Dragger(this._contextmenu, new DefaultDraggerHandler(Contextmenu.contextmenuDragOK_))
                .bind_();
        }
        return this;
    }

    cancel_(): void {
        this._cancelCallback?.();
        this.hide_();
    }

    hide_(): void {
        this._hide();
    }

    protected _hide(): void {
        if (this._shown) {
            this._shown = false;
            this._stopTooltipsTimer();
            if (this._smokescreen != null) {
                this._smokescreen.hide_();
            }
            if (this._contextmenu != null) {
                An.hide_(this._contextmenu);
            }
        }
    }

    destroy_(): void {
        this._hide();
        if (this._dragger != null) {
            this._dragger.destroy_();
            this._dragger = null;
        }
        this._contextmenu.remove();
        if (this._smokescreen != null) {
            this._smokescreen.destroy_();
            this._smokescreen = null;
        }
    }

    isShown_(): boolean {
        return this._shown;
    }

    static createContextmenu_(container: HTMLElement, name: string): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnContextmenu,
            "style": "display: none; visibility: hidden;",
            "name": name,
        });
        return b.cursor_();
    }

    static createNoop_(b: DomBuilderEx): void {
        b.peek_().td_(
            ["class", `${CSS.AnContextButton} ${CSS.AnDisabled}`],
            [ATTR.AnAction, DEF.NOOP],
        );
    }

    static createButtons_(
        ret: Map<string, HTMLElement> | null,
        table: DomBuilderEx,
        keys: Array<Array<string>>,
        infos: StringMap<SStringMap>,
    ): void {
        table.push_();
        for (const row of keys) {
            if (row.length == 0) {
                continue;
            }
            table.peek_().tr_().push_();
            this.createButtonRow_(ret, table, row, infos);
            table.pop_();
        }
        table.pop_();
    }

    static createButtonRow_(
        ret: Map<string, HTMLElement> | null,
        table: DomBuilderEx,
        row: Array<string>,
        infos: StringMap<SStringMap>,
    ): void {
        for (const action of row) {
            if (DEF.NOOP == action) {
                ContextmenuBase.createNoop_(table);
                continue;
            }
            const info = infos[action];
            const attrs = smap_(
                [ATTR.AnAction, action],
                ["class", info["class"] as string],
                [ATTR.xTooltips, info[ATTR.xTooltips] as string],
            );
            table.peek_().td_(attrs);
            if (ret != null) {
                ret.set(action, table.cursor_());
            }
        }
    }
}

class Contextmenu extends PopupBase implements IContextmenu {
    _buttons = new Map<string, HTMLElement>();

    static contextmenuDragOK_ = (_dragger: Dragger, target: EventTarget, _pagex: number, _pagey: number): boolean => {
        const elm = DomUt.asHTMLElement_(target);
        return elm != null &&
            (elm.nodeName == "TABLE" || elm.nodeName == "DIV") &&
            (elm.classList.contains(CSS.AnContextmenu) || elm.classList.contains(CSS.AnVerticalMenu));
    };

    constructor(
        private container: HTMLElement,
        private zindex: number,
        private infos: Array<Array<SStringMap>>
    ) {
        super();
        const menu = this.createContextmenu_(this.container, this.zindex, this.infos);
        this.init_(menu, this.createSmokescreen_(container, zindex + DEF.zindexUnder));
        this.setupHandlers_(menu, `[${ATTR.AnAction}]`, `[${ATTR.xTooltips}]`);
    }

    createContextmenu_(container: HTMLElement, zindex: number, infos: Array<Array<SStringMap>>): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnContextmenu,
            "style": `display:none;z-index:${zindex}`,
        }).push_();
        const menu = b.cursor_();
        b.table1_(CSS.AnContextmenu);
        this._createContextmenuButtons(this._buttons, b, infos);
        container.append(menu);
        return menu;
    }

    private _createContextmenuButtons(table: Map<string, HTMLElement>, b: DomBuilderEx, infos: Array<Array<SStringMap>>): void {
        b.push_();
        for (const row of infos) {
            b.peek_().tr_().push_();
            for (const info of row) {
                const action = info[ATTR.AnAction];
                if (action == null) continue;
                if (action == DEF.NOOP) {
                    b.peek_().td_(
                        ["class", `${CSS.AnContextButton} ${CSS.AnDisabled}`],
                        [ATTR.AnAction, DEF.NOOP],
                    );
                } else {
                    b.peek_().td_(
                        ["class", `${CSS.AnContextButton} ${info["class"]}`],
                        [ATTR.AnAction, action],
                        [ATTR.xTooltips, info[ATTR.xTooltips] ?? ""],
                    );
                }
                table.set(action, b.cursor_());
            }
            b.pop_();
        }
        b.pop_();
    }

    self_(): Contextmenu {
        return this;
    }

    button_(name: string): HTMLElement {
        const ret = this._buttons.get(name);
        if (ret === undefined) {
            throw new Error(name);
        }
        return ret;
    }

    enableButton_(name: string, b: boolean): void {
        An.enableButton_(this.button_(name), b);
    }

    enableButtonIfExists_(name: string, b: boolean): void {
        const button = this._buttons.get(name);
        if (button !== undefined) {
            An.enableButton_(button, b);
        }
    }

    enableButtons_(names: string[], b: boolean): void {
        for (const name of names) {
            An.enableButton_(this.button_(name), b);
        }
    }

    showButton_(name: string, show: boolean, enable: boolean): void {
        const button = this._buttons.get(name);
        if (button == null) throw new Error(name);
        if (show) An.show_(button); else An.hide_(button);
        An.enableButton_(button, enable);
    }
}

////////////////////////////////////////////////////////////////////////

class Toolbar {
    private _buttons = new Map<string, HTMLElement>();
    private _toolbar: HTMLElement;
    private _title: HTMLElementX = null;
    private _actionCallback: ActionMouseEventTargetCallback | null = null;
    private _tooltipsListener: UIUt$.TooltipsListener | null = null;
    private _disabled: boolean = false;
    private _isShown: boolean = true;

    /// @param infos Button infos, eg. [
    ///     ["div", {DEF.Action: _Contextmenu, "class": `${CSS.AnButton} fa fa-toggle-down`, ATTR.xTooltips: "Contextmenu",}],
    ///   ],
    constructor(_container: HTMLElement, infos: Array<SStringMap>) {
        this._toolbar = Toolbar.createToolbar_(this._buttons, _container, infos);
        if (Conf.useFlash$) {
            new Flash(this._toolbar, `div[${ATTR.AnAction}]`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        this._toolbar.style.pointerEvents = "auto";
        An.onClickMatching_<MouseEvent>(this._toolbar, `div[${ATTR.AnAction}]`, (elm, e) => {
            An.stopevent_(e);
            if (this._actionCallback != null
                && !this._disabled
                && elm != null
                && !elm.classList.contains(CSS.AnDisabled)) {
                const action = elm.getAttribute(ATTR.AnAction);
                if (action != null && action.length > 0) {
                    try {
                        this._actionCallback(action, e, elm);
                    } catch (ex) {
                        
                    }
                }
            }
        });
    }

    element_(): HTMLElement {
        return this._toolbar;
    }

    isShown_(): boolean {
        return this._isShown;
    }

    buttons_(): Map<string, HTMLElement> {
        return this._buttons;
    }

    getButtons_(ret: Map<string, HTMLElement>): Map<string, HTMLElement> {
        for (let [key, button] of this._buttons) {
            ret.set(key, button);
        }
        return ret;
    }

    button_(action: string): HTMLElement {
        const ret = this._buttons.get(action);
        if (ret === undefined) {
            throw new Error(action);
        }
        return ret;
    }

    buttonIfExists_(action: string): HTMLElementX {
        const ret = this._buttons.get(action);
        return (ret === undefined ? null : ret);
    }

    hasButton_(action: string): boolean {
        return this._buttons.get(action) !== undefined;
    }

    enableButton_(action: string, yes: boolean): this {
        const button = this._buttons.get(action);
        if (button === undefined) {
            throw new Error(action);
        }
        An.enableButton_(button, yes);
        return this;
    }

    enableButtons_(actions: Iterable<string>, yes: boolean): void {
        for (const action of actions) {
            this.enableButton_(action, yes);
        }
    }

    showButtonIfExists_(action: string, yes: boolean): void {
        if (this.hasButton_(action)) {
            this.showButton_(action, yes);
        }
    }

    showButton_(action: string, yes: boolean): void {
        const button = this.button_(action) as HTMLElement;
        if (yes) {
            An.show_(button);
        } else {
            An.hide_(button);
        }
    }

    showButtons_(actions: string[], yes: boolean): void {
        for (const action of actions) {
            this.showButton_(action, yes);
        }
    }

    querySelector_(selector: string): HTMLElementX {
        return this._toolbar.querySelector(selector);
    }

    onAction_(callback: ActionMouseEventCallback): this {
        this._actionCallback = callback;
        return this;
    }

    onTooltips_(callback: TargetEventCallback): this {
        this._tooltipsListener = new UIUt$.TooltipsListener(this._toolbar, callback);
        return this;
    }

    destroy_(): void {
        if (this._toolbar != null) {
            this.hide_();
            this._tooltipsListener = null;
            this._buttons.clear();
            this._toolbar.remove();
            this._isShown = false;
        }
    }

    hide_(): void {
        this._tooltipsListener?.stopTooltipsTimer_();
        An.hide_(this._toolbar);
        this._isShown = false;
    }

    show_(): void {
        An.showVisible_(this._toolbar);
        this._isShown = true;
    }

    showHidden_(): void {
        An.showHidden_(this._toolbar);
        this._isShown = false;
    }

    enable_(b: boolean): void {
        this._disabled = !b;
        this._toolbar.style.opacity = (b ? DEF.opacityEnabled : DEF.opacityDisabled).toString();
    }

    isEnabled_(): boolean {
        return !this._disabled;
    }

    get title$(): HTMLElementX {
        return this._title;
    }

    titleKey_(titlekey: string): this {
        return this.titleText_(MSG.string_(titlekey));
    }

    titleText_(title: string): this {
        if (this._title == null) {
            this._title = new DomBuilderEx(this._toolbar).childBefore_(this._toolbar.firstChild, "div", {
                "class": CSS.AnTitle,
            }).cursor_();
        }
        this._title.textContent = title;
        return this;
    }

    /// @param table {DEF.Action : HTMLElement, ... } return the elements for the actions.
    /// @param container The DOM element that container the div.toolbar.
    /// @param infos The [{attrs}...] to create the buttons.
    /// @return The div.toolbar DOM element.
    static createToolbar_(table: Map<string, HTMLElement>, container: HTMLElement, infos: Array<SStringMap>): HTMLElement {
        const ret = Toolbar.createToolbarOffline_(table, container.ownerDocument, infos);
        container.append(ret);
        return ret;
    }

    /// Create a toolbar using the given list of attributes.
    /// It create an input element if there is a type attribute.
    /// Otherwise it create a div element.
    static createToolbarOffline_(table: Map<string, HTMLElement>, doc: Document, infos: Array<SStringMap>): HTMLElement {
        const b = DomBuilderEx.offline1_(doc, "div", CSS.AnToolbar).push_();
        const ret = b.cursor_();
        for (const info of infos) {
            const isinput = info[ATTR.placeholder] !== undefined;
            const tag = isinput ? Conf.input$ : "div";
            b.peek_().child_(tag, info);
            if (table != null) {
                const action = info[ATTR.AnAction];
                if (action != null) {
                    table.set(action, b.cursor_());
                }
            }
            if (isinput) {
                const input = b.cursor_();
                An.onInputFocusSelect_(input as AnInputElement);
            }
        }
        return ret as HTMLElement;
    }
}

////////////////////////////////////////////////////////////////////////

/// A clipboard.
class AnClipboard {
    private _content: Map<string, string> | null = null;

    constructor() { }

    /// @param content {Key.kind: string, Key.value: string }.
    map_(content: Map<string, string>): void {
        this._content = new Map(content.entries());
        this._content.set(MapClipboardKey.kind, MapClipboardKind.map);
    }

    dom_(html: string, context: string): void {
        this._content = new Map([
            [MapClipboardKey.kind, MapClipboardKind.dom],
            [MapClipboardKey.value, html],
            [MapClipboardKey.context, context],
        ]);
    }

    string_(value: string): void {
        this._content = new Map([
            [MapClipboardKey.kind, MapClipboardKind.string],
            [MapClipboardKey.value, value],
        ]);
    }

    /// @return A read only copy of the clipboard content.
    get_(): Map<string, string> | null {
        if (this._content == null) {
            return null;
        }
        return new Map(this._content);
    }

    isEmpty_(): boolean {
        return this._content == null;
    }

    clear_(): void {
        this._content = null;
    }
}

const clipboard$ = new AnClipboard();

///////////////////////////////////////////////////////////////////////

type HistoryOnEmptyListener = (isempty: boolean) => void;
type HistoryOnUndoneListener = (label: stringX) => void;

class _HistoryItem {

    constructor(
        private readonly _labelkey: StringId,
        private readonly _detail: string,
        private readonly _records: MutationRecord[]) { }

    get labelkey$(): string {
        return this._labelkey;
    }

    get detail$(): string {
        return this._detail;
    }

    get records$(): IterableIterator<MutationRecord> {
        return this._records[Symbol.iterator]();
    }

    get reversed$(): IterableIterator<MutationRecord> {
        return this._records.reverse()[Symbol.iterator]();
    }

}

abstract class ICommandHistory {
    abstract connect_(): void;
    abstract disconnect_(): void;
    abstract getDescription_(index: number): string;
    abstract undo_(count: number): boolean;
    abstract redo_(): boolean;
    abstract group_(label: string, detail: string, callback: Fun00): void;
    abstract startGroup_(labelkey: StringId, detail: string): void;
    abstract endGroup_(): void;
    abstract groups_(): string[];
    abstract isUndoEmpty_(): boolean;
    abstract isRedoEmpty_(): boolean;
    abstract length_(): number;
    abstract addOnUndoEmptyListener_(l: HistoryOnEmptyListener): void;
    abstract addOnUndoneListener_(l: HistoryOnUndoneListener): void;
    abstract addOnRedoEmptyListener_(l: HistoryOnEmptyListener): void;
    abstract addOnRedoneListener_(l: HistoryOnUndoneListener): void;
}

class CommandHistory implements ICommandHistory {
    static readonly MAX_BAD: number = 64;
    static _EVERYTHING = {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true,
        attributeOldValue: true,
        characterDataOldValue: true,
    };
    private _body: HTMLElementX = null;
    private _group: MutationRecord[] = [];
    private _groupStack: string[] = [];
    private _details: string[] = [];

    private _history: Array<MutationRecord | _HistoryItem> = [];
    private _redo: Array<MutationRecord | _HistoryItem> = [];
    private _prev: MutationRecord | null = null;
    private _undoing: boolean = false;
    private _redoing: boolean = false;
    private _undoLevel: number = 0;
    private _redoLevel: number = 0;
    private _observer: MutationObserver | null = null;
    private _limiter = new RateLimiter(200);
    private _onUndoEmptyListeners: HistoryOnEmptyListener[] = [];
    private _onUndoneListeners: HistoryOnUndoneListener[] = [];
    private _onRedoEmptyListeners: HistoryOnEmptyListener[] = [];
    private _onRedoneListeners: HistoryOnUndoneListener[] = [];
    private _bad: number = 0;

    constructor(private _native: Native, private _size: number = DEFUtil.undoHistorySize) {
    }

    private _fixup(_bad: number): void {
        this._limiter.queue_((_elpased: number, _immediate: boolean) => {
            
            const range = this._native.getIFrameSelectionRange_();
            this._native.iClearSelection_();
            Timer.sleep0_(() => {
                this._native.iSelectRange_(range);
            });
        });
    }

    private _observerCallback(records: MutationRecord[], _observer: MutationObserver): void {
        const rlen: number = records.length;
        const a: Array<MutationRecord | _HistoryItem> = [];
        let prevcontainer: Object[] | null = null;
        NEXT:
        for (let i: number = 0; i < rlen; this._prev = records[i], ++i) {
            const record = records[i];
            const type: string = record.type;
            const target = record.target;
            if (type != "childList") {
                this._bad = 0;
            }
            if (type == "attributes") {
                const name = record.attributeName;
                const oldvalue = record.oldValue;
                const nodename: string = target.nodeName;
                if (nodename == "BODY") {
                    switch (name) {
                        case ATTR.AnUndoing:
                            this._process(a);
                            this._undoing = An.isempty_(oldvalue);
                            continue NEXT;
                        case ATTR.AnRedoing:
                            this._process(a);
                            this._redoing = An.isempty_(oldvalue);
                            continue NEXT;
                        case ATTR.AnToggleGroup:
                            const labelkey = record.oldValue ?? "";
                            let detail = (labelkey != "" && this._details.length > 0) ? this._details.shift()! : "";
                            if (this._group.length > 0 && labelkey != RS.HistoryIgnore) {
                                a.push(new _HistoryItem(labelkey, detail, this._group));
                            }
                            this._group = [];
                            continue NEXT;
                    }
                }
            } else if (type == "characterData") {
                if (this._prev != null && this._prev.type == "characterData") {
                    if (this._prev.target == target) {
                        continue NEXT;
                    }
                }
            } else if (type == "childList") {
                if (prevcontainer != null && this._prev != null && this._prev.type == "childList") {
                    if (this._prev.target == target && this._prev.previousSibling == record.previousSibling) {
                        const added = record.addedNodes;
                        const removed = record.removedNodes;
                        const padded = this._prev.addedNodes;
                        const premoved = this._prev.removedNodes;
                        if (added != null && removed != null && padded != null && premoved != null) {
                            const alen: number = added.length;
                            const rlen: number = removed.length;
                            const palen: number = padded.length;
                            const prlen: number = premoved.length;
                            if (alen == 0 && rlen == 1 && palen == 1 && prlen == 0 && removed[0] == padded[0] ||
                                alen == 1 && rlen == 0 && palen == 0 && prlen == 1 && added[0] == premoved[0]) {
                                prevcontainer.pop();
                                prevcontainer = null;
                                this._prev = null;
                                ++this._bad;
                                continue NEXT;
                            }
                        }
                    }
                    this._bad = 0;
                }
            }
            this._group.push(record);
            prevcontainer = this._group;
        }
        if (this._bad >= CommandHistory.MAX_BAD) {
            
            this._fixup(this._bad);
            this._bad = 0;
        }
        this._process(a);
    }

    private _process(a: Array<MutationRecord | _HistoryItem>): void {
        if (a.length > 0) {
            if (this._undoing) {
                this._processUndoRecords(a);
            } else {
                this._processNormalRecords(a);
            }
            a.length = 0;
        }
    }

    private _processUndoRecords(a: Array<MutationRecord | _HistoryItem>): void {
        const len: number = a.length;
        const wasempty = this._redo.length == 0;
        //// Since we have limited number of undo records,
        //// there is no need to limit the redo queue.
        for (let i: number = 0; i < len; ++i) {
            this._redo.push(a[i]);
        }
        if (wasempty != (this._redo.length == 0)) {
            this._fireOnRedoEmpty(this._redo.length == 0);
        }
    }

    private _processNormalRecords(a: Array<MutationRecord | _HistoryItem>): void {
        if (!this._redoing) {
            this._redo.length = 0;
            this._fireOnRedoEmpty(true);
        }
        const len: number = a.length;
        const wasempty = this._history.length == 0;
        let start: number;
        if (len >= this._size) {
            this._history.length = 0;
            start = len - this._size;
        } else {
            start = 0;
            const hlen: number = this._history.length;
            if (hlen + len > this._size) {
                this._history.splice(0, len + hlen - this._size);
            }
        }
        for (let i: number = start; i < len; ++i) {
            this._history.push(a[i]);
        }
        if (wasempty != (this._history.length == 0)) {
            this._fireOnUndoEmpty(this._history.length == 0);
        }
    }

    connect_(): void {
        if (this._observer == null) {
            this._group = [];
            this._undoing = false;
            this._redoing = false;
            this._undoLevel = 0;
            this._redoLevel = 0;
            const idoc = this._native.getIFrameDocument_();
            if (idoc == null) return;
            const body = idoc.body;
            body.setAttribute(ATTR.AnToggleGroup, "");
            const observer = this._native.createMutationObserver_((records, observer) => this._observerCallback(records, observer));
            this._body = body;
            this._observer = observer;
            observer.observe(this._body, CommandHistory._EVERYTHING);
        }
    }

    disconnect_(): void {
        this.clear_();
        this._onUndoEmptyListeners.length = 0;
        this._onUndoneListeners.length = 0;
        this._onRedoEmptyListeners.length = 0;
        this._onRedoneListeners.length = 0;
        this._body = null;
        if (this._observer != null) {
            this._observer.disconnect();
            this._observer = null;
        }
    }

    clear_(): void {
        this._group = [];
        this._prev = null;
        this._undoing = false;
        this._groupStack.length = 0;
        let wasempty = this._history.length == 0;
        this._history.length = 0;
        if (!wasempty) {
            this._fireOnUndoEmpty(true);
        }
        wasempty = this._redo.length == 0;
        this._redo.length = 0;
        if (!wasempty) {
            this._fireOnRedoEmpty(true);
        }
    }

    destroy_(): void {
        this.disconnect_();
        this._observer = null;
        this._history.length = 0;
        this._redo.length = 0;
        this._groupStack.length = 0;
        this._onUndoEmptyListeners.length = 0;
        this._onUndoneListeners.length = 0;
        this._onRedoEmptyListeners.length = 0;
        this._onRedoneListeners.length = 0;
    }

    getDescription_(index: number): string {
        if (index < 0 || index >= this._history.length) {
            return "";
        }
        const a = this._history[index];
        if (a instanceof _HistoryItem) {
            let ret = MSG.string_(a.labelkey$);
            if (ret == "") return "???";
            if (!An.isempty_(a.detail$)) {
                ret += ": " + a.detail$;
            }
            return ret;
        }
        const r = a;
        switch (r.type) {
            case "attributes":
                const name = r.attributeName;
                const value = r.oldValue;
                return An.truncate_(MSG.string_(RS.history_attributes) + `: ${name}=${value}`, DEF.historyTextLength);
            case "characterData":
                const text = r.oldValue;
                return An.truncate_(MSG.string_(RS.history_text) + `: ${text}`, DEF.historyTextLength);
            case "childList":
                const target = r.target;
                const nodename = target.nodeName;
                return MSG.string_(RS.history_node) + `: ${nodename}`;
            default:
                return "";
        }
    }

    undo_(count: number = 1): boolean {
        if (this._history.length == 0 || count == 0) {
            return false;
        }
        while (--count >= 0 && this._history.length != 0) {
            const a = this._history.pop();
            if (a instanceof _HistoryItem) {
                const labelkey = a.labelkey$;
                const label = MSG.string_(labelkey);
                
                this._startUndo();
                this.startGroup_(labelkey, a.detail$);
                for (const record of a.reversed$) {
                    this._undo1(true, record);
                }
                this.endGroup_();
                this._endUndo();
                this._fireOnUndone(label);
            } else if (a instanceof MutationRecord) {
                this._startUndo();
                this._undo1(true, a);
                this._endUndo();
                this._fireOnUndone(null);
            }
        }
        if (this._history.length == 0) {
            this._fireOnUndoEmpty(true);
        }
        return true;
    }

    private _undo1(_undo: boolean, record: MutationRecord): void {
        const type = record.type;
        
        const target = record.target;
        switch (type) {
            case "attributes": {
                const name = record.attributeName;
                if (name != null) {
                    const value = record.oldValue ?? "";
                    
                    (target as HTMLElement).setAttribute(name, value);
                }
                break;
            }
            case "characterData": {
                const value = record.oldValue;
                target.nodeValue = value;
                break;
            }
            case "childList": {
                const added = record.addedNodes;
                const removed = record.removedNodes;
                for (let i = 0, len = added.length; i < len; ++i) {
                    const node = added[i];
                    const parent = node.parentNode;
                    if (parent == null) {
                        
                    } else {
                        parent.removeChild(node);
                    }
                }
                const count = removed.length;
                if (count > 0) {
                    const next = record.nextSibling;
                    let parent;
                    if (next != null) {
                        parent = next.parentNode;
                        if (parent == null) {
                            
                            parent = target;
                        } else if (parent != target) {
                            
                        }
                    } else {
                        parent = target;
                    }
                    for (let i: number = 0; i < count; ++i) {
                        const node = removed[i];
                        parent.insertBefore(node, next);
                    }
                }
                break;
            }
            default:
                Assert.notReach_(`${MSG.string_(RS.UnsupportedMutationRecordType_)}${type}`);
        }
    }

    redo_(): boolean {
        if (this._redo.length == 0) {
            return false;
        }
        const a = this._redo.pop();
        if (a instanceof _HistoryItem) {
            const labelkey: string = a.labelkey$;
            const label: string = MSG.string_(labelkey);
            
            this._startRedo();
            this.startGroup_(labelkey, a.detail$);
            for (const record of a.reversed$) {
                this._undo1(false, record);
            }
            this.endGroup_();
            this._endRedo();
            this._fireOnRedone(label);
        } else if (a instanceof MutationRecord) {
            this._startRedo();
            this._undo1(false, a);
            this._endRedo();
            this._fireOnRedone(null);
        }
        if (this._redo.length == 0) {
            this._fireOnRedoEmpty(true);
        }
        return true;
    }

    group_<T>(labelkey: StringId, detail: string, callback: Fun01<T>): T {
        this.startGroup_(labelkey, detail);
        try {
            return callback();
        } finally {
            this.endGroup_();
        }
    }

    asyncGroup_(labelkey: StringId, detail: string, callback: Fun10<Fun00>): void {
        this.startGroup_(labelkey, detail);
        callback(() => {
            this.endGroup_();
        });
    }

    startGroup_(labelkey: StringId, detail: string): void {
        if (this._body == null) {
            return;
        }
        this._groupStack.push(labelkey);
        if (this._groupStack.length == 1) {
            this._details.push(detail);
            this._body.setAttribute(ATTR.AnToggleGroup, labelkey);
        }
    }

    endGroup_(): void {
        if (this._body == null) {
            return;
        }
        if (this._groupStack.length != 0) {
            this._groupStack.pop();
            if (this._groupStack.length == 0) {
                this._body.setAttribute(ATTR.AnToggleGroup, "");
            }
        }
    }

    private _startUndo(): void {
        if (this._body == null) {
            return;
        }
        ++this._undoLevel;
        if (this._undoLevel == 1) {
            this._body.setAttribute(ATTR.AnUndoing, "true");
        }
    }

    private _endUndo(): void {
        if (this._body == null) {
            return;
        }
        if (this._undoLevel > 0) {
            --this._undoLevel;
            if (this._undoLevel == 0) {
                this._body.setAttribute(ATTR.AnUndoing, "");
            }
        }
    }

    private _startRedo(): void {
        if (this._body == null) {
            return;
        }
        ++this._redoLevel;
        if (this._redoLevel == 1) {
            this._body.setAttribute(ATTR.AnRedoing, "true");
        }
    }

    private _endRedo(): void {
        if (this._body == null) {
            return;
        }
        if (this._redoLevel > 0) {
            --this._redoLevel;
            if (this._redoLevel == 0) {
                this._body.setAttribute(ATTR.AnRedoing, "");
            }
        }
    }

    groups_(): string[] {
        return Array.from(this._groupStack);
    }

    isUndoEmpty_(): boolean {
        return this._history.length == 0;
    }

    isRedoEmpty_(): boolean {
        return this._redo.length == 0;
    }

    length_(): number {
        return this._history.length;
    }

    records(): IterableIterator<MutationRecord | _HistoryItem> {
        return this._history[Symbol.iterator]();
    }

    addOnUndoEmptyListener_(l: HistoryOnEmptyListener): void {
        this._onUndoEmptyListeners.push(l);
    }

    addOnUndoneListener_(l: HistoryOnUndoneListener): void {
        this._onUndoneListeners.push(l);
    }

    addOnRedoEmptyListener_(l: HistoryOnEmptyListener): void {
        this._onRedoEmptyListeners.push(l);
    }

    addOnRedoneListener_(l: HistoryOnUndoneListener): void {
        this._onRedoneListeners.push(l);
    }

    private _fireOnUndone(label: stringX): void {
        for (const listener of this._onUndoneListeners) {
            listener(label);
        }
    }

    private _fireOnUndoEmpty(isempty: boolean): void {
        for (const listener of this._onUndoEmptyListeners) {
            listener(isempty);
        }
    }

    private _fireOnRedone(label: stringX): void {
        for (const listener of this._onRedoneListeners) {
            listener(label);
        }
    }

    private _fireOnRedoEmpty(isempty: boolean): void {
        for (const listener of this._onRedoEmptyListeners) {
            listener(isempty);
        }
    }
}

const history$ = new CommandHistory(native$);

////////////////////////////////////////////////////////////////////////

type DateCallback = (date: DateTime, dateformat: string, timeformat: string, formatted: string) => void;
type OKCallback0<D extends IDialog> = (dialog: D, done: BoolCallback) => void;
type OKCallback1<D extends IDialog, T> = (dialog: D, value: T, done: BoolCallback) => void;
type OKCallback2<D extends IDialog, T1, T2> = (dialog: D, value1: T1, value2: T2, done: BoolCallback) => void;
type OKCallback3<D extends IDialog, T1, T2, T3> = (dialog: D, value1: T1, value2: T2, value3: T3, done: BoolCallback) => void;
type OKCallback4<D extends IDialog, T1, T2, T3, T4> = (
    dialog: D,
    value1: T1,
    value2: T2,
    value3: T3,
    value4: T4,
    done: BoolCallback
) => void;
type ImageContextmenuCallback = (dialog: ICompositeDialog, info: IDialogField, input: HTMLElement, x: number, y: number) => void;
type OnShowDialogCallback = (dialog: HTMLElement, smokescreen: Smokescreen) => void;
type PreviewCallback = (host: HTMLElement, url: string) => ImageViewerDialog | null;
type PromptColorCallback = (buttonsize: number, zindex: number, color: string, defcolor: ColorValue) => PromptColor;
type PromptCalendarCallback = (date: DateTime, width: string, height: string, datestring: string) => void;
type PromptEditTextCallback = (text: string, fontfamily: string, zindex: number, callback: (dialog: PromptEditText) => void) => void;
type PromptElementCallback = (tag: string, attrs: StringMap<stringX>) => void;
type PromptFilepathCallback = (path: string, basedir: stringX, zindex: number, callback: Fun10<string>) => void;
type PromptSymbolCallback = (text: string, tooltips: stringX, attrs: StringMap<stringX>) => void;
type PromptValuesChangeCallback = (field: IDialogField, input: HTMLElement | SelectOptions) => void;
type String4OKCallback<D extends IDialog> = (dialog: D, value1: string, value2: string, value3: string, value4: string, done: BoolCallback) => void;
type ThumbnailCallback = (fromcpath: string, baseuri: BaseUriX, dialog: IDialog, callback: Fun10<string>) => void;
type UriAttrsCallback = (uri: Uri, attrs: StringMap<string>) => void;
type UriXAttrsCallback = (uri: UriX, attrs: StringMap<string>) => void;
type UriXTextAttrsCallback = (uri: UriX, text: string, attrs: StringMap<string>) => void;
type PromptElementValidator = (tag: string, attributes: string, callback: JSONCallback) => void;
type StringValidatorCallback = (errors: any, sanitized: string) => void;
type StringValidator = (value: string, callback: StringValidatorCallback) => void;
type ValidatorCallback = (ok: BoolCallback) => void;
type HourFormatter = (h: number) => string;
type ZindexOption = HTMLElement | number | null;
type Rotations = "0 deg" | "90 deg" | "180 deg" | "270 deg";

////////////////////////////////////////////////////////////////////////

class INPUT {
    static readonly Filename = "XxXf0";
    static readonly PromptInputAutoFocus = "XxXE7";
    static readonly SearchBox = "XxX1h";
    static readonly PromptInput = "XxXS2";
    static readonly TextareaEditText = "XxXMK";
    static readonly LineNumber = "XxXbj";
    static readonly FilterBox = "XxXd0";
    static readonly TextareaOptionalAttributesFull = "XxXpm";
    static readonly _INFOS = smap_(
        [INPUT.Filename, smap_(
            ["class", CSS.AnFilename],
            ["rows", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocorrect, "off"],
            [ATTR.autocomplete, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.FilterBox, smap_(
            ["class", CSS.AnSearchbox],
            ["placeholder", MSG.string_(RS.Tooltips_Filter)],
            ["rows", "1"],
            ["tabindex", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.LineNumber, smap_(
            ["class", CSS.AnLineNumberInput],
            ["placeholder", ""],
            ["rows", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.PromptInput, smap_(
            ["class", CSS.AnPromptInput],
            ["rows", "1"],
            ["tabindex", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.PromptInputAutoFocus, smap_(
            ["class", CSS.AnPromptInput],
            ["placeholder", ""],
            ["rows", "1"],
            ["tabindex", "1"],
            ["autofocus", "true"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.SearchBox, smap_(
            ["class", CSS.AnSearchbox],
            ["placeholder", MSG.string_(RS.Tooltips_Search)],
            ["rows", "1"],
            ["tabindex", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
        [INPUT.TextareaEditText, smap_(
            ["class", `${CSS.AnPromptTextarea} ${CSS.AnFull}`],
            ["placeholder", MSG.string_(RS.Text)],
            ["tabindex", "1"],
            ["autofocus", "true"],
            ["style", "white-space:pre-wrap;min-height:20vh;max-height:40vh"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "on"],
            [ATTR.autocorrect, "on"],
            [ATTR.spellcheck, "true"],
        )],
        [INPUT.TextareaOptionalAttributesFull, smap_(
            ["class", `${CSS.AnPromptTextarea} ${CSS.AnFull} ${CSS.AnPromptAttributes}`],
            ["tabindex", "1"],
            ["placeholder", MSG.string_(RS.Attributes)],
            ["style", "word-break:break-all;"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )],
    );

    static info_(key: string): SStringMap {
        return INPUT._INFOS[key];
    }

    static searchbox(placeholderkey: StringId, tabindex: string): SStringMap {
        const ret = StringMap.copyOf_(INPUT._INFOS[INPUT.SearchBox]);
        ret["placeholder"] = MSG.string_(placeholderkey);
        ret["tabindex"] = tabindex;
        return ret;
    }

    static optionalAttributes(fullorhalf: string, tabindex: string): SStringMap {
        return smap_(
            ["class", `${CSS.AnPromptTextarea} ${fullorhalf} ${CSS.AnPromptAttributes}`],
            ["tabindex", tabindex],
            ["placeholder", MSG.string_(RS.Attributes)],
            ["style", "word-break:break-all;"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        );
    }
}

/* Valid buttons */
class BUT {
    static readonly CleanupTrash = "XxXYe";
    static readonly RemoveStyles = "XxXl6";
    static readonly Today = "XxXPC";
    static readonly ShowBackground = "XxXop";
    static readonly DeleteEmptyDirs = "XxXHX";
    static readonly PrevMatch = "XxX6D";
    static readonly Symbol = "XxX26";
    static readonly Reset = "XxXwV";
    static readonly Keyboard = "XxXhK";
    static readonly RegexSearch1 = "XxXJH";
    static readonly EditLink = "XxXkI";
    static readonly ClearSearchText1 = "XxX0T";
    static readonly ShowBrokenOnly = "XxX2d";
    static readonly Nobackup = "XxXH6";
    static readonly Apply = "XxXfW";
    static readonly Toolbar2 = "XxXHs";
    static readonly ImageConversion = "XxX8I";
    static readonly CreateThumbnail = "XxXqx";
    static readonly CopyToLocalClipboard = "XxXem";
    static readonly Crop = "XxXi4";
    static readonly Settings = "XxXj6";
    static readonly Save = "XxXUJ";
    static readonly Sort = "XxXKW";
    static readonly GenerateBarcode = "XxXpM";
    static readonly MoveUp = "XxXpZ";
    static readonly RemoveBrokenEntries = "XxXRe";
    static readonly Sync = "XxXRN";
    static readonly CutFile = "XxXN6";
    static readonly Gradient = "XxXZQ";
    static readonly Share = "XxXvU";
    static readonly Clear = "XxXt3";
    static readonly CloneObject = "XxXEa";
    static readonly CollapseAll = "XxXce";
    static readonly ClearHistory = "XxXnt";
    static readonly Searchbar = "XxXOB";
    static readonly PickImage = "XxXZ7";
    static readonly Glass = "XxXbC";
    static readonly Gradient1 = "XxXqP";
    static readonly BarcodeScan = "XxXUF";
    static readonly EditEvent = "XxXg7";
    static readonly After = "XxX6G";
    static readonly Help = "XxXxG";
    static readonly Hide = "XxXhid";
    static readonly Discard = "XxXYO";
    static readonly RuleAdd = "XxXc9";
    static readonly ImportImageFromPhotoLibrary = "XxXgA";
    static readonly Info = "XxXrm";
    static readonly ResetUISettings = "XxXpX";
    static readonly Color = "XxX2l";
    static readonly RulesetEdit = "XxX6V";
    static readonly ImageSource = "XxXox";
    static readonly ImageFilter1 = "XxXoe";
    static readonly NextMatch = "XxXUO";
    static readonly Undo = "XxXln";
    static readonly RootFolder = "XxXuO";
    static readonly RulesetRemove = "XxXvB";
    static readonly ExportToPhotoLibrary = "XxXv2";
    static readonly MoveDown = "XxXVm";
    static readonly Font = "XxXVI";
    static readonly Date = "XxXY1";
    static readonly Date1 = "XxXY11";
    static readonly NewGame = "XxXag";
    static readonly Recover = "XxXVE";
    static readonly ExtendSelection = "XxXyn";
    static readonly InitialDir = "XxXLN";
    static readonly RegenerateKey1 = "XxXH8";
    static readonly Up = "XxXpI";
    static readonly Cancel = "XxXLH";
    static readonly Folder1 = "XxXkQ";
    static readonly TakePhoto = "XxXaV";
    static readonly EscapeText = "XxXeV";
    static readonly OK = "XxXG5";
    static readonly DataUrl1 = "XxXBk";
    static readonly Remove = "XxXfx";
    static readonly ImportExportMove = "XxXou";
    static readonly Mkdir = "XxXmV";
    static readonly ScanDocument = "XxXqG";
    static readonly CurrentDocument = "XxXpG";
    static readonly CutToLocalClipboard = "XxXBq";
    static readonly Indent = "XxXa7";
    static readonly Toolbar = "XxXKI";
    static readonly ImportExportCopy = "XxXDv";
    static readonly CreateLink = "XxXgQ";
    static readonly RotateImage = "XxXKc";
    static readonly RegexSearch = "XxX1i";
    static readonly BackupVerify = "XxXsr";
    static readonly Border1 = "XxXbd1";
    static readonly ClearEvents = "XxXOe";
    static readonly PasteFromLocalClipboard = "XxXV8";
    static readonly PasteFromSystemClipboard = "XxXV8S";
    static readonly OpenDocument = "XxXTB";
    static readonly PathKind = "XxXKG";
    static readonly FixPerspective = "XxXBQ";
    static readonly FixBrokenLinks = "XxXfxr";
    static readonly Search = "XxX0J";
    static readonly Redo = "XxX5S";
    static readonly ShowDoneEvents = "XxXcW";
    static readonly ExportToFile = "XxXc4";
    static readonly BackupSelectKey1 = "XxXbn";
    static readonly Move = "XxXm8";
    static readonly GenerateGallery = "XxXpJ";
    static readonly OpenStylesheet = "XxXoC";
    static readonly Edit1 = "XxXN9";
    static readonly ImportKey = "XxXCC";
    static readonly Color1 = "XxX4G";
    static readonly Preview = "XxXLh";
    static readonly CloneFile = "XxXIG";
    static readonly Forward = "XxX2Z";
    static readonly Backward = "XxXbwd";
    static readonly IgnoreCaseFilter = "XxXSt";
    static readonly RecognizeText = "XxXWo";
    static readonly IgnoreCase = "XxX0r";
    static readonly Filter = "XxXtb";
    static readonly ExpandAll = "XxXCw";
    static readonly PasteFile = "XxXOp";
    static readonly BackupConversion = "XxXli";
    static readonly PauseMedia = "XxXpsm";
    static readonly Stop = "XxX0L";
    static readonly RenameFile = "XxXnu";
    static readonly Screenshot = "XxXbe";
    static readonly DeleteFile = "XxXBp";
    static readonly RecordAudio = "XxXCj";
    static readonly RecordVideo = "XxX6u";
    static readonly ExportKey1 = "XxXis";
    static readonly Toolbar1 = "XxXTA";
    static readonly NextPage = "XxXLt";
    static readonly TargetDocument = "XxXsI";
    static readonly Refresh = "XxXJt";
    static readonly CreateEvent = "XxXtg";
    static readonly DeleteKey1 = "XxX8o";
    static readonly DeleteColor1 = "XxXdco";
    static readonly PickImage1 = "XxXyF";
    static readonly PrevPage = "XxXfu";
    static readonly CopyFile = "XxXyo";
    static readonly BackupRestore = "XxXd4";
    static readonly Nbsp = "XxXDa";
    static readonly Child = "XxXGK";
    static readonly Contextmenu = "XxXZi";
    static readonly Edit = "XxXBw";
    static readonly Fit = "XxXXy";
    static readonly TargetDate = "XxXbc";
    static readonly Down = "XxXqs";
    static readonly ClearSearchText = "XxX2t";
    static readonly Dismiss = "XxXhF";
    static readonly NextBlog = "XxXFU";
    static readonly BackupAction = "XxXym";
    static readonly ShredFile = "XxX4O";
    static readonly RulesetAdd = "XxXyc";
    static readonly Clear1 = "XxXiy";
    static readonly Fsck = "XxXGU";
    static readonly RebuildXrefs = "XxXRxr";
    static readonly FixXrefs = "XxXxrd";
    static readonly Filterbar = "XxXCO";
    static readonly PlayAll = "XxXply";
    static readonly Noop = "XxXcJ";
    static readonly Zip = "XxXit";
    static readonly Folder = "XxXRj";
    static readonly Spacer = "XxXVk";
    static readonly PrevBlog = "XxXph";
    static readonly PrevMedia = "XxXpmd";
    static readonly NextMedia = "XxXnmd";
    static readonly _INFOS = smap_(
        [BUT.After, smap_(
            [ATTR.AnAction, BUT.After],
            [ATTR.xTooltips, RS.Tooltips_InsertAsNextSibling],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaHandODown}`],
        )],
        [BUT.Apply, smap_(
            [ATTR.AnAction, BUT.Apply],
            [ATTR.xTooltips, RS.Tooltips_Apply],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCheck}`],
        )],
        [BUT.BackupAction, smap_(
            [ATTR.AnAction, BUT.BackupAction],
            [ATTR.xTooltips, RS.BackupExportTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArchive}`],
        )],
        [BUT.BackupConversion, smap_(
            [ATTR.AnAction, BUT.BackupConversion],
            [ATTR.xTooltips, RS.BackupConversionTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaExchange}`],
        )],
        [BUT.BackupSelectKey1, smap_(
            [ATTR.AnAction, BUT.BackupSelectKey1],
            [ATTR.xTooltips, RS.BackupSelectKeyTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaKey}`],
        )],
        [BUT.BackupRestore, smap_(
            [ATTR.AnAction, BUT.BackupRestore],
            [ATTR.xTooltips, RS.Tooltips_RestoreData],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFolderOpen}`],
        )],
        [BUT.BackupVerify, smap_(
            [ATTR.AnAction, BUT.BackupVerify],
            [ATTR.xTooltips, RS.BackupVerifyTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCheckSquare}`],
        )],
        [BUT.Backward, smap_(
            [ATTR.AnAction, BUT.Backward],
            [ATTR.xTooltips, RS.Tooltips_GoBackInHistory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleLeft}`],
        )],
        [BUT.Border1, smap_(
            [ATTR.AnAction, BUT.Border1],
            [ATTR.xTooltips, RS.Border],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaSquareO}`],
        )],
        [BUT.Cancel, smap_(
            [ATTR.AnAction, BUT.Cancel],
            [ATTR.xTooltips, RS.Tooltips_Cancel],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaClose}`],
        )],
        [BUT.Child, smap_(
            [ATTR.AnAction, BUT.Child],
            [ATTR.xTooltips, RS.Tooltips_InsertAsFirstChild],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaHandORight}`],
        )],
        [BUT.CleanupTrash, smap_(
            [ATTR.AnAction, BUT.CleanupTrash],
            [ATTR.xTooltips, RS.Tooltips_Cleanup],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaShower}`],
        )],
        [BUT.Clear, smap_(
            [ATTR.AnAction, BUT.Clear],
            [ATTR.xTooltips, RS.Tooltips_Clear],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.Clear1, smap_(
            [ATTR.AnAction, BUT.Clear1],
            [ATTR.xTooltips, RS.Tooltips_Clear],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.ClearEvents, smap_(
            [ATTR.AnAction, BUT.ClearEvents],
            [ATTR.xTooltips, RS.Tooltips_ClearEvents],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.ClearHistory, smap_(
            [ATTR.AnAction, BUT.ClearHistory],
            [ATTR.xTooltips, RS.Tooltips_ClearHistory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.ClearSearchText, smap_(
            [ATTR.AnAction, BUT.ClearSearchText],
            [ATTR.xTooltips, RS.Tooltips_ClearSearchText],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.ClearSearchText1, smap_(
            [ATTR.AnAction, BUT.ClearSearchText1],
            [ATTR.xTooltips, RS.Tooltips_ClearSearchText],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.CloneFile, smap_(
            [ATTR.AnAction, BUT.CloneFile],
            [ATTR.xTooltips, RS.Tooltips_CloneFile],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaClone}`],
        )],
        [BUT.CloneObject, smap_(
            [ATTR.AnAction, BUT.CloneObject],
            [ATTR.xTooltips, RS.Tooltips_CloneObject],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaClone}`],
        )],
        [BUT.CollapseAll, smap_(
            [ATTR.AnAction, BUT.CollapseAll],
            [ATTR.xTooltips, RS.Tooltips_CollapseAll],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMinusSquareO}`],
        )],
        [BUT.Color, smap_(
            [ATTR.AnAction, BUT.Color],
            [ATTR.xTooltips, RS.Tooltips_PickColor],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSpinner}`],
        )],
        [BUT.Color1, smap_(
            [ATTR.AnAction, BUT.Color1],
            [ATTR.xTooltips, RS.Tooltips_PickColor],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaSpinner}`],
        )],
        [BUT.Contextmenu, smap_(
            [ATTR.AnAction, BUT.Contextmenu],
            [ATTR.xTooltips, RS.Tooltips_Contextmenu],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaToggleDown}`],
        )],
        [BUT.ImageConversion, smap_(
            [ATTR.AnAction, BUT.ImageConversion],
            [ATTR.xTooltips, RS.Tooltips_ImageConversion],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaExchange}`],
        )],
        [BUT.CopyFile, smap_(
            [ATTR.AnAction, BUT.CopyFile],
            [ATTR.xTooltips, RS.Tooltips_CopyFileOrDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCopy}`],
        )],
        [BUT.CopyToLocalClipboard, smap_(
            [ATTR.AnAction, BUT.CopyToLocalClipboard],
            [ATTR.xTooltips, RS.Tooltips_CopyToLocalClipboard],
            ["class", `${CSS.Fa} ${CSS.FaCopy}`],
        )],
        [BUT.CreateEvent, smap_(
            [ATTR.AnAction, BUT.CreateEvent],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlus}`],
            [ATTR.xTooltips, RS.Tooltips_CreateEvent],
        )],
        [BUT.CreateLink, smap_(
            [ATTR.AnAction, BUT.CreateLink],
            [ATTR.xTooltips, RS.Tooltips_CreateLink],
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat} ${CSS.Fa} ${CSS.FaLink}`],
        )],
        [BUT.CreateThumbnail, smap_(
            [ATTR.AnAction, BUT.CreateThumbnail],
            [ATTR.xTooltips, RS.Tooltips_CreateThumbnail],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaThumbsOUp}`],
        )],
        [BUT.Crop, smap_(
            [ATTR.AnAction, BUT.Crop],
            [ATTR.xTooltips, RS.CropTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCrop}`],
        )],
        [BUT.CutFile, smap_(
            [ATTR.AnAction, BUT.CutFile],
            [ATTR.xTooltips, RS.Tooltips_CutFileOrDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCut}`],
        )],
        [BUT.CutToLocalClipboard, smap_(
            [ATTR.AnAction, BUT.CutToLocalClipboard],
            [ATTR.xTooltips, RS.Tooltips_CutToLocalClipboard],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCut}`],
        )],
        [BUT.CurrentDocument, smap_(
            [ATTR.AnAction, BUT.CurrentDocument],
            [ATTR.xTooltips, RS.Tooltips_GotoCurrentDocumentDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFlag}`],
        )],
        [BUT.DataUrl1, smap_(
            [ATTR.AnAction, BUT.DataUrl1],
            [ATTR.xTooltips, RS.ButtonDataUrlTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaImage}`],
        )],
        [BUT.Date, smap_(
            [ATTR.AnAction, BUT.Date],
            [ATTR.xTooltips, RS.Tooltips_InsertDateTimeString],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaClockO}`],
        )],
        [BUT.Date1, smap_(
            [ATTR.AnAction, BUT.Date1],
            [ATTR.xTooltips, RS.Tooltips_InsertDateTimeString],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaCalendarO}`],
        )],
        [BUT.DeleteColor1, smap_(
            [ATTR.AnAction, BUT.DeleteColor1],
            [ATTR.xTooltips, RS.ActionDeleteColorTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [BUT.DeleteEmptyDirs, smap_(
            [ATTR.AnAction, BUT.DeleteEmptyDirs],
            [ATTR.xTooltips, RS.Tooltips_RemoveEmptyDirs],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFolder}`],
        )],
        [BUT.DeleteFile, smap_(
            [ATTR.AnAction, BUT.DeleteFile],
            [ATTR.xTooltips, RS.Tooltips_DeleteFileOrDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [BUT.DeleteKey1, smap_(
            [ATTR.AnAction, BUT.DeleteKey1],
            [ATTR.xTooltips, RS.BackupKeyDeleteTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [BUT.Discard, smap_(
            [ATTR.AnAction, BUT.Discard],
            [ATTR.xTooltips, RS.Tooltips_Discard],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTrash}`],
        )],
        [BUT.Dismiss, smap_(
            [ATTR.AnAction, BUT.Dismiss],
            [ATTR.xTooltips, RS.Tooltips_Dismiss],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaClose}`],
        )],
        [BUT.FixXrefs, smap_(
            [ATTR.AnAction, BUT.FixXrefs],
            [ATTR.xTooltips, RS.XrefsFixTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRandom}`],
        )],
        [BUT.Down, smap_(
            [ATTR.AnAction, BUT.Down],
            [ATTR.xTooltips, RS.Tooltips_Down],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowDown}`],
        )],
        [BUT.Edit, smap_(
            [ATTR.AnAction, BUT.Edit],
            [ATTR.xTooltips, RS.Tooltips_Edit],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [BUT.Edit1, smap_(
            [ATTR.AnAction, BUT.Edit1],
            [ATTR.xTooltips, RS.Tooltips_Edit],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [BUT.EditEvent, smap_(
            [ATTR.AnAction, BUT.EditEvent],
            [ATTR.xTooltips, RS.Tooltips_EditEvent],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [BUT.EditLink, smap_(
            [ATTR.AnAction, BUT.EditLink],
            [ATTR.xTooltips, RS.Tooltips_EditLink],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTerminal}`],
        )],
        [BUT.EscapeText, smap_(
            [ATTR.AnAction, BUT.EscapeText],
            [ATTR.xTooltips, RS.Tooltips_EscapeText],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaHashtag}`],
        )],
        [BUT.ExpandAll, smap_(
            [ATTR.AnAction, BUT.ExpandAll],
            [ATTR.xTooltips, RS.Tooltips_ExpandAll],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlusSquareO}`],
        )],
        [BUT.ExportKey1, smap_(
            [ATTR.AnAction, BUT.ExportKey1],
            [ATTR.xTooltips, RS.BackupKeyExportTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaUpload}`],
        )],
        [BUT.ExportToFile, smap_(
            [ATTR.AnAction, BUT.ExportToFile],
            [ATTR.xTooltips, RS.Tooltips_ExportToFile],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSignOut}`],
        )],
        [BUT.ExtendSelection, smap_(
            [ATTR.AnAction, BUT.ExtendSelection],
            [ATTR.xTooltips, RS.Tooltips_ExtendSelection],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleDown}`],
        )],
        [BUT.Filter, smap_(
            [ATTR.AnAction, BUT.Filter],
            [ATTR.xTooltips, RS.Tooltips_Filter],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFilter}`],
        )],
        [BUT.Filterbar, smap_(
            [ATTR.AnAction, BUT.Filterbar],
            [ATTR.xTooltips, RS.Tooltips_Filterbar],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFilter}`],
        )],
        [BUT.Fit, smap_(
            [ATTR.AnAction, BUT.Fit],
            [ATTR.xTooltips, RS.Tooltips_Fit],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaExpand}`],
        )],
        [BUT.FixPerspective, smap_(
            [ATTR.AnAction, BUT.FixPerspective],
            [ATTR.xTooltips, RS.FixPerspectiveTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCube}`],
        )],
        [BUT.FixBrokenLinks, smap_(
            [ATTR.AnAction, BUT.FixBrokenLinks],
            [ATTR.xTooltips, RS.ActionFixBrokenLinksTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaLink}`],
        )],
        [BUT.Folder, smap_(
            [ATTR.AnAction, BUT.Folder],
            [ATTR.xTooltips, RS.Tooltips_PickFile],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFolderOpen}`],
        )],
        [BUT.Folder1, smap_(
            [ATTR.AnAction, BUT.Folder1],
            [ATTR.xTooltips, RS.Tooltips_PickFile],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaFolderOpen}`],
        )],
        [BUT.Font, smap_(
            [ATTR.AnAction, BUT.Font],
            [ATTR.xTooltips, RS.Tooltips_PickFont],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFont}`],
        )],
        [BUT.Forward, smap_(
            [ATTR.AnAction, BUT.Forward],
            [ATTR.xTooltips, RS.Tooltips_GoForwardInHistory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleRight}`],
        )],
        [BUT.Fsck, smap_(
            [ATTR.AnAction, BUT.Fsck],
            [ATTR.xTooltips, RS.FilesFsckTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCheck}`],
        )],
        [BUT.GenerateGallery, smap_(
            [ATTR.AnAction, BUT.GenerateGallery],
            [ATTR.xTooltips, RS.Tooltips_GenerateGallery],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSlideshare}`],
        )],
        [BUT.Gradient, smap_(
            [ATTR.AnAction, BUT.Gradient],
            [ATTR.xTooltips, RS.Tooltips_Gradient],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaBarcode}`],
        )],
        [BUT.Gradient1, smap_(
            [ATTR.AnAction, BUT.Gradient1],
            [ATTR.xTooltips, RS.Tooltips_Gradient],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaBarcode}`],
        )],
        [BUT.Glass, smap_(
            [ATTR.AnAction, BUT.Glass],
            [ATTR.xTooltips, RS.widgetGlassMessage],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaWindows}`],
        )],
        [BUT.Keyboard, smap_(
            [ATTR.AnAction, BUT.Keyboard],
            [ATTR.xTooltips, RS.Tooltips_ToggleKeyboard],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaKeyboardO}`],
        )],
        [BUT.Help, smap_(
            [ATTR.AnAction, BUT.Help],
            [ATTR.xTooltips, RS.Tooltips_Help],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaQuestionCircle}`],
            ["style", "display:none"],
        )],
        [BUT.Hide, smap_(
            [ATTR.AnAction, BUT.Hide],
            [ATTR.xTooltips, RS.Tooltips_ToggleHidden],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEyeSlash}`],
        )],
        [BUT.IgnoreCase, smap_(
            [ATTR.AnAction, BUT.IgnoreCase],
            [ATTR.xTooltips, RS.Tooltips_IgnoreCase],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaInfo}`],
        )],
        [BUT.IgnoreCaseFilter, smap_(
            [ATTR.AnAction, BUT.IgnoreCaseFilter],
            [ATTR.xTooltips, RS.Tooltips_IgnoreCase],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaInfo}`],
        )],
        [BUT.ImageSource, smap_(
            [ATTR.AnAction, BUT.ImageSource],
            [ATTR.xTooltips, RS.ActionImageSourceTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaImage}`],
        )],
        [BUT.ImportExportCopy, smap_(
            [ATTR.AnAction, BUT.ImportExportCopy],
            [ATTR.xTooltips, RS.Tooltips_ImportExportCopy],
            ["class", `${CSS.Fa} ${CSS.FaAmbulance}`],
        )],
        [BUT.ImportExportMove, smap_(
            [ATTR.AnAction, BUT.ImportExportMove],
            [ATTR.xTooltips, RS.Tooltips_ImportExportMove],
            ["class", `${CSS.Fa} ${CSS.FaTruck}`],
        )],
        [BUT.ImageFilter1, smap_(
            [ATTR.AnAction, BUT.ImageFilter1],
            [ATTR.xTooltips, RS.ImageFilter],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaFilter}`],
        )],
        [BUT.ImportKey, smap_(
            [ATTR.AnAction, BUT.ImportKey],
            [ATTR.xTooltips, RS.BackupKeyImportTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlus}`],
        )],
        [BUT.Indent, smap_(
            [ATTR.AnAction, BUT.Indent],
            [ATTR.xTooltips, RS.Tooltips_Indent],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaIndent}`],
        )],
        [BUT.Info, smap_(
            [ATTR.AnAction, BUT.Info],
            [ATTR.xTooltips, RS.Tooltips_Info],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaInfoCircle}`],
        )],
        [BUT.InitialDir, smap_(
            [ATTR.AnAction, BUT.InitialDir],
            [ATTR.xTooltips, RS.Tooltips_GotoInitialDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFlag}`],
        )],
        [BUT.Mkdir, smap_(
            [ATTR.AnAction, BUT.Mkdir],
            [ATTR.xTooltips, RS.Tooltips_CreateDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFolderOpenO}`],
        )],
        [BUT.OpenDocument, smap_(
            [ATTR.AnAction, BUT.OpenDocument],
            [ATTR.xTooltips, RS.Tooltips_OpenOrAddPage],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMagic}`],
        )],
        [BUT.Nobackup, smap_(
            [ATTR.AnAction, BUT.Nobackup],
            [ATTR.xTooltips, RS.Tooltips_ToggleNobackup],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaBan}`],
        )],
        [BUT.Move, smap_(
            [ATTR.AnAction, BUT.Move],
            [ATTR.xTooltips, RS.Tooltips_Move],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrows}`],
        )],
        [BUT.MoveDown, smap_(
            [ATTR.AnAction, BUT.MoveDown],
            [ATTR.xTooltips, RS.Tooltips_MoveDown],
            ["class", `${CSS.Fa} ${CSS.FaAngleDoubleDown}`],
        )],
        [BUT.MoveUp, smap_(
            [ATTR.AnAction, BUT.MoveUp],
            [ATTR.xTooltips, RS.Tooltips_MoveUp],
            ["class", `${CSS.Fa} ${CSS.FaAngleDoubleUp}`],
        )],
        [BUT.Nbsp, smap_(
            [ATTR.AnAction, BUT.Nbsp],
            [ATTR.xTooltips, RS.Tooltips_InsertNonBreakSpace],
            ["class", `${CSS.AnButton} ${CSS.AnFaNbsp}`],
        )],
        [BUT.NextBlog, smap_(
            [ATTR.AnAction, BUT.NextBlog],
            [ATTR.xTooltips, RS.Tooltips_NextBlog],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaChevronRight}`],
        )],
        [BUT.NextMedia, smap_(
            [ATTR.AnAction, BUT.NextMedia],
            [ATTR.xTooltips, RS.ActionPlayAllNextMediaTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaChevronRight}`],
        )],
        [BUT.NextMatch, smap_(
            [ATTR.AnAction, BUT.NextMatch],
            [ATTR.xTooltips, RS.Tooltips_NextMatch],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleDown}`],
        )],
        [BUT.NextPage, smap_(
            [ATTR.AnAction, BUT.NextPage],
            [ATTR.xTooltips, RS.Tooltips_NextPage],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowRight}`],
        )],
        [BUT.Noop, smap_(
            [ATTR.AnAction, DEF.NOOP],
        )],
        [BUT.OK, smap_(
            [ATTR.AnAction, BUT.OK],
            [ATTR.xTooltips, RS.Tooltips_OK],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCheck}`],
        )],
        [BUT.OpenStylesheet, smap_(
            [ATTR.AnAction, BUT.OpenStylesheet],
            [ATTR.xTooltips, RS.Tooltips_EditStylesheet],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFolderOpenO}`],
        )],
        [BUT.PasteFromLocalClipboard, smap_(
            [ATTR.AnAction, BUT.PasteFromLocalClipboard],
            [ATTR.xTooltips, RS.Tooltips_PasteFromLocalClipboard],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPaste}`],
        )],
        [BUT.PasteFile, smap_(
            [ATTR.AnAction, BUT.PasteFile],
            [ATTR.xTooltips, RS.Tooltips_PasteFileOrDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPaste}`],
        )],
        [BUT.PathKind, smap_(
            [ATTR.AnAction, BUT.PathKind],
            [ATTR.xTooltips, RS.Tooltips_PathKind],
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat} ${CSS.AnFaSlash}`],
        )],
        [BUT.PauseMedia, smap_(
            [ATTR.AnAction, BUT.PauseMedia],
            [ATTR.xTooltips, RS.ActionPlayAllPauseTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPause}`],
        )],
        [BUT.PlayAll, smap_(
            [ATTR.AnAction, BUT.PlayAll],
            [ATTR.xTooltips, RS.ActionPlayAllMediasTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlay}`],
        )],
        [BUT.PickImage, smap_(
            [ATTR.AnAction, BUT.PickImage],
            [ATTR.xTooltips, RS.Tooltips_ImagePicker],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTh}`],
        )],
        [BUT.PickImage1, smap_(
            [ATTR.AnAction, BUT.PickImage1],
            [ATTR.xTooltips, RS.Tooltips_ImagePicker],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaTh}`],
        )],
        [BUT.PrevBlog, smap_(
            [ATTR.AnAction, BUT.PrevBlog],
            [ATTR.xTooltips, RS.Tooltips_PreviousBlog],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaChevronLeft}`],
        )],
        [BUT.PrevMedia, smap_(
            [ATTR.AnAction, BUT.PrevMedia],
            [ATTR.xTooltips, RS.ActionPlayAllPrevMediaTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaChevronLeft}`],
        )],
        [BUT.PrevMatch, smap_(
            [ATTR.AnAction, BUT.PrevMatch],
            [ATTR.xTooltips, RS.Tooltips_PreviousMatch],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleUp}`],
        )],
        [BUT.PrevPage, smap_(
            [ATTR.AnAction, BUT.PrevPage],
            [ATTR.xTooltips, RS.Tooltips_PreviousPage],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowLeft}`],
        )],
        [BUT.BarcodeScan, smap_(
            [ATTR.AnAction, BUT.BarcodeScan],
            [ATTR.xTooltips, RS.BarcodeScanTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaQrcode}`],
        )],
        [BUT.GenerateBarcode, smap_(
            [ATTR.AnAction, BUT.GenerateBarcode],
            [ATTR.xTooltips, RS.BarcodeGenerateTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaQrcode}`],
        )],
        [BUT.RebuildXrefs, smap_(
            [ATTR.AnAction, BUT.RebuildXrefs],
            [ATTR.xTooltips, RS.XrefsRebuildTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRandom}`],
        )],
        [BUT.Recover, smap_(
            [ATTR.AnAction, BUT.Recover],
            [ATTR.xTooltips, RS.Tooltips_Recover],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRecycle}`],
        )],
        [BUT.Redo, smap_(
            [ATTR.AnAction, BUT.Redo],
            [ATTR.xTooltips, RS.Tooltips_Redo],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaShare}`],
        )],
        [BUT.Refresh, smap_(
            [ATTR.AnAction, BUT.Refresh],
            [ATTR.xTooltips, RS.Tooltips_Refresh],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRefresh}`],
        )],
        [BUT.RegenerateKey1, smap_(
            [ATTR.AnAction, BUT.RegenerateKey1],
            [ATTR.xTooltips, RS.BackupKeyRegenerateTooltips],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaMagic}`],
        )],
        [BUT.RegexSearch, smap_(
            [ATTR.AnAction, BUT.RegexSearch],
            [ATTR.xTooltips, RS.Tooltips_RegexSearch],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSearchPlus}`],
        )],
        [BUT.RegexSearch1, smap_(
            [ATTR.AnAction, BUT.RegexSearch1],
            [ATTR.xTooltips, RS.Tooltips_RegexSearch],
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaSearchPlus}`],
        )],
        [BUT.Remove, smap_(
            [ATTR.AnAction, BUT.Remove],
            [ATTR.xTooltips, RS.Tooltips_Remove],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [BUT.RemoveBrokenEntries, smap_(
            [ATTR.AnAction, BUT.RemoveBrokenEntries],
            [ATTR.xTooltips, RS.Tooltips_RemoveBrokenEntries],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaUnlink}`],
        )],
        [BUT.RecordAudio, smap_(
            [ATTR.AnAction, BUT.RecordAudio],
            [ATTR.xTooltips, RS.Tooltips_RecordAudio],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMicrophone}`],
        )],
        [BUT.RecordVideo, smap_(
            [ATTR.AnAction, BUT.RecordVideo],
            [ATTR.xTooltips, RS.Tooltips_RecordVideo],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaVideoCamera}`],
        )],
        [BUT.RenameFile, smap_(
            [ATTR.AnAction, BUT.RenameFile],
            [ATTR.xTooltips, RS.Tooltips_RenameFileOrDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTerminal}`],
        )],
        [BUT.RemoveStyles, smap_(
            [ATTR.AnAction, BUT.RemoveStyles],
            [ATTR.xTooltips, RS.Tooltips_RemoveStyles],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.Reset, smap_(
            [ATTR.AnAction, BUT.Reset],
            [ATTR.xTooltips, RS.Tooltips_Reset],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.ResetUISettings, smap_(
            [ATTR.AnAction, BUT.ResetUISettings],
            [ATTR.xTooltips, RS.ResetUserSettingsTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
        )],
        [BUT.RootFolder, smap_(
            [ATTR.AnAction, BUT.RootFolder],
            [ATTR.xTooltips, RS.Tooltips_RootFolder],
            ["class", `${CSS.AnButton} ${CSS.AnLink} ${CSS.Fa} ${CSS.FaBookmarkO}`],
        )],
        [BUT.RotateImage, smap_(
            [ATTR.AnAction, BUT.RotateImage],
            [ATTR.xTooltips, RS.Tooltips_RotateImage],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRotateRight}`],
        )],
        [BUT.RuleAdd, smap_(
            [ATTR.AnAction, BUT.RuleAdd],
            [ATTR.xTooltips, RS.Tooltips_AddRule],
            ["class", `${CSS.AnButton} ${CSS.Noto} ${CSS.NotoColon}`],
        )],
        [BUT.RulesetAdd, smap_(
            [ATTR.AnAction, BUT.RulesetAdd],
            [ATTR.xTooltips, RS.Tooltips_AddRuleset],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlus}`],
        )],
        [BUT.RulesetEdit, smap_(
            [ATTR.AnAction, BUT.RulesetEdit],
            [ATTR.xTooltips, RS.Tooltips_EditRuleset],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [BUT.RulesetRemove, smap_(
            [ATTR.AnAction, BUT.RulesetRemove],
            [ATTR.xTooltips, RS.Tooltips_RemoveRuleset],
            ["class", `${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [BUT.Save, smap_(
            [ATTR.AnAction, BUT.Save],
            [ATTR.xTooltips, RS.Tooltips_Save],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSave}`],
        )],
        [BUT.Search, smap_(
            [ATTR.AnAction, BUT.Search],
            [ATTR.xTooltips, RS.Tooltips_Search],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSearch}`],
        )],
        [BUT.Searchbar, smap_(
            [ATTR.AnAction, BUT.Searchbar],
            [ATTR.xTooltips, RS.Tooltips_SearchBar],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSearch}`],
        )],
        [BUT.Preview, smap_(
            [ATTR.AnAction, BUT.Preview],
            [ATTR.xTooltips, RS.PreviewTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEye}`],
        )],
        [BUT.Screenshot, smap_(
            [ATTR.AnAction, BUT.Screenshot],
            [ATTR.xTooltips, RS.ActionScreenshotTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCameraRetro}`],
        )],
        [BUT.Settings, smap_(
            [ATTR.AnAction, BUT.Settings],
            [ATTR.xTooltips, RS.Tooltips_Settings],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaGear}`],
        )],
        [BUT.Share, smap_(
            [ATTR.AnAction, BUT.Share],
            [ATTR.xTooltips, RS.ShareTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaShareAlt}`],
        )],
        [BUT.ShowBrokenOnly, smap_(
            [ATTR.AnAction, BUT.ShowBrokenOnly],
            [ATTR.xTooltips, RS.Tooltips_ToggleShowBrokenLinksOnly],
            ["class", `${CSS.AnButton} ${CSS.AnToggleOff} ${CSS.Fa} ${CSS.FaUnlink}`],
        )],
        [BUT.ShowDoneEvents, smap_(
            [ATTR.AnAction, BUT.ShowDoneEvents],
            [ATTR.xTooltips, RS.Tooltips_ShowOrHideDoneEvents],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCheckSquare}`],
        )],
        [BUT.ShredFile, smap_(
            [ATTR.AnAction, BUT.ShredFile],
            [ATTR.xTooltips, RS.ActionShredTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaStackExchange}`],
        )],
        [BUT.Sort, smap_(
            [ATTR.AnAction, BUT.Sort],
            [ATTR.xTooltips, RS.Tooltips_SortAlphaAsc],
            ["class", `${CSS.AnButton} ${CSS.AnToggleOff} ${CSS.Fa} ${CSS.FaSortAlphaAsc}`],
        )],
        [BUT.Spacer, smap_(
            ["class", CSS.AnFlex11Auto],
        )],
        [BUT.Stop, smap_(
            [ATTR.AnAction, BUT.Stop],
            [ATTR.xTooltips, RS.Tooltips_StopAudioPlayback],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaStop}`],
        )],
        [BUT.Symbol, smap_(
            [ATTR.AnAction, BUT.Symbol],
            [ATTR.xTooltips, RS.Tooltips_InsertSymbol],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSmileO}`],
        )],
        [BUT.Sync, smap_(
            [ATTR.AnAction, BUT.Sync],
            [ATTR.xTooltips, RS.BackupSyncFilesActionTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRefresh}`],
        )],
        [BUT.TakePhoto, smap_(
            [ATTR.AnAction, BUT.TakePhoto],
            [ATTR.xTooltips, RS.Tooltips_TakePhoto],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaCamera}`],
        )],
        [BUT.TargetDocument, smap_(
            [ATTR.AnAction, BUT.TargetDocument],
            [ATTR.xTooltips, RS.Tooltips_GotoTargetDocumentDirectory],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaDotCircleO}`],
        )],
        [BUT.TargetDate, smap_(
            [ATTR.AnAction, BUT.TargetDate],
            [ATTR.xTooltips, RS.Tooltips_TargetDate],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaDotCircleO}`],
        )],
        [BUT.Today, smap_(
            [ATTR.AnAction, BUT.Today],
            [ATTR.xTooltips, RS.Tooltips_Today],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFlag}`],
        )],
        [BUT.Toolbar, smap_(
            [ATTR.AnAction, BUT.Toolbar],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
        )],
        [BUT.Toolbar1, smap_(
            [ATTR.AnAction, BUT.Toolbar1],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
        )],
        [BUT.Toolbar2, smap_(
            [ATTR.AnAction, BUT.Toolbar2],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
        )],
        [BUT.Undo, smap_(
            [ATTR.AnAction, BUT.Undo],
            [ATTR.xTooltips, RS.Tooltips_Undo],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaReply}`],
        )],
        [BUT.Up, smap_(
            [ATTR.AnAction, BUT.Up],
            [ATTR.xTooltips, RS.Tooltips_Up],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowUp}`],
        )],
        [BUT.Zip, smap_(
            [ATTR.AnAction, BUT.Zip],
            [ATTR.xTooltips, RS.ZipTooltips],
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFileArchiveO}`],
        )],
    );
    static readonly infosCancel = [BUT._INFOS[BUT.Cancel]];
    static readonly infosOKCancel = [BUT._INFOS[BUT.OK], BUT._INFOS[BUT.Cancel]];
    static readonly infosCopyPasteOKCancel = [
        BUT._INFOS[BUT.CopyToLocalClipboard],
        BUT._INFOS[BUT.PasteFromLocalClipboard],
        BUT._INFOS[BUT.OK],
        BUT._INFOS[BUT.Cancel]
    ];
    static readonly infosHelpCopyPasteOKCancel = [
        BUT._INFOS[BUT.Help],
        BUT._INFOS[BUT.CopyToLocalClipboard],
        BUT._INFOS[BUT.PasteFromLocalClipboard],
        BUT._INFOS[BUT.OK],
        BUT._INFOS[BUT.Cancel]
    ];

    static infos_(...keys: string[]): Array<SStringMap> {
        const ret = [];
        for (let key of keys) {
            ret.push(BUT._INFOS[key]);
        }
        return ret;
    }

    static info_(key: string): SStringMap {
        return BUT._INFOS[key];
    }
}

const toasters$ = new Toasters(document.body);
const searchSpotlight$ = new Spotlight(document.body, DEFUtil.searchHighlightDuration$);

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class DialogDraggerHandler extends DefaultDraggerHandler {
    constructor() {
        super((_dragger: Dragger, target: EventTarget, _x: number, _y: number) => {
            const elm = DomUt.asHTMLElement_(target);
            return (elm != null) &&
                (elm.nodeName == "TABLE" || elm.nodeName == "DIV") &&
                (elm.classList.contains(CSS.AnDialog) || elm.classList.contains(CSS.AnTitle));
        });
    }
}

abstract class DialogBase implements IDialog, IUriParser, IWarner {
    protected _dialog!: HTMLElement;
    protected _table!: HTMLElement;
    protected _toolbar: Toolbar | null = null;
    protected _message: HTMLElementX = null;
    protected _status: HTMLElementX = null;
    protected _smokescreen: Smokescreen | null = null;
    protected _dragger: Dragger | null = null;
    protected _cancelCallback: Fun00 | null = null;
    protected _confirmCancelCallback: ConfirmCallback | null = null;
    protected _onShowDialogCallback: OnShowDialogCallback | null = null;
    protected _clipboardGetter = Callbacks.pasteFromClipboard_;
    protected _clipboardSetter = Callbacks.copyToClipboard_;
    protected _busy: boolean = false;
    protected _shown: boolean = false;
    protected _labelWidth = DEF.BASIS_34;
    protected _tabIndex = 0;
    protected _zindex = DEF.zindexPrompt;
    protected _maxWidthMultipler = DEF.dialogMaxWidthMedium;
    protected _smokescreenOpacity = DEF.opacityTransparent;

    private _helpCallback: ToasterCallback | null = null;
    private _resizeRateLimiter: IRateLimiter = new RateLimiter(250);
    private _subscriptions: StreamSubscription[] = [];
    #destroyed0 = false;

    /// Configs
    protected _allowTouchmove(): boolean {
        return true;
    }

    /**
       * @param container The DOM element that host the dialog.
       */
    constructor(
        protected _container: HTMLElement,
        protected _dragHandler: IDraggerHandler | null = new DialogDraggerHandler()
    ) { }

    protected init_(dialog: HTMLElement): void {
        this._dialog = dialog;
        this._dialog.style.pointerEvents = "auto";
        if (!this._allowTouchmove()) {
            const listener = An.subscriptEvent_(this._dialog, "touchmove", (e) => {
                
                e.preventDefault();
            });
            this._subscriptions.push(listener);
        }
        this._dialog.addEventListener("contextmenu", An.sinkhole_);
        for (let elm of new ItemsIterable(this._dialog.querySelectorAll<HTMLTextAreaElement>(`textarea.${CSS.AnPromptInput}`))) {
            An.onKeypress_(elm, (e) => {
                if (e.key == "Enter") {
                    An.stopevent_(e);
                }
            });
        }
        this._table = this._dialog.firstChild as HTMLElement;
    }

    get labelWidth$(): number { return this._labelWidth; };
    get clipboardSetter$(): ClipboardSetter { return this._clipboardSetter; };
    get clipboardGetter$(): ClipboardGetter { return this._clipboardGetter; };

    container_(): HTMLElement {
        return this._container;
    }

    element_(): HTMLElement {
        return this._dialog;
    }

    tabIndex_(): string {
        return `${++this._tabIndex}`;
    }

    titleKey_(titlekey: string): this {
        this._toolbar?.titleKey_(titlekey);
        return this;
    }

    titleText_(title: string): this {
        this._toolbar?.titleText_(title);
        return this;
    }

    maxWidthMultipler_(multipler: number): this {
        this._maxWidthMultipler = multipler;
        return this;
    }

    largeWidth_(): this {
        this._maxWidthMultipler = DEF.dialogMaxWidthLarge;
        return this;
    }

    smallWidth_(): this {
        this._maxWidthMultipler = DEF.dialogMaxWidthSmall;
        return this;
    }

    message_(msg: TestResult): this {
        
        this._setmsg(this._message, msg, false);
        return this;
    }

    messageKey_(msgkey: string): this {
        
        this._setmsgtext(this._message, MSG.string_(msgkey));
        return this;
    }

    private zindex1_(zindex: number): this {
        this._zindex = zindex;
        this._dialog.style.zIndex = `${zindex}`;
        return this;
    }

    zindex_(zindex: HTMLElement | number | null, delta: numberX = null): this {
        return this.zindex1_(zindex == null
            ? DEF.zindexPrompt + (delta == null ? 0 : delta)
            : typeof (zindex) == "number"
                ? zindex + (delta == null ? 0 : delta)
                : An.zindexOf_(zindex, delta == null ? DEF.zindexAbove10 : delta, DEF.zindexPrompt));
    }

    above_(host: HTMLElement | number | null, delta: numberX = null): this {
        return this.zindex_(host, delta);
    }

    smokescreenOpacity_(value: number): this {
        this._smokescreenOpacity = value;
        return this;
    }

    onDrag_(handler: IDraggerHandler): this {
        this._dragHandler = handler;
        return this;
    }

    onCancel_(callback: Fun00): this {
        this._cancelCallback = callback;
        return this;
    }

    onConfirmCancel_(callback: ConfirmCallback | null): this {
        this._confirmCancelCallback = callback;
        return this;
    }

    onHelp_(callback: ToasterCallback): this {
        const button = this._toolbar?.button_(BUT.Help) ?? null;
        
        if (button == null) {
            return this;
        }
        this._helpCallback = callback;
        this._toolbar?.showButton_(BUT.Help, true);
        return this;
    }

    onHelpMessage_(help: string[]): this {
        return this.onHelp_((_t, b) => {
            this._helpMessage(b, help);
        });
    }

    /// Simple help toaster.
    protected _helpMessage(b: DomBuilderEx, help: string[]): void {
        b.push_().div_({
            "class": CSS.AnViewport,
            "style": "white-space:normal;font-size:small"
        });
        for (let s of help) {
            b.text_(s);
            b.append_("br");
        }
        b.pop_();
    }

    protected _onWindowResize(resizer: Fun00): void {
        this._subscriptions.push(An.subscriptEvent_(window, "resize", () => {
            this._resizeRateLimiter.queue_(() => {
                resizer();
            }, An.now_());
        }));
    }

    getStatusText_(): stringX {
        if (this._status != null) {
            return this._status.textContent;
        }
        return null;
    }

    onShowDialog_(callback: OnShowDialogCallback): void {
        this._onShowDialogCallback = callback;
    }

    /// Override this to customize _smokescreen. Call super.onSmokescreenCreated().
    onSmokescreenCreated_(_sm: Smokescreen): void { }

    addSubscription_(a: StreamSubscription): void {
        this._subscriptions.push(a);
    }

    show_(): this {
        if (!this._dialog) { throw new Error(); }
        if (this._shown) { return this; }
        this._shown = true;
        this.showDialog_(() => this._onResize());
        return this;
    }

    showError_(): void {
        this._dialog.classList.add(CSS.AnError);
        this.show_();
    }

    showWarning_(): void {
        this._dialog.classList.add(CSS.AnWarning);
        this.show_();
    }

    showOK_(): void {
        this._dialog.classList.add(CSS.AnOK);
        this.show_();
    }

    showDialog_(resizer: Fun10<DialogBase>): void {
        An.showHidden_(this._dialog, "block");
        let sm = this._smokescreen;
        if (sm == null) {
            sm = new Smokescreen(this._container);
            this._smokescreen = sm;
            this.onSmokescreenCreated_(this._smokescreen);
            for (let elm of DomUt.queryAll_(this._dialog, "input, textarea, select")) {
                if (elm.getAttribute(ATTR.AnNoClick) != null) continue;
                elm.addEventListener("click", () => {
                    this.clearStatus_();
                });
            }
            if (resizer != null) {
                resizer(this);
                this._onWindowResize(() => {
                    resizer(this);
                });
            }
            if (this._dragger == null && this._dragHandler != null) {
                this._dragger = new Dragger(this._dialog, this._dragHandler).bind_();
            }
        }
        sm.zindex_(An.zindexOf_(this._dialog, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
        sm.opacity_(this._smokescreenOpacity);
        sm.show_((sm: Smokescreen) => {
            if (this._onShowDialogCallback != null) {
                this._onShowDialogCallback(this._dialog, sm);
            } else {
                An.setVisible_(this._dialog);
                Timer.sleep0_(() => this.setInitialFocus_());
            }
        });
    }

    protected _onResize(): void {
        const element = this.element_();
        const table = this._table;
        if (element == null || table == null) return;
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        const minxmargin = 20;
        const toolbarheight = this._getToolbarHeight();
        const maxwidth = Math.min(winwidth - minxmargin * 2, toolbarheight * this._maxWidthMultipler);
        const bound = table.getBoundingClientRect();
        const width = this.constraintTableWidth_(toolbarheight, maxwidth, maxwidth, Math.round(bound.width));
        const height = Math.round(bound.height);
        let ymargin = toolbarheight * 2;
        if (ymargin + height + 20 >= winheight) ymargin = 20;
        table.style.width = `${width}px`;
        const xmargin = (winwidth - width) / 2;
        const style = element.style;
        style.left = `${xmargin}px`;
        style.top = `${ymargin}px`;
        const tdwidth = this.getTableCellWidth_(table, width, toolbarheight);
        
        if (!(Conf.useTouch$ ?? true)) {
            style.minWidth = "0";
            table.style.minWidth = "0";
        }
        const tdwidthpx = `${tdwidth}px`;
        for (let tr of new ItemsIterable(table.children)) {
            for (let td of new ItemsIterable(tr.children)) {
                (td as HTMLElement).style.maxWidth = tdwidthpx;
            }
        }
    }

    showAt_(x: numberX, y: numberX, hcenter: boolean = false): this {
        this.showDialog_(() => {
            
            const winwidth = window.innerWidth;
            const winheight = window.innerHeight;
            const bound = this._dialog.getBoundingClientRect();
            const minxmargin = winwidth / 16;
            const width = bound.width;
            let xx: number;
            let yy: number;
            if (x == null) {
                const xmargin = (winwidth - width);
                if (xmargin < minxmargin) {
                    xx = minxmargin;
                } else {
                    xx = xmargin / 2;
                }
            } else {
                xx = hcenter ? x - width / 2 - minxmargin : x - width - minxmargin;
                if (xx < 0) {
                    const xxx = x + minxmargin + width - winwidth;
                    if (xxx <= 0) {
                        xx = x + minxmargin;
                    } else if (xxx < -xx) {
                        xx = winwidth - width;
                    } else {
                        xx = 0;
                    }
                }
            }
            if (y == null) {
                yy = winheight / 16;
            } else {
                const height = bound.height;
                if (height == null) {
                    yy = winheight / 16;
                } else {
                    const h = Math.ceil(height);
                    yy = y - (h / 2);
                    if (yy < 0) {
                        yy = 0;
                    } else if (yy + h > winheight) {
                        yy = winheight - h;
                        if (yy < 0) {
                            yy = 0;
                        }
                    }
                }
            }
            
            const style = this._dialog.style;
            style.left = `${xx}px`;
            style.top = `${yy}px`;
            this._table.style.minWidth = "0";
        });
        return this;
    }

    hide_(): void {
        if (!this._shown) return;
        this._shown = false;
        toasters$.hideModal_();
        if (this._smokescreen != null) {
            this._smokescreen.hide_();
        }
        An.hide_(this._dialog);
    }

    close_(): void {
        if (this.#destroyed0) { return; }
        this.#destroyed0 = true;
        if (this._shown) {
            An.hide_(this._dialog);
            this._shown = false;
        }
        An.cancelSubscriptions_(this._subscriptions);
        this._cancelCallback = null;
        this._confirmCancelCallback = null;
        this._onShowDialogCallback = null;
        toasters$.hideModal_();
        if (this._dragger != null) {
            this._dragger.destroy_();
            this._dragger = null;
        }
        if (this._smokescreen != null) {
            this._smokescreen.destroy_();
            this._smokescreen = null;
        }
        if (this._toolbar != null) {
            this._toolbar.destroy_();
            this._toolbar = null;
        }
        this._dialog.remove();
    }

    constraintTableWidth_(_toolbarheight: number, maxwidth: number, minwidth: number, width: number): number {
        if (width < minwidth) {
            width = minwidth;
        }
        if (width > maxwidth) {
            width = maxwidth;
        }
        return width;
    }

    /**
       * @param width Dialog width.
       */
    getTableCellWidth_(_table: HTMLElement, tablewidth: number, toolbarheight: number): number {
        return tablewidth - DEFUtil.dialogChromeWidth_(toolbarheight);
    }

    protected _getToolbarHeight(): number {
        const toolbarelm = (this._toolbar != null)
            ? this._toolbar.element_()
            : this._dialog.querySelector(`div.${CSS.AnToolbar}`);
        return (toolbarelm == null ? 32 : Math.round(toolbarelm.getBoundingClientRect().height));
    }

    /// Set initial focus on the Cancel button by default.
    setInitialFocus_(): void {
        An.focus_(this._toolbar?.buttonIfExists_(BUT.Cancel) ?? null);
    }

    ////////////////////////////////////////////////////////////////////////

    actionInvalid_(action: string): void {
        throw Assert.notReach_(action);
    }

    actionCancel_(): void {
        if (this._confirmCancelCallback == null) {
            this.actionCancelConfirmed_();
            return;
        }
        this._confirmCancelCallback((yes: boolean) => {
            if (!yes) return;
            this.actionCancelConfirmed_();
        });
    }

    actionCancelConfirmed_() {
        const cb = this._cancelCallback;
        this.close_();
        cb?.();
    }

    actionOKConfirmed_(ok: boolean): void {
        if (ok) this.close_();
    }

    actionHelp_(): void {
        if (this._helpCallback == null) {
            return;
        }
        toasters$.modal_((toaster, builder) => this._helpCallback?.(toaster, builder));
    }

    actionCopy_(elm: HTMLElementX, escaped: boolean = false): void {
        const input = JsUtil.asHTMLTextAreaElement_(elm);
        if (input == null) return;
        if (this._clipboardSetter == null) return;
        Timer.sleep0_(() => {
            let value = this._getfieldtext(input);
            if (escaped) value = An.unescText_(value);
            this._clipboardSetter?.(value);
            toasters$.info_(value, { attop: false });
            Timer.sleep0_(() => {
                input.focus();
            });
        });
    }

    actionCut_(elm: HTMLElement, escaped: boolean = false): void {
        const input = JsUtil.asHTMLTextAreaElement_(elm);
        if (input == null) { return; }
        if (this._clipboardSetter == null) { return; }
        Timer.sleep0_(() => {
            let start = input.selectionStart;
            let end = input.selectionEnd;
            if (end < start) {
                const t = start;
                start = end;
                end = t;
            }
            let text = "";
            if (start == end) {
                text = this._getfieldtext(input);
                input.value = "";
            } else {
                const value = input.value;
                text = value.substring(start, end);
                input.value = value.substring(0, start) + value.substring(end);
            }
            if (escaped) text = An.unescText_(text);
            this._clipboardSetter?.(text);
            toasters$.info_(text, { attop: false });
            Timer.sleep0_(() => {
                input.selectionStart = start;
                input.selectionEnd = start;
                input.focus();
            });
        });
    }

    private _getfieldtext(input: HTMLTextAreaElement) {
        let start = input.selectionStart;
        let end = input.selectionEnd;
        if (end < start) {
            const t = start;
            start = end;
            end = t;
        }
        let value = input.value.substring(start, end);
        if (start == end) {
            if (input.hasAttribute(ATTR.AnInfo)) {
                value = HumanLink.getValue_(input);
            } else if (input.hasAttribute(ATTR.AnText)) {
                value = HumanFilepath.getValue_(input);
            } else {
                value = input.value;
            }
        }
        return value;
    }

    actionPaste_(elm: HTMLElementX, escaped: boolean = false, callback: Fun00 | null = null): void {
        let input = JsUtil.asHTMLTextAreaElement_(elm) ?? JsUtil.asHTMLInputElement_(elm);
        if (input == null) { return; }
        if (this._clipboardGetter == null) return;
        this._clipboardGetter((ret) => {
            if (this.warn_(ret[Key.errors])) {
                callback?.();
                return;
            }
            const value = ret[Key.result];
            this._pasteValue(input, null, escaped ? An.escText_(value) : value);
            callback?.();
        });
    }

    ////////////////////////////////////////////////////////////////////////

    protected _defaultToolbarHandler1(action: string): void {
        switch (action) {
            case BUT.Cancel:
            case BUT.Dismiss:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    /// Create a standard dialog with title, toolbar, message, content and status.
    createDialog_(
        container: HTMLElement,
        createContentCallback: Fun10<HTMLElement>,
        createToolbarCallback: Fun11<HTMLElement, Toolbar>,
        toolbarcallback: ActionMouseEventCallback
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden",
        });
        const ret = b.cursor_() as HTMLInputElement;
        b.table1_(CSS.AnDialog).push_().tr_().td_();
        this._toolbar = createToolbarCallback(b.cursor_());
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._toolbar.onAction_(toolbarcallback);
        this._message = b.peek_()
            .tr_()
            .td_()
            .div1_(CSS.AnPromptViewport)
            .div1_(CSS.AnPromptMsg)
            .cursor_();
        const content = b.peek_()
            .tr_()
            .td_()
            .div1_(CSS.AnPromptContent)
            .cursor_();
        new UIUt$.TooltipsListener(content, toasters$.onTooltipsKey_);
        createContentCallback?.(content);
        this._status = b.peek_()
            .tr_()
            .td_()
            .div1_(CSS.AnPromptViewport)
            .div1_(CSS.AnPromptStatus)
            .cursor_();
        container.append(ret);
        return ret;
    }

    /// Create a message dialog with title, toolbar and message only.
    protected _createMessageDialog(
        container: HTMLElement,
        infos: Array<SStringMap>,
        toolbarcallback: ActionMouseEventCallback
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden",
        });
        const ret = b.cursor_();
        b.table1_(CSS.AnDialog).push_();
        b.tr_().td_();
        this._toolbar = new Toolbar(b.cursor_(), infos);
        this._toolbar.onAction_(toolbarcallback);
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._message = b.peek_()
            .tr_()
            .td_()
            .div1_(CSS.AnPromptViewport)
            .div1_(CSS.AnPromptMsg)
            .cursor_();
        container.append(ret);
        return ret;
    }

    /// Create a standard dialog with title, toolbar, message, content.
    protected _createDialogWithoutStatus(
        container: HTMLElement,
        contentcallback: Fun10<HTMLElement>,
        infos: Array<SStringMap>,
        toolbarcallback: ActionMouseEventCallback
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden",
        });
        const ret = b.cursor_();
        b.table1_(CSS.AnDialog).push_().tr_().td_();
        this._toolbar = new Toolbar(b.cursor_(), infos);
        this._toolbar.onAction_(toolbarcallback);
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._message = b.peek_()
            .tr_()
            .td_()
            .div1_(CSS.AnPromptViewport)
            .div1_(CSS.AnPromptMsg)
            .cursor_();
        const content = b.peek_().tr_().td_().div1_(CSS.AnPromptContent).cursor_();
        new UIUt$.TooltipsListener(content, toasters$.onTooltipsKey_);
        if (contentcallback != null) {
            contentcallback(content);
        }
        container.append(ret);
        return ret;
    }

    /// Create a simple dialog with title, toolbar and content only.
    protected _createDialogWithoutMessageStatus(
        container: HTMLElement,
        contentcallback: Fun10<HTMLElement>,
        infos: Array<SStringMap>,
        toolbarcallback: ActionMouseEventCallback
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden",
        });
        const ret = b.cursor_();
        b.table1_(CSS.AnDialog).push_().tr_().td_();
        this._toolbar = new Toolbar(b.cursor_(), infos);
        this._toolbar.onAction_(toolbarcallback);
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        const content = b.peek_().tr_().td_().div1_(CSS.AnPromptContent).cursor_();
        new UIUt$.TooltipsListener(content, toasters$.onTooltipsKey_);
        if (contentcallback != null) {
            contentcallback(content);
        }
        container.append(ret);
        return ret;
    }

    /// Create a simple dialog with content only.
    protected _createDialogWithContentOnly(
        container: HTMLElement,
        contentcallback: Fun10<HTMLElement>): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden;",
        });
        const ret = b.cursor_();
        b
            .table_({
                "class": CSS.AnDialog,
                "style": `padding-top:${DEF.dialogPaddingWidth}px;`,
            })
            .push_()
            .tr_()
            .td_();
        const content = b.div1_(CSS.AnPromptContent).cursor_();
        new UIUt$.TooltipsListener(content, toasters$.onTooltipsKey_);
        contentcallback(content);
        container.append(ret);
        return ret;
    }

    protected _pasteName(elm: HTMLElement, name: stringX): void {
        if (name == null || name.length == 0) {
            return;
        }
        const nodename = elm.nodeName;
        if ("INPUT" == nodename) {
            const input = (elm as HTMLInputElement);
            const v = input.value;
            const start = input.selectionStart ?? 0;
            const end = input.selectionEnd ?? start;
            
            if (start == end) {
                const ret = DialogBase.pasteNameSmarter_(name, v, start);
                DialogBase._setInputValueRange(input, ret[0], ret[1], ret[1]);
            } else {
                const s = (start <= end ? start : end);
                const e = (start <= end ? end : start);
                const before = v.substring(0, s);
                const after = v.substring(e);
                const offset = s + name.length;
                DialogBase._setInputValueRange(input, (before + name + after), offset, offset);
            }
        } else if ("TEXTAREA" == nodename) {
            const input = (elm as HTMLTextAreaElement);
            const v = input.value;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            
            if (start == end) {
                const ret = DialogBase.pasteNameSmarter_(name, v, start);
                DialogBase._setTextAreaValueRange(input, ret[0], ret[1], ret[1]);
            } else {
                const s = (start <= end ? start : end);
                const e = (start <= end ? end : start);
                const before = v.substring(0, s);
                const after = v.substring(e);
                const offset = s + name.length;
                DialogBase._setTextAreaValueRange(input, (before + name + after), offset, offset);
            }
        } else {
            this.warnKey_(RS.ActionRequireAValidSelection);
        }
        Timer.sleep0_(() => {
            elm.focus();
        });
    }

    protected _pasteValue(elm: HTMLInputElement | HTMLTextAreaElement | null, name: stringX, value: stringX): void {
        if (elm == null || value == null || value.length == 0) {
            return;
        }
        const nodename = elm.nodeName;
        if ("INPUT" == nodename) {
            const input = (elm as HTMLInputElement);
            const v = input.value;
            const start = input.selectionStart ?? 0;
            const end = input.selectionEnd ?? start;
            
            if (name != null && start == end) {
                const ret = DialogBase.pasteValueSmarter_(name, value, v, start);
                DialogBase._setInputValueRange(input, ret[0], ret[1], ret[1]);
            } else {
                const s = (start <= end ? start : end);
                const e = (start <= end ? end : start);
                const before = v.substring(0, s);
                const after = v.substring(e);
                const offset = s + value.length;
                DialogBase._setInputValueRange(input, (before + value + after), offset, offset);
            }
        } else if ("TEXTAREA" == nodename) {
            const input = (elm as HTMLTextAreaElement);
            const v = input.value;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            
            if (name != null && start == end) {
                const ret = DialogBase.pasteValueSmarter_(name, value, v, start);
                DialogBase._setTextAreaValueRange(input, ret[0], ret[1], ret[1]);
            } else {
                const s = (start <= end ? start : end);
                const e = (start <= end ? end : start);
                const before = v.substring(0, s);
                const after = v.substring(e);
                const offset = s + value.length;
                DialogBase._setTextAreaValueRange(input, (before + value + after), offset, offset);
            }
        } else {
            this.warnKey_(RS.ActionRequireAValidSelection);
        }
        Timer.sleep0_(() => {
            elm.focus();
        });
    }

    protected static _setInputValueRange(input: HTMLInputElement, value: string, start: number, end: number): void {
        input.value = value;
        Timer.sleep0_(() => {
            input.selectionStart = start;
            input.selectionEnd = end;
            input.focus();
        });
    }

    protected static _setTextAreaValueRange(input: HTMLTextAreaElement, value: string, start: number, end: number): void {
        input.value = value;
        Timer.sleep0_(() => {
            input.selectionStart = start;
            input.selectionEnd = end;
            input.focus();
        });
    }

    static pasteNameSmarter_(name: string, ovalue: string, offset: number): [value: string, start: number] {
        const line = DialogBase._getLine(ovalue, offset);
        while (line.start$ < line.end$ && An.isWhitespace_(ovalue.codePointAt(line.start$))) {
            ++line.start$;
        }
        if (line.start$ == line.end$) {
            return [ovalue.substring(0, line.start$) + name + " " + An.trimLeftSpaces_(ovalue.substring(line.end$)),
            line.start$ + name.length + 1];
        }
        let end = line.start$;
        while (end < line.end$ && !An.isWhitespace_(ovalue.charCodeAt(end))) {
            ++end;
        }
        return [ovalue.substring(0, line.start$) + name + " " + An.trimLeftSpaces_(ovalue.substring(end)),
        line.start$ + name.length + 1];
    }

    static pasteValueSmarter_(name: string, value: string, ovalue: string, offset: number): [value: string, start: number] {
        const line = DialogBase._getLine(ovalue, offset);
        while (line.start$ < line.end$ && An.isWhitespace_(ovalue.codePointAt(line.start$))) {
            ++line.start$;
        }
        if (line.start$ == line.end$) {
            return [ovalue.substring(0, line.start$) + name + " " + value + ovalue.substring(line.end$),
            line.start$ + name.length + 1 + value.length];
        }
        while (line.start$ < line.end$ && !An.isWhitespace_(ovalue.codePointAt(line.start$))) {
            ++line.start$;
        }
        const lc = name.toLowerCase();
        if (lc == "color" || lc == PK.BackgroundColor || lc == PK.BackgroundImage) {
            const s = ovalue.substring(line.start$, line.end$);
            const m = (lc == "color" || lc == PK.BackgroundColor)
                ? RX.CSSColorValue.exec(s)
                : (lc == PK.BackgroundImage)
                    ? RX.CSSUrlValue.exec(s)
                    : null;
            if (m != null) {
                const a = m[1].trim();
                const z = m[3].trim();
                value = (a + " " + value + " " + z).trim();
            }
        }
        return [ovalue.substring(0, line.start$) + " " + value + ovalue.substring(line.end$),
        line.start$ + 1 + value.length];
    }

    protected static _getLine(value: string, offset: number): AnRange {
        let start = offset;
        let end = offset;
        const len = value.length;
        while (end < len && !An.isLinebreak_(value.codePointAt(end))) {
            ++end;
        }
        while (start > 0) {
            const c = value.codePointAt(start - 1);
            if (An.isLinebreak_(c)) {
                break;
            }
            --start;
        }
        return new AnRange(start, end);
    }

    protected _setmsg(elm: HTMLElementX, msg: TestResult, warn: boolean): boolean {
        if (elm == null) return false;
        if (msg == null) {
            elm.style.display = "none";
            elm.textContent = "";
            elm.style.color = "inherit";
            return false;
        }
        if (msg instanceof Array) {
            if (msg.length == 0) { return false; }
            const b = new DomBuilderEx(elm).empty_();
            elm.style.color = (warn ? "red" : "inherit");
            for (let i = 0; i < msg.length; ++i) {
                if (i > 0) {
                    b.append_("BR");
                }
                b.text_(msg[i]);
            }
            elm.style.display = "block";
            return true;
        }
        if (typeof (msg) === "object") {
            return this._setmsg(elm, msg[Key.errors], warn);
        }
        elm.textContent = msg.toString();
        elm.style.color = (warn ? "red" : "inherit");
        elm.style.display = "block";
        return true;
    }

    protected _setmsgtext(elm: HTMLElementX, msg: string): void {
        if (elm == null) return;
        if (msg == null || msg.length == 0) {
            elm.style.display = "none";
            elm.textContent = "";
        } else {
            elm.textContent = msg;
            elm.style.display = "block";
        }
    }

    protected _showstatus1(msg: TestResult, warn: boolean): boolean {
        if (this._status == null) return warn ? toasters$.warn_(msg) : toasters$.info_(msg);
        return this._setmsg(this._status, msg, warn);
    }

    /**
       * @param msg The message to be shown. It may be null, String or List<String>.
       * @return true if any msg is shown.
       */
    info_(msg: TestResult): boolean {
        return (this._showstatus1(msg, false));
    }

    /**
       * @param msg The message to be shown. It may be null, String or List<String>.
       * @return true if any msg is shown.
       */
    warn_(msg: TestResult): boolean {
        return (this._showstatus1(msg, true));
    }

    warnKey_(msgkey: string): void {
        this.warn_(MSG.string_(msgkey));
    }

    warn0_(msg: any): boolean {
        msg = An.result_(msg);
        if (msg == null) return false;
        Timer.sleep0_(() => {
            this._showstatus1(msg, true);
        });
        return true;
    }

    clearStatus_(): void {
        if (this._status != null) {
            this._setmsg(this._status, null, false);
        }
    }

    /**
     * Like An.parseUriSafe() but show warning at dialog status area.
     * @return A valid Uri or null if uri is null, empty or invalid.
     * If input is not valid, show error in status panel.
     */
    parseUri_(href: stringX, baseurl: BaseUriX): UriX {
        if (href == null || href.length == 0) {
            return null;
        }
        try {
            return An.parseUri_(href, baseurl);
        } catch (e: any) {
            this.warn_(`${e}`);
            return null;
        }
    }

    static help_(b: DomBuilderEx, stringarrayid: string): void {
        const a = MSG.stringArray_(stringarrayid);
        b.push_().div_({
            "class": CSS.AnViewport,
            "style": "white-space:normal;font-size:small"
        });
        const len = a.length;
        if (len == 0) {
            return;
        }
        b.text_(a[0]);
        b.append_("br");
        for (let i = 1; i + 1 < len;) {
            b.b_().text_(a[i++]).up_().text_("\u00a0").text_(a[i++]).append_("br");
        }
        b.pop_();
    }
}

////////////////////////////////////////////////////////////////////////

abstract class FixedSizeDialogBase extends DialogBase {

    constructor(container: HTMLElement, protected _buttonSize: number) {
        super(container, new DialogDraggerHandler());
    }

    protected abstract getContentWidth_(): number;

    get buttonSize$(): number {
        return this._buttonSize;
    }

    getDialogWidth_(): number {
        return this.getContentWidth_() + DEFUtil.dialogChromeWidth_(this._buttonSize);
    }

    show_(): this {
        if (this._shown) return this;
        this._shown = true;
        this.showAt_(null, null);
        return this;
    }

    /**
       * @param x, y Window offset, ie. relative to smokescreen.
       */
    showAt_(x: numberX, y: numberX): this {
        this.showDialog_(() => {
            
            const winwidth = window.innerWidth;
            const winheight = window.innerHeight;
            const minxmargin = winwidth / 16;
            const width = this.getDialogWidth_();
            let xx: number;
            let yy: number;
            if (x == null) {
                const xmargin = (winwidth - width);
                if (xmargin < minxmargin) {
                    xx = minxmargin;
                } else {
                    xx = xmargin / 2;
                }
            } else {
                xx = x - width - minxmargin;
                if (xx < 0) {
                    const xxx = x + minxmargin + width - winwidth;
                    if (xxx <= 0) {
                        xx = x + minxmargin;
                    } else if (xxx < -xx) {
                        xx = winwidth - width;
                    } else {
                        xx = 0;
                    }
                }
            }
            if (y == null) {
                yy = winheight / 16;
            } else {
                const cstyle = An.getComputedStyle_(this._dialog);
                const height = An.parseDoublePx_(cstyle?.height, null);
                if (height == null) {
                    yy = winheight / 16;
                } else {
                    const h = Math.ceil(height);
                    yy = y - (h / 2);
                    if (yy < 0) {
                        yy = 0;
                    } else if (yy + h > winheight) {
                        yy = winheight - h;
                        if (yy < 0) {
                            yy = 0;
                        }
                    }
                }
            }
            if (this._toolbar != null) {
                this._toolbar.element_().style.width = `${this.getContentWidth_()}px`;
            }
            
            const style = this._dialog.style;
            style.left = `${xx}px`;
            style.top = `${yy}px`;
            this._table.style.minWidth = "0";
        });
        return this;
    }

    close_() {
        super.close_();
    }

    protected _styleRowHeight(): number {
        return this._buttonSize * 4 / 5;
    }
}

abstract class FullscreenDialogBase extends DialogBase {

    protected abstract showFullscreen_(): void;

    abstract onResize_(): void;

    constructor(container: HTMLElement, protected _gestureHandler: IGestureHandler | null) {
        super(container);
    }

    get toolbar$(): Toolbar | null {
        return this._toolbar;
    }

    createFullscreenDialog_(
        container: HTMLElement,
        toolbarcreator: (b: DomBuilderEx) => Toolbar,
        contentcreator: (b: DomBuilderEx) => void
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "table", {
            "class": CSS.AnWindow,
            "style": "display: none; visibility: hidden;",
        }).push_();
        const ret = b.cursor_();
        this._toolbar = toolbarcreator(b.tr_().td_());
        contentcreator(b.pop_().tr_().td_());
        container.append(ret);
        return ret;
    }

    show_(): this {
        if (this._shown) {
            return this;
        }
        this._shown = true;
        An.showHidden_(this._dialog, "block");
        this._onWindowResize(() => this.onResize_());
        if (this._gestureHandler != null) this._gestureHandler.pause_();
        this.showFullscreen_();
        return this;
    }

    close_(): void {
        if (this._gestureHandler != null) {
            this._gestureHandler.resume_();
            this._gestureHandler = null;
        }
        super.close_();
    }

    static fullscreenToolbarCreator_(b: DomBuilderEx, titlekey: stringX, infos: Array<SStringMap>): Toolbar {
        const toolbar = new Toolbar(b.cursor_(), infos);
        toolbar.onTooltips_(toasters$.onTooltipsKey_);
        if (titlekey != null) {
            toolbar.titleKey_(titlekey);
        }
        //// Fix width to 100vw to prevent overflow.
        toolbar.element_().style.width = "100vw";
        b.peek_().tr_().td_({
            "class": CSS.AnPanel,
        });
        return toolbar;
    }
}

////////////////////////////////////////////////////////////////////////

abstract class DialogBaseWithFocusInput extends DialogBase {
    protected _focusInput: HTMLElementX = null;

    constructor(container: HTMLElement) {
        super(container);
    }

    private _onChangeCallback: PromptValuesChangeCallback | null = null;

    get onChangeCallback$(): PromptValuesChangeCallback | null { return this._onChangeCallback; };

    onFocus_(input: HTMLTextAreaElement | HTMLInputElement) {
        this._focusInput = input;
    }

    onChange_(callback: PromptValuesChangeCallback): this {
        this._onChangeCallback = callback;
        return this;
    }

    fireOnChange_(field: IDialogField, input: HTMLElement | SelectOptions): void {
        Timer.sleep0_(() => {
            if (this._shown) this._onChangeCallback?.(field, input);
        });
    }

    close_() {
        super.close_();
        this._onChangeCallback = null;
    }

    protected defaultToolbarActions_(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.PasteFromLocalClipboard:
                if (this._focusInput != null) {
                    this.actionPaste_(this._focusInput);
                }
                break;
            case BUT.CopyToLocalClipboard:
                if (this._focusInput != null) {
                    this.actionCopy_(this._focusInput);
                }
                break;
            default:
                this._defaultToolbarHandler1(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

type DialogFieldValueElement = HTMLElement | HTMLElement[] | SelectOptions;

interface IDialogFIeldSpec {
    key$: string;
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField | IDialogField[];
}

interface IDatetimeFieldSpec extends IDialogFIeldSpec {
    readonly label$: string;
    readonly buttonsize$: number,
    readonly dateformat$: string,
    readonly timeformat$: string,
}
interface IBasenameFieldSpec extends IDialogFIeldSpec {
    readonly label$: string;
    readonly filename$: string;
    readonly placeholder$: string;
    readonly basedir$: BasedirX;
    readonly foldercallback$: PromptFilepathCallback;
}

interface IFilepathFieldSpec extends IDialogFIeldSpec {
    readonly label$: string;
    readonly value$: HumanFilepath;
    readonly placeholder$: string;
    readonly basedir$: BasedirX;
    readonly buttons$: string[];
    readonly foldercallback$: PromptFilepathCallback;
}

interface IUriFieldSpec extends IDialogFIeldSpec {
    readonly label$: string;
    readonly value$: HumanLink;
    readonly placeholder$: string;
    readonly baseuri$: BaseUriX;
    readonly buttons$: string[];
    readonly foldercallback$: PromptFilepathCallback;
}

interface IDialogField {
    readonly spec$: IDialogFIeldSpec;
    element_(): HTMLElement;
    focus_(): HTMLElementX;
    blur_(): void;
    getValue_(at?: Int): string;
    setValue_(value: string, at?: Int): void;
    setEnable_(enable: boolean): void;
    setButtonEnable_(name: string, enable: boolean): HTMLElementX;
    getButton_(name: string): HTMLElementX;
    getInput_(at: Int): AnInputElementX;
    /// @return The elements that are holding values, including elements returned by getInput()
    /// and other non-input elements.
    getValueElement_(at: Int): DialogFieldValueElement | null;
    onResize_(): void;
}

interface IDialog extends IWarner, IUriParser {
    readonly labelWidth$: number;
    readonly clipboardSetter$: ClipboardSetter | null;
    readonly clipboardGetter$: ClipboardGetter | null;
    container_(): HTMLElement;
    element_(): HTMLElement;
    tabIndex_(): string;
    clearStatus_(): void;
    info_(msg: TestResult): boolean;
    warn_(msg: TestResult): boolean;
    warnKey_(msgid: string): void;
    zindex_(zindex: number): this;
    onCancel_(callback: Fun00): this;
    show_(): this;
}

interface IDialogWithInput extends IDialog {
    onFocus_(input: AnInputElement | HTMLInputElement): void;
    fireOnChange_(field: IDialogField, input: SelectOptions | HTMLElement): void;
    actionOK_(): void;
}

interface ICompositeDialog extends IDialogWithInput {
    getField_(key: string): IDialogField;
    getFieldAt_(index: number): IDialogField;
    getValue_(key: string, at?: number): string;
    getValueAt_(index: number, at?: number): string;
    setValue_(key: string, value: string, at?: number): ICompositeDialog;
    setValueAt_(index: number, value: string, at?: number): ICompositeDialog;
    setVisible_(key: string, yes: boolean): void;
    setVisibleAt_(index: number, yes: boolean): void;
    getChanged_(original?: Map<string, string>): Map<string, string>;
    postUpdate(callback: Fun00): void;
}

interface IDialogFieldHost extends ICompositeDialog {
    readonly onImageContextmenuCallback$: ImageContextmenuCallback | null;
    readonly onPreviewCallback$: PreviewCallback | null;
    readonly onChangeCallback$: PromptValuesChangeCallback | null;
    filepathKindButtonPressed_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, basedir: BasedirX): void;
    uriKindButtonPressed_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, baseuri: BaseUriX): void;
    basenameButtonPressed_(field: IDialogField, input: AnInputElement, filename: string, cdir: BasedirX, foldercallback: PromptFilepathCallback): void;
    filepathFolderButtonPressed_(
        field: IDialogField,
        input: AnInputElement,
        pathkind: HTMLElementX,
        basedir: BasedirX,
        foldercallback: PromptFilepathCallback): void;
    filepathInputChanged_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, basedir: BasedirX): void;
    uriFolderButtonPressed_(
        field: IDialogField,
        input: AnInputElement,
        pathkind: HTMLElementX,
        baseuri: BaseUriX,
        foldercallback: PromptFilepathCallback): void;
    uriInputChanged_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, baseuri: BaseUriX): void;
}

abstract class DialogField implements IDialogField {
    abstract spec$: IDialogFIeldSpec;
    abstract element_(): HTMLElement;
    abstract focus_(): HTMLElementX;
    abstract blur_(): void;
    abstract getValue_(at?: number): string;
    abstract setValue_(value: string, at?: number): void;
    abstract getInput_(at: number): AnInputElementX;
    abstract getValueElement_(at: number): DialogFieldValueElement | null;
    setEnable_(_enable: boolean) {
        Assert.unsupportedOperation_();
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    setButtonEnable_(name: string, enable: boolean): HTMLElementX {
        const but = this.getButton_(name);
        if (but == null) return null;
        if (enable) but.classList?.remove(CSS.AnDisabled);
        else but.classList?.add(CSS.AnDisabled);
        return but;
    }
    onResize_(): void {
    }
    protected setupInput_(host: IDialogWithInput, input: AnInputElement | HTMLInputElement) {
        An.onInputChange_(input, () => host.fireOnChange_(this, input));
        input.addEventListener("focus", () => host.onFocus_(input));
    }
    protected setupInput1_(host: IDialogWithInput, input: AnInputElement, onchange: Fun00) {
        An.onInputChange_(input, () => onchange());
        input.addEventListener("focus", () => host.onFocus_(input));
    }
}

abstract class DialogFieldSpecBase {
}

class AttributesFIeld extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly classes$: string
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new AttributesFieldImpl(host, builder, this);
    }
}

class AttributesFieldImpl extends DialogField {
    private readonly _input: HTMLTextAreaElement;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: AttributesFIeld) {
        super();
        this._input = builder.peek_().flexTextTextarea_(
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$),
            smap_(
                ["class", `${_spec.classes$} ${CSS.AnPromptAttributes}`],
                ["placeholder", _DialogUt.placeholder_(_spec.placeholder$)],
                ["tabindex", host.tabIndex_()],
                [ATTR.autocapitalize, "none"],
                [ATTR.autocomplete, "off"],
                [ATTR.autocorrect, "off"],
                [ATTR.spellcheck, "false"],
            ));
        this._input.value = _spec.value$;
        this.setupInput_(host, this._input);
    }
    get spec$(): AttributesFIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.value;
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class BasenameFIeld extends DialogFieldSpecBase implements IBasenameFieldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly filename$: string,
        readonly placeholder$: string,
        readonly basedir$: BasedirX,
        readonly foldercallback$: PromptFilepathCallback,
        readonly entercallback$: Fun10X<IDialogWithInput> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new BasenameFieldImpl(host, builder, this);
    }
}

class BasenameFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _input: HTMLTextAreaElement;
    private _ext: SelectOptions;
    private _buttons: Map<string, HTMLButtonElement>;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: BasenameFIeld) {
        super();
        [this._top, this._input, this._ext, this._buttons] = _DialogUt.createBasenameInput_(
            builder,
            host,
            _spec,
            () => host.basenameButtonPressed_(this, this._input, this.getValue_(), _spec.basedir$, _spec.foldercallback$),
        );
        this.setupInput_(host, this._input);
        if (_spec.entercallback$ != null) An.onInputEnterKey_(this._input, () => _spec.entercallback$?.(host));
    }
    get spec$(): BasenameFIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._buttons.forEach((button) => button.blur());
    }
    getValue_(_at?: Int): string {
        return this._input.value.trim() + this._ext.getValue_(0);
    }
    setValue_(value: string, _at?: Int): void {
        const basepath = new Basepath(value);
        this._input.value = basepath.stem$;
        this._ext.setValue_(basepath.suffix$, 0);
    }
    getButton_(name: string): HTMLElementX {
        return this._buttons.get(name) ?? null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class CheckboxField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly text$ = "",
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new CheckboxFieldImpl(host, builder, this);
    }
}

class CheckboxFieldImpl extends DialogField {
    private _input: HTMLInputElement;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: CheckboxField) {
        super();
        builder.peek_().flexTextDiv_(
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$)
        ).attrs_({
            "class": CSS.AnPromptCheckbox,
        });
        this._input = DialogUt.createCheckboxRow_(builder, [["tabindex", host.tabIndex_()]], _spec.text$);
        this.setupInput_(host, this._input);
        this._input.checked = (_spec.value$ === "true");
    }
    get spec$(): CheckboxField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.checked ? "true" : "false";
    }
    setValue_(value: string, _at?: Int): void {
        this._input.checked = (value == "true");
    }
    setEnable_(enable: boolean) {
        this._input.disabled = !enable;
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class ColorField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly buttonsize$: number,
        readonly placeholder$: string,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new ColorFieldImpl(host, builder, this);
    }
}

class ColorFieldImpl extends DialogField {
    private _colorinput: HTMLTextAreaElement;
    private _colorcell: HTMLElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: ColorField) {
        super();
        builder.peek_().flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$));
        [this._colorinput, this._colorcell] = DialogUt.promptColorInput_(
            builder,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
            ColorUtil.validateColor_(_spec.value$),
            ColorUtil.validateCSSColor_(_spec.value$));
        const setcolor = (c: ColorValue | null, format: string) => {
            this._colorinput.value = (c == null ? "" : ColorUtil.formatString_(format, c));
            this._colorcell.style.backgroundColor = (c == null ? "" : ColorUtil.formatCSSString_(format, c));
            host.fireOnChange_(this, this._colorinput);
        };
        const handler = (e: Event) => {
            An.stopevent_(e);
            Callbacks.promptColor_(
                _spec.buttonsize$,
                An.above_(host.element_()),
                this._colorcell.style.backgroundColor,
                ColorValue.X_WHITE)
                .onOK_(setcolor)
                .show_();
        };
        An.onClick_(this._colorinput, handler);
        An.onClick_(this._colorcell, handler);
        An.onChange_(this._colorinput, (_e: Event) => {
            
            setcolor(
                ColorUtil.getColorValue_(this._colorinput.value),
                ColorUtil.getFormat_(this._colorinput.value));
        });
        this._colorinput.addEventListener("focus", () => {
            host.onFocus_(this._colorinput);
        });
    }
    get spec$(): ColorField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._colorinput.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._colorinput.focus();
        return this._colorinput;
    }
    blur_(): void {
        this._colorinput.blur();
    }
    getValue_(_at?: Int): string {
        return ColorUtil.validateCSSColor_(this._colorinput.value.trim());
    }
    setValue_(value: string, _at?: Int): void {
        this._colorinput.value = value;
        this._colorinput.dispatchEvent(new Event("change"));
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._colorinput : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._colorinput : at == 1 ? this._colorcell : null;
    }
}

class ColorStop {
    constructor(
        readonly color: string,
        readonly position: string,
    ) { }
    toString() {
        if (this.position.length == 0) return this.color;
        return `${this.color} ${this.position}`;
    }
}

type ColorStops = Array<ColorStop | null>;
type SamplesSpec = StringMap<Array<[label: string, styles: SStringMap]>>;
class Gradient {
    static readonly _COLOR0 = "rgba(221, 221, 0, 0.50)";
    static readonly _COLOR1 = "rgba(136, 221, 170, 0.50)";
    constructor(
        readonly name: string,
        readonly position: string,
        readonly colorstops: ColorStops
    ) { }
    toString(): string {
        let ret = sarray_();
        ret.push(this.position);
        for (const stop of this.colorstops) {
            if (stop == null) continue;
            ret.push(stop.toString());
        }
        return this.name + "(" + An.joinNotEmpty_(", ", ret) + ")";
    }
    static linear(position: string, colorstops: ColorStops): Gradient {
        return new Gradient("linear-gradient", position, colorstops);
    }
    static def(): Gradient {
        return this.linear("180deg", [
            new ColorStop(Gradient._COLOR0, ""),
            new ColorStop(Gradient._COLOR1, ""),
            null,
            null,
        ]);
    }
}

class ColorStopsField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly buttonsize$: number,
        readonly colors$: ColorStops,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new ColorsFieldImpl(host, builder, this);
    }
}

class ColorsFieldImpl extends DialogField {
    private _colorCells: HTMLElement[];
    private _positions = Array<string>();
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: ColorStopsField) {
        super();
        builder.peek_().flexTextContainer_(
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$)).addClass_(CSS.AnColorStops);
        if (_spec.colors$.length < 2) throw new Error(_spec.colors$.length.toString());
        this._colorCells = DialogUt.promptColorStopsInput_(builder, _spec.colors$);
        for (let index = 0; index < this._colorCells.length; ++index) {
            const cell = this._colorCells[index];
            An.onClick_(cell, (e) => {
                An.stopevent_(e);
                Callbacks.promptColor_(
                    _spec.buttonsize$,
                    An.above_(host.element_()),
                    cell.style.backgroundColor,
                    ColorValue.X_WHITE,
                ).onOK_((c, format) => {
                    if (c != null) {
                        cell.style.backgroundColor = ColorUtil.formatCSSString_(format, c);
                        host.fireOnChange_(this, cell);
                    }
                    let sizeunit: DoubleStringUnit = ["", "%"];
                    const pos = this._positions[index];
                    if (pos.length > 0) {
                        sizeunit = An.doubleStringSizeUnit_(pos) ?? ["", "%"];
                    }
                    new PromptCSSLength(accessories$, RS.Position, sizeunit, RS.Position)
                        .above_(host.element_())
                        .onOK_((value) => {
                            this._positions[index] = value;
                            cell.textContent = (value.length > 0 ? value : "\u00a0");
                            host.fireOnChange_(this, cell);
                        })
                        .show_();
                }).show_();
            });
        }
        for (const stop of this._spec.colors$) {
            this._positions.push(stop?.position ?? "");
        }
    }
    get spec$(): ColorStopsField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._colorCells[0].parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        const ret: string[] = [];
        for (let index = 0; index < this._colorCells.length; ++index) {
            const cell = this._colorCells[index];
            const s = cell.style.backgroundColor ?? "";
            if (s != null && s.length > 0) {
                const c = ColorValue.from_(s);
                if (c != null) {
                    let value = c.toCSSString_();
                    const pos = this._positions[index];
                    if (pos.length > 0) value += " " + pos;
                    ret.push(value);
                }
            }
        }
        return ret.join(", ");
    }
    setValue_(value: string, _at?: Int): void {
        for (const cell of this._colorCells) {
            const m = RX.CSSColorValue1.exec(value);
            if (m == null) return;
            const c = ColorValue.from_(m[1]);
            cell.style.backgroundColor = (c == null ? "" : c.toCSSString_());
            const mm = RX.Comma1.exec(m[2]);
            if (mm == null) return;
            value = mm[1];
        }
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(_at: number): DialogFieldValueElement | null {
        return this._colorCells;
    }
}

class DataUrlField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly src$: string,
        readonly width$: string,
        readonly height$: string
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new DataUrlFieldImpl(host, builder, this);
    }
}

class DataUrlFieldImpl extends DialogField {
    private readonly _img: HTMLElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: DataUrlField) {
        super();
        const attrs = ssmap_();
        attrs["src"] = _spec.src$;
        let style = "margin:20px 10px 10px 0;border:none;";
        if (_spec.width$.length > 0) {
            style += `max-width:${_spec.width$};`;
        }
        if (_spec.height$.length > 0) {
            style += `max-height:${_spec.height$};`;
        }
        attrs["style"] = style;
        const haslabel = _spec.label$.length > 0;
        builder.peek_().flexTextContainer_(haslabel ? host.labelWidth$ : 0, _spec.label$);
        if (!haslabel) builder.addStyle_("justify-content", "center");
        this._img = builder.img_(attrs).cursor_();
        An.onClick_(this._img, () => {
            if (_spec.src$.length > 0) {
                host.onPreviewCallback$!(host.element_(), _spec.src$)?.show_();
            }
        });
    }
    get spec$(): DataUrlField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._img.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return this._img.getAttribute("src") ?? "";
    }
    setValue_(value: string, _at?: Int): void {
        this._img.setAttribute("src", value);
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(_at: number): DialogFieldValueElement | null {
        return this._img;
    }
}

class MillisecondsField extends DialogFieldSpecBase implements IDatetimeFieldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly ms$: Int,
        readonly buttonsize$: number,
        readonly placeholder$: string,
        readonly dateformat$: string,
        readonly timeformat$: string,
        readonly showpanel$?: Int
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new MillisecondsFieldImpl(host, builder, this);
    }
}

class MillisecondsFieldImpl extends DialogField {
    private _input: HTMLElement;

    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: MillisecondsField) {
        super();
        const date = _spec.ms$ < 0 ? DateTime.now_() : DateTime.fromMs_(_spec.ms$);
        const showpanel = _spec.showpanel$ ?? PromptDate.TIME;
        builder.peek_().flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$));
        this._input = MillisecondsFieldImpl._promptMillisecondsInput(builder, host, _spec, date, showpanel);
    }

    private static _promptMillisecondsInput(
        b: DomBuilderEx,
        host: IDialog,
        spec: IDatetimeFieldSpec,
        date: DateTime,
        showpanel: number
    ): HTMLElement {
        const container = host.container_();
        const buttonsize = spec.buttonsize$;
        const dateformat = spec.dateformat$;
        const timeformat = spec.timeformat$;
        b.push_();
        const input = b.flexDivInput_(100) as HTMLElement;
        b.pop_();
        if (date != null) {
            input.setAttribute(ATTR.xTooltips, `${date.millisecondsSinceEpoch$}`);
            input.textContent = An.datetimeString_(dateformat, timeformat, date);
        }
        const handler = (e: UIEvent) => {
            An.stopevent_(e);
            const ms = An.parseInt_(input.getAttribute(ATTR.xTooltips), -1);
            const now = An.now00_();
            const datetime = ms < 0 ? now : new DateTime(ms);
            new PromptDate(container, now, datetime, PromptDate.DATE | PromptDate.TIME, buttonsize)
                .zindex_(host == null ? DEF.zindexPrompt : An.zindexOf_(host.element_(), DEF.zindexAbove10, DEF.zindexPrompt + DEF.zindexAbove10))
                .dateFormat_(dateformat)
                .timeFormat_(timeformat)
                .allowAuto(false)
                .onOK_((ret: DateTime, _dontcare1: string, _dontcare2: string, _dontcare3: string) => {
                    input.setAttribute(ATTR.xTooltips, `${ret.millisecondsSinceEpoch$}`);
                    input.textContent = An.datetimeString_(dateformat, timeformat, ret);
                })
                .showTab_(showpanel);
        };
        An.onClick_(input, handler);
        return input;
    }

    get spec$(): MillisecondsField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return this._input.getAttribute(ATTR.xTooltips) ?? "";
    }
    setValue_(value: string, _at?: Int): void {
        const ms = An.parseInt_(value, -1);
        if (ms < 0) {
            this._input.setAttribute(ATTR.xTooltips, "");
            this._input.textContent = "";
        } else {
            this._input.setAttribute(ATTR.xTooltips, `${ms}`);
            this._input.textContent = value;
        }
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._input : null;
    }
}

class DirpathField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    readonly label$ = "";
    constructor(
        readonly key$: string,
        readonly value: string,
        readonly rootdir$: string,
        readonly onclick_: Fun10<HTMLElementX>,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new DirpathFieldImpl(host, builder, this);
    }
}

class DirpathFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _rootbutton: HTMLButtonElement;
    private _dirpath: HTMLDivElement;
    constructor(
        host: IDialogFieldHost,
        b: DomBuilderEx,
        private readonly _spec: DirpathField) {
        super();
        this._top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        b.div1_(CSS.AnFlex, CSS.AnDirpath).push_();
        this._rootbutton = _DialogUt.createActionButton_(b.peek_(), BUT.RootFolder);
        this._rootbutton.style.marginLeft = "-1em";
        this._rootbutton.style.minHeight = "0";
        this._rootbutton.style.alignSelf = "baseline";
        this._rootbutton.style.flexShrink = "0";
        this._dirpath = b.pop_().div1_(CSS.AnDirpathDir).cursor_() as HTMLDivElement;
        this._rootbutton.addEventListener("click", e => {
            An.stopevent_(e);
            host.clearStatus_();
            this._spec.onclick_(null);
        });
        An.onClickMatching_(this._dirpath, "a", (target, e) => {
            An.stopevent_(e);
            host.clearStatus_();
            this._spec.onclick_(target);
        });
    }
    get spec$(): DirpathField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        /// Not used, client should keep maintain dirpath info.
        return "";
    }
    setValue_(_value: string, _at?: Int): void {
        /// Not used, client should update UI using getValueElement()
    }
    getButton_(name: string): HTMLElementX {
        return (name == BUT.RootFolder) ? this._rootbutton : null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(_at: number): DialogFieldValueElement | null {
        return this._dirpath;
    }
}

class DirtreeField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    readonly label$ = "";
    constructor(
        readonly key$: string,
        readonly onclick_: Fun10<HTMLElement>,
        readonly onresize_: Fun10X<HTMLElement> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new DirtreeFieldImpl(host, builder, this);
    }
}

class DirtreeFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _dirtree: HTMLDivElement;
    constructor(
        host: IDialogFieldHost,
        b: DomBuilderEx,
        private readonly _spec: DirtreeField) {
        super();
        this._top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        b.div_({
            "class": CSS.AnFlex,
            "style": `flex-basis:100%;flex-flow:nowrap;overflow:hidden`,
        });
        this._dirtree = b.div_(
            ["class", `${CSS.AnFilepicker} ${CSS.AnDirtree}`],
        ).cursor_() as HTMLDivElement;
        An.onClickMatching_(this._dirtree, `a, div.${CSS.AnRow}`, (target, e) => {
            An.stopevent_(e);
            host.clearStatus_();
            this._spec.onclick_(target);
        });
    }
    onResize_() {
        this._spec.onresize_?.(this._dirtree);
    }
    get spec$(): DirtreeField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return "";
    }
    setValue_(_value: string, _at?: Int): void {
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(_at: number): DialogFieldValueElement | null {
        return this._dirtree;
    }
}

class FilepathField extends DialogFieldSpecBase implements IFilepathFieldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: HumanFilepath,
        readonly placeholder$: string,
        readonly basedir$: BasedirX,
        readonly buttons$: string[],
        readonly foldercallback$: PromptFilepathCallback,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new FilepathFieldImpl(host, builder, this);
    }
}

class FilepathFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _input: HTMLTextAreaElement;
    private _pathkind: HTMLElementX;
    private _buttons: Map<string, HTMLButtonElement>;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: FilepathField) {
        super();
        [this._top, this._input, this._pathkind, this._buttons] = _DialogUt.createFilepathInput_(
            builder, host, _spec,
            () => host.filepathFolderButtonPressed_(this, this._input, this._pathkind, _spec.basedir$, _spec.foldercallback$),
            () => host.filepathKindButtonPressed_(this, this._input, this._pathkind!, _spec.basedir$));
        this.setupInput1_(host, this._input, () => {
            host.filepathInputChanged_(this, this._input, this._pathkind, _spec.basedir$);
        });
        this._input.setAttribute(ATTR.AnNoClick, "true");
        An.onFocus_(this._input, () => host.info_(this.getValue_()));
    }
    get spec$(): FilepathField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._buttons.forEach((button) => button.blur());
    }
    getValue_(_at?: Int): string {
        return HumanFilepath.getValue_(this._input);
    }
    setValue_(value: string, _at?: Int): void {
        HumanFilepath.setValue_(this._input, value);
    }
    getButton_(name: string): HTMLElementX {
        return this._buttons.get(name) ?? null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class FilepathFolderField extends DialogFieldSpecBase implements IFilepathFieldSpec {
    readonly buttons$ = [BUT.Folder];
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: HumanFilepath,
        readonly placeholder$: string,
        readonly basedir$: BasedirX,
        readonly foldercallback$: PromptFilepathCallback,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new FilepathFolderFieldImpl(host, builder, this);
    }
}

class FilepathFolderFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _input: AnInputElement;
    private _button: HTMLButtonElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: FilepathFolderField) {
        super();
        [this._top, this._input, this._button] = _DialogUt.createFilepathFolderInput_(
            builder, host, _spec,
            () => host.filepathFolderButtonPressed_(this, this._input, null, _spec.basedir$, _spec.foldercallback$));
        this.setupInput1_(host, this._input, () => {
            host.filepathInputChanged_(this, this._input, null, _spec.basedir$);
        });
        this._input.setAttribute(ATTR.AnNoClick, "true");
        An.onFocus_(this._input, () => host.info_(this.getValue_()));
    }
    get spec$(): FilepathFolderField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._button.blur();
    }
    getValue_(_at?: Int): string {
        return HumanFilepath.getValue_(this._input);
    }
    setValue_(value: string, _at?: Int): void {
        HumanFilepath.setValue_(this._input, value);
    }
    getButton_(name: string): HTMLElementX {
        return name == BUT.Folder ? this._button : null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class FilterField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly onsearch_: Fun10<string>,
    ) {
        super();
    }

    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new FilterFieldImpl(host, builder, this);
    }
}

class FilterFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _input: HTMLTextAreaElement;
    private _clearbutton: HTMLButtonElement;
    private _searchbutton: HTMLButtonElement;
    constructor(
        host: IDialogFieldHost,
        b: DomBuilderEx,
        private readonly _spec: FilterField) {
        super();
        this._top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        b.div_({
            "class": CSS.AnFlex,
            "style": `flex-basis:100%;flex-flow:nowrap;overflow:hidden`,
        }).push_();
        const disableSearch = () => {
            this._searchbutton.classList.add(CSS.AnDisabled);
            this._clearbutton.classList.add(CSS.AnDisabled);
        };
        const search = () => {
            host.clearStatus_();
            this._spec.onsearch_(input.value.trim());
        };
        const input = b.flexInput_(
            100,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
        );
        input.style.marginRight = "5px";
        input.value = _spec.value$;
        this._input = input;
        this._clearbutton = _DialogUt.createActionButton_(b, BUT.ClearSearchText1);
        this._searchbutton = _DialogUt.createActionButton_(b, BUT.RegexSearch1);
        disableSearch();
        b.pop_();
        this._clearbutton.addEventListener("click", (e) => {
            An.stopevent_(e);
            host.clearStatus_();
            input.value = "";
            disableSearch();
            this._spec.onsearch_("");
        });
        this._searchbutton.addEventListener("click", (e) => {
            An.stopevent_(e);
            search();
        });
        this.setupInput1_(host, input, () => {
            host.fireOnChange_(this, input);
            search();
        });
        An.onInput_(input, () => {
            if (this._input.value.length > 0) {
                this._searchbutton.classList.remove(CSS.AnDisabled);
                this._clearbutton.classList.remove(CSS.AnDisabled);
            } else {
                disableSearch();
            }
        });
        An.onInputEnterKey_(this._input, search);
    }
    get spec$(): FilterField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._clearbutton.blur();
        this._searchbutton.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.value.trim();
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    getButton_(name: string): HTMLElementX {
        return (name == BUT.ClearSearchText) ? this._clearbutton
            : (name == BUT.RegexSearch) ? this._searchbutton
                : null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class GlassLayerFIeld extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly buttonsize$: number,
        readonly baseuri$: BaseUriX,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new GlassLayerFIeldImpl(host, builder, this);
    }
}

class GlassLayerFIeldImpl extends DialogField {
    private _sample: HTMLElement;
    private _buttonClear: HTMLElement;
    private _buttonEdit: HTMLElement;
    private _buttonGradient: HTMLElement;
    private _buttonImage: HTMLElement;
    constructor(
        host: IDialogFieldHost,
        b: DomBuilderEx,
        private readonly _spec: GlassLayerFIeld
    ) {
        super();
        if (_spec.label$.length > 0) b.peek_().flexTextContainer_(host.labelWidth$, MSG.string_(_spec.label$));
        else b.peek_().div1_(CSS.AnFlex).div1_(CSS.AnFlexRowNoWrap);
        this._sample = b.push_().div_(
            ["class", CSS.AnFlex],
            [ATTR.placeholder, _DialogUt.placeholder_(this._spec.placeholder$)],
            ["style", "margin-right:5px;flex-basis:100%;justify-self:stretch;"],
        ).cursor_();
        this._buttonClear = _DialogUt.createActionButton_(b, BUT.Clear1);
        this._buttonEdit = _DialogUt.createActionButton_(b, BUT.Edit1);
        this._buttonGradient = _DialogUt.createActionButton_(b, BUT.Gradient1);
        this._buttonImage = _DialogUt.createActionButton_(b, BUT.PickImage1);
        b.pop_();
        if (this._spec.value$ != null) this._sample.style.backgroundImage = this._spec.value$;
        const setvalue = (value: string) => {
            this._sample.style.backgroundImage = value;
            host.fireOnChange_(this, this._sample);
        };
        An.onClick_(this._sample, (e) => {
            An.stopevent_(e);
            host.info_(this._getvalue());
        });
        An.onClick_(this._buttonClear, (e) => {
            An.stopevent_(e);
            setvalue("");
        });
        An.onClick_(this._buttonEdit, (e) => {
            An.stopevent_(e);
            const value = this._getvalue();
            const cpath = native$.getIFrameContextPath_();
            const baseuri = native$.getIFrameUri_();
            if (cpath == null || baseuri == null) return;
            _Util.styleEditor_(accessories$, `background-image: ${value}`, cpath, baseuri, An.above_(this.element_()), host, (styles) => {
                const value = styles[PK.BackgroundImage] ?? "";
                setvalue(value);
            }).show_();
        });
        An.onClick_(this._buttonGradient, (e) => {
            An.stopevent_(e);
            const value = this._sample.style.backgroundImage;
            let gradient = (value.length == 0 || value.startsWith("url(")) ? Gradient.def() : cssParser$.parseGradient_(value);
            if (gradient == null) {
                toasters$.warnKey_(RS.ErrorParsingStyle);
                gradient = Gradient.def();
            }
            while (gradient.colorstops.length < 4) gradient.colorstops.push(null);
            new PromptGradient(host.container_(), _spec.buttonsize$, gradient)
                .above_(host.element_())
                .onOK_(value => {
                    setvalue(value);
                })
                .show_();
        });
        An.onClick_(this._buttonImage, (e) => {
            An.stopevent_(e);
            const value = this._sample.style.backgroundImage;
            const url = (value.length == 0 || value == "none" || An.isGradient_(value))
                ? HumanLink.Empty$
                : CSSUtil.humanCSSUrl_(value);
            new PromptImageUrl(host.container_(), url, _spec.baseuri$, RS.ImageURL, Callbacks.onReadImageFolderButton_)
                .titleKey_(RS.PickImage)
                .above_(host.element_())
                .onOK_((d, uri, okcallback) => {
                    Sanitizers.checkOptionalImageUri_(uri).onFail_(msgs => {
                        okcallback(false);
                        d.warn_(msgs);
                    })?.onOK_(uri => {
                        okcallback(true);
                        this._sample.style.backgroundImage = (uri == null ? "" : CSSUtil.toCSSUrl_(uri.encodedPath$ + uri.hash$));
                        host.fireOnChange_(this, this._sample);
                    });
                })
                .showFilepicker_()
                .show_();
        });
    }
    get spec$(): GlassLayerFIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._sample.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._sample.focus();
        return this._sample;
    }
    blur_(): void {
        this._sample.blur();
    }
    getValue_(_at?: Int): string {
        return this._sample.style.backgroundImage;
    }
    setValue_(value: string, _at?: Int): void {
        this._sample.style.backgroundImage = value;
    }
    getButton_(name: string): HTMLElementX {
        if (name == BUT.Clear1) return this._buttonClear;
        else if (name == BUT.Edit1) return this._buttonEdit;
        else if (name == BUT.Gradient1) return this._buttonGradient;
        else if (name == BUT.PickImage1) return this._buttonImage;
        else return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._sample : null;
    }
    private _getvalue(): string {
        return this._sample.style.backgroundImage;
    }
}

class ImageFilepathFolderField extends DialogFieldSpecBase implements IFilepathFieldSpec {
    readonly buttons$ = [BUT.Folder];
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: HumanFilepath,
        readonly placeholder$: string,
        readonly basedir$: BasedirX,
        readonly foldercallback$: PromptFilepathCallback,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new ImageFilepathFolderFieldImpl(host, builder, this);
    }
}

class ImageFilepathFolderFieldImpl extends DialogField {
    private _top: HTMLElement;
    private _input: AnInputElement;
    private _folderButton: HTMLButtonElement;
    private _dataurlButton: HTMLButtonElement;
    constructor(private readonly _host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: ImageFilepathFolderField) {
        super();
        [this._top, this._input, this._folderButton, this._dataurlButton] = _DialogUt.createImageFilepathFolderInput_(
            builder, _host, _spec,
            () => _host.filepathFolderButtonPressed_(this, this._input, null, _spec.basedir$, _spec.foldercallback$),
            () => this._toggleDataUrlButton());
        this.setupInput1_(_host, this._input, () => {
            _host.filepathInputChanged_(this, this._input, null, _spec.basedir$);
        });
        this._input.setAttribute(ATTR.AnNoClick, "true");
        An.onFocus_(this._input, () => _host.info_(this.getValue_()));
    }
    get spec$(): FilepathFolderField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._folderButton.blur();
    }
    getValue_(_at?: Int): string {
        return An.isToggleButtonDown_(this._dataurlButton) ? "data:" : HumanFilepath.getValue_(this._input);
    }
    setValue_(value: string, _at?: Int): void {
        if (value == "data:") {
            this._setDataUrlButton(true);
        } else {
            HumanFilepath.setValue_(this._input, value);
        }
    }
    getButton_(name: string): HTMLElementX {
        return name == BUT.Folder1 ? this._folderButton : name == BUT.DataUrl1 ? this._dataurlButton : null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
    private _toggleDataUrlButton() {
        this._setDataUrlButton(!An.isToggleButtonDown_(this._dataurlButton));
    }
    private _setDataUrlButton(down: boolean) {
        An.setToggleButton_(this._dataurlButton, down);
        if (down) {
            this._input.classList.add(CSS.AnDisabled);
            this._folderButton.classList.add(CSS.AnDisabled);
        } else {
            this._input.classList.remove(CSS.AnDisabled);
            this._folderButton.classList.remove(CSS.AnDisabled);
        }
        this._host.filepathInputChanged_(this, this._input, null, this._spec.basedir$);
    }
}

class InputField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value: string,
        readonly placeholder$: string,
        readonly entercallback$: Fun10X<IDialogWithInput> = null,
    ) {
        super();
    }
    create_(host: IDialogWithInput, builder: DomBuilderEx): IDialogField {
        return new InputFIeldImpl(host, builder, this);
    }
}

class InputFIeldImpl extends DialogField {
    private _input: HTMLTextAreaElement;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: InputField) {
        super();
        this._input = builder.peek_()
            .flexTextInput_(
                (_spec.label$.length > 0 ? host.labelWidth$ : 0),
                MSG.string_(_spec.label$),
                _DialogUt.placeholder_(_spec.placeholder$),
                host.tabIndex_());
        An.onInputFocusSelect_(this._input);
        if (_spec.value.length > 0) {
            this._input.value = _spec.value;
        }
        this.setupInput_(host, this._input);
        if (_spec.entercallback$ != null) An.onInputEnterKey_(this._input, () => _spec.entercallback$?.(host));
    }
    get spec$(): InputField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.value.trim();
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class InputButtonField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly button$: string,
        readonly buttoncallback$: Fun30X<DialogField, AnInputElement, HTMLButtonElement> = null,
        readonly entercallback$: Fun10X<IDialogWithInput> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new InputButtonFieldImpl(host, builder, this);
    }
}

class InputButtonFieldImpl extends DialogField {
    private _input: AnInputElement;
    private _button: HTMLButtonElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: InputButtonField) {
        super();
        builder.peek_().flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$));
        [this._input, this._button] = _DialogUt.createInputButton_(
            builder,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
            _spec.value$,
            _spec.button$,
        );
        this.setupInput_(host, this._input);
        if (_spec.buttoncallback$ != null) {
            An.onClick_(this._button, (e) => {
                An.stopevent_(e);
                if (An.isButtonDisabled_(this._button)) return;
                this._spec.buttoncallback$?.(this, this._input, this._button);
            });
        }
        if (_spec.entercallback$ != null) An.onInputEnterKey_(this._input, () => _spec.entercallback$?.(host));
    }
    get spec$(): InputButtonField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._button.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.value.trim();
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    setEnable_(enable: boolean) {
        this._input.disabled = !enable;
        An.enableButton_(this._button, enable);
    }
    getButton_(_name: string): HTMLElement {
        return this._button;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._input : at == 1 ? this._button : null;
    }
}

class LabelButtonsField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly placeholder$: string,
        readonly buttons$: string[],
        readonly createlabel$: Fun10<DomBuilderEx>,
        readonly buttoncallback$: Fun20X<DialogField, string> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new LabelButtonsFieldImpl(host, builder, this);
    }
}

class LabelButtonsFieldImpl extends DialogField {
    private _field: HTMLElement;
    private _buttons: HTMLButtonElement[] = [];
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: LabelButtonsField) {
        super();
        this._field = builder.peek_()
            .flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$))
            .push_().cursor_().parentElement as HTMLElement;
        _spec.createlabel$(new DomBuilderEx(builder.cursor_()));
        let first = true;
        for (const name of _spec.buttons$) {
            const button = _DialogUt.createActionButton_(builder, name);
            if (first) {
                button.style.marginLeft = "5px";
                first = false;
            }
            this._buttons.push(button);
            if (_spec.buttoncallback$ != null) {
                An.onClick_(button, (e) => {
                    An.stopevent_(e);
                    this._spec.buttoncallback$?.(this, name);
                });
            }
        }
    }
    get spec$(): LabelButtonsField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._field;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return "";
    }
    setValue_(_value: string, _at?: Int): void {
    }
    getButton_(name: string): HTMLElementX {
        const index = this.spec$.buttons$.indexOf(name);
        return (index >= 0) ? this._buttons[index] : null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this._buttons[at] ?? null;
    }
}

class InputButtonsField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly buttons$: string[],
        readonly callback$: Fun10<string>,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new InputButtonsFieldImpl(host, builder, this);
    }
}

class InputButtonsFieldImpl extends DialogField {
    private _input: AnInputElement;
    private _buttons: StringMap<HTMLButtonElement>;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: InputButtonsField) {
        super();
        builder.peek_().flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$));
        [this._input, this._buttons] = _DialogUt.createInputButtons_(
            builder,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
            _spec.value$,
            _spec.buttons$,
            _spec.callback$,
        );
        this.setupInput_(host, this._input);
    }
    get spec$(): InputButtonsField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        Object.values(this._buttons).forEach((e) => e.blur());
    }
    getValue_(_at?: Int): string {
        return this._input.value.trim();
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    getButton_(name: string): HTMLElementX {
        return this._buttons[name];
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class InputSelectField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly selectvalue$: string,
        readonly options$: string[],
        readonly entercallback$: Fun10X<IDialogWithInput> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new InputSelectFieldImpl(host, builder, this);
    }
}

class InputSelectFieldImpl extends DialogField {
    private _input: HTMLTextAreaElement;
    private _select: SelectOptions;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: InputSelectField) {
        super();
        [this._input, this._select] = _DialogUt.flexTextInputSelect_(
            accessories$,
            builder.peek_(),
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            DEF.BASIS_60,
            MSG.string_(_spec.label$),
            _spec.value$,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
            _spec.selectvalue$,
            _spec.options$);
        this.setupInput_(host, this._input);
        this._select.onChange_((_value) => {
            host.fireOnChange_(this, this._select);
        });
        if (_spec.entercallback$ != null) An.onInputEnterKey_(this._input, () => _spec.entercallback$?.(host));
    }
    get spec$(): InputSelectField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(at?: Int): string {
        let size = this._input.value.trim();
        if (at == 0) { return size; }
        const unit = this._select.getValue_("");
        if (at == 1) { return unit; }
        return size.length == 0 ? "" : size += unit;
    }
    setValue_(value: string, _at?: Int): void {
        if (value.length == 0) {
            this._input.value = "";
            return;
        }
        const sizeunit = An.splitSizeUnit_(value);
        if (sizeunit == null) { return; }
        this._input.value = sizeunit[0];
        this._select.setValue_(sizeunit[1]);
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._input : at == 1 ? this._select : null;
    }
}

class SelectInputField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly sep$: string,
        readonly placeholder$: string,
        readonly selectvalue$: string,
        readonly options$: string[]
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new SelectInputFieldImpl(host, builder, this);
    }
}

class SelectInputFieldImpl extends DialogField {
    private _input: HTMLTextAreaElement;
    private _select: SelectOptions;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: SelectInputField) {
        super();
        [this._select, this._input] = _DialogUt.flexTextSelectInput_(
            accessories$,
            builder.peek_(),
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            DEF.BASIS_60,
            MSG.string_(_spec.label$),
            _spec.value$,
            _DialogUt.placeholder_(_spec.placeholder$),
            host.tabIndex_(),
            _spec.selectvalue$,
            _spec.options$);
        this.setupInput_(host, this._input);
        this._select.onChange_((_value) => {
            host.fireOnChange_(this, this._select);
        });
    }
    get spec$(): SelectInputField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(at?: Int): string {
        let size = this._input.value.trim();
        if (at == 0) { return size; }
        const unit = this._select.getValue_("");
        if (at == 1) { return unit; }
        if (size.length > 0) {
            size += this._spec.sep$ + unit;
        }
        return size;
    }
    setValue_(value: string, _at?: Int): void {
        if (value.length == 0) {
            this._input.value = "";
            return;
        }
        const sizeunit = value.split(this._spec.sep$);
        if (sizeunit.length != 2) { return; }
        this._input.value = sizeunit[0];
        this._select.setValue_(sizeunit[1]);
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._input : at == 1 ? this._select : null;
    }
}

class InputSelect2Field extends DialogFieldSpecBase implements IDialogFIeldSpec {
    static splitValue(value: string, sep: string): [size1: string, unit1: string, size2: string, unit2: string] | null {
        const a = value.split(sep);
        if (a.length == 1) {
            const su = An.doubleStringSizeUnit_(a[0].trim());
            return su == null ? null : [su[0], su[1], "", su[1]];
        }
        if (a.length == 2) {
            const su1 = An.doubleStringSizeUnit_(a[0].trim());
            const su2 = An.doubleStringSizeUnit_(a[1].trim());
            return (su1 == null || su2 == null) ? null : [su1[0], su1[1], su2[0], su2[1]];
        }
        return null;
    }
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly sep$: string,
        readonly value1$: string,
        readonly placeholder1$: string,
        readonly selectvalue1$: string,
        readonly options1$: string[],
        readonly value2$: string,
        readonly placeholder2$: string,
        readonly selectvalue2$: string,
        readonly options2$: string[]
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new InputSelect2FieldImpl(host, builder, this);
    }
}

class InputSelect2FieldImpl extends DialogField {
    private _input1: HTMLTextAreaElement;
    private _select1: SelectOptions;
    private _input2: HTMLTextAreaElement;
    private _select2: SelectOptions;
    constructor(
        host: IDialogWithInput,
        builder: DomBuilderEx,
        private readonly _spec: InputSelect2Field
    ) {
        super();
        [this._input1, this._select1, this._input2, this._select2] = _DialogUt.flexTextInputSelect2_(
            accessories$,
            builder.peek_(),
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            DEF.BASIS_60,
            host.tabIndex_(),
            host.tabIndex_(),
            _spec);
        this.setupInput_(host, this._input1);
        this._select1.onChange_((_value) => {
            host.fireOnChange_(this, this._select1);
        });
        this.setupInput_(host, this._input2);
        this._select2.onChange_((_value) => {
            host.fireOnChange_(this, this._select2);
        });
    }
    get spec$(): InputSelect2Field {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input1.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input1.focus();
        return this._input1;
    }
    blur_(): void {
        this._input1.blur();
        this._input2.blur();
    }
    /// @return value in form ${size1}${unit1}${sep}${size2}${unit2}
    getValue_(at?: Int): string {
        let size1 = this._input1.value.trim();
        if (at == 0) { return size1; }
        const unit1 = this._select1.getValue_("");
        if (at == 1) { return unit1; }
        let size2 = this._input2.value.trim();
        if (at == 2) { return size2; }
        const unit2 = this._select2.getValue_("");
        if (at == 3) { return unit1; }
        if (size1.length > 0) {
            size1 += unit1;
        }
        if (size2.length > 0) {
            size2 += unit2;
        }
        return size1 + this._spec.sep$ + size2;
    }
    /// @value at==0 for input1, 1 for select1, 2 for input2, 3 for select2, null for all.
    setValue_(value: string, at?: Int): void {
        if (at == 0) {
            this._input1.value = value;
            return;
        } if (at == 1) {
            this._select1.setValue_(value);
            return;
        }
        if (at == 2) {
            this._input2.value = value;
            return;
        }
        if (at == 3) {
            this._select2.setValue_(value);
            return;
        }
        if (value.length == 0) {
            this._input1.value = "";
            this._input2.value = "";
            return;
        }
        const a = InputSelect2Field.splitValue(value, this._spec.sep$);
        if (a != null) {
            this._input1.value = a[0];
            this._select1.setValue_(a[1]);
            this._input2.value = a[2];
            this._select2.setValue_(a[3]);
        }
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        if (at == 0) return this._input1;
        else if (at == 2) return this._input2;
        else return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        if (at == 0) return this._input1;
        else if (at == 1) return this._select1;
        else if (at == 2) return this._input2;
        else if (at == 3) return this._select2;
        else return null;
    }
}

class Input2FIeld extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly sep$: string,
        readonly buttonsize$: number,
        readonly placeholder1$: string,
        readonly key1$: string,
        readonly value1$: string,
        readonly unit1$: string,
        readonly placeholder2$: string,
        readonly key2$: string,
        readonly value2$: string,
        readonly unit2$: string
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new Input2FieldImpl(host, builder, this);
    }
}

class Input2FieldImpl extends DialogField {
    private _input1: HTMLTextAreaElement;
    private _input2: HTMLTextAreaElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: Input2FIeld) {
        super();
        [this._input1, this._input2] = _DialogUt.flexTextInput2_(
            builder.peek_(),
            _spec.buttonsize$,
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$),
            DEF.BASIS_60,
            host.tabIndex_(),
            _DialogUt.placeholder_(_spec.placeholder1$),
            _spec.value1$,
            _spec.unit1$,
            host.tabIndex_(),
            _DialogUt.placeholder_(_spec.placeholder2$),
            _spec.value2$,
            _spec.unit2$);
        this.setupInput_(host, this._input1);
        this.setupInput_(host, this._input2);
    }
    get spec$(): Input2FIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input1.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input1.focus();
        return this._input1;
    }
    blur_(): void {
        this._input1.blur();
        this._input2.blur();
    }
    getValue_(at?: Int): string {
        const value1 = this._input1.value.trim();
        if (at == 0) return value1;
        const value2 = this._input2.value.trim();
        if (at == 1) { return value2; }
        return value1 + this._spec.sep$ + value2;
    }
    setValue_(value: string, at?: Int): void {
        if (at == 0) {
            this._input1.value = value;
            return;
        }
        if (at == 1) {
            this._input2.value = value;
            return;
        }
        if (value.length == 0) {
            this._input1.value = "";
            this._input2.value = "";
        } else if (!value.includes(this._spec.sep$)) {
            this._input1.value = value;
            this._input2.value = "";
        } else {
            const values = value.split(this._spec.sep$);
            if (values.length >= 2) {
                this._input1.value = values[0];
                this._input2.value = values[1];
            }
        }
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input1 : at == 1 ? this._input2 : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class ImageDimFIeld extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly placeholder1$: string,
        readonly placeholder2$: string,
        readonly buttonsize$: number,
        readonly originalDim$: [Int, Int],
        readonly value$: [Int, Int],
        readonly defSize$: Int,
        readonly defSizeList$: string[],
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new ImageSizeSelectFieldImpl(host, builder, this);
    }
}
class ImageSizeSelectFieldImpl extends DialogField {
    private _input1: AnInputElement;
    private _input2: AnInputElement;
    private _select: SelectOptions;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: ImageDimFIeld) {
        super();
        const flexTextImageSizeSelect_ = (): [AnInputElement, AnInputElement, SelectOptions] => {
            const labelbasis = (_spec.label$.length > 0 ? host.labelWidth$ : 0);
            const label = MSG.string_(_spec.label$);
            const placeholder1 = _DialogUt.placeholder_(_spec.placeholder1$);
            const placeholder2 = _DialogUt.placeholder_(_spec.placeholder2$);
            const tabindex1 = host.tabIndex_();
            const tabindex2 = host.tabIndex_();
            const b = builder.peek_();
            b.flexTextContainer_(labelbasis, label).push_();
            let input1 = b.flexInput_(35, placeholder1, tabindex1);
            b.peek_().span_({
                "class": CSS.AnFlex01Auto,
                "style": "margin:0 5px",
            }).text_("x");
            let input2 = b.peek_()
                .flexInput_(35, placeholder2, tabindex2);
            b.peek_().span_({
                "class": CSS.AnFlex01Auto,
                "style": `min-width:${_spec.buttonsize$ + 5}px`,
            }).text_(CSSLength.PX);
            const select = new SelectOptions(accessories$, b.peek_().div_(
                ["class", `${CSS.AnPromptSelect} ${CSS.AnMarginLeft5}`],
                ["style", "flex-basis:30%;background-color:rgba(0, 0, 0, 0.0);"],
            ).cursor_());
            select.setOptions_(_spec.defSizeList$, null, _spec.defSizeList$.indexOf(`${_spec.defSize$}`));
            input1.value = With.map_(_spec.value$[0], (v) => v == 0 ? "" : `${v}`);
            input2.value = With.map_(_spec.value$[1], (v) => v == 0 ? "" : `${v}`);
            b.pop_();
            b.up_();
            return [input1, input2, select];
        };
        [this._input1, this._input2, this._select] = flexTextImageSizeSelect_();
        this.setupInput_(host, this._input1);
        this.setupInput_(host, this._input2);
        this._select.onChange_((value) => {
            const empty1 = With.map_(this._input1.value.trim(), (value) => value.length == 0 || value == "0");
            const empty2 = With.map_(this._input2.value.trim(), (value) => value.length == 0 || value == "0");
            const iwidth = _spec.originalDim$[0];
            const iheight = _spec.originalDim$[1];
            if (value.length == 0) {
                this._input1.value = "";
                this._input2.value = "";
            } else if (empty1 && !empty2) {
                this._input1.value = "";
                this._input2.value = value;
            } else if (!empty1 && empty2) {
                this._input1.value = value;
                this._input2.value = "";
            } else {
                const size = An.parseInt_(value, null);
                if (size != null) {
                    const dim = MediaUtil.fit_(iwidth, iheight, size, size);
                    this._input1.value = dim.x == 0 ? "" : `${dim.x}`;
                    this._input2.value = dim.y == 0 ? "" : `${dim.y}`;
                }
            }
        });
    }
    get spec$(): ImageDimFIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input1.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input1.focus();
        return this._input1;
    }
    blur_(): void {
        this._input1.blur();
        this._input2.blur();
    }
    getValue_(at?: Int): string {
        const value1 = this._input1.value.trim();
        if (at == 0) return value1;
        const value2 = this._input2.value.trim();
        if (at == 1) { return value2; }
        return value1 + "x" + value2;
    }
    setValue_(value: string, at?: Int): void {
        this._select.setSelectedIndex_(0);
        if (at == 0) {
            this._input1.value = value;
            return;
        }
        if (at == 1) {
            this._input2.value = value;
            return;
        }
        if (value.length == 0) {
            this._input1.value = "";
            this._input2.value = "";
        } else if (!value.includes("x")) {
            this._input1.value = value;
            this._input2.value = "";
        } else {
            const values = value.split("x");
            if (values.length >= 2) {
                this._input1.value = values[0];
                this._input2.value = values[1];
            }
        }
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input1 : at == 1 ? this._input2 : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class SampleField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly key$: string,
        readonly style$: string = "",
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new SampleFieldImpl(host, builder, this);
    }
}

class SampleFieldImpl extends DialogField {
    private _div: HTMLElement;
    constructor(_host: IDialog, builder: DomBuilderEx, private readonly _spec: SampleField) {
        super();
        const attrs = smap_(
            ["class", CSS.AnFlexCenter],
            ["style", "width:100%;overflow:hidden;" + _spec.style$],
        );
        this._div = builder.peek_()
            .div_(attrs)
            .cursor_();
    }
    get spec$(): SampleField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._div;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return "";
    }
    setValue_(_value: string, _at?: Int): void {
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._div : null;
    }
}

class SelectFIeld extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly options$: string[],
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new SelectFIeldImpl(host, builder, this);
    }
}

class SelectFIeldImpl extends DialogField {
    private _select: SelectOptions;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: SelectFIeld) {
        super();
        builder.peek_();
        this._select = _DialogUt.flexTextSelect_(
            accessories$,
            builder,
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$),
            _DialogUt.placeholder_(_spec.placeholder$));
        const selectedindex = Math.max(0, _spec.options$.indexOf(_spec.value$));
        this._select.setOptions_(_spec.options$, null, selectedindex);
        this._select.onChange_((_value) => {
            host.fireOnChange_(this, this._select);
        });
    }
    get spec$(): SelectFIeld {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._select.element_().parentElement!;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return this._select.getValue_("");
    }
    setValue_(value: string, _at?: Int): void {
        this._select.setValue_(value);
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._select : null;
    }
}

class SeparatorField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    static readonly DEF = new SeparatorField();
    constructor(
        readonly style$ = "height:0;margin:5px 0;",
    ) {
        super();
    }
    get key$(): string { return ""; }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new SeparatorFieldImpl(host, builder, this);
    }
}

class SeparatorFieldImpl extends DialogField {
    private _div: HTMLElement;
    constructor(_host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: SeparatorField) {
        super();
        this._div = builder.peek_().div_({
            "class": `${CSS.AnFlex}`,
            "style": _spec.style$,
        }).cursor_();
    }
    get spec$(): SeparatorField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._div;
    }
    focus_(): HTMLElementX {
        return null;
    }
    blur_(): void {
    }
    getValue_(_at?: Int): string {
        return "";
    }
    setValue_(_value: string, _at?: Int): void {
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._div : null;
    }
}

class SliderField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: number,
        readonly placeholder$: string,
        readonly min$: number,
        readonly max$: number,
        readonly step$: number,
        readonly mark$: number,
        readonly height$: string,
        readonly oninput$: Fun10X<string> = null,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new SliderFIeldImpl(host, builder, this);
    }
}

class SliderFIeldImpl extends DialogField {
    private _slider: HTMLInputElement;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: SliderField) {
        super();
        builder.peek_().flexTextContainer_((_spec.label$.length > 0 ? host.labelWidth$ : 0), MSG.string_(_spec.label$));
        this._slider = DialogUt.createInputSlider_(
            builder, _spec.min$, _spec.max$, _spec.step$, _spec.mark$, _spec.height$,
            _spec.value$, _spec.placeholder$, host.tabIndex_(), () => {
                
                host.fireOnChange_(this, this._slider);
            });
    }
    get spec$(): SliderField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._slider.parentElement!.parentElement!;
    }
    focus_(): HTMLElementX {
        this._slider.focus();
        return this._slider;
    }
    blur_(): void {
        this._slider.blur();
    }
    getValue_(_at?: Int): string {
        return this._slider.value;
    }
    setValue_(value: string, _at?: Int): void {
        this._slider.value = value;
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(_at: number): AnInputElementX | null {
        return null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return at == 0 ? this._slider : null;
    }
}

abstract class CompositeTabPanel extends UIPanelBase {
    protected _fields = new Array<IDialogField>();
    constructor(
        protected readonly _container: HTMLElement,
        protected readonly _host: IDialogFieldHost,
        protected readonly _specs: IDialogFIeldSpec[],
    ) {
        super();
        const b = new DomBuilderEx(this._container);
        b.div_({
            "class": CSS.AnFlexColumnNoWrap,
            "style": "align-items:stretch;margin:5px 0;",
        }).push_();
        const addfield = (field: IDialogField) => {
            field.element_().classList.add(CSS.AnMarginTop5);
            this._fields.push(field);
        };
        for (let spec of _specs) {
            const field = spec.create_(_host, b.peek_());
            if (field instanceof Array) {
                for (const f of field) {
                    addfield(f);
                }
            } else {
                addfield(field);
            }
        }
    }
    element_(): HTMLElement {
        return this._container;
    }
}

class TabField {
    constructor(
        readonly tooltips$: string,
        readonly classes$: string,
        readonly createPanel_: Fun31<IDialogField[], IDialogFieldHost, HTMLElement, IUIPanel>,
    ) { }
}

class TabbedPanelField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly key$ = "",
        readonly tabs$: TabField[],
    ) {
        super();
    }

    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField[] {
        return new TabbedPanelFieldImpl(host, builder, this).create_();
    }
}

interface ITabbedPanelField extends IDialogField {
    tabPanel_(): TabPanel;
}

class TabbedPanelFieldImpl extends DialogField implements ITabbedPanelField {
    private _container: HTMLElement;
    private _tabPanel: TabPanel;
    constructor(
        private readonly _host: IDialogFieldHost,
        b: DomBuilderEx,
        private readonly _spec: TabbedPanelField) {
        super();
        this._container = b.cursor_();
        const tabpanel = new TabPanel(this._container);
        this._tabPanel = tabpanel;
    }
    create_(): IDialogField[] {
        const ret = new Array<IDialogField>();
        ret.push(this);
        for (const tab of this._spec.tabs$) {
            this._tabPanel.addTab(tab.tooltips$, tab.classes$, (top) => {
                top.style.overflow = "auto";
                return tab.createPanel_(ret, this._host, top);
            });
        }
        this._tabPanel.onTabClicked(() => {
            this._host.clearStatus_();
        });
        return ret;
    }
    tabPanel_() {
        return this._tabPanel;
    }
    get spec$(): TabbedPanelField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._container;
    }
    focus_(): HTMLElementX {
        const tab = this._tabPanel.activeTab();
        this._tabPanel.selectTab(tab);
        return tab;
    }
    blur_(): void {
        this._tabPanel.selectTab(null);
    }
    getValue_(_at?: number): string {
        return this._tabPanel.activeTab()?.getAttribute(ATTR.xTooltips) ?? "";
    }
    setValue_(_value: string, _at?: number): void {
    }
    getInput_(_at: number): AnInputElementX {
        return null;
    }
    getValueElement_(_at: number): HTMLElement | HTMLElement[] | SelectOptions | null {
        return this._tabPanel.activeTab();
    }
}

class TextAreaField extends DialogFieldSpecBase implements IDialogFIeldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: string,
        readonly placeholder$: string,
        readonly classes$: string,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new TextAreaFieldImpl(host, builder, this);
    }
}

class TextAreaFieldImpl extends DialogField {
    private _input: HTMLTextAreaElement;
    constructor(host: IDialogWithInput, builder: DomBuilderEx, private readonly _spec: TextAreaField) {
        super();
        const attrs = smap_<string>(
            ["class", _spec.classes$],
            ["tabindex", host.tabIndex_()],
            [ATTR.placeholder, _DialogUt.placeholder_(_spec.placeholder$)],
            [ATTR.autocapitalize, "none"],
        );
        this._input = builder.peek_().flexTextTextarea_(
            (_spec.label$.length > 0 ? host.labelWidth$ : 0),
            MSG.string_(_spec.label$), attrs);
        this._input.value = _spec.value$;
        this.setupInput_(host, this._input);
    }
    get spec$(): TextAreaField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._input.parentElement!;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
    }
    getValue_(_at?: Int): string {
        return this._input.value;
    }
    setValue_(value: string, _at?: Int): void {
        this._input.value = value;
    }
    getButton_(_name: string): HTMLElementX {
        return null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class UriField extends DialogFieldSpecBase implements IUriFieldSpec {
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: HumanLink,
        readonly placeholder$: string,
        readonly baseuri$: BaseUriX,
        readonly buttons$: string[] = [],
        readonly foldercallback$: PromptFilepathCallback,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new UriFIeldImpl(host, builder, this);
    }
}

class UriFIeldImpl extends DialogField {
    private readonly _top: HTMLElement;
    private readonly _input: HTMLTextAreaElement;
    private readonly _pathkind: HTMLElementX;
    private readonly _buttons: Map<string, HTMLButtonElement>;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: UriField) {
        super();
        [this._top, this._input, this._pathkind, this._buttons] = _DialogUt.createUrlInput_(
            builder,
            host,
            _spec,
            () => host.uriFolderButtonPressed_(this, this._input, this._pathkind, _spec.baseuri$, _spec.foldercallback$),
            () => host.uriKindButtonPressed_(this, this._input, this._pathkind, _spec.baseuri$),
        );
        this.setupInput1_(host, this._input, () => {
            host.uriInputChanged_(this, this._input, this._pathkind, _spec.baseuri$);
        });
        this._input.setAttribute(ATTR.AnNoClick, "true");
        An.onFocus_(this._input, () => host.info_(this.getValue_()));
    }
    get spec$(): UriField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._buttons.forEach((button) => button.blur());
    }
    getValue_(_at?: Int): string {
        return HumanLink.getValue_(this._input);
    }
    setValue_(value: string, _at?: Int): void {
        HumanLink.setHref_(this._input, value);
    }
    getButton_(name: string): HTMLElementX {
        return this._buttons.get(name) ?? null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

class UriFolderField extends DialogFieldSpecBase implements IUriFieldSpec {
    readonly buttons$ = [BUT.Folder];
    constructor(
        readonly label$: string,
        readonly key$: string,
        readonly value$: HumanLink,
        readonly placeholder$: string,
        readonly baseuri$: BaseUri,
        readonly foldercallback$: PromptFilepathCallback,
    ) {
        super();
    }
    create_(host: IDialogFieldHost, builder: DomBuilderEx): IDialogField {
        return new UriFolderFieldImpl(host, builder, this);
    }
}

class UriFolderFieldImpl extends DialogField {
    private readonly _top: HTMLElement;
    private readonly _input: HTMLTextAreaElement;
    private readonly _button: HTMLButtonElement;
    constructor(host: IDialogFieldHost, builder: DomBuilderEx, private readonly _spec: UriFolderField) {
        super();
        [this._top, this._input, this._button] = _DialogUt.createUrlFolderInput_(
            builder, host, _spec,
            () => host.uriFolderButtonPressed_(this, this._input, null, _spec.baseuri$, _spec.foldercallback$)),
            this.setupInput1_(host, this._input, () => {
                host.uriInputChanged_(this, this._input, null, _spec.baseuri$);
            });
        this._input.setAttribute(ATTR.AnNoClick, "true");
        An.onFocus_(this._input, () => host.info_(this.getValue_()));
    }
    get spec$(): UriFolderField {
        return this._spec;
    }
    element_(): HTMLElement {
        return this._top;
    }
    focus_(): HTMLElementX {
        this._input.focus();
        return this._input;
    }
    blur_(): void {
        this._input.blur();
        this._button.blur();
    }
    getValue_(_at?: Int): string {
        return HumanLink.getValue_(this._input);
    }
    setValue_(value: string, _at?: Int): void {
        HumanLink.setHref_(this._input, value);
    }
    getButton_(name: string): HTMLElementX {
        return name == BUT.Folder ? this._button : null;
    }
    getInput_(at: number): AnInputElementX {
        return at == 0 ? this._input : null;
    }
    getValueElement_(at: number): DialogFieldValueElement | null {
        return this.getInput_(at);
    }
}

abstract class CompositeDialogBase extends DialogBaseWithFocusInput implements IDialogFieldHost {
    private readonly _fieldsArray = new Array<IDialogField>();
    private _content!: HTMLElement;
    private _onImageContextmenuCallback: ImageContextmenuCallback | null = null;
    private _onPreviewCallback: PreviewCallback | null = null;
    get onImageContextmenuCallback$() { return this._onImageContextmenuCallback; }
    get onPreviewCallback$() { return this._onPreviewCallback; }

    constructor(
        container: HTMLElement,
        private _specs: IDialogFIeldSpec[],
        labelwidth: numberX = null,
    ) {
        super(container);
        if (labelwidth != null) this._labelWidth = labelwidth;
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infosHelpCopyPasteOKCancel),
            (action) => this._toolbarActions(action)
        );
    }

    protected createContent(content: HTMLElement): void {
        //// Additional inputs are referenced relative to the primary input and should not be added to _inputs.
        this._content = content;
        for (let spec of this._specs) {
            this._addField(spec);
        }
    }

    protected specs(): IDialogFIeldSpec[] {
        return this._specs;
    }

    protected _removeField(field: IDialogField) {
        const index = this._fieldsArray.findIndex((f) => f.spec$.key$ == field.spec$.key$);
        if (index >= 0) {
            this._fieldsArray.splice(index, 1);
            field.element_().remove();
        }
    }

    protected _addField(spec: IDialogFIeldSpec): IDialogField | IDialogField[] {
        const addField = (field: IDialogField) => {
            field.element_().classList.add(CSS.AnMarginTop5);
            this._fieldsArray.push(field);
        };
        let field = spec.create_(this, new DomBuilderEx(this._content).push_());
        if (field instanceof Array) {
            for (const f of field) {
                addField(f);
            }
        } else {
            addField(field);
        }
        return field;
    }

    protected _foreachField(callback: Fun10<IDialogField>) {
        this._fieldsArray.forEach(callback);
    }

    actionOK_() {
        this._onOK((yes) => {
            if (yes) this.close_();
        });
    }

    close_() {
        super.close_();
        this._fieldsArray.length = 0;
        this._onImageContextmenuCallback = null;
        this._onPreviewCallback = null;
    }

    onImageContextmenu_(callback: ImageContextmenuCallback): this {
        this._onImageContextmenuCallback = callback;
        return this;
    }

    filepathKindButtonPressed_(field: IDialogField, input: HTMLTextAreaElement, pathkind: HTMLElement, basedir: string): void {
        const filepath = HumanFilepath.getValue_(input);
        const [path] = DialogUt.onFilepathKindButton_(pathkind, filepath, basedir);
        HumanFilepath.setValue_(input, path);
        this.info_(HumanFilepath.getValue_(input));
        this.fireOnChange_(field, input);
    }

    filepathFolderButtonPressed_(
        field: IDialogField,
        input: AnInputElement,
        pathkind: HTMLElementX,
        basedir: BasedirX,
        foldercallback: PromptFilepathCallback,
    ): void {
        foldercallback(HumanFilepath.getValue_(input), basedir, An.above_(this.element_()), (cpath) => {
            const path = Callbacks.getFilepathOfKind_(DialogUt.getPathKind_(pathkind), cpath, basedir);
            HumanFilepath.setValue_(input, path);
            this.info_(HumanFilepath.getValue_(input));
            this.fireOnChange_(field, input);
        });
    }

    filepathInputChanged_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, basedir: string): void {
        const filepath = HumanFilepath.getValue_(input);
        const path = Callbacks.getFilepathOfKind_(DialogUt.getPathKind_(pathkind), filepath, basedir);
        HumanFilepath.setValue_(input, path);
        this.info_(HumanFilepath.getValue_(input));
        this.fireOnChange_(field, input);
    }

    basenameButtonPressed_(field: IDialogField, input: AnInputElement, filename: string, basedir: BasedirX, foldercallback: PromptFilepathCallback) {
        foldercallback(Basepath.joinPath_(basedir, filename), basedir, An.above_(this.element_()), (cpath) => {
            field.setValue_(Basepath.filename_(cpath));
            this.info_(HumanFilepath.getValue_(input));
            this.fireOnChange_(field, input);
        });
    }

    uriKindButtonPressed_(field: IDialogField, input: HTMLTextAreaElement, pathkind: HTMLElement, baseuri: BaseUri): void {
        const href = HumanLink.getValue_(input);
        An.classlist_(pathkind).toggleAll_(CSS.AnButtonDown, CSS.AnButtonFlat);
        this._updateUriInput(input, pathkind, baseuri, href);
        this.info_(HumanLink.getValue_(input));
        this.fireOnChange_(field, input);
    }

    uriFolderButtonPressed_(
        field: IDialogField,
        input: AnInputElement,
        pathkind: HTMLElementX,
        baseuri: BaseUri,
        foldercallback: PromptFilepathCallback
    ) {
        const ovalue = HumanLink.fromInput_(input);
        foldercallback(ovalue.filepath$, An.cdirOfUri_(baseuri), An.above_(this.element_()), (cpath) => {
            const href = ovalue.changeFilepath_(cpath).humanHref$;
            this._updateUriInput(input, pathkind, baseuri, href);
            this.info_(HumanLink.getValue_(input));
            this.fireOnChange_(field, input);
        });
    }

    uriInputChanged_(field: IDialogField, input: AnInputElement, pathkind: HTMLElementX, baseuri: BaseUriX): void {
        const href = HumanLink.getValue_(input);
        if (href.length == 0 || href == ".") {
            this.warn_(MSG.string_(RS.URLInputMustNotBeEmpty));
            return;
        }
        this._updateUriInput(input, pathkind, baseuri, href);
        this.info_(HumanLink.getValue_(input));
        this.fireOnChange_(field, input);
    }

    protected _updateUriInput(input: AnInputElement, pathkind: HTMLElementX, baseuri: BaseUriX, href: string) {
        const uri = this.parseUri_(href, baseuri);
        if (uri == null) {
            this.warn_(MSG.string1_(RS.InvalidURL_, href));
            return;
        }
        if (An.dataUrlScheme_(href) != null) {
            HumanLink.setHref_(input, href);
            return;
        }
        const absolute = DialogUt.getPathKind_(pathkind);
        const u = Callbacks.getUriOfKind_(absolute, uri);
        HumanLink.setUri_(input, u);
        toasters$.infoKey_((absolute ? RS.Absolute : RS.Relative), { attop: false });
    }

    /// @param done Call done(true) if success and close the dialog,
    /// done(false) to abort closing and keep dialog open.
    protected abstract _onOK(done: BoolCallback): void;

    postUpdate(callback: Fun00): void {
        if (!this._shown) return;
        callback();
    }

    onPreview(callback: PreviewCallback): this {
        this._onPreviewCallback = callback;
        return this;
    }

    /**
       * Focus on the first input element by default.
       */
    setInitialFocus_(): void {
        for (const field of this._fieldsArray) {
            const ret = field.focus_();
            if (ret != null) {
                this._focusInput = ret;
                break;
            }
        }
    }

    blurAll(): void {
        for (const field of this._fieldsArray) {
            field.blur_();
        }
        this._focusInput = null;
    }

    setVisible_(key: string, b: boolean): this {
        this.getField_(key).element_().style.display = b ? "" : "none";
        return this;
    }

    setVisibleAt_(index: Int, b: boolean): void {
        this.getFieldAt_(index).element_().style.display = b ? "" : "none";
    }

    protected _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Help:
                this.actionHelp_();
                break;
            case BUT.PasteFromLocalClipboard:
                if (this._focusInput != null) {
                    this.actionPaste_(this._focusInput);
                    this._focusInput.dispatchEvent(new Event("change"));
                }
                break;
            case BUT.CopyToLocalClipboard:
                if (this._focusInput != null) {
                    this.actionCopy_(this._focusInput);
                }
                break;
            case BUT.OK: {
                this.actionOK_();
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    getValue_(key: string, at?: number): string {
        return this.getField_(key).getValue_(at);
    }

    getValueAt_(index: number, at?: number): string {
        return this.getFieldAt_(index).getValue_(at);
    }

    getIntValue(key: string, at?: number): Int | null {
        return An.parseInt_(this.getField_(key).getValue_(at), null);
    }

    getIntValueAt(index: number, at?: number): Int | null {
        return An.parseInt_(this.getFieldAt_(index).getValue_(at), null);
    }

    setValue_(key: string, value: string, at?: number): ICompositeDialog {
        const field = this._fieldsArray.find(f => f.spec$.key$ == key);
        if (field === undefined) { throw new Error(key); }
        field.setValue_(value, at);
        return this;
    }

    setLabel(key: string, value: string): void {
        const field = this._fieldsArray.find(f => f.spec$.key$ == key);
        if (field === undefined) { throw new Error(key); }
        const label = field.element_().querySelector(`div.${CSS.AnRightAlignLabel}`);
        if (label != null) {
            label.textContent = value;
        }
    }

    setValueAt_(index: number, value: string, at?: number): ICompositeDialog {
        if (index < 0 || index >= this._fieldsArray.length) {
            throw new Error(`${index}`);
        }
        this._fieldsArray[index].setValue_(value, at);
        return this;
    }

    getChanged_(original?: Map<string, string>): Map<string, string> {
        const old = (original !== undefined ? original : new Map<string, string>());
        const ret = new Map<string, string>();
        this._fieldsArray.forEach((field) => {
            const spec = field.spec$;
            const key = spec.key$;
            if (key.length == 0 || key.startsWith("#")) {
                return;
            }
            const value = field.getValue_();
            if (value !== old.get(key)) {
                ret.set(key, value);
            }
            if (field instanceof Input2FieldImpl) {
                const input2 = spec as Input2FIeld;
                const value1 = field.getValue_(0);
                const value2 = field.getValue_(1);
                if (value1 != old.get(input2.key1$)) {
                    ret.set(input2.key1$, value1);
                }
                if (value2 != old.get(input2.key2$)) {
                    ret.set(input2.key2$, value2);
                }
            }
        });
        return ret;
    }

    getField_(key: string): IDialogField {
        const field = this._fieldsArray.find(f => f.spec$.key$ == key);
        if (field === undefined) throw new Error(key);
        return field;
    }

    getFieldAt_(index: Int): IDialogField {
        if (index < 0 || index >= this._fieldsArray.length) {
            throw new Error(`${index}`);
        }
        return this._fieldsArray[index];
    }

    protected _onResize() {
        super._onResize();
        for (let field of this._fieldsArray) {
            field.onResize_();
        }
    }
}

////////////////////////////////////////////////////////////////////////

class PromptWarning extends DialogBase {
    constructor(container: HTMLElement, titlekey: StringId, msg: TestResult, above: HTMLElement | number | null = null) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(titlekey);
        this.message_(msg);
        this.above_(above);
    }

    protected create_(container: HTMLElement): HTMLElement {
        const ret = this._createMessageDialog(
            container, BUT.infosCancel,
            (action) => this._defaultToolbarHandler1(action)
        );
        ret.classList.add(CSS.AnWarning);
        return ret;
    }

    onDismiss_(cb: Fun00): void {
        this._cancelCallback = cb;
    }
}

////////////////////////////////////////////////////////////////////////

class PromptOK extends DialogBase {
    private _okCallback: Fun00X = null;

    constructor(container: HTMLElement, titlekey: StringId, msg: TestResult, above: ZindexOption = null) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(titlekey);
        this.message_(msg);
        this.above_(above);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createMessageDialog(
            container,
            BUT.infosOKCancel,
            (action) => this._toolbarActions(action)
        );
    }

    /// @param callback()
    onOK_(callback: Fun00): this {
        this._okCallback = callback;
        return this;
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    private _toolbarActions(action: string): void {
        switch (action) {
            case BUT.OK:
                const callback = this._okCallback!;
                this.close_();
                callback();
                break;
            default:
                this._defaultToolbarHandler1(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class PromptSave extends DialogBase {
    private _saveCallback: Fun00 | null = null;
    private _discardCallback: Fun00 | null = null;

    constructor(container: HTMLElement, titlekey: StringId, msg: TestResult, above: ZindexOption = DEF.zindexPromptSave) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(titlekey);
        this.message_(msg);
        this.above_(above);
    }

    protected create_(container: HTMLElement): HTMLElement {
        const ret = this._createMessageDialog(
            container,
            BUT.infos_(BUT.Save, BUT.Discard, BUT.Cancel),
            (action) => {
                switch (action) {
                    case BUT.Save: {
                        const callback = this._saveCallback!;
                        this.close_();
                        callback();
                        break;
                    }
                    case BUT.Discard: {
                        const callback = this._discardCallback!;
                        this.close_();
                        callback();
                        break;
                    }
                    default:
                        this._defaultToolbarHandler1(action);
                }
            });
        ret.classList.add(CSS.AnWarning);
        return ret;
    }

    close_() {
        super.close_();
        this._saveCallback = null;
        this._discardCallback = null;
    }

    /// @param callback()
    onSave_(callback: Fun00): void {
        this._saveCallback = callback;
    }

    /// @param callback()
    onDiscard_(callback: Fun00): void {
        this._discardCallback = callback;
    }
}

////////////////////////////////////////////////////////////////////////

class PromptInput extends DialogBaseWithFocusInput {
    private _input!: HTMLTextAreaElement;
    private _okCallback: OKCallback1<IDialog, string> | null = null;

    constructor(container: HTMLElement, titlekey: StringId, value: string, above: ZindexOption = null) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(titlekey);
        this.above_(above);
        if (this._input != null) {
            this._input.value = value;
        }
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (content) => this._createContent(content),
            (elm) => new Toolbar(elm, BUT.infosCopyPasteOKCancel),
            (action) => this._toolbarActions(action));
    }

    private _createContent(content: HTMLElement) {
        const b = new DomBuilderEx(content);
        this._input = b.child_(Conf.input$, INPUT.info_(INPUT.PromptInputAutoFocus)).cursor_() as AnInputElement;
        An.onInputEnterKey_(An.onInputFocusSelect_(this._input), () => {
            this._ok();
        });
    }

    close_() {
        super.close_();
        this._okCallback = null;
    }

    onOK_(callback: OKCallback1<IDialog, string>): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        An.focus_(this._input);
    }

    private _ok() {
        this._okCallback!(this, (this._input?.value ?? ""), (yes) => {
            if (yes) this.close_();
        });
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK:
                this._ok();
                break;
            default:
                super.defaultToolbarActions_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for text node using a textarea input,
 * with Insert as child or after actions.
 */
abstract class PromptEditTextBase extends DialogBaseWithFocusInput {
    protected _contextmenu: Contextmenu | null = null;
    protected _textarea: HTMLTextAreaElement | null = null;
    protected _escaped: boolean = false;

    constructor(
        container: HTMLElement,
        private _buttonSize: number,
        private _fontFamily: stringX,
        private _dateFormat: string,
        private _timeFormat: string,
        private _promptSymbolHandler: IPromptSymbolHandler | null
    ) {
        super(container);
        this.largeWidth_();
    }

    protected _createContent(content: HTMLElement): void {
        this._textarea = new DomBuilderEx(content)
            .textarea_(INPUT.info_(INPUT.TextareaEditText)).addStyle_("margin-top", "5px")
            .cursor_() as HTMLTextAreaElement;
        if (this._fontFamily != null) {
            this._textarea.style.fontFamily = this._fontFamily;
        }
    }

    protected _createContextmenu(): Contextmenu {
        const menu = new Contextmenu(this._container, An.above_(this._dialog), [
            BUT.infos_(
                BUT.CopyToLocalClipboard,
                BUT.CutToLocalClipboard,
                BUT.PasteFromLocalClipboard,
            ),
            BUT.infos_(
                BUT.Nbsp,
                BUT.Symbol,
                BUT.Date,
            ),
        ]);
        menu.onTooltips_(toasters$.onTooltipsKey_);
        menu.onDrag_(Contextmenu.contextmenuDragOK_);
        menu.onAction_((action) => this._contextActions(action));
        menu.onShow_(() => {
            menu?.enableButton_(BUT.Symbol, this._promptSymbolHandler != null);
        });
        return menu;
    }

    close_() {
        this._contextmenu?.destroy_();
        this._contextmenu = null;
        super.close_();
    }

    setInitialFocus_(): void {
        An.focus_(this._textarea);
    }

    private _contextActions(action: string): void {
        this.clearStatus_();
        this._contextmenu?.hide_();
        if (this._textarea == null) { return; }
        switch (action) {
            case BUT.Symbol: {
                if (this._promptSymbolHandler != null) {
                    const d = new PromptSymbol(this._container, this._promptSymbolHandler);
                    d.titleKey_(RS.InsertSymbolTitle);
                    d.above_(this.element_());
                    d.onOK_((text, _tooltips, _attrs) => {
                        this._pasteValue(this._textarea, null, this._escaped ? An.escText_(text) : text);
                    });
                    d.show_();
                }
                break;
            }
            case BUT.Date: {
                const now = DateTime.now_();
                new PromptDate(this._container, now, now, PromptDate.ALL, this._buttonSize)
                    .titleKey_(RS.PromptDateTimeTitle)
                    .above_(this.element_())
                    .dateFormat_(this._dateFormat)
                    .timeFormat_(this._timeFormat)
                    .allowAuto(false)
                    .onOK_((_date, _dateformat, _timeformat, formatted) => {
                        formatted = replaceAll_(formatted, " ", "\u00a0");
                        this._pasteValue(this._textarea, null, this._escaped ? An.escText_(formatted) : formatted);
                    })
                    .showTab_(PromptDate.DATE);
                break;
            }
            case BUT.Nbsp: {
                const v = this._textarea.value;
                const start = this._textarea.selectionStart;
                const end = this._textarea.selectionEnd;
                const s = (start <= end ? start : end);
                const e = (start <= end ? end : start);
                const before = v.substring(0, s);
                const after = v.substring(e);
                let text = (this._escaped ? "&#xa0;" : "\u00a0");
                if (e > s) {
                    text = replaceAll_(v.substring(s, e), " ", text);
                }
                text = (before + text + after);
                const offset = s + text.length;
                DialogBase._setTextAreaValueRange(this._textarea, text, offset, offset);
                break;
            }
            case BUT.PasteFromLocalClipboard:
                this.actionPaste_(this._textarea, this._escaped);
                break;
            case BUT.CutToLocalClipboard:
                this.actionCut_(this._textarea, this._escaped);
                break;
            case BUT.CopyToLocalClipboard:
                this.actionCopy_(this._textarea, this._escaped);
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    actionEscapeText(): void {
        if (this._textarea == null || this._toolbar == null) { return; }
        this._escaped = !this._escaped;
        const button = this._toolbar.button_(BUT.EscapeText);
        if (this._escaped) {
            button.classList.add(CSS.AnButtonDown);
            this._textarea.style.fontFamily = "";
            this._textarea.value = An.escText_(this._textarea.value);
            this._textarea.setSelectionRange(0, 0);
        } else {
            button.classList.remove(CSS.AnButtonDown);
            if (this._fontFamily != null) {
                this._textarea.style.fontFamily = this._fontFamily;
            }
            this._textarea.value = An.unescText_(this._textarea.value);
            this._textarea.setSelectionRange(0, 0);
        }
    }

    getvalue_(): string {
        const value = this._textarea?.value ?? "";
        return (this._escaped ? An.unescText_(value) : value);
    }
}

//////////////////////////////////////////////////////////////////////////

/**
 * Prompt for text node using a textarea,
 * with an nbsp action.
 */
class PromptEditText extends PromptEditTextBase {
    _okCallback: OKCallback2<IDialog, string, number> | null = null;
    _initialValue: stringX = null;

    constructor(
        container: HTMLElement,
        buttonSize: number,
        fontfamily: stringX,
        dateFormat: string,
        timeFormat: string,
        handler: IPromptSymbolHandler | null,
        above: ZindexOption = null
    ) {
        super(container, buttonSize, fontfamily, dateFormat, timeFormat, handler);
        super.init_(this.create_(container));
        this.above_(above);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (content) => this._createContent(content),
            (elm) => new Toolbar(elm, BUT.infos_(BUT.Contextmenu, BUT.EscapeText, BUT.OK, BUT.Cancel)),
            (action, e) => this._toolbarActions(action, e));
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    private _toolbarActions(action: string, e: Event): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Contextmenu: {
                Timer.sleep1_(() => {
                    if (this._contextmenu == null) {
                        this._contextmenu = this._createContextmenu();
                    }
                    this._contextmenu.show_(e as MouseEvent);
                });
                break;
            }
            case BUT.EscapeText:
                this.actionEscapeText();
                break;
            case BUT.OK: {
                const value = this.getvalue_();
                const start = this._textarea?.selectionStart ?? 0;
                this._okCallback!(this, value, start, (yes) => this.actionOKConfirmed_(yes));
                break;
            }
            case BUT.Cancel: {
                const modified = (this._initialValue != null && this._textarea != null && this._initialValue != this.getvalue_());
                _DialogUt.confirmCancel_(this, modified, () => this.actionCancelConfirmed_());
                break;
            }
            default:
                this.actionInvalid_(action);
        }
    }

    onOK_(callback: OKCallback2<IDialog, string, number>): this {
        this._okCallback = callback;
        return this;
    }

    value_(value: string, start: numberX = null, end: numberX = null): void {
        this._initialValue = value;
        if (this._textarea == null) { return; }
        this._textarea.value = value;
        if (start != null) {
            if (end == null) {
                end = start;
            }
            this._textarea.selectionStart = start;
            this._textarea.selectionEnd = end;
        }
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for text node using a textarea input,
 * with Insert as child or after actions.
 */
class PromptInsertText extends PromptEditTextBase {
    _afterCallback: OKCallback1<IDialog, string> | null = null;
    _childCallback: OKCallback1<IDialog, string> | null = null;

    constructor(
        container: HTMLElement,
        buttonSize: number,
        fontfamily: stringX,
        dateFormat: string,
        timeFormat: string,
        handler: IPromptSymbolHandler | null
    ) {
        super(container, buttonSize, fontfamily, dateFormat, timeFormat, handler);
        super.init_(this.create_(container));
        this._toolbar!.button_(BUT.After)?.classList.add(CSS.AnDisabled);
        this._toolbar!.button_(BUT.Child)?.classList.add(CSS.AnDisabled);
        if (this._textarea != null) {
            this._textarea.value = MSG.XXX$;
            An.select_(this._textarea);
        }
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (content) => this._createContent(content),
            (elm) => new Toolbar(elm, BUT.infos_(
                BUT.Contextmenu,
                BUT.EscapeText,
                BUT.Child,
                BUT.After,
                BUT.Cancel
            )),
            (action, e) => this._toolbarActions(action, e)
        );
    }

    close_() {
        super.close_();
        this._childCallback = null;
        this._afterCallback = null;
    }

    onAfter_(callback: OKCallback1<IDialog, string>): void {
        this._toolbar!.button_(BUT.After)?.classList.remove(CSS.AnDisabled);
        this._afterCallback = callback;
    }

    onChild_(callback: OKCallback1<IDialog, string>): void {
        this._toolbar!.button_(BUT.Child)?.classList.remove(CSS.AnDisabled);
        this._childCallback = callback;
    }

    private _toolbarActions(action: string, e: Event): void {
        this.clearStatus_();
        if (this._textarea == null) { return; }
        switch (action) {
            case BUT.Contextmenu: {
                Timer.sleep1_(() => {
                    if (this._contextmenu == null) {
                        this._contextmenu = this._createContextmenu();
                    }
                    this._contextmenu.show_(e as MouseEvent);
                });
                break;
            }
            case BUT.EscapeText:
                this.actionEscapeText();
                break;
            case BUT.After:
                if (this._afterCallback != null) {
                    this._afterCallback(this, this._textarea.value, (yes) => this.actionOKConfirmed_(yes));
                }
                break;
            case BUT.Child:
                if (this._childCallback != null) {
                    this._childCallback(this, this._textarea.value, (yes) => this.actionOKConfirmed_(yes));
                }
                break;
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for element tag using a text input and attributes using a textarea input.
 */
abstract class PromptElementBase extends DialogBaseWithFocusInput {
    protected _okCallback: OKCallback2<IDialog, string, string> | null = null;
    protected _textarea!: HTMLTextAreaElement;
    protected _initialAttributes: stringX = null;
    protected _initialTag: stringX = null;

    protected abstract _createContent(content: HTMLElement): void;

    protected abstract _gettag(): string;

    constructor(container: HTMLElement) {
        super(container);
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (content) => this._createContent(content),
            (elm) => new Toolbar(elm, BUT.infosCopyPasteOKCancel),
            (action) => this._toolbarActions(action)
        );
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: OKCallback2<IDialog, string, string>): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        An.focus_(this._textarea);
    }

    attributes_(value: string): void {
        this._initialAttributes = value;
        this._textarea.value = value;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.PasteFromLocalClipboard:
                this.actionPaste_(this._textarea);
                break;
            case BUT.CopyToLocalClipboard:
                this.actionCopy_(this._textarea);
                break;
            case BUT.OK:
                this._okCallback!(this, this._gettag(), this._textarea.value, (yes) => this.actionOKConfirmed_(yes));
                break;
            case BUT.Cancel: {
                _DialogUt.confirmCancel_(
                    this,
                    (this._initialTag != null && this._initialTag != this._gettag() ||
                        this._initialAttributes != null && this._initialAttributes != this._textarea.value),
                    () => this.actionCancelConfirmed_());
                break;
            }
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for element tag using a select input and attributes using a textarea input.
 */
class PromptInsertElement extends DialogBaseWithFocusInput {
    private _textarea!: HTMLTextAreaElement;
    private _inputTag!: HTMLTextAreaElement;
    private _afterCallback: PromptElementCallback | null = null;
    private _childCallback: PromptElementCallback | null = null;
    private _validator: PromptElementValidator | null = null;
    private _tag: stringX = null;

    constructor(container: HTMLElement) {
        super(container);
        super.init_(this.create_(container));
        this._toolbar!.button_(BUT.After)?.classList.add(CSS.AnDisabled);
        this._toolbar!.button_(BUT.Child)?.classList.add(CSS.AnDisabled);
        this._onShowDialogCallback = (dialog) => {
            if (this._tag != null) {
                this._inputTag.value = this._tag;
            }
            An.setVisible_(dialog);
            Timer.sleep0_(() => this.setInitialFocus_());
        };
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (content) => this._createContent(content),
            (elm) => new Toolbar(elm, BUT.infos_(
                BUT.CopyToLocalClipboard,
                BUT.PasteFromLocalClipboard,
                BUT.Child,
                BUT.After,
                BUT.Cancel
            )),
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content).push_();
        this._inputTag = b.peek_()
            .child_(Conf.input$, INPUT.info_(INPUT.PromptInput))
            .attr_("style", "margin:5px 0;").cursor_() as AnInputElement;
        this._textarea = b.peek_()
            .textarea_(INPUT.info_(INPUT.TextareaOptionalAttributesFull))
            .cursor_() as HTMLTextAreaElement;
    }

    close_() {
        super.close_();
        this._afterCallback = null;
        this._childCallback = null;
    }

    onAfter_(callback: PromptElementCallback): this {
        this._toolbar!.button_(BUT.After)?.classList.remove(CSS.AnDisabled);
        this._afterCallback = callback;
        return this;
    }

    onChild_(callback: PromptElementCallback): this {
        this._toolbar!.button_(BUT.Child)?.classList.remove(CSS.AnDisabled);
        this._childCallback = callback;
        return this;
    }

    onValidate_(validator: PromptElementValidator): this {
        this._validator = validator;
        return this;
    }

    tag_(tag: string): this {
        this._tag = tag;
        return this;
    }

    private _gettag(): string {
        return this._inputTag.value.trim();
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.PasteFromLocalClipboard:
                this.actionPaste_(this._textarea);
                break;
            case BUT.CopyToLocalClipboard:
                this.actionCopy_(this._textarea);
                break;
            case BUT.After:
                if (this._afterCallback != null) {
                    this._ok(this._afterCallback);
                }
                break;
            case BUT.Child:
                if (this._childCallback != null) {
                    this._ok(this._childCallback);
                }
                break;
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _ok(callback: PromptElementCallback): void {
        if (this._validator == null) {
            this.warnKey_(RS.AnElementValidatorIsRequired);
            return;
        }
        this._validator(this._gettag(), this._textarea.value, (ret) => {
            if (this.warn_(ret[Key.errors])) {
                return;
            }
            this.close_();
            toasters$.warn_(ret[Key.warns]);
            if (callback != null) {
                const tag = ret[Key.tag];
                const attrs = (ret[Key.attrs] as SStringMap);
                callback(tag, attrs);
            }
        });
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for element tag using a select input and attributes using a textarea input.
 */
class PromptElement extends PromptElementBase {
    _inputTag!: HTMLTextAreaElement;

    constructor(container: HTMLElement) {
        super(container);
        this._onShowDialogCallback = (dialog) => {
            if (this._initialTag != null) {
                this._inputTag.value = this._initialTag;
            }
            An.setVisible_(dialog);
            Timer.sleep0_(() => this.setInitialFocus_());
        };
    }

    tag_(tag: string): void {
        this._initialTag = tag;
    }

    protected _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content).push_();
        this._inputTag = b.peek_()
            .child_(Conf.input$, INPUT.info_(INPUT.PromptInput))
            .attr_("style", "margin:5px 0;").cursor_() as AnInputElement;
        this._textarea = b.peek_()
            .textarea_(INPUT.info_(INPUT.TextareaOptionalAttributesFull))
            .cursor_() as HTMLTextAreaElement;
    }

    protected _gettag(): string {
        return this._inputTag.value.trim();
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for element tag using a text input and attributes using a textarea input.
 */
class PromptEditElement extends PromptElementBase {
    _inputTag!: HTMLTextAreaElement;

    constructor(container: HTMLElement) {
        super(container);
        this._onShowDialogCallback = (dialog) => {
            if (this._initialTag != null) {
                this._inputTag.value = this._initialTag;
            }
            An.setVisible_(dialog);
            Timer.sleep0_(() => this.setInitialFocus_());
        };
    }

    tag_(tag: string): void {
        this._initialTag = tag;
    }

    protected _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content).push_();
        this._inputTag = b.peek_()
            .child_(Conf.input$, INPUT.info_(INPUT.PromptInput))
            .attr_("style", "margin:5px 0;").cursor_() as AnInputElement;
        this._textarea = b.peek_()
            .textarea_(INPUT.optionalAttributes(CSS.AnFull, "2"))
            .cursor_() as HTMLTextAreaElement;
        An.onInputFocusSelect_(this._inputTag);
    }

    protected _gettag(): string {
        return this._inputTag.value;
    }
}

////////////////////////////////////////////////////////////////////////

class CompositeDialog extends CompositeDialogBase {
    private _okCallback: OKCallback0<ICompositeDialog> | null = null;
    constructor(
        container: HTMLElement,
        specs: IDialogFIeldSpec[],
        labelwidth: numberX = null
    ) {
        super(container, specs, labelwidth);
    }
    close_() {
        this._okCallback = null;
        super.close_();
    }
    getValueAt_(index: number, at?: number): string {
        return super.getValueAt_(index, at);
    }
    onOK_(callback: OKCallback0<ICompositeDialog>): this {
        this._okCallback = callback;
        return this;
    }
    protected _onOK(done: BoolCallback): void {
        this._okCallback!(this, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for name attribute.
 */
class PromptNamedAnchor extends CompositeDialogBase {
    private _okCallback: OKCallback2<ICompositeDialog, string, boolean> | null = null;

    /**
       * @Param container The DOM element that host the dialog.
       */
    constructor(container: HTMLElement, name: string) {
        super(container, [
            new InputField("", "", name, RS.Name,),
            new CheckboxField("", "", "false", MSG.string_(RS.ActionInsertNamedAnchorShowIcon)),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    /// @param callback(href: string, attrs: string)
    onOK_(callback: OKCallback2<ICompositeDialog, string, boolean>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const name = this.getValueAt_(0);
        const showicon = this.getValueAt_(1) == "true";
        this._okCallback!(this, name, showicon, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for URL.
 */
class PromptLink extends CompositeDialogBase {
    private _okCallback: OKCallback1<IDialog, string> | null = null;

    /**
       * @Param container The DOM element that host the dialog.
       */
    constructor(container: HTMLElement, url: HumanLink, baseuri: BaseUri, placeholder: StringId, foldercallback: PromptFilepathCallback) {
        super(container, [
            new UriField("", "", url, placeholder, baseuri, [BUT.PathKind, BUT.Folder], foldercallback),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    /**
       * @param callback(Dialog dialog, href: string)
       */
    onOK_(callback: OKCallback1<IDialog, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const href = this.getValueAt_(0);
        this._okCallback!(this, href, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for URL and attributes.
 */
class PromptLink2 extends CompositeDialogBase {
    private _okCallback: OKCallback2<ICompositeDialog, string, string> | null = null;

    /**
       * @Param container The DOM element that host the dialog.
       */
    constructor(container: HTMLElement, href: HumanLink, attrs: string, baseuri: BaseUri, foldercallback: PromptFilepathCallback) {
        super(container, [
            new UriField("", "", href, RS.URL, baseuri, [BUT.PathKind, BUT.Folder], foldercallback),
            new AttributesFIeld("", "", attrs, RS.Attributes, `${CSS.AnPromptTextarea} ${CSS.AnHalf}`),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    /// @param callback(href: string, attrs: string)
    onOK_(callback: OKCallback2<ICompositeDialog, string, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const href = this.getValueAt_(0);
        const attrs = this.getValueAt_(1);
        this._okCallback!(this, href, attrs, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

/// Prompt for URL, Text and Attributes.
class PromptLink3 extends CompositeDialogBase {
    private _okCallback: OKCallback3<ICompositeDialog, string, string, string> | null = null;

    constructor(container: HTMLElement, uri: HumanLink, text: string, attrs: string, baseuri: BaseUri) {
        super(container, [
            new UriField("", RS.URL, uri, RS.URL, baseuri, [BUT.PathKind, BUT.Folder], Callbacks.onLinkFolderButton_),
            new InputField("", RS.Text, text, RS.Text),
            new AttributesFIeld("", RS.Attributes, attrs, RS.Attributes, `${CSS.AnPromptTextarea} ${CSS.AnHalf}`),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    /// @param callback(url, text, attrs)
    onOK_(callback: OKCallback3<ICompositeDialog, string, string, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const href = this.getValueAt_(0);
        const text = this.getValueAt_(1);
        const attrs = this.getValueAt_(2);
        this._okCallback!(this, href, text, attrs, (ok) => {
            done(ok);
        });
    }
}

//////////////////////////////////////////////////////////////////////////

/**
 * Prompt for media path, caption and attributes.
 */
class PromptInsertImg extends CompositeDialogBase {

    _okCallback: String4OKCallback<IDialog> | null = null;
    _onThumbnailButtonCallback: ThumbnailCallback | null = null;
    _createLinkButton: HTMLElement;
    _createThumbnailButton: HTMLElement;
    _createLink: boolean = false;

    constructor(container: HTMLElement, caption: string, attrs: stringX, baseuri: BaseUriX, foldercallback: PromptFilepathCallback) {
        super(container, [
            new UriField("", "", HumanLink.Empty$, RS.PlaceholderRequiredUrl, baseuri,
                [
                    BUT.CreateThumbnail,
                    BUT.Folder,
                    BUT.CreateLink,
                    BUT.PathKind,
                ],
                foldercallback,
            ),
            new InputField("", "", caption, RS.Caption),
            new AttributesFIeld("", "", (attrs ?? ""), RS.Attributes, `${CSS.AnPromptTextarea} ${CSS.AnHalf}`),
            new UriField("", "", HumanLink.Empty$, RS.LinkURL, baseuri,
                [BUT.PathKind, BUT.Folder],
                Callbacks.onLinkFolderButton_,
            ),
        ]);
        if (attrs == null) {
            this.setVisibleAt_(2, false);
        }
        let field0 = this.getFieldAt_(0);
        this._createLinkButton = field0.getButton_(BUT.CreateLink)!;
        An.onButtonClick_(this._createLinkButton, (e) => {
            An.stopevent_(e);
            this.clearStatus_();
            An.classlist_(this._createLinkButton).toggleAll_(CSS.AnButtonFlat, CSS.AnButtonDown);
            this._createLink = !this._createLink;
            this._showLinkField(this._createLink);
            let src = this.hrefPathPart_(field0.getValue_());
            const m = RX.Tn.exec(src);
            if (m != null) {
                src = m[1] + m[3];
            }
            this.setValueAt_(3, src + `?${Param.view}`);
        });
        this._createThumbnailButton = field0.getButton_(BUT.CreateThumbnail)!;
        this._createThumbnailButton.classList.add(CSS.AnDisabled);
        An.onButtonClick_(this._createThumbnailButton, (e) => {
            An.stopevent_(e);
            this.clearStatus_();
            if (this._onThumbnailButtonCallback != null) {
                const input = field0.getInput_(0)!;
                const ovalue = HumanLink.fromInput_(input);
                let path = ovalue.filepath$;
                if (An.dataUrlScheme_(path) != null && this._createLink) {
                    const linkinput = this.getFieldAt_(3).getInput_(0)!;
                    path = HumanLink.fromInput_(linkinput).filepath$;
                }
                this._onThumbnailButtonCallback(path, baseuri, this, (cpath) => {
                    const pathkind = field0.getButton_(BUT.PathKind);
                    const href = ovalue.changeFilepath_(cpath).humanHref$;
                    this._updateUriInput(input, pathkind, baseuri, href);
                    this.fireOnChange_(field0, input);
                });
            }
        });
        this._showLinkField(this._createLink);
    }

    close_() {
        this._okCallback = null;
        this._onThumbnailButtonCallback = null;
        super.close_();
    }

    onOK_(callback: String4OKCallback<IDialog>): this {
        this._okCallback = callback;
        return this;
    }

    onThumbnailButton_(callback: ThumbnailCallback | null): this {
        this._onThumbnailButtonCallback = callback;
        An.enableButton_(this._createThumbnailButton, callback != null);
        return this;
    }

    private _showLinkField(yes: boolean): void {
        this.setVisibleAt_(3, yes);
        if (yes) {
            const pathkind = this.getFieldAt_(3).getButton_(BUT.PathKind);
            if (pathkind != null) {
                const absolute = DialogUt.getPathKind_(this.getFieldAt_(0).getButton_(BUT.PathKind));
                DialogUt.setPathKind_(pathkind, absolute);
            }
        }
    }

    isCreateLink_(): boolean {
        return this._createLink;
    }

    getSrcPathKind_(): boolean {
        return DialogUt.getPathKind_(this.getFieldAt_(0).getButton_(BUT.PathKind));
    }

    getHrefPathKind_(): boolean {
        return DialogUt.getPathKind_(this.getFieldAt_(3).getButton_(BUT.PathKind));
    }

    protected _onOK(done: BoolCallback): void {
        const src = this.getValueAt_(0);
        const caption = this.getValueAt_(1);
        const attrs = this.getValueAt_(2);
        const href = this._createLink ? this.getValueAt_(3) : "";
        this._okCallback!(this, src, caption, attrs, href, (ok) => {
            done(ok);
        });
    }

    /**
     * Strip fragment and query parts from a href.
     */
    private hrefPathPart_(href: string): string {
        if (An.isempty_(href)) return href;
        let index = href.indexOf("?");
        if (index >= 0) {
            return href.substring(0, index);
        }
        index = href.indexOf("#");
        if (index >= 0) {
            href = href.substring(0, index);
        }
        return href;
    }

    showCaption_(b: boolean): this {
        this.setVisibleAt_(1, b);
        return this;
    }

    showAttributes_(b: boolean): this {
        this.setVisibleAt_(2, b);
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for media path and attributes.
 */
class PromptEditMedia extends CompositeDialogBase {
    _okCallback: OKCallback2<ICompositeDialog, Uri, string> | null = null;

    /// Use by actionEditImg.
    /// @param container The DOM element to host the dialog
    constructor(
        container: HTMLElement,
        url: HumanLink,
        attrs: stringX,
        baseuri: BaseUriX,
        buttons: string[],
        foldercallback: PromptFilepathCallback
    ) {
        super(container, [
            new UriField(
                "",
                "",
                url,
                RS.PlaceholderRequiredUrl,
                baseuri,
                buttons,
                foldercallback),
            new AttributesFIeld(
                "",
                "",
                attrs ?? "",
                RS.Attributes,
                `${CSS.AnPromptTextarea} ${CSS.AnHalf}`),
        ]);
        if (attrs == null) {
            this.setVisibleAt_(1, false);
        }
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    /// @param callback(url, attributes) for OK button
    onOK_(callback: OKCallback2<ICompositeDialog, Uri, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const href = this.getValueAt_(0);
        const attributes = this.getValueAt_(1);
        const uri = An.parseUriSafe_(href, native$.getIFrameUri_());
        if (uri == null) {
            done(false);
            return;
        }
        this._okCallback!(this, uri, attributes, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

class PromptInputImage extends CompositeDialogBase {
    _okCallback: OKCallback4<IDialog, string, string, string, number> | null = null;

    /// @param container The DOM element to host the dialog
    constructor(container: HTMLElement, basedir: string, width: Int, height: Int, rotation: Rotations) {
        super(container, [
            new FilepathField(
                "", "", HumanFilepath.Empty$, RS.PlaceholderRequiredFilepath, basedir,
                [BUT.PathKind, BUT.Folder],
                Callbacks.onReadImageFolderButton_,
            ),
            new InputSelectField(
                "", "", width.toString(), RS.Width,
                CSSLength.PX, CSSLengths
            ),
            new InputSelectField(
                "", "", height.toString(), RS.Height,
                CSSLength.PX, CSSLengths
            ),
            new SelectFIeld(
                "", "", rotation, RS.Rotation,
                ["0 deg", "90 deg", "180 deg", "270 deg"]
            ),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: OKCallback4<IDialog, string, string, string, number>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback) {
        const filepath = this.getValueAt_(0);
        let w = this.getValueAt_(1, 0);
        let h = this.getValueAt_(2, 0);
        if (!An.isempty_(w)) w += this.getValueAt_(1, 1);
        if (!An.isempty_(h)) h += this.getValueAt_(2, 1);
        const rotation = An.parseIntUnit_(this.getValueAt_(3))?.[0] ?? 0;
        this._okCallback!(this, filepath, w, h, rotation, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for image and link path.
 */
class PromptImageUrl2 extends CompositeDialogBase {
    private _onThumbnailButtonCallback: ThumbnailCallback | null = null;
    private _okCallback: OKCallback4<IDialog, string, string, boolean, string> | null = null;
    _createLink: boolean = false;

    constructor(
        container: HTMLElement,
        src: HumanLink,
        attrs: string,
        href: HumanLink,
        baseuri: BaseUri,
        imagefoldercallback: PromptFilepathCallback,
        usecreatelinkbutton: boolean = true,
        linkfoldercallback: PromptFilepathCallback = Callbacks.onLinkFolderButton_,
    ) {
        super(container, [
            ///#NOTE: There are two IMAGE_FILEPATH field here and
            /// _buttons[BUT.PathKind] and _buttons[BUT.Folder] are overwritten by the those for #href.
            /// Use getSrcPathKind() and getHrefPathKind() to get the proper path kind value.
            new UriField(
                "", "#0", src, RS.ImageURL, baseuri,
                (usecreatelinkbutton ? [
                    BUT.CreateThumbnail,
                    BUT.Folder,
                    BUT.CreateLink,
                    BUT.PathKind,
                ] : [
                    BUT.CreateThumbnail,
                    BUT.Folder,
                    BUT.PathKind,
                ]),
                imagefoldercallback,
            ),
            new AttributesFIeld("", "", attrs, RS.Attributes, `${CSS.AnPromptTextarea} ${CSS.AnHalf}`),
            new UriField(
                "", "", href, RS.LinkURL, baseuri,
                (usecreatelinkbutton
                    ? [BUT.ImageSource, BUT.PathKind, BUT.Folder]
                    : [BUT.PathKind, BUT.Folder]
                ),
                linkfoldercallback,
            ),
        ]);
        const field0 = this.getFieldAt_(0);
        if (usecreatelinkbutton) {
            const linkbutton = field0.getButton_(BUT.CreateLink)!;
            this.setRawUrls(linkbutton, href);
            An.onButtonClick_(linkbutton, (e) => {
                An.stopevent_(e);
                this.clearStatus_();
                An.classlist_(linkbutton).toggleAll_(CSS.AnButtonFlat, CSS.AnButtonDown);
                this._createLink = !this._createLink;
                this.setVisibleAt_(2, this._createLink);
                let src = field0.getValue_();
                const m = RX.Tn.exec(src);
                if (m != null) {
                    src = m[1] + m[3];
                }
                this.setValueAt_(2, src + `?${Param.view}`);
            });
            const field2 = this.getFieldAt_(2);
            const srcbutton = field2.getButton_(BUT.ImageSource)!;
            An.onClick_(srcbutton, (e) => {
                An.stopevent_(e);
                this.clearStatus_();
                const baseuri = native$.getIFrameUri_();
                const uri = An.parseUriSafe_(field2.getValue_(), baseuri);
                if (uri == null) return;
                const src = An.addRemoveQueryParams_(uri, null, [Param.view], baseuri);
                if (src == null) return;
                this.setValueAt_(0, src.toString());
            });
        } else {
            this._createLink = true;
        }
        const tnbutton = field0.getButton_(BUT.CreateThumbnail)!;
        tnbutton.classList.add(CSS.AnDisabled);
        An.onButtonClick_(tnbutton, (e) => {
            An.stopevent_(e);
            this.clearStatus_();
            if (this._onThumbnailButtonCallback != null) {
                const input = field0.getInput_(0)!;
                const ovalue = HumanLink.fromInput_(input);
                let path = ovalue.filepath$;
                if (An.dataUrlScheme_(path) != null && this._createLink) {
                    const linkinput = this.getFieldAt_(2).getInput_(0)!;
                    const linkpath = HumanLink.fromInput_(linkinput).filepath$;
                    if (MimeUtil.isImageLcSuffix_(Basepath.lcSuffix_(linkpath))) {
                        path = linkpath;
                    }
                }
                if (An.dataUrlScheme_(path)) {
                    this.warnKey_(RS.InvalidImagePath_);
                } else {
                    this._onThumbnailButtonCallback(path, baseuri, this, (cpath) => {
                        const pathkind = field0.getButton_(BUT.PathKind);
                        const href = ovalue.changeFilepath_(cpath).humanHref$;
                        this._updateUriInput(input, pathkind, baseuri, href);
                        this.fireOnChange_(field0, input);
                    });
                }
            }
        });
    }

    close_() {
        this._okCallback = null;
        this._onThumbnailButtonCallback = null;
        super.close_();
    }

    private setRawUrls(linkbutton: HTMLElement, href: HumanLink): void {
        if (href.isEmpty$) {
            this._createLink = false;
        } else {
            this._createLink = true;
        }
        An.setToggleButton_(linkbutton, this._createLink);
        this.setVisibleAt_(2, this._createLink);
    }

    onThumbnailButton(callback: ThumbnailCallback): this {
        this._onThumbnailButtonCallback = callback;
        An.enableButton_(this.getFieldAt_(0).getButton_(BUT.CreateThumbnail)!, callback != null);
        return this;
    }

    onOK_(callback: OKCallback4<IDialog, string, string, boolean, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback) {
        const src = this.getValueAt_(0);
        const attrs = this.getValueAt_(1);
        const href = this.getValueAt_(2);
        this._okCallback!(this, src, attrs, this._createLink, href, (ok) => {
            done(ok);
        });
    }

}

////////////////////////////////////////////////////////////////////////

class PromptImageUrl extends CompositeDialogBase {
    private _okCallback: OKCallback1<IDialog, Uri> | null = null;

    constructor(
        container: HTMLElement,
        url: HumanLink,
        baseuri: BaseUriX,
        placeholder: StringId,
        foldercallback: PromptFilepathCallback,
    ) {
        super(container, [
            new UriField(
                "", "", url, placeholder, baseuri,
                [
                    BUT.PathKind,
                    BUT.Folder,
                ],
                foldercallback),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: OKCallback1<IDialog, Uri>): this {
        this._okCallback = callback;
        return this;
    }

    showFilepicker_(): this {
        this.onShowDialog_(() => {
            An.setVisible_(this._dialog);
            Timer.sleep0_(() => {
                this.setInitialFocus_();
                this.getFieldAt_(0).getButton_(BUT.Folder)?.click();
            });
        });
        return this;
    }

    protected _onOK(done: BoolCallback) {
        const href = this.getValueAt_(0).trim();
        const uri = href.length == 0 ? null : An.parseUriSafe_(href, native$.getIFrameUri_());
        if (uri == null) {
            this.warn_(MSG.string_((href.length == 0 || href == ".")
                ? RS.URLInputMustNotBeEmpty
                : RS.InvalidURL));
            done(false);
            return;
        }
        if (!MimeUtil.isImageLcSuffix_(UriUt.lcSuffix_(uri))) {
            this.warnKey_(RS.ExpectingImageExt);
            done(false);
            return;
        }
        this._okCallback!(this, uri, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

class PromptImageFilepath extends CompositeDialogBase {
    private _okCallback: OKCallback1<IDialog, string> | null = null;

    constructor(
        container: HTMLElement,
        filepath: HumanFilepath,
        basedir: BasedirX,
        placeholder: StringId,
        foldercallback: PromptFilepathCallback,
    ) {
        super(container, [
            new FilepathField(
                "", "", filepath, placeholder, basedir,
                [
                    BUT.Folder,
                ],
                foldercallback),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: OKCallback1<IDialog, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback) {
        const cpath = this.getValueAt_(0).trim();
        this._okCallback!(this, cpath, (ok) => {
            done(ok);
        });
    }
}

//////////////////////////////////////////////////////////////////////////

class SelectOptions {
    private _values: string[] = [];
    private _labels: string[] = [];
    private _onchangeListeners: StringCallback[] = [];
    private _selectedIndex = -1;
    private _onClickListener: MouseEventCallback;
    private _alignEnd = false;

    element_(): HTMLElement {
        return this._input;
    }

    constructor(
        private _container: HTMLElement,
        private _input: HTMLElement,
        private readonly: boolean = false
    ) {
        this._onClickListener = (e) => {
            An.stopevent_(e);
            if (!this.readonly && this._values != null && this._values.length != 0) {
                const d = new PromptSelect(this._container, _input, this._labels, this._selectedIndex);
                if (this._alignEnd) {
                    d.style_("display:flex;flex-flow:column;align-items:end;");
                }
                d.onOK_((index: number) => {
                    this._selectedIndex = index;
                    const label = this._labels[index];
                    _input.textContent = (label.length == 0 ? "\u00a0" : label);
                    for (let onchange of this._onchangeListeners) {
                        onchange(this._values[index]);
                    }
                });
                d.show_();
            }
        };
        An.onClick_(_input, (e) => this._onClickListener(e));
    }

    destroy_() {
        this._onchangeListeners = [];
    }

    get isReadonly$(): boolean {
        return this.readonly;
    }

    alignEnd_(): this {
        this._alignEnd = true;
        return this;
    }

    setOptions_(values: string[], labels: string[] | null = null, selectedindex: numberX = null): this {
        this._values = values;
        this._labels = (labels != null ? labels : Array.from(this._values));
        this._selectedIndex = (selectedindex != null ? selectedindex : this._labels.length == 0 ? -1 : 0);
        this._refresh();
        SelectOptionUtil.setOptions_(this._input, this._values, labels, this._selectedIndex);
        return this;
    }

    onChange_(callback: StringCallback): this {
        this._onchangeListeners.push(callback);
        return this;
    }

    onClick_(callback: MouseEventCallback): this {
        this._onClickListener = callback;
        return this;
    }

    getValues_(): string[] {
        return this._values;
    }

    getLabels_(): string[] {
        return this._labels;
    }

    getSelectedIndex_(): number {
        return this._selectedIndex;
    }

    /// @param @nonnull index
    setSelectedIndex_(index: number): void {
        this._selectedIndex = index;
        this._refresh();
    }

    getValue_<T>(def: T): string | T {
        if (this._isValidIndex(this._selectedIndex, this._values)) {
            return this._values[this._selectedIndex];
        }
        if (typeof def === "number") {
            return this._values[def];
        }
        return def;
    }

    setValue_(value: string | number, def?: number): void {
        let index = (typeof value === "number") ? value : this._values.indexOf(value);
        if (!this._isValidIndex(index, this._values)) {
            if (!this._isValidIndex(def, this._values)) { return; }
            index = def!;
        }
        this._selectedIndex = index;
        this._refresh();
    }

    getLabel_<T>(def: T): string | T {
        if (this._selectedIndex != null && this._selectedIndex >= 0 && this._selectedIndex < this._labels.length) {
            return this._labels[this._selectedIndex];
        }
        return def;
    }

    private _refresh(): void {
        let label = this.getLabel_(null);
        if (label == null) {
            label = "\u00a0";
            this._selectedIndex = -1;
        } else if (label.length == 0) {
            label = "\u00a0";
        }
        this._input.textContent = label;
    }

    private _isValidIndex(index: numberXX, values: string[]): boolean {
        return index !== undefined && index !== null && index >= 0 && index < values.length;
    }
}

///////////////////////////////////////////////////////////////////////

/// A SelectElement replacement.
class PromptSelect extends DialogBase {

    private _viewport!: HTMLElement;
    private _content!: HTMLElement;
    private _okCallback: IntCallback | null = null;

    constructor(
        container: HTMLElement,
        private _select: HTMLElement,
        private _labels: string[],
        private _selectedIndex: number
    ) {
        super(container);
        super.init_(this.create_(container));
        this.zindex_(DEF.zindexAbove10);
        this.smokescreenOpacity_(DEF.opacityTransparent);
        if (Conf.useFlash$) {
            new Flash(this._content, "div", CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        An.onClick_(this._content, (e) => {
            An.stopevent_(e);
            const target = DomUt.asHTMLElement_(e.target) as HTMLElement;
            if (target == null) { return; }
            const y = target.offsetTop + (target.offsetHeight / 2);
            const height = this._content.clientHeight;
            if (height <= 0) {
                return;
            }
            const index = Math.floor(y * _labels.length / height);
            if (index >= 0 && index < _labels.length) {
                
                const callback = this._okCallback!;
                this.close_();
                callback(index);
                return;
            }
        });
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithContentOnly(container, (content) => {
            this._viewport = content as HTMLElement;
            const b = new DomBuilderEx(content);
            this._content = b.div1_(CSS.AnSelect).push_().cursor_();
        });
    }

    style_(style: string) {
        new DomBuilderEx(this._content).attr_("style", style);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onSmokescreenCreated_(sm: Smokescreen): void {
        super.onSmokescreenCreated_(sm);
        sm.on_(Conf.pointerend$, (e) => {
            An.stopevent_(e);
            this.actionCancel_();
        });
    }

    protected _allowTouchmove(): boolean {
        return true;
    }

    showDialog_(resizer: Fun10<DialogBase>): void {
        if (this._labels == null || this._labels.length <= 0) {
            this.actionCancel_();
            return;
        }
        let selelm: HTMLElementX = null;
        const b = new DomBuilderEx(this._content).empty_().push_();
        for (let i = 0; i < this._labels.length; ++i) {
            const label = this._labels[i];
            b.peek_().div_().text_(label);
            if (i == this._selectedIndex) {
                b.addClass_(CSS.AnSelected);
                selelm = b.cursor_();
            }
        }
        //// FIXME May not work for sidepanels.
        let e: HTMLElementX = this._select;
        for (; e != null; e = e.parentElement) {
            const style = An.getComputedStyle_(e);
            if (style == null) continue;
            const z = style?.zIndex ?? null;
            if (z != null && z.length > 0 && z != "auto" && z != "0") {
                const position = style.position;
                if (position == "fixed" || position == "absolute") {
                    const zindex = An.adjustZIndex_(z, DEF.zindexAbove10, DEF.zindexPrompt);
                    this.element_().style.zIndex = `${zindex}`;
                    break;
                }
            }
        }
        super.showDialog_(resizer);
        if (selelm != null) {
            JsUtil.scrollIntoView(this._content.parentElement!, selelm);
        }
    }

    protected _onResize(): void {
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        const minxmargin = winwidth / 16;
        const minymargin = winheight / 16;
        const buttonsize = cache$.ui$.buttonSize_();
        this._table.style.padding = "1ex 0.5em";
        this._table.style.minWidth = "0";
        this._table.style.minHeight = "0";
        const bound = this._table.getBoundingClientRect();
        let width = Math.max(Math.round(bound.width), buttonsize * 3);
        const maxheight = (winheight - minymargin * 2 - DEF.dialogPaddingWidth * 2 - 20);
        const height = Math.min(this._content.offsetHeight, maxheight);
        const xmargin = (winwidth - width);
        const left = (xmargin < minxmargin) ? minxmargin : xmargin / 2;
        const top = minymargin;
        
        const maxwidth = Math.min(this._maxWidthMultipler * buttonsize, winwidth - left * 2);
        const style = this._dialog.style;
        style.left = `${left}px`;
        style.top = `${top}px`;
        if (width > maxwidth) {
            width = maxwidth;
        }
        this._table.style.width = `${width}px`;
        this._table.style.maxWidth = `${maxwidth}px`;
        
        this._viewport.style.height = `${height}px`;
    }

    onOK_(callback: IntCallback): this {
        this._okCallback = callback;
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

abstract class ChecklistDialogBase extends DialogBase {
    protected _viewport!: HTMLElementX;
    protected _checkboxListener!: UIUt$.CheckboxSelectListener;
    constructor(container: HTMLElement) {
        super(container);
        this._onShowDialogCallback = (dialog) => this._onshow(dialog);
    }

    protected abstract _populate(viewport: HTMLElement, dialog: HTMLElement): void;

    protected _createChecklistDialog(
        container: HTMLElement,
        buttons: Array<SStringMap>,
        toolbaractions: ActionMouseEventCallback,
        optionscallback: Fun10X<DomBuilderEx> = null,
    ): HTMLElement {
        const b = new DomBuilderEx(container);
        const ret = b.div_({
            "class": CSS.AnDialog,
            "style": "display: none; visibility: hidden",
        }).cursor_();
        b.table1_(CSS.AnDialog).push_().tr_().td_();
        this._toolbar = new Toolbar(b.cursor_(), buttons);
        this._toolbar.onAction_(toolbaractions);
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._viewport = b.peek_().tr_().td_().div1_(CSS.AnPromptViewport).addStyle_("margin-top", "-0.5ex").cursor_();
        this._checkboxListener = new UIUt$.CheckboxSelectListener(this._viewport);
        this._populate(this._viewport, ret);
        optionscallback?.(b.peek_());
        this._status = b
            .peek_()
            .tr_()
            .td1_(CSS.AnPromptStatus)
            .div1_(CSS.AnPromptViewport)
            .div1_(CSS.AnPromptStatus)
            .cursor_();
        b.pop_();
        return ret;
    }

    protected _onshow(dialog: HTMLElement): void {
        An.showHidden_(dialog, "block");
        this._resizecontent(this._viewport);
        this._checkboxListener.onShow_();
        An.setVisible_(dialog);
        Timer.sleep0_(() => this.setInitialFocus_());
    }

    protected _resizecontent(viewport: HTMLElementX): void {
        if (viewport == null) return;
        const rect = viewport.getBoundingClientRect();
        const top = Math.round(rect.top);
        const maxheight = `${window.innerHeight - top - DEFUtil.dialogBottom_() - DEF.dialogPaddingWidth /* content padding */}px`;
        viewport.style.maxHeight = maxheight;
    }

    protected _getSelected(): string[] {
        return this._foreachChecked((ret, checkbox) => {
            const text = checkbox.getAttribute(ATTR.AnInfo) ?? null;
            if (text != null) ret.push(text);
        });
    }

    protected _foreachChecked(callback: Fun20<string[], HTMLInputElement>): string[] {
        const ret = sarray_();
        const a = this._dialog.querySelectorAll<HTMLInputElement>(
            `div.${CSS.AnPromptChecklist} input[type=checkbox], div.${CSS.AnPromptChecklist} input[type=radio]`);
        for (const checkbox of new ItemsIterable(a)) {
            if (checkbox.checked) callback(ret, checkbox);
        }
        return ret;
    }
}

abstract class PromptCopyBase extends ChecklistDialogBase {
    protected _selectOnly: string[] | null = null;

    protected _allowTouchmove(): boolean {
        return true;
    }

    constructor(
        container: HTMLElement,
        protected _cut: boolean,
        private _usexrefs: boolean,
        private _copyInfos: JSONObject,
    ) {
        super(container);
        super.init_(this.create_(container));
        this.largeWidth_();
    }

    protected create_(container: HTMLElement): HTMLElement {
        return super._createChecklistDialog(container,
            (this._usexrefs ?
                BUT.infos_(
                    BUT.FixXrefs,
                    BUT.OK,
                    BUT.Cancel,
                ) :
                BUT.infos_(
                    BUT.OK,
                    BUT.Cancel,
                )
            ), (action) => this._toolbarActions(action));
    }

    protected abstract _onOK(fixxrefs: boolean, tocopy: string[]): void;

    protected abstract _notCopyingTitle(total: Int): string;

    protected abstract _copyingTitle(count: Int, total: Int): string;

    protected _overwritingTitle(count: Int, total: Int): string {
        return MSG.string_(RS.Overwriting) + `: ${count} / ${total}`;
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.Cancel));
    }

    protected selectOnly(names: string[]): void {
        this._selectOnly = names;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.FixXrefs: {
                this._actionOK(this._usexrefs);
                break;
            }
            case BUT.OK: {
                this._actionOK(false);
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _actionOK(fixxrefs: boolean) {
        this._toolbar!.enableButton_(BUT.OK, false);
        this._toolbar!.enableButton_(BUT.Cancel, false);
        const tocopy = this._getSelected();
        this._onOK(fixxrefs, tocopy);
    }

    protected _populateNotCopying(
        b: DomBuilderEx,
        notcopying: Map<string, string[]>): void {
        if (notcopying.size > 0) {
            DialogUt.populateNotCopyingInfoList_(b, notcopying, (count) => {
                return this._notCopyingTitle(count);
            });
        }
    }

    protected _populateOverwriting(
        b: DomBuilderEx,
        overwriting: Map<string, CopyInfo>,
        listener: UIUt$.CheckboxSelectListener,
        onchanged: Fun30X<HTMLElement, Int, Int>): void {
        if (overwriting.size > 0) {
            DialogUt.populateOverwritingInfoList_(b, overwriting, listener, onchanged, (name) => {
                return this._selectOnly != null && this._selectOnly.includes(name);
            });
        }
    }

    protected _populateCopying(
        b: DomBuilderEx,
        copying: Map<string, CopyInfo>,
        overwritingsize: Int,
        notcopyingsize: Int,
        listener: UIUt$.CheckboxSelectListener,
        onchanged: Fun30X<HTMLElement, Int, Int>,
    ): void {
        if (copying.size > 0 || notcopyingsize == 0 && overwritingsize == 0) {
            DialogUt.populateOverwritingInfoList_(b, copying, listener, onchanged, (name) => {
                return this._selectOnly == null || this._selectOnly.includes(name);
            });
        }
    }

    protected _populateCopyInfo1(
        b: DomBuilderEx,
        listener: UIUt$.CheckboxSelectListener,
        copying: Map<string, CopyInfo>,
        overwriting: Map<string, CopyInfo>,
        notcopying: Map<string, Array<string>>
    ): void {
        this._populateNotCopying(b, notcopying);
        this._populateOverwriting(b, overwriting, listener,
            (header, checked, total) => this._updateOverwriteHeader(header, checked, total));
        this._populateCopying(b, copying, overwriting.size, notcopying.size, listener,
            (header, checked, total) => this._updateCopyingHeader(header, checked, total));
    }

    protected _populate(viewport: HTMLElement): void {
        const copying = mapFromStringMap_<CopyInfo>(this._copyInfos[Key.copying] ?? {});
        const overwriting = mapFromStringMap_<CopyInfo>(this._copyInfos[Key.overwriting] ?? {});
        const notcopying = mapFromStringMap_<string[]>(this._copyInfos[Key.notcopying] ?? {});
        const b = new DomBuilderEx(viewport).push_();
        this._populateCopyInfo1(b, this._checkboxListener, copying, overwriting, notcopying);
        b.pop_();
        this._toolbar!.enableButton_(BUT.OK, copying.size > 0 || overwriting.size > 0);
    }

    private _updateOverwriteHeader(header: HTMLElement, checked: Int, total: Int) {
        header.textContent = this._overwritingTitle(checked, total);
    }

    private _updateCopyingHeader(header: HTMLElement, checked: Int, total: Int) {
        header.textContent = this._copyingTitle(checked, total);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptCopy extends PromptCopyBase {
    private _okCallback: JSONCallback | null = null;

    constructor(
        container: HTMLElement,
        private _handler: IFilepickerHandler,
        cut: boolean,
        private _preserveTimestamp: boolean,
        private _dstdir: string,
        private _srcpath: string,
        copyinfos: JSONObject
    ) {
        super(container, cut, true, copyinfos);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: JSONCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(fixxrefs: boolean, tocopy: string[]): void {
        const callback = this._okCallback!;
        if (tocopy.length > 0) {
            const spinner = new Spinner(this._container);
            spinner.show_(() => {
                Timer.sleep0_(() => {
                    this._handler.copy_(this._cut, this._preserveTimestamp, fixxrefs, this._dstdir, this._srcpath, tocopy, (ret) => {
                        this.close_();
                        spinner.destroy_();
                        callback?.(ret);
                    });
                });
            });
        } else {
            this.close_();
            const ret = json_();
            //// Returns an error to prevent refresh.
            ret[Key.errors] = MSG.format1_((this._cut ? RS.Moved_files : RS.Copied_files), "0");
            callback(ret);
        }
    }

    protected _copyingTitle(count: Int, total: Int): string {
        return MSG.string_(this._cut ? RS.Moving : RS.Copying) + `: ${count} / ${total}`;
    }

    protected _notCopyingTitle(count: number): string {
        return MSG.string_(this._cut ? RS.NotMoving : RS.NotCopying) + `: ${count}`;
    }
}

////////////////////////////////////////////////////////////////////////

class PromptFilelist extends PromptCopyBase {
    private _okCallback: StringListCallback | null = null;

    constructor(container: HTMLElement, copyinfos: JSONObject) {
        super(container, false, false, copyinfos);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: StringListCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(_fixxrefs: boolean, filelist: string[]): void {
        const callback = this._okCallback!;
        this.close_();
        callback(filelist);
    }

    protected _copyingTitle(count: Int, total: Int): string {
        return MSG.format1_(RS.Total_files, `${count} / ${total}`);
    }

    protected _overwritingTitle(count: Int, total: Int): string {
        return MSG.format1_(RS.Total_files, `${count} / ${total}`);
    }

    protected _notCopyingTitle(_count: number): string {
        return "";
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for file delete confirmation.
 */
class PromptDelete extends ChecklistDialogBase {
    private _okCallback: Fun10<string[]> | null = null;

    constructor(
        container: HTMLElement,
        private _filename: string,
        private _infos: JSONObject,
    ) {
        super(container);
        super.init_(this.create_(container));
        this.largeWidth_();
    }

    protected create_(container: HTMLElement): HTMLElement {
        return super._createChecklistDialog(container, BUT.infosOKCancel, (action) => this._toolbarActions(action));
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: Fun10<string[]>): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.Cancel));
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                this._toolbar!.enableButton_(BUT.OK, false);
                const todelete = this._getSelected();
                this._okCallback?.(todelete);
                this.close_();
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    protected _populate(viewport: HTMLElement, _dialog: HTMLElement) {
        //// Deleting files
        const deleting = mapFromStringMap_(this._infos[Key.deleting] ?? {}) as Map<string, DeleteInfo>;
        const inuse = mapFromStringMap_(this._infos[Key.overwriting] ?? {}) as Map<string, DeleteInfo>;
        const notdeleting = (this._infos[Key.notdeleting] ?? {}) as Map<string, string>;
        const b = new DomBuilderEx(viewport).empty_().push_();
        if (deleting.size > 0) {
            const nofilename = An.isempty_(this._filename);
            DialogUt.populateDeleteInfoList_(b, deleting, this._checkboxListener, (header, checked, total) =>
                this._updateHeader(header, RS.Deleting, checked, total), (name) => {
                    return nofilename || name == this._filename;
                });
        }
        if (inuse.size > 0) {
            DialogUt.populateDeleteInfoList_(b, inuse, this._checkboxListener, (header, checked, total) =>
                this._updateHeader(header, RS.XrefsInuse, checked, total), (name) => {
                    return name == this._filename;
                });
        }
        if (notdeleting.size > 0) {
            b.peek_().div1_(CSS.AnHeading).text_(MSG.string_(RS.NotDeleting_));
            b.peek_().div1_(CSS.AnPromptList).push_();
            notdeleting.forEach((v, k) => {
                b.peek_().div_().text_(`${k} : ${v.length}`);
                b.peek_().ul_().push_();
                b.peek_().li_().text_(v);
                b.pop_();
            });
            b.pop_();
        }
        if (deleting.size == 0 && inuse.size == 0 && notdeleting.size == 0) {
            this.warnKey_(RS.NothingToDelete);
        }
        this._toolbar!.enableButton_(BUT.OK, deleting.size > 0 || inuse.size > 0);
    }

    private _updateHeader(header: HTMLElement, key: StringId, checked: Int, total: Int) {
        header.textContent = `${MSG.string_(key)}: ${checked} / ${total}`;
    }

}

////////////////////////////////////////////////////////////////////////

type FixBrokenLinksInfo = [string, Long, Long];

/**
 * Prompt for fix link choices.
 */
class PromptFixBrokenLinks extends ChecklistDialogBase {
    private _okCallback: JSONCallback | null = null;

    constructor(
        container: HTMLElement,
        private _basedir: stringX,
        private _infos: StringMap<Array<FixBrokenLinksInfo>>,
    ) {
        super(container);
        super.init_(this.create_(container));
        this.largeWidth_();
    }

    protected create_(container: HTMLElement): HTMLElement {
        return super._createChecklistDialog(container, BUT.infosOKCancel, (action) => this._toolbarActions(action));
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: JSONCallback): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.Cancel));
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                this._toolbar!.enableButton_(BUT.OK, false);
                const tofix = new StringMap<string>();
                this._foreachChecked((_, checkbox) => {
                    const name = checkbox.getAttribute(ATTR.name$) ?? null;
                    const value = checkbox.getAttribute(ATTR.AnInfo) ?? null;
                    if (name != null && value != null) tofix[name] = value;
                });
                const callback = this._okCallback!;
                this.close_();
                callback(tofix);
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    protected _populate(viewport: HTMLElement, _dialog: HTMLElement) {
        const b = new DomBuilderEx(viewport).empty_().push_();
        this.populateFixBrokenLinksInfoList_(
            b, this._checkboxListener,
            (header, checked, total) => header.textContent = `${MSG.string_(RS.ActionFixBrokenLinksFixing_)} ${checked} / ${total}`);
    }

    private populateFixBrokenLinksInfoList_(
        b: DomBuilderEx,
        listener: UIUt$.CheckboxSelectListener,
        updateheader: Fun30X<HTMLElement, Int, Int>,
    ) {
        DialogUt.populateCheckboxList1_(b, listener, updateheader, () => {
            return this.createFixBrokenLinksInfoList_(b);
        });
    }

    private createFixBrokenLinksInfoList_(
        b: DomBuilderEx,
    ): [Int, Int] {
        const df = new AutoDateFormatter();
        let selected = 0;
        const entries = Object.entries(this._infos);
        for (const [apath, choices] of entries) {
            b.peek_().div_().text_(apath).ul_();
            choices.forEach(([path, size, date], index) => {
                const rpath = An.rpath2_(this._basedir, path);
                if (DialogUt.createFileInfoCheckbox_(b, () => {
                    return index == 0;
                }, df, [], false, size, date, rpath, apath, path)) {
                    ++selected;
                }
            });
        }
        return [selected, entries.length];
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Prompt for file image conversion confirmation.
 */
class PromptImageConversion extends ChecklistDialogBase {
    private _cutOption: HTMLInputElement | null = null;
    private _okCallback: Fun20<string[], boolean> | null = null;

    constructor(
        container: HTMLElement,
        private _filename: string,
        private _converting: FileInfo[],
        private _overwriting: FileInfo[],
        private _notconverting: Map<string, string[]>,
    ) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(RS.PickImage);
        this.largeWidth_();
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createChecklistDialog(container, BUT.infosOKCancel, (action) => this._toolbarActions(action), (b) => {
            b.peek_().tr_().td_().div_({
                "class": CSS.AnFlexRowNoWrap,
            });
            this._cutOption = DialogUt.createCheckboxRow_(b,
                [["style", "margin-left:0.5em;"]],
                MSG.string_(RS.ActionConvertDeleteSource));
        });
    }

    protected _populate(viewport: HTMLElement, _dialog: HTMLElement) {
        const b = new DomBuilderEx(viewport).empty_().push_();
        const nofilename = An.isempty_(this._filename);
        if (this._notconverting.size > 0) {
            DialogUt.populateNotCopyingInfoList_(b, this._notconverting, (count) => {
                return `${MSG.string_(RS.ConvertingNot)}: ${count}`;
            });
        }
        DialogUt.populateFileInfoList_(b, this._converting, this._checkboxListener, (header, checked, total) => {
            header.textContent = `${MSG.string_(RS.Converting)}: ${checked} / ${total}`;
        }, (name) => {
            return nofilename || name == this._filename;
        });
        if (this._overwriting.length > 0) {
            DialogUt.populateFileInfoList_(b, this._overwriting, this._checkboxListener, (header, checked, total) => {
                header.textContent = `${MSG.string_(RS.Overwriting)}: ${checked} / ${total}`;
            }, (name) => {
                return nofilename || name == this._filename;
            });
        }
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: Fun20<string[], boolean>): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.Cancel));
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                const images = this._getSelected();
                const callback = this._okCallback!;
                this.close_();
                callback(images, this._cutOption?.checked == true);
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _OpacitySlider extends Slider {
    private _opacity = 0.0;
    private _changeCallback: DoubleCallback | null = null;

    constructor(container: HTMLElement, major: number, halfminor: number, step: number, handleOffset: number, vertical: boolean) {
        super(container, major, halfminor, step, handleOffset, vertical);
        this.onClick_((y: number) => {
            const range = super.range_();
            const value = Math.round(Math.max(0, Math.min(100, (y / range) * 100)));
            this._setvalue(value / 100);
        });
        this.onDrag_((delta: number) => {
            const value = Math.max(0.0, Math.min(1.0, this._opacity + delta * 0.01));
            this._setvalue(value);
        });
        this.element_().style.margin = `${halfminor}px 0`;
    }

    destroy_(): void {
        super.destroy_();
        this._changeCallback = null;
    }

    onChange_(callback: DoubleCallback): void {
        this._changeCallback = callback;
    }

    get value$(): number {
        return this._opacity;
    }

    set value$(value: number) {
        this._setvalue(value);
    }

    private _setvalue(value: number): void {
        if (value != this._opacity) {
            this._opacity = value;
            const y = Math.round(super.range_() * this._opacity);
            super.setPosition_(y);
            if (this._changeCallback != null) {
                this._changeCallback(this._opacity);
            }
        }
    }
}

class PromptColor extends FixedSizeDialogBase {
    static _singleton: PromptColor | null = null;
    static _count = 0;

    static getSingleton_(container: HTMLElement, buttonsize: number): PromptColor {
        ++PromptColor._count;
        if (PromptColor._singleton == null
            || PromptColor._singleton._buttonSize != buttonsize
            || PromptColor._singleton.element_() == null
            || PromptColor._count >
            100
        ) {
            if (PromptColor._singleton != null) PromptColor._singleton.destroy();
            PromptColor._singleton = new PromptColor(container, buttonsize);
            PromptColor._count = 1;
        }
        return PromptColor._singleton;
    }

    private _inputOpacity!: _OpacitySlider;
    private _inputColor!: HTMLTextAreaElement;
    private _initialColor!: HTMLElement;
    private _currentColor!: HTMLElement;
    private _currentOpacity!: HTMLElement;
    private _hexButton!: HTMLElement;
    private _tabPanel!: TabPanel;
    private _colorPalettePanel!: _ColorPalettePanel;
    private _colorListPanel!: _ColorListPanel;
    private _colorPickerPanel!: _ColorPickerPanel;

    private _okCallback: Fun20<ColorValue | null, string> | null = null;

    private _initialColorValue: ColorValue | null = null;
    private _color: ColorValue | null = null;
    private _name = "";
    private _hex: boolean = false;
    #destroyed = false;

    constructor(container: HTMLElement, buttonsize: number) {
        super(container, buttonsize);
        super.init_(this.create_(container));
        this.titleKey_(RS.PickColor);
        this.setColor("255, 255, 255, 0.0", ColorValue.X_TRANSPARENT);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infosCopyPasteOKCancel,
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content).push_();
        b.div_({
            "class": CSS.AnFlex,
            "style": "flex-flow: column nowrap; padding-top: 10px; ",
        }).push_();
        this._createColorInput(b);
        this._createOpacityInput(b);
        this._createTabpanel(b);
        An.onInputFocusSelect_(this._inputColor);
        An.onInputChange_(this._inputColor, () => this._inputColorChanged());
        An.onInputEnterKey_(this._inputColor, () => {
            this._inputColorChanged();
        });
        An.onClick_(this._currentOpacity, () => {
            let opacity = this._inputOpacity.value$;
            if (opacity < 0.25) {
                opacity = 0.25;
            } else if (opacity < 0.5) {
                opacity = 0.5;
            } else if (opacity < 0.75) {
                opacity = 0.75;
            } else if (opacity < 1.0) {
                opacity = 1.0;
            } else {
                opacity = 0.0;
            }
            const colorvalue = ColorUtil.getColorValue_(this._currentColor.style.backgroundColor, opacity);
            if (colorvalue != null) {
                this._setcolor(colorvalue, null);
            }
        });
        this._inputOpacity.onChange_((opacity: number) => {
            const colorvalue = ColorUtil.getColorValue_(this._currentColor.style.backgroundColor, opacity);
            if (colorvalue != null) {
                this._setcolor(colorvalue, this._inputOpacity.slider_());
            }
        });
        this._colorPalettePanel.onColorChanged((color: string) => {
            const colorvalue = ColorUtil.getColorValue_(color, 1.0);
            if (colorvalue != null) {
                this._setcolor(colorvalue, this._colorPalettePanel._container);
            }
        });
        this._colorListPanel.onColorChanged((info: string[]) => {
            const colorvalue = ColorUtil.getColorValue_(info[1], 1.0);
            if (colorvalue != null) {
                this._setcolor(colorvalue, this._colorListPanel.container());
                if (colorvalue != null && colorvalue.isOpaque$ && ColorUtil.isCSSColor_(info)) {
                    this._inputColor.value = info[0];
                }
            }
        });
        this._colorPickerPanel.onColorChanged((color, _hue, _saturation, _brightness) => {
            const opacity = this._getopacity();
            const value = ColorValue.fromRGBA_(color.r$, color.g$, color.b$, opacity);
            this._setcolor(value, this._colorPickerPanel._container);
        });
    }

    private _createColorInput(b: DomBuilderEx): void {
        b.peek_().div1_(CSS.AnFlex).push_();
        b
            .peek_()
            .div_({
                "class": CSS.AnFlex,
                "style": `flex-basis:${DEF
                    .BASIS_20}%;align-self:stretch;border:${DEF.themeBorder};background-color:#fff;`
            })
            .push_()
            .cursor_()
            .addEventListener("click", (e) => {
                An.stopevent_(e);
                if (this._initialColorValue != null) {
                    this._setcolor(this._initialColorValue);
                }
            });
        this._initialColor = b.div_({
            "style": `flex-basis:${DEF.BASIS_50}%;align-self:stretch;`
        }).cursor_();
        this._currentColor = b.pop_().div_({
            "style": `flex-basis:${DEF.BASIS_50}%;align-self:stretch;`
        }).cursor_();
        b.peek_().div_({ "style": "width:5px;" });
        const w = Math.round((((this._buttonSize * 6) - 5) * 0.8));
        b.peek_().div_({
            "class": CSS.AnFlex,
            "style": `flex-basis:${DEF
                .BASIS_80}%;width:${w}px;box-sizing:border-box;`,
        }).push_();
        this._inputColor = b.div_({
            "class": CSS.AnButtonInput,
            "style": "flex-basis:100%;",
        }).child_(Conf.input$, smap_(
            ["rows", "1"],
            ["class", CSS.AnButtonInput],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )).cursor_() as AnInputElement;
        this._hexButton = b.peek_().button_(
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaSlack} ${this._hex ? CSS.AnButtonDown : CSS.AnButtonFlat}`],
            ["style", "margin-left:5px;"],
            [ATTR.xTooltips, RS.Tooltips_ToggleShowHex],
        ).cursor_();
        An.onClick_(this._hexButton, () => this._toggleHex());
        DialogUt.setTooltipsHandler_(this._hexButton);
        b.pop_(2);
    }

    private _createOpacityInput(b: DomBuilderEx): void {
        b.peek_().div_({
            "class": CSS.AnFlex,
            "style": "margin:0.75ex 0",
        }).push_();
        this._currentOpacity = b.peek_().div_(
            ["class", CSS.AnTextButton],
            [ATTR.xTooltips, RS.Tooltips_Opacity],
            ["style", `flex-basis:${DEF.BASIS_20}%;`],
        ).cursor_();
        DialogUt.setTooltipsHandler_(this._currentOpacity);
        b.peek_().div_({ "style": "width: 5px;" });
        const w = Math.floor((((this._buttonSize * 6) - 5 /* spacing */) * 0.8) - 2 /* slider border */ - 1 /* handler border */);
        const d4 = this._buttonSize / 4;
        const d2 = d4 * 2;
        this._inputOpacity = new _OpacitySlider(b.peek_().cursor_(), w, d4, Math.min(d2, 16), d2, false);
        b.pop_();
    }

    private _createTabpanel(b: DomBuilderEx): void {
        const top = b.peek_().div_({}).cursor_();
        const tabpanel = new TabPanel(top, true);
        tabpanel.addTab(RS.Tooltips_ColorPalette, `${CSS.Fa} ${CSS.FaTh}`, (e) => {
            return this._colorPalettePanel = new _ColorPalettePanel(e, this._buttonSize);
        });
        tabpanel.addTab(RS.Tooltips_ColorNames, `${CSS.Fa} ${CSS.FaTags}`, (e) => {
            return this._colorListPanel = new _ColorListPanel(e, this._buttonSize, this._inputColor);
        });
        tabpanel.addTab(RS.Tooltips_ColorPicker, `${CSS.Fa} ${CSS.FaEyedropper}`, (e) => {
            return this._colorPickerPanel = new _ColorPickerPanel(e, this._buttonSize);
        });
        tabpanel.onTooltips(toasters$.onTooltipsKey_);
        tabpanel.onTabClicked((tab: HTMLElement, index: number) => {
            if (index == 1 && tabpanel.activeTab() == tab) {
                const span = tab.querySelector("span");
                if (span == null) return;
                const istag = An.classlist_(span).toggleAll_(CSS.FaTag, CSS.FaTags).contains_(CSS.FaTag);
                this._colorListPanel.onCSSColorsOnlyChanged(istag);
            }
        });
        tabpanel.onTabChanged(() => {
            this._updatecolorinput();
        });

        this._tabPanel = tabpanel;
    }

    close_(): void {
        this._okCallback = null;
        super.hide_();
    }

    destroy(): void {
        if (!this.#destroyed) {
            this.#destroyed = true;
            super.close_();
            this._inputOpacity.destroy_();
            this._colorPalettePanel.destroy();
            this._colorListPanel.destroy();
            this._colorPickerPanel.destroy();
        }
    }

    getContentWidth_(): number {
        return this._buttonSize * 6;
    }

    /// @param callback(value)
    onOK_(callback: Fun20<ColorValue | null, string>): this {
        this._okCallback = callback;
        return this;
    }

    setInitialFocus_(): void {
        if (this._inputColor != null) {
            this._inputColor.blur();
        }
    }

    setColor(value: stringX, def: ColorValue): this {
        let color = def;
        this._sethex(false);
        this._name = "";
        this._inputColor.style.color = "";
        if (value != null) {
            value = value.trim();
            const info = ColorUtil.findByName_(value.toLowerCase());
            if (info != null) {
                color = ColorValue.parseSafe_(info[1]) ?? def;
                this._sethex(true);
                this._name = info[0];
                this._inputColor.value = this._name;
            } else {
                color = ColorValue.parseSafe_(value) ?? def;
                this._sethex(value.startsWith("#"));
                this._inputColor.value = ColorUtil.toHexOrRgbString_(color, this._hex);
            }
        } else {
            this._inputColor.value = ColorUtil.toHexOrRgbString_(color, this._hex);
        }
        this._initialColorValue = color;
        this._initialColor.style.backgroundColor = (color == null ? "" : color.toCSSString_());
        this._setcolor(color, this._inputColor);
        return this;
    }

    private _inputColorChanged(): void {
        const value = this._inputColor.value.trim();
        if (this._colorListPanel._shown && RX.Word1.test(value)) {
            const search = value.toLowerCase();
            for (let [key, info] of x11Colors) {
                if (key.startsWith(search)) {
                    const c = ColorUtil.getColorValue_(info[1], this._getopacity());
                    if (c != null) {
                        this._setcolor(c, null);
                        if (c.isOpaque$ && ColorUtil.isCSSColor_(info)) {
                            this._inputColor.value = info[0];
                        }
                        return;
                    }
                }
            }
        }
        let c = ColorUtil.getColorValue_(value);
        if (c == null) {
            if (!An.isempty_(value)) {
                this._inputColor.style.color = "red";
            }
            return;
        }
        if (c.a$ == null) {
            c = ColorValue.fromRGBA_(c.r$, c.g$, c.b$, this._getopacity());
        }
        this._setcolor(c, null);
    }

    private _getopacity(): number {
        return (this._color == null ? 1.0 : this._inputOpacity.value$);
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.PasteFromLocalClipboard: {
                const value = this._inputColor.value;
                this._inputColor.setSelectionRange(0, value.length);
                this.actionPaste_(this._inputColor, false, () => {
                    this._inputColorChanged();
                });
                break;
            }
            case BUT.CopyToLocalClipboard:
                const value = this._inputColor.value;
                this._inputColor.setSelectionRange(0, value.length);
                this.actionCopy_(this._inputColor);
                break;
            case BUT.OK: {
                Timer.sleep0_(() => {
                    const value = this._inputColor.value.trim();
                    const c = value.length == 0 ? null : this._color;
                    const format = this._getformat(value, c);
                    const callback = this._okCallback!;
                    this.close_();
                    callback(c, format);
                });
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _getformat(value: string, c: ColorValue | null): string {
        if (c == null) return ColorUtil.NULL;
        const opaque = c.isOpaque$;
        if (this._colorListPanel._shown && opaque) {
            const info = ColorUtil.findByName_(value.toLowerCase());
            if (info != null && ColorUtil.isCSSColor_(info)) {
                return info[0];
            }
        }
        return (opaque && this._hex ? ColorUtil.HEX : ColorUtil.DEC);
    }

    private _setcolor(color: ColorValue, ignore: HTMLElementX = null): void {
        if (color == null && this._color == null
            || color != null && this._color != null && color.equals_(this._color)) {
            return;
        }
        this._setcolor1(color, ignore);
    }

    private _setcolor1(color: ColorValue, ignore: HTMLElementX): void {
        this._color = color;
        if (this._currentColor != ignore) {
            this._currentColor.style.backgroundColor = (color == null ? "" : color.toCSSString_());
        }
        if (this._inputColor != ignore) {
            this._updatecolorinput();
        }
        this._currentOpacity.textContent = (color == null ? "0.00" : color.a$.toFixed(2));
        if (this._inputOpacity.slider_() != ignore) {
            this._inputOpacity.value$ = (color == null ? 0.0 : color.a$);
        }
        if (this._colorPickerPanel._container != ignore) {
            this._colorPickerPanel.setColor(color == null ? ColorValue.X_TRANSPARENT : color);
        }
        if (this._colorListPanel.container() != ignore) {
            this._colorListPanel.setColor(color);
        }
    }

    private _updatecolorinput(): void {
        this._inputColor.style.color = "";
        if (this._color == null) {
            this._inputColor.value = "";
            return;
        }
        const info = this._findnamedcolor(this._color);
        if (info != null) {
            const oinfo = ColorUtil.findByName_(this._inputColor.value.trim().toLowerCase());
            if (oinfo != null && oinfo[1] == info[1]) {
                return;
            }
            this._inputColor.value = info[0];
            return;
        }
        this._inputColor.value = ColorUtil.toHexOrRgbString_(this._color, this._hex);
    }

    private _findnamedcolor(color: ColorValue): string[] | null {
        if (color != null && this._colorListPanel._shown && color.isOpaque$) {
            const hex = "#" + color.toHex3String_();
            const info = ColorUtil.findByHex_(hex);
            if (info != null && ColorUtil.isCSSColor_(info)) {
                return info;
            }
        }
        return null;
    }

    private _sethex(ishex: boolean): void {
        this._hex = An.setToggleButton_(this._hexButton, ishex);
    }

    private _toggleHex(): void {
        this._hex = An.toggleToggleButton_(this._hexButton);
        this._inputColor.value = ColorUtil.toHexOrRgbString_(this._color, this._hex);
        this._inputColor.style.color = "";
    }

    show_(): this {
        super.show_();
        if (this._hex != An.isToggleButtonDown_(this._hexButton)) {
            this._toggleHex();
        }
        if (this._name.length != 0) {
            this._inputColor.value = this._name;
        }
        this._tabPanel.selectTabAt(this._name.length != 0 ? 1 : 0);
        return this;
    }
}

class _ColorPalettePanel extends UIPanelBase {
    static _paletteColors: Array<Array<string>> = [
        [
            "#000000",
            "#434343",
            "#666666",
            "#999999",
            "#b7b7b7",
            "#cccccc",
            "#d9d9d9",
            "#efefef",
            "#f3f3f3",
            "#ffffff",
        ],
        [
            "#980000",
            "#ff0000",
            "#ff9900",
            "#ffff00",
            "#00ff00",
            "#1e90ff",
            "#4a86e8",
            "#0000ff",
            "#9900ff",
            "#ff00ff",
        ],
        [
            "#e6b8af",
            "#f4cccc",
            "#fce5cd",
            "#fff2cc",
            "#d9ead3",
            "#d9e3d9",
            "#c9daf8",
            "#cfe2f3",
            "#d9d2e9",
            "#ead1dc",
        ],
        [
            "#dd7e6b",
            "#ea9999",
            "#f9cb9c",
            "#ffe599",
            "#b6d7a8",
            "#a2c4c9",
            "#a4c2f4",
            "#9fc5e8",
            "#b4a7d6",
            "#d5a6bd",
        ],
        [
            "#cc4125",
            "#e06666",
            "#f6b26b",
            "#ffd966",
            "#93c47d",
            "#76a5af",
            "#6d9eeb",
            "#6fa8dc",
            "#8e7cc3",
            "#c27ba0",
        ],
        [
            "#a61c00",
            "#cc0000",
            "#e69138",
            "#f1c232",
            "#6aa84f",
            "#45818e",
            "#3c78d8",
            "#3d85c6",
            "#674ea7",
            "#a64d79",
        ],
        [
            "#85200c",
            "#990000",
            "#b45f06",
            "#bf9000",
            "#38761d",
            "#134f5c",
            "#1155cc",
            "#0b5394",
            "#351c75",
            "#741b47",
        ],
        [
            "#5b0f00",
            "#660000",
            "#783f04",
            "#7f6000",
            "#274e13",
            "#0c343d",
            "#1c4587",
            "#073763",
            "#20124d",
            "#4c1130",
        ],
        [
            "#f98",
            "#f85",
            "#fa4",
            "#fc3",
            "#bc6",
            "#8c7",
            "#8da",
            "#8de",
            "#9cd",
            "#cbf",
        ],
        [
            "#fcc",
            "#fda",
            "#fe9",
            "#ee8",
            "#de8",
            "#ceb",
            "#bbeed4",
            "#c8e8f8",
            "#e0e0ff",
            "#ecd8ec",
        ],
        [
            "#ccc",
            "#ddd",
            "#eee",
            "#dd0",
            "#ee0",
            "#ffff90",
            "#ffffa8",
            "#ffffc0",
            "#ffffd8",
            "#fffff0",
        ],
    ];
    _container: HTMLElement;
    _paletteContainer: HTMLElement;
    _listener: StringCallback | null = null;

    constructor(container: HTMLElement, buttonsize: number) {
        super();
        this._container = container;
        container.style.overflow = "auto";
        const x6 = buttonsize * 6;
        const x5 = buttonsize * 5;
        const b = new DomBuilderEx(this._container);
        this._paletteContainer = b
            .div_({
                "class": CSS.AnPalette,
                "style": `width: ${x6}px; height: ${x5}px;margin-bottom:5px;`,
            })
            .push_()
            .cursor_();
        for (let row of _ColorPalettePanel._paletteColors) {
            for (let color of row) {
                b.peek_().div_({ "style": `background-color: ${color};` });
            }
        }
        An.onClickMatching_(this._paletteContainer, "div", (elm) => {
            if (this._listener != null) {
                this._listener((elm as HTMLElement).style.backgroundColor);
            }
        });
    }

    destroy(): void {
        this._listener = null;
    }

    onColorChanged(listener: StringCallback): void {
        this._listener = listener;
    }

    element_(): HTMLElement {
        return this._container;
    }
}

class _ColorListPanel extends UIPanelBase {
    _paletteContainer: HTMLElement;
    _listener: StringListCallback | null = null;
    _hex = "";
    _cssColorsOnly: boolean = false;
    _shown: boolean = false;

    constructor(
        private _container: HTMLElement,
        buttonsize: number,
        private _colorInput: HTMLTextAreaElement
    ) {
        super();
        this._container.style.overflow = "hidden";
        const x6 = buttonsize * 6;
        const x5 = buttonsize * 5;
        const b = new DomBuilderEx(_container);
        this._paletteContainer = b
            .div_({
                "class": `${CSS.AnMenu} ${CSS.AnColorList}`,
                "style": `width:${x6}px;height:${x5}px;margin-bottom:5px;position:relative;left:0;top:0;`,
            })
            .push_()
            .cursor_();
        for (let [name, info] of x11Colors) {
            const iscsscolor = ColorUtil.isCSSColor_(info);
            let style = `background-color: ${info[1]};`;
            const color = ColorUtil.getForegroundColor_(info);
            if (color != null) {
                style += `color:${color};`;
            }
            const label = (iscsscolor ? info[0] + " " + info[2] : info[0]);
            b
                .peek_()
                .div_(
                    [ATTR.AnInfo, name],
                    ["style", style],
                )
                .span_()
                .text_(label)
                .up_()
                .span_()
                .text_(info[1]);
        }
        An.onClickMatching_(this._paletteContainer, `div[${ATTR.AnInfo}]`, (elm) => {
            const name = elm.getAttribute(ATTR.AnInfo);
            if (name != null) {
                const info = ColorUtil.findByName_(name);
                if (info != null) {
                    this._hex = info[1];
                    if (this._listener != null) {
                        this._listener(info);
                    }
                }
            }
        });
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            An.show_(this._container);
            this._find();
        }
    }

    destroy(): void {
        this._listener = null;
    }

    container(): HTMLElement { return this._container; }

    element_(): HTMLElement {
        return this._container;
    }

    onColorChanged(listener: StringListCallback): void {
        this._listener = listener;
    }

    onCSSColorsOnlyChanged(csscolorsonly: boolean): void {
        if (this._cssColorsOnly == csscolorsonly) return;
        this._cssColorsOnly = csscolorsonly;
        for (let e of DomUt.queryAll_(this._paletteContainer, `div[${ATTR.AnInfo}]`)) {
            const name = e.getAttribute(ATTR.AnInfo);
            if (name == null) continue;
            const info = x11Colors.get(name);
            if (info === undefined) continue;
            if (ColorUtil.isCSSColor_(info)) continue;
            if (csscolorsonly) {
                An.hide_(e);
            } else {
                An.show_(e);
            }
        }
        if (this._shown) {
            this._find();
        }
    }

    reveal(i: number): void {
        const children = this._paletteContainer.children;
        if (i >= 0 && i < children.length) {
            const elm = children[i];
            if (this._shown) {
                JsUtil.scrollIntoView(elm.parentElement!, elm as HTMLElement);
            }
        }
    }

    setColor(c: ColorValue): void {
        if (c == null) {
            this._hex = "";
        } else {
            this._hex = "#" + c.toHex3String_();
            if (this._shown) {
                this._find();
            }
        }
    }

    private _find(): void {
        const value = this._colorInput.value.trim();
        if (value.length > 0) {
            const i = ColorUtil.findIndexByName_(value.toLowerCase());
            if (i >= 0) {
                this.reveal(i);
                return;
            }
        }
        const i = ColorUtil.findIndexByHex_(this._hex);
        if (i >= 0) {
            this.reveal(i);
        }
    }
}

class _ColorPickerPanel extends UIPanelBase {
    _container: HTMLElement;
    _colorPicker: ColorValue$.HsvGradientPicker;
    _hueSlider: ColorValue$.HueSlider;
    _listener: ColorValue$.ColorChangeListener | null = null;
    _shown: boolean = false;
    #destroyed = false;

    constructor(container: HTMLElement, buttonsize: number) {
        super();
        this._container = container;
        container.style.overflow = "hidden";
        const x6 = buttonsize * 6;
        const x5 = buttonsize * 5;
        this._colorPicker = new ColorValue$.HsvGradientPicker(container, x5, x5, Conf.useTouch$);
        this._hueSlider = new ColorValue$.HueSlider(container, buttonsize - 8, x5, Conf.useTouch$);
        const b = new DomBuilderEx(this._container);
        b.div_({
            "class": CSS.AnFlex,
            "style": `flex-flow: row nowrap; width: ${x6}px; height: ${x5 +
                5}px`,
        }).push_();
        b
            .peek_()
            .div_({
                "style": `flex: 0 0 ${x5}px`,
            })
            .cursor_()
            .append(this._colorPicker.canvas);
        b
            .peek_()
            .div_({
                "style": `flex: 0 0 ${x5}px; margin-left: 8px;`,
            })
            .cursor_()
            .append(this._hueSlider.canvas);
        this._colorPicker.colorChangeListener = (color: ColorValue, hue: number, saturation: number, brightness: number) => {
            if (this._listener != null) {
                this._listener(color, hue, saturation, brightness);
            }
        };
        this._hueSlider.hueChangelistener = this._colorPicker;
    }

    setColor(color: ColorValue): void {
        this._colorPicker.color$ = color;
        this._hueSlider.hueAngle$ = this._colorPicker.hue;
    }

    onColorChanged(listener: ColorValue$.ColorChangeListener): void {
        this._listener = listener;
    }

    element_(): HTMLElement {
        return this._container;
    }

    destroy(): void {
        if (this.#destroyed) { return; }
        this.#destroyed = true;
        this._container.remove();
        this._listener = null;
    }
}

////////////////////////////////////////////////////////////////////////

class _PromptFgStyleInputPanel extends CompositeTabPanel {
    private _sample!: HTMLElement;
    private _filter: IDialogField;
    constructor(
        ret: IDialogField[],
        container: HTMLElement,
        private readonly _target: HTMLElementX,
        host: IDialogFieldHost,
        buttonsize: Int,
        style: CSSStyleDeclaration,
        values: SStringMap,
        zindex: Int,
        blur: Fun00,
        selectFilterTab: Fun00,
    ) {
        super(container, host, [
            new InputButtonField("", "", values[PK.TextShadow], RS.Tooltips_TextShadow, BUT.Color1, () => {
                this._textshadowCallback(buttonsize, zindex);
            }),
            new InputField("", "", _PromptFgStyleInputPanel._transformValue(values), RS.Transform,),
            new InputButtonsField("", PromptBgImg._FILTER, CSSUtil.ignoreInheritNone(values[PK.Filter] ?? ""), RS.ImageFilter,
                [BUT.Clear1, BUT.Edit1, BUT.ImageFilter1], (button) => {
                    if (button == BUT.Clear1) this._setfilter1("");
                    else if (button == BUT.Edit1) this._editfilter(host);
                    else if (button == BUT.ImageFilter1) selectFilterTab();
                }),
            new SampleField("", ""),
        ]);
        ret.push(...this._fields);
        const x2 = buttonsize * 2;
        this._sample = new DomBuilderEx(this._fields[3].element_()).div_({
            "class": CSS.AnFlex,
            "style": `width:75%;height:${x2}px;margin:40px 0 20px 0;overflow:hidden;align-item:center;justify-content:center;`
                + `color:${style.color};background-color:${style.backgroundColor};background-image:${style.backgroundImage};`
                + `font-family:${style.fontFamily};font-size:${style.fontSize};font-weight:${style.fontWeight};`
                + `filter:${CSSUtil.ignoreInheritNone(values["filter"] ?? "")}`,
        }).text_(style.fontFamily).cursor_();
        this._filter = this._fields[2];
        An.onClick_(this._sample, blur);
        this.updateSample_(this.getValue_());
    }
    private _textshadowCallback(buttonsize: Int, zindex: Int) {
        const textshadow = this._sample.style.textShadow;
        let node = cssParser$.findColor_(textshadow);
        let color = node == null ? "" : CSSNode.text_(textshadow, node);
        Callbacks.promptColor_(buttonsize, zindex + DEF.zindexAbove10, color, ColorValue.X_TRANSPARENT_DARK)
            .onOK_((c, _format) => {
                let formatted = (c == null ? "" : c.toCSSString_());
                if (node != null) {
                    formatted = textshadow.substring(0, node.offset) + formatted + textshadow.substring(node.offset + node.length);
                } else {
                    formatted = textshadow + " " + formatted;
                }
                this._fields[0].setValue_(formatted);
                this.updateSample_(this.getValue_());
            })
            .show_();
    }
    private _setfilter1(style: string) {
        if (style.length == 0) {
            this._filter.setValue_("");
            this.updateSample_(this.getValue_());
            return;
        }
        const map = CSSUtil.splitFilter_(this._sample.style.getPropertyValue(PK.Filter));
        Object.entries(CSSUtil.splitFilter_(style)).forEach(([k, v]) => { map[k] = v; });
        const backdropfilter = Object.entries(map).map(([k, v]) => k + v).join(" ");
        this._filter.setValue_(backdropfilter);
        this.updateSample_(this.getValue_());
    }
    private _editfilter(host: IDialogFieldHost): void {
        const value = this._filter.getValue_();
        const cpath = native$.getIFrameContextPath_();
        const baseuri = native$.getIFrameUri_();
        if (cpath == null || baseuri == null) return;
        _Util.styleEditor_(accessories$, `filter: ${value}`, cpath, baseuri,
            An.above_(this.element_()), host, (styles) => {
                this._setfilter1(styles[PK.Filter] ?? "");
            }).show_();
    }
    updateSample_(styles: SStringMap) {
        const style = this._sample.style;
        const targetstyle = this._target?.style ?? null;
        for (const [name, value] of Object.entries(styles)) {
            style.setProperty(name, value);
            if (targetstyle != null) targetstyle.setProperty(name, value);
        }
    }
    getValue_(): SStringMap {
        const ret = smap_(
            [PK.TextShadow, this._fields[0].getValue_().trim()],
            [PK.Transform, ""],
            [PK.TransformOrigin, ""],
        );
        const value1 = this._fields[1].getValue_().trim();
        CSSUtil.splitStyle_(ret, value1, (ret, name, value) => { ret[name] = value; });
        const filter = this._filter.getValue_().trim();
        ret["filter"] = filter;
        return ret;
    }
    setValue_(styles: SStringMap) {
        this._fields[0].setValue_(styles[PK.TextShadow] ?? "");
        this._fields[1].setValue_(_PromptFgStyleInputPanel._transformValue(styles));
        this.updateSample_(styles);
    }
    setFilter_(name: string, value: string, toggle: boolean): string {
        const ovalue = this._sample.style.getPropertyValue("filter");
        const filter = CSSUtil.updateFilter_(ovalue, name, value, toggle);
        this._filter.setValue_(filter);
        this.updateSample_(this.getValue_());
        this._host.info_(filter);
        return filter;
    }
    updateValue_(styles: SStringMap) {
        const keys = Object.keys(styles);
        if (keys.includes(PK.TextShadow)) {
            this._fields[0].setValue_(styles[PK.TextShadow] ?? "");
        }
        if (keys.includes(PK.Transform)) {
            this._fields[1].setValue_(_PromptFgStyleInputPanel._transformValue(styles));
        }
        if (keys.includes("filter")) {
            this._fields[2].setValue_(styles["filter"] ?? "");
        }
        this.updateSample_(styles);
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
    sampleStyle_(): CSSStyleDeclaration {
        return this._sample.style;
    }
    private static _transformValue(styles: SStringMap): string {
        return An.joinNotEmpty_("; ", [
            this._nonemptystyle(styles, PK.Transform),
            this._nonemptystyle(styles, PK.TransformOrigin),
        ]);
    }
    private static _nonemptystyle(styles: StringMap<any>, name: string): string {
        if (styles.hasOwnProperty(name)) {
            const value = CSSUtil.ignoreInheritNone(styles[name]);
            return value.length > 0 ? `${name}: ${value}` : "";
        }
        return "";
    }
}

class _PromptFgStyleSamplesPanel extends UIPanelBase {
    constructor(
        private readonly _container: HTMLElement,
        buttonsize: Int,
        samples: SamplesSpec,
        private _onClick: JSONCallback
    ) {
        super();
        const x1 = buttonsize;
        const x2 = buttonsize * 2;
        const x8 = buttonsize * 8;
        const b = new DomBuilderEx(this._container);
        b.div_({
            "class": CSS.AnFlex,
            "style": "flex-flow:column nowrap;margin:5px 0;" + `max-height:${x8}px;overflow:auto;`,
        }).push_();
        for (const e of Object.entries(samples)) {
            const title = e[0];
            const array = e[1];
            b.peek_().div_([
                "style", "margin-top:10px;",
            ]).text_(title);
            b.peek_().div_({
                "class": CSS.AnFlex,
                "style": "flex-flow:wrap;justify-content:center;margin:5px 0;",
            }).push_();
            for (let index = 0; index < array.length; ++index) {
                const [label, styles] = array[index];
                const style = CSSUtil.joinStyles1_(Object.entries(styles));
                b.peek_().div_(
                    ["class", `${CSS.AnLink} ${CSS.AnFlexCenter}`],
                    ["style", `width:calc(${x2}px - 16px);height:calc(${x2}px - 16px);`
                        + (label == "A" ? `font-size:${x1}px;font-weight:bold;${style};` : "")
                        + "margin:8px;box-sizing:border-box;flex:0 0 auto;background-color:#eee;overflow:hidden;"
                    ],
                    [ATTR.AnInfo, JSON.stringify(styles)],
                ).text_(label);
            }
            b.pop_();
        }
        An.onClickMatching_(this._container, `div.${CSS.AnLink}`, (elm) => {
            const styles = An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.AnInfo));
            if (styles != null) this._onClick(styles);
        });
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
}

class PromptFgStyle extends CompositeDialogBase {
    static readonly _SAMPLES: SamplesSpec = smap_(
        [MSG.string_(RS.Tooltips_TextShadow), [
            ["", smap_([PK.TextShadow, ""])],
            ["none", smap_([PK.TextShadow, "none"])],
            ["A", smap_([PK.TextShadow, "2px 2px 5px rgba(0, 0, 0, 0.5)"])],
            ["A", smap_([PK.TextShadow, "2px 2px 5px rgba(255, 255, 255, 0.5)"])],
        ]],
        [MSG.string_(RS.Transform), [
            ["", smap_([PK.Transform, ""], [PK.TransformOrigin, ""])],
            ["none", smap_([PK.Transform, "none"], [PK.TransformOrigin, ""])],
            ["5", smap_([PK.Transform, "rotate(5deg)"], [PK.TransformOrigin, "50% 50%"])],
            ["90", smap_([PK.Transform, "rotate(90deg) translateY(-100%)"], [PK.TransformOrigin, "0 0"])],
            ["-5", smap_([PK.Transform, "rotate(-5deg)"], [PK.TransformOrigin, "50% 50%"])],
            ["-90", smap_([PK.Transform, "translateX(-100%) rotate(-90deg)"], [PK.TransformOrigin, "100% 0"])],
            ["0.5x", smap_([PK.Transform, "scale(0.5, 0.5)"])],
            ["2x", smap_([PK.Transform, "scale(2.0, 2.0)"])],
        ]],
    );
    private _okCallback: Fun10X<SStringMap> = null;
    private _tabPanel!: TabPanel;
    private _inputTab: _PromptFgStyleInputPanel;
    constructor(
        container: HTMLElement,
        target: HTMLElementX,
        buttonsize: Int,
        style: CSSStyleDeclaration,
        value: SStringMap,
        samples: SamplesSpec,
        zindex: Int,
    ) {
        super(container, [
            new TabbedPanelField("", [
                new TabField(RS.Tooltips_EnterAsText, `${CSS.Fa} ${CSS.FaFolder}`, (ret, host, container) => {
                    return new _PromptFgStyleInputPanel(ret, container, target, host, buttonsize, style, value, zindex, () => {
                        this.blurAll();
                    }, () => {
                        this._tabPanel?.selectTabAt(2);
                    });
                }),
                new TabField(RS.Tooltips_PickFromSamples, `${CSS.Fa} ${CSS.FaTh}`, (_ret, _host, container) => {
                    return new _PromptFgStyleSamplesPanel(container, buttonsize, samples, (styles) => {
                        this._onSample(styles);
                    });
                }),
                new TabField(RS.ImageFilterSamplesTooltips, `${CSS.Fa} ${CSS.FaFilter}`, (ret, host, container) => {
                    return new _PromptFilterSamplesPanel(ret, host, container, buttonsize, (name, value, toggle) => {
                        return this._onFilterSample(name, value, toggle);
                    });
                }),
            ]),
        ]);
        this.zindex_(zindex);
        this.largeWidth_();
        this._tabPanel = (this.getFieldAt_(0) as ITabbedPanelField).tabPanel_();
        this._inputTab = this._tabPanel.getPanelAt(0) as _PromptFgStyleInputPanel;
        this._tabPanel?.onTabChanged((_elm, index) => {
            this._toolbar?.showButton_(BUT.OK, index == 0);
        });
        this.onChange_((_field, _input) => {
            this._inputTab.updateSample_(this._inputTab.getValue_());
        });
        this._tabPanel.onTabChanged((_, index) => {
            if (index == 2) this.info_(this._inputTab.sampleStyle_().getPropertyValue("filter"));
        });
        this._tabPanel.selectTabAt(0);
    }
    _onSample(styles: SStringMap) {
        this._tabPanel?.selectTabAt(0);
        this._inputTab.updateValue_(styles);
    }
    _onFilterSample(name: string, value: string, toggle: boolean): string {
        return this._inputTab.setFilter_(name, value, toggle);
    }
    onOK_(callback: Fun10<SStringMap>): this {
        this._okCallback = callback;
        return this;
    }
    _onOK(done: BoolCallback) {
        const value = this._inputTab.getValue_();
        if (value == null) {
            done(false);
            return;
        }
        done(true);
        this._okCallback?.(value);
        this._okCallback = null;
    }
    show_(): this {
        super.show_();
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

class _PromptBgImgInputPanel extends UIPanelBase {
    private readonly _fields = new Array<IDialogField>();
    private _sample!: HTMLElement;
    private _filter: IDialogField;
    constructor(
        ret: IDialogField[],
        private _host: IDialogFieldHost,
        private readonly _container: HTMLElement,
        buttonsize: Int,
        baseuri: BaseUriX,
        bgstyles: [bgimg: string, backdropfilter: string],
        fgstyles: [bgcolor: string, fgcolor: string, border: Map<string, string>] | null,
        blur: Fun00,
        selectFilterTab: Fun00,
    ) {
        super();
        const b = new DomBuilderEx(this._container);
        b.div_({
            "class": CSS.AnFlexColumnNoWrap,
            "style": "align-items:stretch;margin:5px 0;",
        }).push_();
        const bgimg = bgstyles[0];
        const backdropfilter = bgstyles[1];
        let layers = CSSUtil.splitBgImg_(bgimg);
        const specs = [
            new GlassLayerFIeld("", PromptBgImg._LAYER0, layers[0], RS.Layer0, buttonsize, baseuri),
            new GlassLayerFIeld("", PromptBgImg._LAYER1, layers[1], RS.Layer1, buttonsize, baseuri),
            new GlassLayerFIeld("", PromptBgImg._LAYER2, layers[2], RS.Layer2, buttonsize, baseuri),
            new InputButtonsField("", PromptBgImg._FILTER, backdropfilter, RS.BackdropFilter,
                [BUT.Clear1, BUT.Edit1, BUT.ImageFilter1], (button) => {
                    if (button == BUT.Clear1) this._setfilter1("");
                    else if (button == BUT.Edit1) this._editfilter(_host);
                    else if (button == BUT.ImageFilter1) selectFilterTab();
                }),
            new SampleField(PromptBgImg._SAMPLE, ""),
        ];
        for (let spec of specs) {
            let field = spec.create_(_host, b.peek_());
            field.element_().classList.add(CSS.AnMarginTop5);
            this._fields.push(field);
            ret.push(field);
        }
        const x2 = buttonsize * 2;
        this._sample = new DomBuilderEx(this._fields[4].element_()).div_({
            "class": CSS.AnFlexCenter,
            "style": `width:50%;height:${x2}px;margin:40px 0 20px 0;background-image:${bgimg};`
                + (backdropfilter.length == 0 ? "" : `backdrop-filter:${backdropfilter};`),
        }).text_(MSG.string_(RS.Sample)).cursor_();
        if (fgstyles != null) {
            const style = this._sample.style;
            style.backgroundColor = fgstyles[0];
            style.color = fgstyles[1];
            for (const [name, value] of fgstyles[2]) {
                style.setProperty(name, value);
            }
        }
        this._filter = this._fields[3];
        An.onClick_(this._sample, (e) => {
            An.stopevent_(e);
            blur();
            _host.clearStatus_();
        });
    }
    private _editfilter(host: IDialogFieldHost): void {
        const value = this._filter.getValue_();
        const cpath = native$.getIFrameContextPath_();
        const baseuri = native$.getIFrameUri_();
        if (cpath == null || baseuri == null) return;
        _Util.styleEditor_(accessories$, `backdrop-filter: ${value}`, cpath, baseuri,
            An.above_(this.element_()), host, (styles) => {
                this._setfilter1(styles[PK.BackdropFilter] ?? "");
            }).show_();
    }
    updateSample_(value: [string, string]) {
        this._sample.style.backgroundImage = value[0];
        this._sample.style.setProperty(PK.BackdropFilter, value[1]);
    }
    updateSampleStyle_(name: string, value: string) {
        this._sample.style.setProperty(name, value);
    }
    getValue_(): [string, string] {
        return [An.joinNotEmpty_(", ", [
            this._fields[0].getValue_(),
            this._fields[1].getValue_(),
            this._fields[2].getValue_(),
        ]), this._fields[3].getValue_()];
    }
    setBgImg_(value: string) {
        const values = CSSUtil.splitBgImg_(value);
        for (let index = 0; index < 3; ++index) {
            this._fields[index].setValue_(values[index]);
        }
        this.updateSample_([value, this._sample.style.getPropertyValue(PK.BackdropFilter)]);
    }
    setFilter_(name: string, value: string, toggle: boolean): string {
        const ovalue = this._sample.style.getPropertyValue(PK.BackdropFilter);
        const filter = CSSUtil.updateFilter_(ovalue, name, value, toggle);
        this._filter.setValue_(filter);
        this.updateSample_([this._sample.style.backgroundImage, filter]);
        this._host.info_(filter);
        return filter;
    }
    private _setfilter1(style: string) {
        if (style.length == 0) {
            this._filter.setValue_("");
            this.updateSample_([this._sample.style.backgroundImage, ""]);
            return;
        }
        const map = CSSUtil.splitFilter_(this._sample.style.getPropertyValue(PK.BackdropFilter));
        Object.entries(CSSUtil.splitFilter_(style)).forEach(([k, v]) => { map[k] = v; });
        const backdropfilter = Object.entries(map).map(([k, v]) => k + v).join(" ");
        this._filter.setValue_(backdropfilter);
        this.updateSample_([this._sample.style.backgroundImage, backdropfilter]);
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
    sampleStyle_(): CSSStyleDeclaration {
        return this._sample.style;
    }
}

class _PromptBgImgFgPanel extends UIPanelBase {
    private readonly _fields = new Array<IDialogField>();
    constructor(
        ret: IDialogField[],
        host: IDialogFieldHost,
        private readonly container: HTMLElement,
        buttonsize: Int,
        fgstyles: [bgcolor: string, fgcolor: string, border: Map<string, string>],
    ) {
        super();
        const b = new DomBuilderEx(this.container);
        b.div_({
            "class": CSS.AnFlexColumnNoWrap,
            "style": "align-items:stretch;margin:5px 0;",
        }).push_();
        const specs = [
            new ColorField(RS.BGColor, PromptBgImg._BGCOLOR, fgstyles[0], buttonsize, RS.BGColor),
            new ColorField(RS.FGColor, PromptBgImg._FGCOLOR, fgstyles[1], buttonsize, RS.FGColor),
            new InputButtonField(RS.Border, PromptBgImg._BORDER, CSSUtil.joinStyles_(fgstyles[2]), RS.Border, BUT.Border1, (field, input) => {
                new PromptBorders(
                    accessories$,
                    buttonsize,
                    CSSUtil.splitStyle_(map_(), field.getValue_(), (ret, name, value) => ret.set(name, value)))
                    .titleKey_(RS.Borders)
                    .above_(host.element_())
                    .onOK_((_, styles, done) => {
                        done(true);
                        field.setValue_(CSSUtil.joinStyles_(styles));
                        host.fireOnChange_(field, input);
                    })
                    .show_();
            }),
        ];
        for (let spec of specs) {
            let field = spec.create_(host, b.peek_());
            field.element_().classList.add(CSS.AnMarginTop5);
            this._fields.push(field);
            ret.push(field);
        }
    }
    getValue_(): [bgcolor: string, fgcolor: string, border: string] {
        return [
            this._fields[0].getValue_(),
            this._fields[1].getValue_(),
            this._fields[2].getValue_(),
        ];
    }
    setBgcolor_(value: string) {
        this._fields[0].setValue_(value);
    }
    setFgcolor_(value: string) {
        this._fields[1].setValue_(value);
    }
    setBorder_(value: string) {
        this._fields[2].setValue_(value);
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this.container;
    }
}

class _PromptFilterSamplesPanel extends UIPanelBase {
    private static readonly _SAMPLES = BackdropFilter.FILTERS$.map((name, index) => {
        return [name, BackdropFilter.DEF$[index]];
    });
    private _slider: HTMLInputElement;
    constructor(
        _ret: IDialogField[],
        _host: IDialogFieldHost,
        private readonly _container: HTMLElement,
        buttonsize: Int,
        private _updateFilter: Fun31<string, string, boolean, string>,
    ) {
        super();
        const x2 = buttonsize * 2;
        const x8 = buttonsize * 8;
        const b = new DomBuilderEx(this._container);
        b.push_().div_({
            "class": CSS.AnFlexCenter,
            "style": "flex-flow:column nowrap;margin:5px 0;" + `max-height:${x8}px;overflow:auto;`,
        }).push_().div_({
            "style": "margin:10px 0 5px 0;",
        }).text_(MSG.string_(RS.BackdropFilter)).peek_().div_({
            "class": CSS.AnFlex,
            "style": "flex-flow:wrap;justify-content:center;align-items:center;margin:5px 0;",
        }).push_();
        for (const [name, arg] of _PromptFilterSamplesPanel._SAMPLES) {
            const value = `(${arg})`;
            b.peek_().div_(
                ["class", CSS.AnFlexCenter],
                ["style", "background-image:url('/assets/templates/memo/memo-v2-09-button.jpg');"
                    + "background-size:cover;margin:5px;"],
            ).div_(
                ["class", `${CSS.AnLink}`],
                ["style", "display:flex;justify-content:center;align-items:flex-end;overflow:hidden;"
                    + `width:${x2}px;height:${x2}px;color:${name == "invert" ? "#fff" : "#444"};`
                    + `backdrop-filter:${name}${value};`],
                [ATTR.AnInfo, JSON.stringify([name, value])],
            ).text_(name);
        }
        this._slider = DialogUt.createInputSlider_(b.pop_(3), 0, 1.0, 0.01, 0, `${buttonsize}px`, 0, RS.Adjust, "1", () => {
            const name = this._slider.getAttribute(ATTR.AnAction);
            if (name == null) return;
            const adjustvalue = `(${this._slider.value}${this._slider.getAttribute(ATTR.AnInfo) ?? ""})`;
            this._updateFilter(name, adjustvalue, false);
        });
        this._slider.disabled = true;
        this._slider.setAttribute(ATTR.AnNoClick, "true");
        this._slider.style.width = "100%";
        An.onClickMatching_(this._container, `div.${CSS.AnLink}`, (elm) => {
            const namevalue = An.parseJSONArrayOrNull_<string>(elm.getAttribute(ATTR.AnInfo));
            if (namevalue != null) {
                const name = namevalue[0];
                const value = namevalue[1];
                const filter = this._updateFilter(name, value, true);
                const map = CSSUtil.splitFilter_(filter);
                if (Object.keys(map).includes(name)) {
                    this._updateSlider(name, value);
                    return;
                }
                const a = ArrayUt.last_(Object.entries(map));
                if (a == undefined) {
                    this._slider.disabled = true;
                    return;
                };
                this._updateSlider(a[0], a[1]);
            }
        });
    }
    private _updateSlider(name: string, value: string) {
        const index = BackdropFilter.FILTERS$.indexOf(name);
        if (index <= 0) return;
        const range = BackdropFilter.RANGE$[index];
        const sizeunit = An.doubleValueUnit_(value.substring(1, value.length - 1));
        if (sizeunit == null || range == null) return;
        this._slider.min = `${range[0]}`;
        this._slider.max = `${range[1]}`;
        this._slider.step = `${range[2]}`;
        this._slider.value = `${sizeunit[0]}`;
        this._slider.setAttribute(ATTR.AnAction, name);
        this._slider.setAttribute(ATTR.AnInfo, sizeunit[1]);
        this._slider.disabled = false;
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
}

class _PromptBgImgSamplesPanel extends UIPanelBase {
    constructor(
        _ret: IDialogField[],
        _host: IDialogFieldHost,
        private readonly _container: HTMLElement,
        buttonsize: Int,
        samples: string[],
        private _onClick: Fun10<Int>
    ) {
        super();
        const b = new DomBuilderEx(this._container);
        const x2 = buttonsize * 2;
        const x3 = buttonsize * 3;
        const x8 = buttonsize * 8;
        b.div_({
            "class": CSS.AnFlex,
            "style": "flex-flow:wrap;justify-content:center;margin:5px 0;" + `max-height:${x8}px;overflow:auto;`,
        }).push_();
        for (let index = 0; index < samples.length; ++index) {
            b.peek_().div_(
                ["class", CSS.AnLink],
                ["style", `width:calc(${x3}px - 2px);height: ${x2}px;background-image:${samples[index]};`
                    + "margin:1px;box-sizing:border-box;flex:0 0 auto;background-color:#fff;"],
                [ATTR.AnInfo, `${index}`],
            );
        }
        An.onClickMatching_(this._container, `div.${CSS.AnLink}`, (elm) => {
            const index = An.parseInt_(elm.getAttribute(ATTR.AnInfo), -1);
            if (index >= 0) this._onClick(index);
        });
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
}

class PromptBgImg extends CompositeDialogBase {
    static readonly _FILTER = "#XwQ";
    static readonly _SAMPLE = "#XXy";
    static readonly _LAYER2 = "#XhS";
    static readonly _LAYER0 = "#X65";
    static readonly _LAYER3 = "#XNC";
    static readonly _PANEL = "#X9d";
    static readonly _LAYER1 = "#XO7";
    static readonly _FGCOLOR = "#Xfg";
    static readonly _BGCOLOR = "#Xbg";
    static readonly _BORDER = "#Xbd";
    private _okCallback: Fun10X<CSSStyleDeclaration> = null;
    private _tabPanel!: TabPanel;
    private _inputTab: _PromptBgImgInputPanel;

    constructor(
        container: HTMLElement,
        buttonsize: Int,
        baseuri: BaseUriX,
        bgstyles: [bgimg: string, backdropfilter: string],
        fgstyles: [bgcolor: string, fgcolor: string, border: Map<string, string>] | null,
        private readonly samples: string[],
        zindex: Int,
    ) {
        const specs = () => {
            const ret = [
                new TabField(RS.Tooltips_EnterAsText, `${CSS.Fa} ${CSS.FaFolder}`, (ret, host, container) => {
                    return new _PromptBgImgInputPanel(ret, host, container, buttonsize, baseuri, bgstyles, fgstyles, () => {
                        this.blurAll();
                    }, () => {
                        this._tabPanel.selectTabAt(2);
                    });
                }),
                new TabField(RS.BackgroundImageSamplesTooltips, `${CSS.Fa} ${CSS.FaTh}`, (ret, host, container) => {
                    return new _PromptBgImgSamplesPanel(ret, host, container, buttonsize, samples, (index) => {
                        this._onBackgroundSample(index);
                    });
                }),
                new TabField(RS.BackdropFilterSamplesTooltips, `${CSS.Fa} ${CSS.FaFilter}`, (ret, host, container) => {
                    return new _PromptFilterSamplesPanel(ret, host, container, buttonsize, (name, value, toggle) => {
                        return this._onFilterSample(name, value, toggle);
                    });
                }),
            ];
            if (fgstyles != null) {
                ret.push(new TabField(RS.FGColor, `${CSS.Fa} ${CSS.FaSpinner}`, (ret, host, container) => {
                    return new _PromptBgImgFgPanel(ret, host, container, buttonsize, fgstyles);
                }));
            }
            return ret;
        };
        super(container, [new TabbedPanelField(PromptBgImg._PANEL, specs())]);
        this.largeWidth_();
        this.zindex_(zindex);
        this.titleKey_(RS.EditBGImageTitle);
        this._tabPanel = (this.getFieldAt_(0) as ITabbedPanelField).tabPanel_();
        this._inputTab = this._tabPanel.getPanelAt(0) as _PromptBgImgInputPanel;
        this._tabPanel.onTabChanged((_elm, index) => {
            this._toolbar?.showButton_(BUT.OK, index == 0);
        });
        this.onChange_((field) => {
            if (field.spec$.key$ == PromptBgImg._FGCOLOR) {
                this._inputTab.updateSampleStyle_(PK.Color, field.getValue_());
            } else if (field.spec$.key$ == PromptBgImg._BGCOLOR) {
                this._inputTab.updateSampleStyle_(PK.BackgroundColor, field.getValue_());
            } else if (field.spec$.key$ == PromptBgImg._BORDER) {
                this._inputTab.updateSampleStyle_(PK.Border, "");
                this._inputTab.updateSampleStyle_(PK.BorderRadius, "");
                this._inputTab.updateSampleStyle_(PK.BoxShadow, "");
                const styles = CSSUtil.splitStyle_(ssmap_(), field.getValue_(), (ret, name, value) => ret[name] = value);
                for (const [name, value] of Object.entries(styles)) {
                    this._inputTab.updateSampleStyle_(name, value);
                }
            } else {
                this._inputTab.updateSample_(this._inputTab.getValue_());
            }
        });
        this._tabPanel.onTabChanged((_, index) => {
            if (index == 2) this.info_(this._inputTab.sampleStyle_().getPropertyValue(PK.BackdropFilter));
        });
        const hasstyle = (bgstyles[0].length == 0 || bgstyles[0] == "none") && (bgstyles[1].length == 0 || bgstyles[1] == "none");
        this._tabPanel.selectTabAt(hasstyle ? 1 : 0);
    }
    _onBackgroundSample(index: Int) {
        if (index >= 0 && index < this.samples.length) {
            this._inputTab.setBgImg_(this.samples[index]);
        }
        this._tabPanel.selectTabAt(0);
    }
    _onFilterSample(name: string, value: string, toggle: boolean) {
        return this._inputTab.setFilter_(name, value, toggle);
    }
    onOK_(callback: Fun10<CSSStyleDeclaration>): this {
        this._okCallback = callback;
        return this;
    }
    _onOK(done: BoolCallback) {
        const styles = this._inputTab.sampleStyle_();
        done(true);
        this._okCallback?.(styles);
        this._okCallback = null;
    }
    show_(): this {
        super.show_();
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

namespace ShapePicker$ {

    type OnRectChangeCallback = (rect: MutRect, origin: Point<number>, _zoom: number) => void;
    type OnQuadChangeCallback = (current: Quad, origin: Point<number>, _zoom: number) => void;

    class DownState {
        constructor(
            public scrollx: number,
            public scrolly: number,
            public x0: number,
            public y0: number,
            public buttons: number
        ) { };
    }

    abstract class _ShapePickerBase {

        static readonly _DASH = 5;
        static readonly _DELTA = 5;
        static readonly _SCALE = 0.05;
        static readonly _MAX_ZOOM = 2.0;

        _snapper: ISnapper<number>;

        protected _background: HTMLCanvasElement;
        protected _overlay: HTMLCanvasElement;
        protected _backgroundContext: CanvasRenderingContext2D;
        protected _overlayContext: CanvasRenderingContext2D;
        _canvasSize: Point<number>;
        _zoomFit: number;
        _scaled: MutRect;

        _moved: boolean = false;
        _center: Point<number> | null = null;
        _limiter: IRateLimiter = new FrameLimiter(4);

        constructor(
            container: HTMLElement,
            protected _buttonSize: number,
            private _viewportSize: Point<number>,
            protected _imageSize: Point<number>,
            protected _origin: Point<number>,
            protected _image: HTMLImageElement,
            protected _zoom: number,
            protected _margin: number,
            protected _useTouch: boolean,
            snapper: ISnapper<number>) {
            this._snapper = (snapper != null ? snapper : new DumbSnapper<number>());
            this._canvasSize = MediaUtil.fit_(_imageSize.x, _imageSize.y, _viewportSize.x - _margin * 2, _viewportSize.y - _margin * 2);
            this._zoomFit = MediaUtil.zoomOf_(this._canvasSize, _imageSize.x, _imageSize.y);
            _zoom = An.clamp_(this._zoomFit, _ShapePickerBase._MAX_ZOOM, _zoom);
            const w = _imageSize.x * _zoom;
            const h = _imageSize.y * _zoom;
            this._scaled = new MutRect(
                _origin.x * w,
                _origin.y * h,
                w,
                h);
            const doc = container.ownerDocument;
            this._background = doc.createElement("canvas");
            this._background.width = this._canvasSize.x;
            this._background.height = this._canvasSize.y;
            this._positionCanvas(this._background);
            this._background.style.backgroundColor = "rgba(255,255,255,1.0)";
            this._background.style.outline = "1px solid #aaa";
            this._overlay = doc.createElement("canvas");
            this._overlay.width = this._canvasSize.x;
            this._overlay.height = this._canvasSize.y;
            this._positionCanvas(this._overlay);
            this._overlay.classList.add(CSS.AnOverlayCanvas);
            this._overlay.style.backgroundColor = "rgba(255,255,255,0)";
            container.append(this._background);
            container.append(this._overlay);
            this._backgroundContext = this._background.getContext("2d")!;
            this._backgroundContext.imageSmoothingQuality = "high";
            this._backgroundContext.imageSmoothingEnabled = true;
            this._overlayContext = this._overlay.getContext("2d")!;
            this._overlayContext.imageSmoothingQuality = "high";
            this._overlayContext.imageSmoothingEnabled = true;
            this._overlayContext.setLineDash([_ShapePickerBase._DASH, _ShapePickerBase._DASH]);
        }

        private _positionCanvas(canvas: HTMLCanvasElement): void {
            const marginx = Math.max(this._margin, (this._viewportSize.x - this._canvasSize.x) / 2);
            const style = canvas.style;
            style.position = "absolute";
            style.float = "left";
            style.clear = "both";
            style.top = `${this._margin}px`;
            style.left = `${marginx}px`;
        }

        protected _setupPinchZoomListener(zoomat: (x: number, y: number) => Point<number>): void {
            new RubberBandListener(this._overlay, Conf.pointerstart$ == "touchstart", (center, delta) => {
                
                if (center != null) {
                    const sx = center.x - this._margin - this._scaled.x;
                    const sy = center.y - this._margin - this._scaled.y;
                    this._center = new Point(sx, sy);
                    return delta;
                }
                if (this._center != null) {
                    let z = this._zoom;
                    while (delta <= -_ShapePickerBase._DELTA) {
                        z = z * (1.0 - _ShapePickerBase._SCALE);
                        delta += _ShapePickerBase._DELTA;
                    }
                    while (delta >= _ShapePickerBase._DELTA) {
                        z = z * (1.0 + _ShapePickerBase._SCALE);
                        delta -= _ShapePickerBase._DELTA;
                    }
                    z = An.clamp_(this._zoomFit, _ShapePickerBase._MAX_ZOOM, z);
                    if (z != this._zoom) {
                        this._zoom = z;
                        const center = this._center;
                        this._limiter.queue_(() => {
                            this._center = zoomat(center.x, center.y);
                        });
                    }
                }
                return delta;
            });
        }

        protected _rescale(sx: number, sy: number): Point<number> {
            const w = this._imageSize.x * this._zoom;
            const h = this._imageSize.y * this._zoom;
            const sxx = w * sx / this._scaled.w;
            const syy = h * sy / this._scaled.h;
            const dx = w - this._canvasSize.x;
            const dy = h - this._canvasSize.y;
            let ox: number;
            let oy: number;
            if (dx <= 0) {
                ox = 0.0;
                oy = 0.0;
            } else {
                ox = An.clamp_(-dx, 0.0, (sx + this._scaled.x) - sxx);
                oy = An.clamp_(-dy, 0.0, (sy + this._scaled.y) - syy);
            }
            this._scaled = new MutRect(ox, oy, w, h);
            
            return new Point(sxx, syy);
        }

        protected _reposition(sx0: number, sy0: number, sx: number, sy: number): void {
            let xx = this._scaled.x + (sx - sx0);
            let yy = this._scaled.y + (sy - sy0);
            xx = An.clamp_(-(this._scaled.w - this._canvasSize.x), 0.0, xx);
            yy = An.clamp_(-(this._scaled.h - this._canvasSize.y), 0.0, yy);
            
            this._scaled.x = xx;
            this._scaled.y = yy;
        }

        protected _distance2(x0: number, y0: number, x: number, y: number): number {
            const dx = x - x0;
            const dy = y - y0;
            return dx * dx + dy * dy;
        }

    }

    ////////////////////////////////////////////////////////////////////////

    class RectHandle {
        x: number;
        y: number;
        w: number;
        h: number;

        constructor(
            public readonly index: number,
            r: MutRect,
            public readonly state: DownState
        ) {
            this.w = r.w;
            this.h = r.h;
            switch (index) {
                case 0:
                    this.x = r.x;
                    this.y = r.y;
                    break;
                case 1:
                    this.x = r.x + r.w;
                    this.y = r.y;
                    break;
                case 2:
                    this.x = r.x + r.w;
                    this.y = r.y + r.h;
                    break;
                case 3:
                    this.x = r.x;
                    this.y = r.y + r.h;
                    break;
                case 4:
                    this.x = r.x + r.w / 2;
                    this.y = r.y;
                    break;
                case 5:
                    this.x = r.x + r.w;
                    this.y = r.y + r.h / 2;
                    break;
                case 6:
                    this.x = r.x + r.w / 2;
                    this.y = r.y + r.h;
                    break;
                case 7:
                    this.x = r.x;
                    this.y = r.y + r.h / 2;
                    break;
                default:
                    this.x = r.x;
                    this.y = r.y;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////

    export class RectPicker extends _ShapePickerBase {

        private _original: MutRect;
        private _current: MutRect;
        private _handle: RectHandle | null = null;

        /// Listener for mouse events in the canvas element
        private _mouseListener: UIUt$.IPointerListener;

        constructor(
            parent: HTMLElement,
            buttonsize: number,
            viewportsize: Point<number>,
            imagesize: Point<number>,
            origin: Point<number>,
            image: HTMLImageElement,
            zoom: number,
            margin: number,
            usetouch: boolean,
            snapper: ISnapper<number>,
            rect: MutRect,
            private _onChangeCallback: OnRectChangeCallback) {
            super(
                parent,
                buttonsize,
                viewportsize,
                imagesize,
                origin,
                image,
                zoom,
                margin,
                usetouch,
                snapper);
            this._original = rect.clampSize_(0.0, 1.0);
            this._current = MutRect.fromRect_(this._original);
            
            
            this._redraw(false, false);
            this._fireOnChange();
            this._mouseListener = this._useTouch
                ? new UIUt$.TouchListener(this._overlay, true)
                : new UIUt$.MouseListener(this._overlay, true);
            this._mouseListener.onPointerDown((x, y, buttons) => this.onMouseDown_(x, y, buttons));
            this._mouseListener.onPointerMoved((x, y, buttons) => this.onMouseMove_(x, y, buttons));
            this._mouseListener.onPointerUp((x, y, buttons) => this.onMouseUp_(x, y, buttons));
            this._setupPinchZoomListener((sx, sy) => this._zoomAt(sx, sy));
        }

        reset_(): void {
            this._current = MutRect.fromRect_(this._original);
            this._drawOverlay(false, false);
            this._fireOnChange();
        }

        onMouseDown_(x: number, y: number, buttons: number): boolean {
            const sx = x - this._margin - this._scaled.x;
            const sy = y - this._margin - this._scaled.y;
            this._moved = false;
            this._handle = null;
            
            if (buttons != 3 && buttons != 1) {
                return false;
            }
            const state: DownState = new DownState(
                this._scaled.x,
                this._scaled.y,
                sx,
                sy,
                buttons);
            if (buttons == 3) {
                this._handle = new RectHandle(8, this._current, state);
                this._drawOverlay(true, false);
                return true;
            }
            const max = (this._buttonSize * this._buttonSize);
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            let d = sw * sw + sh * sh;
            let corner: RectHandle | null = null;
            for (const c of [
                new RectHandle(0, this._current, state),
                new RectHandle(1, this._current, state),
                new RectHandle(2, this._current, state),
                new RectHandle(3, this._current, state),
            ]) {
                const d1 = this._distance2(c.x * sw, c.y * sh, sx, sy);
                if (d1 < max && d1 < d) {
                    corner = c;
                    d = d1;
                }
            }
            if (corner == null) {
                const rx = this._current.x * sw;
                const ry = this._current.y * sh;
                const rw = this._current.w * sw;
                const rh = this._current.h * sh;
                for (const c of [
                    new RectHandle(4, this._current, state),
                    new RectHandle(5, this._current, state),
                    new RectHandle(6, this._current, state),
                    new RectHandle(7, this._current, state),
                ]) {
                    let d1 = d;
                    switch (c.index) {
                        case 4:
                            if (sx >= rx && sx <= rx + rw) {
                                d1 = (sy - ry) * (sy - ry);
                            }
                            break;
                        case 5:
                            if (sy >= ry && sy <= ry + rh) {
                                d1 = (sx - rx - rw) * (sx - rx - rw);
                            }
                            break;
                        case 6:
                            if (sx >= rx && sx <= rx + rw) {
                                d1 = (sy - ry - rh) * (sy - ry - rh);
                            }
                            break;
                        default:
                            if (sy >= ry && sy <= ry + rh) {
                                d1 = (sx - rx) * (sx - rx);
                            }
                    }
                    if (d1 < max && d1 < d) {
                        corner = c;
                        d = d1;
                    }
                }
            }
            if (corner == null) {
                this._handle = new RectHandle(8, this._current, state);
                this._drawOverlay(true, false);
                return true;
            }
            this._handle = corner;
            this._update(x, y, true);
            return true;
        }

        onMouseMove_(x: number, y: number, buttons: number): void {
            
            if (buttons != 1 && buttons != 3) {
                return;
            }
            this._moved = true;
            this._update(x, y, true);
        }

        onMouseUp_(x: number, y: number, _buttons: number): void {
            
            if (!this._moved && this._handle != null && this._handle.index >= 8) {
                const zoom = MediaUtil.zoomOf_(this._canvasSize, this._imageSize.x, this._imageSize.y);
                if (this._zoom <= zoom) {
                    this._zoom = 1.0;
                } else {
                    this._zoom = zoom;
                }
                const sx = x - this._margin - this._scaled.x;
                const sy = y - this._margin - this._scaled.y;
                this._zoomAt(sx, sy);
                return;
            }
            this._update(x, y, false);
            this._handle = null;
            this._moved = false;
        }

        private _redraw(fill: boolean, dragging: boolean): void {
            this._drawBackground();
            this._drawOverlay(fill, dragging);
        }

        private _drawBackground(): void {
            this._backgroundContext.drawImage(
                this._image,
                this._scaled.x,
                this._scaled.y,
                this._scaled.w,
                this._scaled.h);
        }

        private _drawOverlay(fill: boolean, dragging: boolean): void {
            const ctx = this._overlayContext;
            ctx.fillStyle = "rgba(255, 255, 255, 0.0)";
            ctx.clearRect(0, 0, this._canvasSize.x, this._canvasSize.y);
            const sx = this._scaled.x;
            const sy = this._scaled.y;
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            const rx = this._current.x * sw + sx;
            const ry = this._current.y * sh + sy;
            const rw = this._current.w * sw;
            const rh = this._current.h * sh;
            if (fill) {
                if (dragging) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                } else {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                }
                ctx.fillRect(rx, ry, rw, rh);
            }
            ctx.strokeStyle = "rgba(0, 0, 0, 1.0)";
            ctx.lineDashOffset = 0;
            ctx.strokeRect(rx, ry, rw, rh);
            ctx.strokeStyle = "rgba(255, 255, 255, 1.0)";
            ctx.lineDashOffset = _ShapePickerBase._DASH;
            ctx.strokeRect(rx, ry, rw, rh);
        }

        private _zoomAt(sx: number, sy: number): Point<number> {
            const ret = this._rescale(sx, sy);
            this._redraw(false, false);
            this._fireOnChange();
            return ret;
        }

        private _scrollTo(handle: RectHandle, sx: number, sy: number, fill: boolean): void {
            this._reposition(handle.state.x0, handle.state.y0, sx, sy);
            this._redraw(fill, false);
            this._fireOnChange();
        }

        private _update(x: number, y: number, selecting: boolean): void {
            const sx = x - this._margin - this._scaled.x;
            const sy = y - this._margin - this._scaled.y;
            
            if (this._handle == null) {
                this._drawOverlay(selecting, false);
                return;
            }
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            const dx = sx - this._handle.state.x0;
            const dy = sy - this._handle.state.y0;
            const hx = this._handle.x * sw;
            const hy = this._handle.y * sh;
            const handle = this._handle;
            this._snapper.snap(hx + dx, hy + dy, (xx: number, yy: number) => {
                const hw = handle.w * sw;
                const hh = handle.h * sh;
                switch (handle.index) {
                    case 0:
                        this._current.x = An.clamp_(0.0, hx + hw - 1.0, xx) / sw;
                        this._current.y = An.clamp_(0.0, hy + hh - 1.0, yy) / sh;
                        this._current.w = An.clamp_(1.0, sw, hw + (hx - xx)) / sw;
                        this._current.h = An.clamp_(1.0, sh, hh + (hy - yy)) / sh;
                        break;
                    case 1:
                        this._current.y = An.clamp_(0.0, hy + hh - 1.0, yy) / sh;
                        this._current.w = An.clamp_(1.0, sw, hw + (xx - hx)) / sw;
                        this._current.h = An.clamp_(1.0, sh, hh + (hy - yy)) / sh;
                        break;
                    case 2:
                        this._current.w = An.clamp_(1.0, sw, hw + (xx - hx)) / sw;
                        this._current.h = An.clamp_(1.0, sh, hh + (yy - hy)) / sh;
                        break;
                    case 3:
                        this._current.x = An.clamp_(0.0, hx + hw - 1.0, xx) / sw;
                        this._current.w = An.clamp_(1.0, sw, hw + (hx - xx)) / sw;
                        this._current.h = An.clamp_(1.0, sh, hh + (yy - hy)) / sh;
                        break;
                    case 4:
                        this._current.y = An.clamp_(0.0, hy + hh - 1.0, yy) / sh;
                        this._current.h = An.clamp_(1.0, sh, hh + (hy - yy)) / sh;
                        break;
                    case 5:
                        this._current.w = An.clamp_(1.0, sw, hw + (xx - hx)) / sw;
                        break;
                    case 6:
                        this._current.h = An.clamp_(1.0, sh, hh + (yy - hy)) / sh;
                        break;
                    case 7:
                        this._current.x = An.clamp_(0.0, hx + hw - 1.0, xx) / sw;
                        this._current.w = An.clamp_(1.0, sw, hw + (hx - xx)) / sw;
                        break;
                    default:
                        this._scrollTo(handle, sx, sy, selecting);
                        return;
                }
                
                this._drawOverlay(selecting, true);
                this._fireOnChange();
            });
        }

        private _fireOnChange(): void {
            if (this._onChangeCallback != null) {
                this._onChangeCallback(new MutRect(
                    this._current.x,
                    this._current.y,
                    this._current.w,
                    this._current.h),
                    new Point(this._scaled.x / this._scaled.w, this._scaled.y / this._scaled.h),
                    this._zoom);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////

    class Quad {
        constructor(
            public topLeftX: number,
            public topLeftY: number,
            public topRightX: number,
            public topRightY: number,
            public bottomRightX: number,
            public bottomRightY: number,
            public bottomLeftX: number,
            public bottomLeftY: number) { }

        static from(from: Quad): Quad {
            return new Quad(
                from.topLeftX,
                from.topLeftY,
                from.topRightX,
                from.topRightY,
                from.bottomLeftX,
                from.bottomLeftY,
                from.bottomRightX,
                from.bottomRightY);
        }

        scaledBy(w: number, h: number): Quad {
            return new Quad(
                Math.round((this.topLeftX * w)),
                Math.round((this.topLeftY * h)),
                Math.round((this.topRightX * w)),
                Math.round((this.topRightY * h)),
                Math.round((this.bottomRightX * w)),
                Math.round((this.bottomRightY * h)),
                Math.round((this.bottomLeftX * w)),
                Math.round((this.bottomLeftY * h)));
        }

        toString(): string {
            return `(${this.topLeftX}, ${this.topLeftY}), `
                + `(${this.topRightX}, ${this.topRightY}), `
                + `(${this.bottomRightX}, ${this.bottomRightY}), `
                + `(${this.bottomLeftX}, ${this.bottomLeftY})`;
        }
    }

    class _QuadHandle {
        quad: Quad;
        x: number;
        y: number;

        constructor(
            public readonly index: number,
            r: Quad,
            public readonly state: DownState) {
            this.quad = Quad.from(r);
            switch (index) {
                case 0:
                    this.x = r.topLeftX;
                    this.y = r.topLeftY;
                    break;
                case 1:
                    this.x = r.topRightX;
                    this.y = r.topRightY;
                    break;
                case 2:
                    this.x = r.bottomRightX;
                    this.y = r.bottomRightY;
                    break;
                case 3:
                    this.x = r.bottomLeftX;
                    this.y = r.bottomLeftY;
                    break;
                default:
                    this.x = r.topLeftX;
                    this.y = r.topLeftY;
            }
        }
    }

    export class QuadPicker extends _ShapePickerBase {

        private _current: Quad;
        private _handle: _QuadHandle | null = null;

        /// Listener for mouse events in the canvas element
        private _mouseListener: UIUt$.IPointerListener;

        constructor(
            parent: HTMLElement,
            buttonsize: number,
            viewportsize: Point<number>,
            imagesize: Point<number>,
            origin: Point<number>,
            image: HTMLImageElement,
            zoom: number,
            margin: number,
            usetouch: boolean,
            snapper: ISnapper<number>,
            private _original: Quad,
            private _onChangeCallback: OnQuadChangeCallback) {
            super(
                parent,
                buttonsize,
                viewportsize,
                imagesize,
                origin,
                image,
                zoom,
                margin,
                usetouch,
                snapper);
            this._current = Quad.from(_original);
            
            
            this._redraw(false, false);
            this._fireOnChange();
            this._mouseListener = this._useTouch
                ? new UIUt$.TouchListener(this._overlay, true)
                : new UIUt$.MouseListener(this._overlay, true);
            this._mouseListener.onPointerDown((x, y, buttons) => this.onMouseDown_(x, y, buttons));
            this._mouseListener.onPointerMoved((x, y, buttons) => this.onMouseMove_(x, y, buttons));
            this._mouseListener.onPointerUp((x, y, buttons) => this.onMouseUp_(x, y, buttons));
            this._setupPinchZoomListener((sx, sy) => this._zoomAt(sx, sy));
        }

        private _redraw(fill: boolean, dragging: boolean): void {
            this._drawBackground();
            this._drawOverlay(fill, dragging);
        }

        private _drawBackground(): void {
            this._backgroundContext.drawImage(
                this._image,
                this._scaled.x,
                this._scaled.y,
                this._scaled.w,
                this._scaled.h);
        }

        private _drawOverlay(fill: boolean, dragging: boolean): void {
            const sx = this._scaled.x;
            const sy = this._scaled.y;
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            const ctx = this._overlayContext;
            ctx.fillStyle = "rgba(255, 255, 255, 0.0)";
            ctx.clearRect(0, 0, this._canvasSize.x, this._canvasSize.y);
            ctx.beginPath();
            ctx.moveTo(this._current.topLeftX * sw + sx, this._current.topLeftY * sh + sy);
            ctx.lineTo(this._current.topRightX * sw + sx, this._current.topRightY * sh + sy);
            ctx.lineTo(this._current.bottomRightX * sw + sx, this._current.bottomRightY * sh + sy);
            ctx.lineTo(this._current.bottomLeftX * sw + sx, this._current.bottomLeftY * sh + sy);
            ctx.closePath();
            if (fill) {
                if (dragging) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                } else {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                }
                ctx.fill();
            }
            ctx.strokeStyle = "rgba(0, 0, 0, 1.0)";
            ctx.lineDashOffset = 0;
            ctx.stroke();
            ctx.strokeStyle = "rgba(255, 255, 255, 1.0)";
            ctx.lineDashOffset = _ShapePickerBase._DASH;
            ctx.stroke();
        }

        reset_(): void {
            this._current.topLeftX = this._original.topLeftX;
            this._current.topLeftY = this._original.topLeftY;
            this._current.topRightX = this._original.topRightX;
            this._current.topRightY = this._original.topRightY;
            this._current.bottomRightX = this._original.bottomRightX;
            this._current.bottomRightY = this._original.bottomRightY;
            this._current.bottomLeftX = this._original.bottomLeftX;
            this._current.bottomLeftY = this._original.bottomLeftY;
            this._redraw(false, false);
            this._fireOnChange();
        }

        onMouseDown_(x: number, y: number, buttons: number): boolean {
            const sx = x - this._margin - this._scaled.x;
            const sy = y - this._margin - this._scaled.y;
            this._moved = false;
            this._handle = null;
            
            if (buttons != 1 && buttons != 3) {
                return false;
            }
            const state = new DownState(
                this._scaled.x,
                this._scaled.y,
                sx,
                sy,
                buttons);
            if (buttons == 3) {
                this._handle = new _QuadHandle(8, this._current, state);
                this._redraw(true, false);
                return true;
            }
            const max = (this._buttonSize * this._buttonSize);
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            let d = sw * sw + sh * sh;
            let corner: _QuadHandle | null = null;
            for (const c of [
                new _QuadHandle(0, this._current, state),
                new _QuadHandle(1, this._current, state),
                new _QuadHandle(2, this._current, state),
                new _QuadHandle(3, this._current, state),
            ]) {
                const d1 = this._distance2(c.x * sw, c.y * sh, sx, sy);
                if (d1 < max && d1 < d) {
                    corner = c;
                    d = d1;
                }
            }
            if (corner == null) {
                this._handle = new _QuadHandle(8, this._current, state);
                this._redraw(true, false);
                return true;
            }
            this._handle = corner;
            this._update(x, y, true);
            return true;
        }

        onMouseMove_(x: number, y: number, buttons: number): void {
            
            if (buttons != 1 && buttons != 3) {
                return;
            }
            this._moved = true;
            this._update(x, y, true);
        }

        onMouseUp_(x: number, y: number, _buttons: number): void {
            
            if (!this._moved && this._handle != null && this._handle.index >= 8) {
                const zoom = MediaUtil.zoomOf_(this._canvasSize, this._imageSize.x, this._imageSize.y);
                if (this._zoom <= zoom) {
                    this._zoom = 1.0;
                } else {
                    this._zoom = zoom;
                }
                const sx = x - this._margin - this._scaled.x;
                const sy = y - this._margin - this._scaled.y;
                this._zoomAt(sx, sy);
                return;
            }
            this._update(x, y, false);
            this._handle = null;
            this._moved = false;
        }

        private _zoomAt(sx: number, sy: number): Point<number> {
            const ret = this._rescale(sx, sy);
            this._redraw(false, false);
            this._fireOnChange();
            return ret;
        }

        private _scrollTo(handle: _QuadHandle, sx: number, sy: number, fill: boolean): void {
            this._reposition(handle.state.x0, handle.state.y0, sx, sy);
            this._redraw(fill, false);
            this._fireOnChange();
        }

        private _update(x: number, y: number, selecting: boolean): void {
            const sx = x - this._margin - this._scaled.x;
            const sy = y - this._margin - this._scaled.y;
            
            if (this._handle == null) {
                this._drawOverlay(selecting, false);
                return;
            }
            const sw = this._scaled.w;
            const sh = this._scaled.h;
            const dx = sx - this._handle.state.x0;
            const dy = sy - this._handle.state.y0;
            const hx = this._handle.x * sw;
            const hy = this._handle.y * sh;
            const handle = this._handle;
            this._snapper.snap(hx + dx, hy + dy, (xx: number, yy: number) => {
                xx = An.clamp_(0, sw, xx);
                yy = An.clamp_(0, sh, yy);
                switch (handle.index) {
                    case 0:
                        this._current.topLeftX = xx / sw;
                        this._current.topLeftY = yy / sh;
                        break;
                    case 1:
                        this._current.topRightX = xx / sw;
                        this._current.topRightY = yy / sh;
                        break;
                    case 2:
                        this._current.bottomRightX = xx / sw;
                        this._current.bottomRightY = yy / sh;
                        break;
                    case 3:
                        this._current.bottomLeftX = xx / sw;
                        this._current.bottomLeftY = yy / sh;
                        break;
                    default:
                        this._scrollTo(handle, sx, sy, selecting);
                        return;
                }
                
                this._drawOverlay(selecting, true);
                this._fireOnChange();
            });
        }

        private _fireOnChange(): void {
            if (this._onChangeCallback != null) {
                this._onChangeCallback(Quad.from(this._current), new Point(this._origin.x, this._origin.y), this._zoom);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////

    export abstract class PromptXYBase extends FixedSizeDialogBase {
        private readonly defaultTitleCallback = (x: number, y: number) => {
            return `${Math.round(x * 100)}, ${Math.round(y * 100)}`;
        };
        private _resetCallback: Fun01<[number, number]> | null = null;
        private _titleCallback: Fun21<number, number, string> = this.defaultTitleCallback;
        private _picker!: GradientPicker;
        protected _content!: HTMLElement;

        constructor(
            container: HTMLElement,
            buttonsize: number,
            private _canvasSize: number,
            private _labelX: string,
            private _labelY: string,
            protected _x: number,
            protected _y: number,
            private _snapper: ISnapper<number>
        ) {
            super(container, buttonsize);
            super.init_(this.create_(container));
            this._toolbar!.showButton_(BUT.Reset, false);
        }

        protected abstract actionOK_(): void;

        protected create_(container: HTMLElement): HTMLElement {
            return this._createDialogWithoutMessageStatus(
                container,
                (content) => this._createContent(content),
                BUT.infos_(BUT.Reset, BUT.OK, BUT.Cancel),
                (action) => this._toolbarActions(action)
            );
        }

        protected _createContent(content: HTMLElement): void {
            const x1 = this.buttonSize$ * 3 / 4;
            const size = this._canvasSize;
            this._picker = new GradientPicker(this.container_(), size, size, this._x, this._y, Conf.useTouch$, this._snapper, (x: number, y: number) => {
                
                this._x = x;
                this._y = y;
                if (this._titleCallback != null) {
                    this._toolbar!.titleText_(this._titleCallback(x, y));
                }
            });
            const b = new DomBuilderEx(content);
            this._content = b.div_({
                "style": "display: flex;flex-flow: column nowrap;",
            }).cursor_();
            b.push_().div_({
                "style": "width: 100%;height: 0px;border-bottom: 1px solid #aaa;margin: 0 0 10px 0;"
            });
            b.peek_().div_({
                "style": "display: flex;flex-flow: row nowrap;",
            }).indent_(
                b.push_().div_({
                    "style": `width: ${x1}px;height: ${size}px;position: relative;`,
                }).div_({
                    "style": `position: absolute;top: 0;left: 0;width: ${size}px;height: ${x1}px;`
                        + "display: flex;align-items: center;justify-content: center;font-size: 90%;"
                        + `transform: translateY(${size}px) rotate(-90deg);transform-origin: 0 0;`,
                }).text_(this._labelY),
                b.pop_().div_({
                    "style": `width: ${size}px;height: ${size}px;outline:1px solid #aaa;`,
                }).appendNodes_(this._picker.canvas$),
            );
            b.pop_().div_({
                "style": "display: flex;flex-flow: row nowrap;",
            }).indent_(
                b.push_().div_({
                    "style": `width: ${x1}px;height: ${x1}px;`
                }),
                b.pop_().div_({
                    "style": `width: ${size}px;height: ${x1}px;`
                        + "display: flex;align-items: center;justify-content: center;font-size: 90%;",
                }).text_(this._labelX),
            );
        }

        close_() {
            this._resetCallback = null;
            this._titleCallback = this.defaultTitleCallback;
            super.close_();
        }

        getContentWidth_(): number {
            return this.buttonSize$ + this._canvasSize;
        }

        onReset(callback: Fun01<[number, number]>): void {
            this._resetCallback = callback;
            this._toolbar!.showButton_(BUT.Reset, callback != null);
        }

        onTitle(callback: Fun21<number, number, string>): void {
            this._titleCallback = callback;
            if (this._titleCallback != null) {
                this._toolbar!.titleText_(this._titleCallback(this._x, this._y));
            }
        }

        private _toolbarActions(action: string): void {
            this.clearStatus_();
            switch (action) {
                case BUT.Reset: {
                    if (this._resetCallback != null) {
                        const ret = this._resetCallback();
                        this._picker.setValue(ret[0], ret[1]);
                    }
                    break;
                }
                case BUT.OK:
                    this.actionOK_();
                    break;
                case BUT.Cancel:
                    this.actionCancel_();
                    break;
                default:
                    this.actionInvalid_(action);
            }
        }
    }

    export class PromptXY extends PromptXYBase {
        private _okCallback: Fun20<number, number> | null = null;
        constructor(
            container: HTMLElement,
            buttonsize: number,
            canvasSize: number,
            labelX: string,
            labelY: string,
            x: number,
            y: number,
            snapper: ISnapper<number>
        ) {
            super(container, buttonsize, canvasSize, labelX, labelY, x, y, snapper);
        }
        onOK_(callback: Fun20<number, number>): this {
            this._okCallback = callback;
            return this;
        }
        close_() {
            this._okCallback = null;
            super.close_();
        }
        protected actionOK_() {
            const callback = this._okCallback!;
            this.close_();
            callback(this._x, this._y);
        }
    }

    ////////////////////////////////////////////////////////////////////////

    export class PromptRect extends FullscreenDialogBase {

        static readonly _MARGIN = 5;

        _original: MutRect;
        _viewport!: HTMLElement;
        _image!: HTMLImageElement;
        _viewportSize: Point<number>;
        _current: MutRect;
        _origin: Point<number> = new Point(0.0, 0.0);
        _picker: ShapePicker$.RectPicker | null = null;
        _okCallback: Fun10<MutRect> | null = null;

        constructor(
            container: HTMLElement,
            gesturehandler: IGestureHandler | null,
            private _buttonSize: number,
            zindex: number,
            private _zoom: number,
            private _imageSize: Point<number>,
            rect: number[],
            private _dataurl: string
        ) {
            super(container, gesturehandler);
            this._original = PromptRect._rectFromList(rect);
            this._current = PromptRect._rectFromList(rect);
            this._viewportSize = new Point(window.innerWidth, window.innerHeight - _buttonSize - _buttonSize / 2 - 1);
            super.init_(this.create_(container));
            this.zindex_(zindex);
        }

        protected create_(container: HTMLElement): HTMLElement {
            return this.createFullscreenDialog_(
                container,
                (b) => this._createFullscreenToolbar(b),
                (b) => this._createFullscreenContent(b));
        }

        private _createFullscreenToolbar(b: DomBuilderEx): Toolbar {
            const toolbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, RS.PickRectTitle, BUT.infos_(BUT.Reset, BUT.OK, BUT.Cancel));
            toolbar.onAction_((action) => this._toolbarActions(action));
            return toolbar;
        }

        private _createFullscreenContent(b: DomBuilderEx): void {
            this._viewport = b.div_().div_({
                "class": CSS.AnFullscreenViewport,
                "style": `height: calc(100vh - ${this._buttonSize + this._buttonSize / 2 + 1}px);`,
            }).cursor_();
            b.img_({ "background-color": "rgba(255, 255, 255, 1.0)" });
            this._image = b.cursor_() as HTMLImageElement;
        }

        static _rectFromList(rect: number[]): MutRect {
            return new MutRect(rect[0], 1.0 - (rect[1] + rect[3]), rect[2], rect[3]).clampSize_(0.0, 1.0);
        }

        close_() {
            this._okCallback = null;
            super.close_();
        }

        /// @param callback(value)
        onOK_(callback: Fun10<MutRect>): this {
            this._okCallback = callback;
            return this;
        }

        private _toolbarActions(action: string): void {
            this.clearStatus_();
            switch (action) {
                case BUT.Reset:
                    this._picker?.reset_();
                    break;
                case BUT.OK:
                    const callback = this._okCallback!;
                    this.close_();
                    callback(new MutRect(this._current.x, this._current.y, this._current.w, this._current.h)
                        .scaledBy_(this._imageSize.x, this._imageSize.y)
                        .rounded_());
                    break;
                case BUT.Cancel:
                    this.actionCancel_();
                    break;
                default:
                    this.actionInvalid_(action);
            }
        }

        showFullscreen_(): void {
            this._image.src = this._dataurl;
            An.onLoad_(this._image, () => {
                this.onResize_();
                An.setVisible_(this._dialog);
            });
            An.onError_(this._image, () => {
                toasters$.error_(MSG.string_(RS.ImageReadFailed));
                this.actionCancelConfirmed_();
            });
        }

        onResize_(): void {
            this._viewportSize = new Point(window.innerWidth, window.innerHeight - this._buttonSize - this._buttonSize / 2 - 1);
            new DomBuilderEx(this._viewport).empty_();
            this._picker = new ShapePicker$.RectPicker(
                this._viewport,
                this._buttonSize,
                this._viewportSize,
                this._imageSize,
                this._origin,
                this._image,
                this._zoom,
                PromptRect._MARGIN,
                Conf.pointerstart$ == "touchstart",
                new DumbSnapper(),
                this._original,
                (rect, scroll, zoom) => {
                    this._onchange(rect, scroll, zoom);
                });
        }

        private _onchange(rect: MutRect, scroll: Point<number>, zoom: number): void {
            this._current.setRect_(rect).clampSize_(0.0, 1.0);
            this._origin = scroll;
            this._zoom = zoom;
            this.toolbar$?.titleText_(`${this._current.scaledBy_(this._imageSize.x, this._imageSize.y).rounded_()}`);
        }
    }

    ////////////////////////////////////////////////////////////////////////

    export class PromptQuad extends FullscreenDialogBase {
        static readonly _MARGIN = 5;

        _viewport!: HTMLElement;
        _image!: HTMLImageElement;

        _viewportSize: Point<number>;
        _origin: Point<number> = new Point(0.0, 0.0);
        _original: Quad;
        _current: Quad;
        _picker: QuadPicker | null = null;
        _okCallback: Fun20<boolean, Quad> | null = null;

        constructor(
            container: HTMLElement,
            gesturehandler: IGestureHandler,
            private _buttonSize: number,
            zindex: number,
            private _zoom: number,
            private _imageSize: Point<number>,
            quad: number[],
            private _dataurl: string,
        ) {
            super(container, gesturehandler);
            this._original = PromptQuad._fromList(quad);
            this._current = PromptQuad._fromList(quad);
            this._viewportSize = new Point(window.innerWidth, window.innerHeight - _buttonSize - _buttonSize / 2 - 1);
            super.init_(this.create_(container));
            this.zindex_(zindex);
        }

        protected create_(container: HTMLElement): HTMLElement {
            return this.createFullscreenDialog_(
                container,
                (b) => this._createFullscreenToolbar(b),
                (b) => this._createFullscreenContent(b));
        }

        private _createFullscreenToolbar(b: DomBuilderEx): Toolbar {
            const toolbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, null, BUT.infos_(BUT.Reset, BUT.Crop, BUT.OK, BUT.Cancel));
            toolbar.onAction_((action) => this._toolbarActions(action));
            return toolbar;
        }

        private _createFullscreenContent(b: DomBuilderEx): void {
            this._viewport = b.div_().div_({
                "class": CSS.AnFullscreenViewport,
                "style": `height: calc(100vh - ${this._buttonSize + this._buttonSize / 2 + 1}px);`,
            }).cursor_() as HTMLElement;
        }

        close_() {
            this._okCallback = null;
            super.close_();
        }

        static _fromList(quad: number[]): Quad {
            return new Quad(
                An.clamp_(0.0, 1.0, quad[0]),
                An.clamp_(0.0, 1.0, 1.0 - quad[1]),
                An.clamp_(0.0, 1.0, quad[2]),
                An.clamp_(0.0, 1.0, 1.0 - quad[3]),
                An.clamp_(0.0, 1.0, quad[4]),
                An.clamp_(0.0, 1.0, 1.0 - quad[5]),
                An.clamp_(0.0, 1.0, quad[6]),
                An.clamp_(0.0, 1.0, 1.0 - quad[7]));
        }

        /// @param callback(value)
        onOK_(callback: Fun20<boolean, Quad>): this {
            this._okCallback = callback;
            return this;
        }

        private _toolbarActions(action: string): void {
            this.clearStatus_();
            switch (action) {
                case BUT.Reset:
                    this._picker?.reset_();
                    break;
                case BUT.Crop: {
                    const callback = this._okCallback!;
                    this.close_();
                    callback(true, this._current);
                    break;
                }
                case BUT.OK: {
                    const callback = this._okCallback!;
                    this.close_();
                    callback(false, this._current);
                    break;
                }
                case BUT.Cancel:
                    this.actionCancel_();
                    break;
                default:
                    this.actionInvalid_(action);
            }
        }

        showFullscreen_(): void {
            this._image = new HTMLImageElement();
            this._image.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
            this._image.src = this._dataurl;
            An.onLoad_(this._image, () => {
                this.onResize_();
                An.setVisible_(this._dialog);
            });
            An.onError_(this._image, () => {
                toasters$.error_(MSG.string_(RS.ImageReadFailed));
                this.actionCancelConfirmed_();
            });
        }

        onResize_(): void {
            if (this._viewport == null) return;
            this._viewportSize = new Point(window.innerWidth, window.innerHeight - this._buttonSize - this._buttonSize / 2 - 1);
            new DomBuilderEx(this._viewport).empty_();
            this._picker = new QuadPicker(
                this._viewport,
                this._buttonSize,
                this._viewportSize,
                this._imageSize,
                this._origin,
                this._image,
                this._zoom,
                PromptQuad._MARGIN,
                Conf.pointerstart$ == "touchstart",
                new DumbSnapper(),
                this._original,
                this._onchange);
        }

        _onchange(quad: Quad, origin: Point<number>, zoom: number): void {
            this._current = quad;
            this._origin = origin;
            this._zoom = zoom;
        }
    }
}

////////////////////////////////////////////////////////////////////////

/**
 * Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
 * for details. All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE file.
 */

/// When compiled to JS, forward slashes are always escaped in [RegExp.pattern].
/// See issue 17998.
const _slashAutoEscape = new RegExp(FS).source == "\\/";

/// A class that scans through a string using [RegExp]s.
class StringScanner {
    /// The current position of the scanner in the string, in characters.
    #position = 0;
    get position$(): number { return this.#position; }
    set position$(position: number) {
        if (position < 0 || position > this.source.length) {
            throw new Error(`Invalid position ${position}`);
        }
        this.#position = position;
    }

    /// The data about the previous match made by the scanner.
    /// If the last match failed, this will be `null`.
    #lastMatch: RegExpExecArray | null = null;
    get lastMatch$(): RegExpExecArray | null { return this.#lastMatch; }

    /// The portion of the string that hasn't yet been scanned.
    get rest$(): string { return this.source.substring(this.position$); }

    /// Whether the scanner has completely consumed [string].
    get isDone$(): boolean { return this.position$ == this.source.length; }

    /// Creates a new [StringScanner] that starts scanning from [position].
    ///
    /// [position] defaults to 0, the beginning of the string. [sourceUrl] is the
    /// URL of the source of the string being scanned, if available. It can be
    /// a [String], a [Uri], or `null`.
    constructor(
        protected source: string,
        position: number = 0
    ) {
        this.#position = position;
    }

    /// Consumes a single character and returns its character code.
    ///
    /// This throws a [FormatException] if the string has been fully consumed. It
    /// doesn't affect [lastMatch].
    readChar_(): number {
        if (this.isDone$) this.fail_("No more input");
        let ret = this.source.codePointAt(this.#position++);
        if (ret === undefined) throw new Error("Invalid source");
        return ret;
    }

    /// Returns the character code of the character [offset] away from [position].
    ///
    /// [offset] defaults to zero, and may be negative to inspect already-consumed
    /// characters.
    ///
    /// This returns `null` if [offset] points outside the string. It doesn't
    /// affect [lastMatch].
    peekChar_(offset: number): number | null {
        if (offset == null) offset = 0;
        const index = this.position$ + offset;
        if (index < 0 || index >= this.source.length) return null;
        return this.source.codePointAt(index) ?? null;
    }

    /// If [pattern] matches at the current position of the string, scans forward
    /// until the end of the match.
    ///
    /// Returns whether or not [pattern] matched.
    scan_(pattern: RegExp): boolean {
        const success = this.matches_(pattern);
        if (success) {
            let m = this.#lastMatch!;
            this.#position += m.index! + m[0].length;
        }
        return success;
    }

    /// If [pattern] matches at the current position of the string, scans forward
    /// until the end of the match.
    ///
    /// If [pattern] did not match, throws a [FormatException] describing the
    /// position of the failure. [name] is used in this error as the expected name
    /// of the pattern being matched; if it's `null`, the pattern itself is used
    /// instead.
    expect_(pattern: RegExp, name: string): void {
        if (this.scan_(pattern)) return;
        if (name == null) {
            let source = pattern.source;
            if (!_slashAutoEscape) source = replaceAll_(source, FS, "\\/");
            name = `/${source}/`;
        }
        this.fail_(name);
    }

    /// If the string has not been fully consumed, this throws a
    /// [FormatException].
    expectDone_(): void {
        if (this.isDone$) return;
        this.fail_("no more input");
    }

    /// Returns whether or not [pattern] matches at the current position of the
    /// string.
    ///
    /// This doesn't move the scan pointer forward.
    matches_(pattern: RegExp): boolean {
        this.#lastMatch = pattern.exec(this.source.slice(this.#position));
        return this.#lastMatch != null;
    }

    /// Returns the substring of [string] between [start] and [end].
    ///
    /// Unlike [String.substring], [end] defaults to [position] rather than the
    /// end of the string.
    substring_(start: number, end: number): string {
        if (end == null) end = this.position$;
        return this.source.substring(start, end);
    }

    /// Throws a [FormatException] with [message] as well as a detailed
    /// description of the location of the error in the string.
    ///
    /// [match] is the match information for the span of the string with which the
    /// error is associated. This should be a match returned by this scanner's
    /// [lastMatch] property. By default, the error is associated with the last
    /// match.
    ///
    /// If [position] and/or [length] are passed, they are used as the error span
    /// instead. If only [length] is passed, [position] defaults to the current
    /// position; if only [position] is passed, [length] defaults to 1.
    ///
    /// It's an error to pass [match] at the same time as [position] or [length].
    error_(message: string, match: RegExpExecArray | null = null, position: number | null = null, length: number | null = null): void {
        if (match == null && position == null && length == null) match = this.lastMatch$;
        if (position == null) {
            position = match == null ? this.position$ : match.index;
        }
        if (length == null) length = match == null ? 1 : match[0].length;
        throw new Error(`${message}: offset=${position}, length=${length}`);
    }

    /// Throws a [FormatException] describing that [name] is expected at the
    /// current position in the string.
    fail_(name: string): void {
        this.error_(`expected ${name}.`, null, this.position$, 0);
    }
}

abstract class ISnapper<T> {
    abstract snap(x: T, y: T, callback: (x: T, y: T) => void): void;
}

////////////////////////////////////////////////////////////////////////

class ImageViewerDialog extends FullscreenDialogBase {
    private _imageviewer!: ImageViewerBase;
    private _uri: UriX;
    private _onImageInfo: Fun00X = null;
    private _okCallback: Fun00 | null = null;
    #destroyed = false;

    constructor(
        container: HTMLElement,
        gesturehandler: IGestureHandler | null,
        zindex: Int,
        private _url: string,
        private _srcs: Uri[] = [],
        private _initial: Int = -1,
        private _width: Int = 0,
        private _height: Int = 0,
        private _rotation: Int = 0,
        private _effect: Int = Effect.NONE,
        private _adjust: Double = 0.0,
        private _quality: Int = DEF.jpegQualityHigh,
    ) {
        super(container, gesturehandler);
        this._uri = An.parseUriSafe_(this._url, native$.getIFrameUri_())?.toAbsolute_() ?? null;
        super.init_(this.create_(container/*, zoom */));
        this.zindex_(zindex);
        this.onImageInfo_(() => {
            if (this._uri != null && !this._uri.isDataUrl$) {
                Callbacks.showImageInfo_(this._uri.path$);
            } else {
                toasters$.warnKey_(RS.NoImageInfoAvailable);
            }
        });
    }

    protected create_(
        container: HTMLElement,
    ): HTMLElement {
        return this.createFullscreenDialog_(
            container,
            (b) => this._createToolbar(b),
            (b) => this._createContent(b /* , zoom */),
        );
    }

    private _createToolbar(b: DomBuilderEx): Toolbar {
        const toolbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, null, BUT.infos_(
            BUT.Contextmenu,
            BUT.RotateImage,
            BUT.PrevMedia,
            BUT.NextMedia,
            BUT.Info,
            BUT.OK,
            BUT.Cancel,
        ));
        toolbar.onAction_((action) => this._toolbarActions(action));
        toolbar!.showButton_(BUT.Info, false);
        toolbar!.showButton_(BUT.OK, false);
        if (this._srcs.length < 2 || this._initial < 0) {
            toolbar!.showButton_(BUT.PrevMedia, false);
            toolbar!.showButton_(BUT.NextMedia, false);
        } else {
            if (this._initial == 0) toolbar.enableButton_(BUT.PrevMedia, false);
            if (this._initial == this._srcs.length - 1) toolbar.enableButton_(BUT.NextMedia, false);
        }
        return toolbar;
    }

    private _createContent(b: DomBuilderEx /* , zoom: DoubleX = null */) {
        b.div1_(CSS.AnFullscreenViewport).div_({ "style": "position:relative;" });
        b.div_().img1_(null, CSS.AnImageViewer);
    }

    showOnlyButtons(buttons: string[]): this {
        for (const but of this._toolbar!!.getButtons_(map_()).keys()) {
            if (!buttons.includes(but)) this._toolbar?.showButton_(but, false);
        }
        return this;
    }

    protected showFullscreen_(): void {
        const image = this._dialog.querySelector<HTMLImageElement>(`img.${CSS.AnImageViewer}`)!;
        An.onLoad_(image, () => {
            const viewer = image.parentElement!.parentElement!;
            this._imageviewer = new ImageViewerBase(viewer.parentElement!, viewer, image /*, zoom */, (handler) => {
                new PinchZoomListener(this._dialog, Conf.pointerstart$ == "touchstart", handler);
            });
            this._imageviewer.resize1_();
            this._imageviewer.show_();
        });
        An.onError_(image, () => {
            this.actionCancel_();
            toasters$.warnKey_(RS.ImageNotFound);
        });
        const uri = this._uri;
        if (uri == null) {
            image.src = "";
        } else {
            host$.previewImage_(
                uri.encoded$,
                this._width,
                this._height,
                this._rotation,
                this._effect,
                this._adjust,
                this._quality,
                (ret) => {
                    if (toasters$.warn_(ret)) {
                        image.src = "";
                        this.close_();
                        return;
                    }
                    image.src = ret[Key.result];
                });
        }
        An.showVisible_(this._dialog, "block");
    }

    close_(): void {
        if (this.#destroyed) { return; }
        this.#destroyed = true;
        this._imageviewer?.destroy_();
        this._okCallback = null;
        this._onImageInfo = null;
        super.close_();
    }

    onResize_(): void {
        this._imageviewer.resize_();
    }

    onOK_(callback: Fun00): this {
        this._okCallback = callback;
        this._toolbar!.showButton_(BUT.OK, callback != null);
        return this;
    }

    onImageInfo_(callback: Fun00X): this {
        this._onImageInfo = callback;
        const toolbar = this._toolbar!;
        if (!toolbar.hasButton_(BUT.Contextmenu)) {
            toolbar.showButtonIfExists_(BUT.Info, callback != null);
        }
        return this;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Contextmenu:
                const p = An.documentOffset_(this._toolbar!.button_(BUT.Contextmenu));
                this._showContextmenu(p.x, cache$.ui$.toolbarHeight_(), (action) => this._contextActions(action));
                break;
            case BUT.RotateImage:
                this._actionRotate();
                break;
            case BUT.Info:
                this._onImageInfo?.();
                break;
            case BUT.PrevMedia:
                this._show(this._initial - 1);
                break;
            case BUT.NextMedia:
                this._show(this._initial + 1);
                break;
            case BUT.Cancel:
                this.actionCancel_();
                break;
            case BUT.OK: {
                const callback = this._okCallback!;
                this.close_();
                callback();
                break;
            }
            default:
                this.actionInvalid_(action);
        }
    }

    private _show(index: Int) {
        if (this._srcs.length < 2 || this._initial < 0 || index < 0 || index >= this._srcs.length) return;
        const uri = this._srcs[index];
        if (!uri) return;
        fileinfoUt$.fileInfo_(uri.toAbsolute_().path$, (ret) => {
            if (toasters$.warn_(ret)) return;
            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
            if (fileinfo == null || !fileinfo.exists$) {
                toasters$.warn_(MSG.string1_(RS.ImageNotFound_, Basepath.filename_(uri.path$)));
                return;
            }
            this.close_();
            new ImageViewerDialog(this._container, this._gestureHandler, this._zindex, uri.encoded$, this._srcs, index)
                .titleKey_(RS.Image)
                .show_();
        });
    }

    private _contextActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case _ImageContextmenu._IMAGE_EXPORT:
                this._imageviewer.export_(this._uri, An.noop_);
                break;
            case _ImageContextmenu._IMAGE_MOVE:
                this._imageviewer.move_(An.above_(this.element_()), () => {
                    this.close_();
                });
                break;
            case _ImageContextmenu._IMAGE_INFO:
                this._onImageInfo?.();
                break;
            case _ImageContextmenu._ANNOTATE_IMAGE:
                const img = this._imageviewer.image_();
                const baseuri = native$.getIFrameUri_();
                if (baseuri != null) {
                    this.close_();
                    _MainPanel.actionAnnotateImg_(img, baseuri, An.noop_);
                }
                break;
            case _ImageContextmenu._SCAN_BARCODE:
                this._actionScanBarcode();
                break;
            case _ImageContextmenu._SCREENSHOT:
                _Util.actionScreenshot_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _showContextmenu(x: number, y: number, handler: Fun10<string>): void {
        const menu = new _ImageContextmenu(accessories$, [
            [
                _ImageContextmenu._IMAGE_EXPORT,
                _ImageContextmenu._IMAGE_INFO,
            ],
            [
                _ImageContextmenu._ANNOTATE_IMAGE,
                _ImageContextmenu._IMAGE_MOVE,
            ],
            [
                _ImageContextmenu._SCAN_BARCODE,
                _ImageContextmenu._SCREENSHOT,
            ],
        ]);
        menu
            .above_(this.element_())
            .onAction_(action => {
                toasters$.hideAll_();
                menu.destroy_();
                handler(action);
            }).onCancel_(() => {
                menu.destroy_();
            }).onContextmenu_(toasters$.onTooltipsKey_)
            .show_(x, y, false, true);
    }

    private _actionScanBarcode(): void {
        const [r, rotation, zoom] = this._imageviewer.getVisibleRegion_();
        const uri = An.parseUriSafe_(this._url, native$.getIFrameUri_());
        if (uri == null) return;
        host$.scanBarcode_(uri.toAbsolute_().path$, "", new CropInfo(
            Math.round(r.x),
            Math.round(r.y),
            Math.round(r.w),
            Math.round(r.h),
            zoom,
            rotation,
        ), (ret) => {
            toasters$.warn_(ret);
            const text = ret[Key.result];
            if (text != null) {
                clipboard$.string_(text);
                toasters$.ok_([MSG.string_(RS.CopiedToLocalClipboard_), text], { attop: true, hold: true });
            }
        });
    }

    private _actionRotate(): void {
        this._imageviewer.rotate_();
    }
}

////////////////////////////////////////////////////////////////////////

type ImageAnnotatorCallback = (canvas: HTMLCanvasElement, history: ScribblerHistory, ok: BoolCallback) => void;

class ScribblerContextActions {
    static readonly BG: string = ScribblerAction.BG;
    static readonly CURVE: string = ScribblerAction.CURVE;
    static readonly ELLIPSE: string = ScribblerAction.ELLIPSE;
    static readonly EMBEDED_IMAGE: string = ScribblerAction.EMBEDED_IMAGE;
    static readonly IMAGE: string = ScribblerAction.IMAGE;
    static readonly POLYCURVE: string = ScribblerAction.POLYCURVE;
    static readonly POLYGON: string = ScribblerAction.POLYGON;
    static readonly RECTANGLE: string = ScribblerAction.RECTANGLE;
    static readonly TEXT: string = ScribblerAction.TEXT;
    static readonly export: string = ScribblerAction.export;
    static readonly history: string = ScribblerAction.history;
    static readonly more: string = ScribblerAction.more;
    static readonly shift: string = ScribblerAction.shift;

    static readonly LINE_STYLE = "XxXoO";
    static readonly STROKE_COLOR = "XxXfi";
    static readonly FONT_NAME = "XxXZY";
    static readonly TEXT_COLOR = "XxXts";
    static readonly resize = "XxXUu";
    static readonly LINE_HEIGHT = "XxX0C";
    static readonly fit = "XxXOh";
    static readonly TEXTING = "XxXOl";
    static readonly STROKE = "XxXOC";
    static readonly FONT_SIZE = "XxX9a";
    static readonly FILL_COLOR = "XxXpa";
    static readonly clear = "XxXHV";
    static readonly FILL = "XxXON";
    static readonly FONT_CAT = "XxXcu";
    static readonly LINE_WIDTH = "XxXWK";
    static readonly FONT_STYLE = "XxXgx";
    static readonly CORNER_RADIUS = "XxXGC";
    static readonly GRID = "XxXgp";
    static readonly TEXT_ALIGN = "XxX4A";
    static readonly CORNERING = "XxX9z";
    static readonly FONT_SAMPLE = "XxXWx";
}

class ScribblerContextmenu extends PopupBase {
    private _fontSizes!: number[];
    private _inputGrid!: SelectOptions;
    private _inputLineheight!: SelectOptions;
    private _inputFontcat!: SelectOptions;
    private _inputFontname!: SelectOptions;
    private _inputFontstyle!: SelectOptions;
    private _inputFontsize!: SelectOptions;
    private _inputAlignment!: SelectOptions;
    private _inputLinestyle!: SelectOptions;
    private _inputLinewidth!: SelectOptions;
    private _inputCornering!: SelectOptions;
    private _inputCorner!: SelectOptions;
    private _inputFontsample!: HTMLElement;
    private _inputTexting!: HTMLElement;
    private _inputTextcolor!: HTMLElement;
    private _inputFill!: HTMLElement;
    private _inputFillcolor!: HTMLElement;
    private _inputStroke!: HTMLElement;
    private _inputStrokecolor!: HTMLElement;

    _tooltipsCallback: TargetEventCallback | null = null;
    private _promptColorCallback: PromptColorCallback | null = null;

    private _buttons = new Map<string, HTMLElement>();
    private _submenus = new Map<string, HTMLElement>();
    #destroyed = false;

    constructor(
        private _container: HTMLElement,
        private _buttonSize: number,
        private _settings: Settings,
        private _scribbler: Scribbler
    ) {
        super();
        const menu = this.createContextmenu_(_container);
        const sm = this.createSmokescreen_(_container, An.zindexOf_(menu, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
        this.init_(menu, sm);
        this.setupHandlers_(menu, `td[${ATTR.AnAction}]`, `td[${ATTR.xTooltips}]`);
        this._getButtonForAction(_scribbler.getAction_()).classList.add(CSS.AnSelected);
        this._updateContextmenuState();
        this.onDrag_((_dragger: Dragger, target: EventTarget, _pagex: number, _pagey: number) => {
            const elm = DomUt.asHTMLElement_(target);
            const ok = elm != null &&
                (elm.nodeName == "TABLE" || elm.nodeName == "DIV") &&
                elm.classList.contains(CSS.AnContextmenu);
            return ok;
        });
        this.onShow_(() => {
            if (this._submenus.get(ScribblerContextActions.more)!.style.display != "none") {
                this._updateContextmenuState();
            }
        });
    }

    destroy_(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this._scribbler?.destroy_();
        this._contextmenu?.remove();
        this._smokescreen?.destroy_();
        this._tooltipsCallback = null;
        this._promptColorCallback = null;
        super.destroy_();
    }

    getButton_(action: string): HTMLElementX {
        return this._buttons.get(action) ?? null;
    }

    onTooltips_(callback: TargetEventCallback): this {
        this._tooltipsCallback = callback;
        return this;
    }

    onPromptColor_(callback: PromptColorCallback | null): void {
        this._promptColorCallback = callback;
    }

    private _selectoptions(elm: HTMLElement): SelectOptions {
        return new SelectOptions(accessories$, elm as HTMLElement);
    }

    createContextmenu_(container: HTMLElement): HTMLElement {
        const b = new DomBuilderEx(container).push_();
        const ret = b.div_({
            "class": CSS.AnContextmenu,
            "style": "display: none;",
        }).cursor_();
        b.table1_(CSS.AnContextmenu).push_();
        this._createbuttons(this._buttons, b, [
            [
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.more],
                    [ATTR.xTooltips, RS.Tooltips_CanvasActions],
                    ["class", `${CSS.Fa} ${CSS.FaGear}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.export],
                    [ATTR.xTooltips, RS.Tooltips_ExportAsImage],
                    ["class", `${CSS.Fa} ${CSS.FaExternalLink}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.history],
                    [ATTR.xTooltips, RS.Tooltips_EditDrawingHistory],
                    ["class", `${CSS.Fa} ${CSS.FaHistory}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.BG],
                    [ATTR.xTooltips, RS.Tooltips_SetBackgroundColor],
                    ["class", `${CSS.Fa} ${CSS.FaSpinner}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.IMAGE],
                    [ATTR.xTooltips, RS.Tooltips_ImportImageFile],
                    ["class", `${CSS.Fa} ${CSS.FaFileImageO}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.EMBEDED_IMAGE],
                    [ATTR.xTooltips, RS.Tooltips_EmbedImage],
                    ["class", `${CSS.Fa} ${CSS.FaImage}`],
                ),
            ],
            [
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.CURVE],
                    [ATTR.xTooltips, RS.Tooltips_DrawFreehandCurves],
                    ["class", `${CSS.Fa} ${CSS.FaHandOUp}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.POLYCURVE],
                    [ATTR.xTooltips, RS.Tooltips_DrawCurves],
                    ["class", `${CSS.Fa} ${CSS.FaHeartO}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.POLYGON],
                    [ATTR.xTooltips, RS.Tooltips_DrawPolylineOrPolygons],
                    ["class", `${CSS.Fa} ${CSS.FaStarO}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.TEXT],
                    [ATTR.xTooltips, RS.Tooltips_DrawText],
                    ["class", `${CSS.Fa} ${CSS.FaTumblr}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.RECTANGLE],
                    [ATTR.xTooltips, RS.Tooltips_DrawRectangles],
                    ["class", `${CSS.Fa} ${CSS.FaSquareO}`],
                ),
                smap_(
                    [ATTR.AnAction, ScribblerContextActions.ELLIPSE],
                    [ATTR.xTooltips, RS.Tooltips_DrawEllipses],
                    ["class", `${CSS.Fa} ${CSS.FaCircleThin}`],
                ),
            ],
        ]);
        this._submenus.set(ScribblerContextActions.GRID, this._menurow(b));
        b.push_().div1_(CSS.AnInput4).text_(MSG.string_(RS.Grid));
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputGrid = this._selectoptions(b.cursor_());
        this._inputGrid.setOptions_(An.createStringList1_([
            [1, 20, 1],
            [20, 50, 5],
            [50, 101, 10]
        ]));
        this._submenus.set(ScribblerContextActions.LINE_HEIGHT, this._menurow(b));
        b.push_().div1_(CSS.AnInput4).text_(MSG.string_(RS.LineHeight));
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputLineheight = this._selectoptions(b.cursor_());
        this._inputLineheight.setOptions_([
            "0.80",
            "0.85",
            "0.9",
            "0.95",
            "1.00",
            "1.05",
            "1.10",
            "1.15",
            "1.20",
            "1.25",
            "1.30",
            "1.35",
            "1.40",
            "1.45",
            "1.50",
            "1.55",
        ]);
        this._submenus.set(ScribblerContextActions.TEXT_ALIGN, this._menurow(b));
        b.push_().div1_(CSS.AnInput4).text_(MSG.string_(RS.Alignment));
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputAlignment = this._selectoptions(b.cursor_());
        this._inputAlignment.setOptions_([
            MSG.string_(RS.Left),
            MSG.string_(RS.Center),
            MSG.string_(RS.Right)
        ]);
        this._submenus.set(ScribblerContextActions.TEXT_COLOR, this._menurow(b));
        this._inputTexting = b.div1_(CSS.AnInputButton, CSS.Fa, CSS.FaCheck).cursor_();
        const textcolorlabel = b.up_().div1_(CSS.AnInput4).text_(MSG.string_(RS.TextColor)).cursor_();
        this._inputTextcolor = b.up_().div1_(CSS.AnColorCell).cursor_();
        this._submenus.set(ScribblerContextActions.FILL_COLOR, this._menurow(b));
        this._inputFill = b.div1_(CSS.AnInputButton, CSS.Fa, CSS.FaCheck).cursor_();
        const fillcolorlabel = b.up_().div1_(CSS.AnInput4).text_(MSG.string_(RS.FillColor)).cursor_();
        this._inputFillcolor = b.up_().div1_(CSS.AnColorCell).cursor_();
        this._submenus.set(ScribblerContextActions.STROKE_COLOR, this._menurow(b));
        this._inputStroke = b.div1_(CSS.AnInputButton, CSS.Fa, CSS.FaCheck).cursor_();
        const strokecolorlabel = b.up_().div1_(CSS.AnInput4).text_(MSG.string_(RS.StrokeColor)).cursor_();
        this._inputStrokecolor = b.up_().div1_(CSS.AnColorCell).cursor_();
        this._submenus.set(ScribblerContextActions.LINE_STYLE, this._menurow(b));
        b.push_().div1_(CSS.AnMenuSelect, CSS.AnWidth4);
        this._inputLinestyle = this._selectoptions(b.cursor_());
        this._inputLinestyle.setOptions_([
            ScribblerLineStyle.SOLID,
            ScribblerLineStyle.DASH,
            ScribblerLineStyle.DOTTED
        ]);
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputLinewidth = this._selectoptions(b.cursor_());
        this._inputLinewidth.setOptions_(An.createStringList_([
            "1"
        ], [
            [2, 10, 1],
            [10, 20, 2],
            [20, 50, 5],
            [50, 100, 10],
            [100, 200, 25],
            [200, 300, 50],
            [300, 501, 100],
        ]));
        this._submenus.set(ScribblerContextActions.CORNERING, this._menurow(b));
        b.push_().div1_(CSS.AnInput4).text_(MSG.string_(RS.Cornering));
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputCornering = this._selectoptions(b.cursor_());
        this._inputCornering.setOptions_(An.createStringList1_([
            [0, 101, 5]
        ]));
        this._submenus.set(ScribblerContextActions.CORNER_RADIUS, this._menurow(b));
        b.push_().div1_(CSS.AnInput4).text_(MSG.string_(RS.Corner));
        b.pop_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._inputCorner = this._selectoptions(b.cursor_());
        this._inputCorner.setOptions_(An.createStringList1_([
            [0, 10, 1],
            [10, 20, 2],
            [20, 50, 5],
            [50, 101, 10]
        ]));
        this._submenus.set(ScribblerContextActions.FONT_CAT, this._menurow(b));
        b.div1_(CSS.AnMenuSelect, CSS.AnWidth6);
        this._inputFontcat = this._selectoptions(b.cursor_());
        this._inputFontcat.setOptions_(this._settings.fontCategories_());
        this._submenus.set(ScribblerContextActions.FONT_NAME, this._menurow(b));
        b.div1_(CSS.AnMenuSelect, CSS.AnWidth6);
        this._inputFontname = this._selectoptions(b.cursor_());
        DialogUt.populateFontName_(this._inputFontname, [], this._settings.fontFamilies_(), this._inputFontcat.getValue_(""), "");
        this._submenus.set(ScribblerContextActions.FONT_SIZE, this._menurow(b));
        b.div1_(CSS.AnMenuSelect, CSS.AnWidth4);
        this._inputFontstyle = this._selectoptions(b.cursor_());
        b.up_().div1_(CSS.AnMenuSelect, CSS.AnWidth2);
        this._fontSizes = An.createIntList_([], [
            [6, 20, 1],
            [20, 36, 2],
            [36, 72, 4],
            [72, 144, 8],
            [144, 257, 16]
        ]);
        this._inputFontsize = this._selectoptions(b.cursor_());
        this._inputFontsize.setOptions_(Array.from(this._fontSizes, (value: number, _index: number) => {
            return value.toString();
        }));
        this._submenus.set(ScribblerContextActions.FONT_SAMPLE, this._menurow(b));
        this._inputFontsample = b.div1_(CSS.AnMenurow6).cursor_();
        this._submenus.set(ScribblerContextActions.more, b
            .peek_()
            .tr_({
                "style": `border-top:${DEF.themeBorder}`,
            })
            .push_()
            .cursor_());
        this._createbuttonrow(this._buttons, b, [
            smap_(
                [ATTR.AnAction, ScribblerContextActions.resize],
                [ATTR.xTooltips, RS.Tooltips_ResizeCanvas],
                ["class", `${CSS.Fa} ${CSS.FaExpand}`],
            ),
            smap_(
                [ATTR.AnAction, ScribblerContextActions.fit],
                [ATTR.xTooltips, RS.Tooltips_CropCanvasToFitContent],
                ["class", `${CSS.Fa} ${CSS.FaCompress}`],
            ),
            smap_(
                [ATTR.AnAction, ScribblerContextActions.shift],
                [ATTR.xTooltips, RS.Tooltips_ShiftCanvas],
                ["class", `${CSS.Fa} ${CSS.FaArrows}`],
            ),
            smap_(
                [ATTR.AnAction, DEF.NOOP],
            ),
            smap_(
                [ATTR.AnAction, DEF.NOOP],
            ),
            smap_(
                [ATTR.AnAction, ScribblerContextActions.clear],
                [ATTR.xTooltips, RS.Tooltips_ClearCanvasAndDrawingHistory],
                ["class", `${CSS.Fa} ${CSS.FaTimesCircle}`],
            ),
        ]);
        b.pop_();
        this._updateContextmenuState();
        this._inputFontcat.onChange_((cat: string) => {
            const family = this._inputFontname.getValue_("");
            DialogUt.populateFontName_(this._inputFontname, [], this._settings.fontFamilies_(), cat, family);
        });
        this._inputFontname.onChange_((name: string) => {
            const style = this._inputFontstyle.getValue_("");
            const size = this._inputFontsize.getValue_("");
            const selectedstyle = DialogUt.populateFontStyle_(this._inputFontstyle, [], this._settings.fontInfo_(name), style);
            const family = FontUtil.fontFamilyOf_(name, selectedstyle);
            this._setfont0(this._inputFontsample, family, size);
        });
        this._inputFontstyle.onChange_((style: string) => {
            const name = this._inputFontname.getValue_("");
            const size = this._inputFontsize.getValue_("");
            const family = FontUtil.fontFamilyOf_(name, style);
            this._setfont0(this._inputFontsample, family, size);
        });
        this._inputFontsize.onChange_((size: string) => {
            const name = this._inputFontname.getValue_("");
            const style = this._inputFontstyle.getValue_("");
            const family = FontUtil.fontFamilyOf_(name, style);
            this._setfont(family, size);
        });
        An.onClick_(this._inputFontsample, (e) => {
            An.stopevent_(e);
            const d = new PromptFont(
                this._container,
                this._buttonSize,
                this._inputFontsample.style.fontFamily,
                DEFUtil.fontSamplerList,
                PATH._assetsFontsPng);
            d.above_(this.element_());
            d.onOK_((familystyle: string) => {
                const namestyle = FontUtil.splitNameStyle_(familystyle);
                const name = this._inputFontname.getValue_("");
                const style = this._inputFontstyle.getValue_("");
                const size = this._inputFontsize.getValue_("");
                if (namestyle[0] != name || namestyle[1] != style) {
                    this._inputFontname.setValue_(namestyle[0]);
                    DialogUt.populateFontStyle_(
                        this._inputFontstyle,
                        [],
                        this._settings.fontInfo_(namestyle[0]),
                        namestyle[1]);
                    this._setfont0(this._inputFontsample, familystyle, size);
                }
            });
            d.show_();
        });
        this._inputAlignment.onChange_((value: string) => {
            this._scribbler.setTextAlign_(value);
        });
        this._inputCornering.onChange_((value: string) => {
            const v = An.parseInt_(value, 50);
            this._scribbler.setCornering_(v / 100);
        });
        this._inputCorner.onChange_((radius: string) => {
            const value = An.parseInt_(radius, 0);
            this._scribbler.setCornerRadius_(value);
        });
        const strokecolorhandler = (e: MouseEvent) => {
            An.stopevent_(e);
            if (this._promptColorCallback == null) return;
            const d = this._promptColorCallback(
                this._buttonSize,
                An.above_(this.element_()),
                this._inputStrokecolor.style.backgroundColor,
                ColorValue.X_BLACK);
            d.onOK_((color, _format) => {
                if (color != null) {
                    this._inputStrokecolor.style.backgroundColor = color.toCSSString_();
                    this._scribbler.setStrokeColor_(color);
                }
            });
            d.show_();
        };
        const fillcolorhandler = (e: MouseEvent) => {
            An.stopevent_(e);
            if (this._promptColorCallback == null) return;
            const d = this._promptColorCallback(
                this._buttonSize,
                An.above_(this.element_()),
                this._inputFillcolor.style.backgroundColor,
                ColorValue.X_TRANSPARENT);
            d.onOK_((color, _format) => {
                if (color != null) {
                    this._inputFillcolor.style.backgroundColor = color.toCSSString_();
                    this._scribbler.setFillColor_(color);
                }
            });
            d.show_();
        };
        this._inputGrid.onChange_((grid: string) => {
            const o = this._scribbler.getScribblerSetting_();
            const value = An.parseInt_(grid, o.x_grid);
            if (value != o.x_grid) {
                this._scribbler.setGrid_(value);
            }
        });
        this._inputLineheight.onChange_((lineheight: string) => {
            const o = this._scribbler.getScribblerSetting_();
            const value = An.parseDouble_(lineheight, o.x_lineHeight);
            if (value != o.x_lineHeight) {
                this._scribbler.setLineHeight_(value);
            }
        });
        An.onClick_(this._inputTexting, (e) => {
            An.stopevent_(e);
            const classes = An.classlist_(this._inputTexting);
            if (!classes.contains_(CSS.AnDisabled)) {
                classes.toggleAll_(CSS.FaCheck, CSS.FaClose);
                const enable = classes.contains_(CSS.FaCheck);
                this._scribbler.enableText_(enable);
            }
        });
        An.onClick_(this._inputFill, (e) => {
            An.stopevent_(e);
            const enable = An.classlist_(this._inputFill)
                .toggleAll_(CSS.FaCheck, CSS.FaClose)
                .contains_(CSS.FaCheck);
            this._scribbler.enableFill_(enable);
        });
        An.onClick_(this._inputStroke, (e) => {
            An.stopevent_(e);
            const classes = An.classlist_(this._inputStroke);
            if (!classes.contains_(CSS.AnDisabled)) {
                classes.toggleAll_(CSS.FaCheck, CSS.FaClose);
                const enable = classes.contains_(CSS.FaCheck);
                this._scribbler.enableStroke_(enable);
            }
        });
        const textcolorhandler = (e: UIEvent) => {
            An.stopevent_(e);
            if (this._promptColorCallback == null) return;
            const d = this._promptColorCallback(
                this._buttonSize,
                An.above_(this.element_()),
                this._inputTextcolor.style.backgroundColor,
                ColorValue.X_BLACK);
            d.onOK_((color, _format) => {
                if (color != null) {
                    this._inputTextcolor.style.backgroundColor = color.toCSSString_();
                    this._scribbler.setTextColor_(color);
                }
            });
            d.show_();
        };
        An.onClick_(strokecolorlabel, strokecolorhandler);
        An.onClick_(this._inputStrokecolor, strokecolorhandler);
        An.onClick_(fillcolorlabel, fillcolorhandler);
        An.onClick_(this._inputFillcolor, fillcolorhandler);
        An.onClick_(textcolorlabel, textcolorhandler);
        An.onClick_(this._inputTextcolor, textcolorhandler);
        this._inputLinestyle.onChange_((style) => {
            this._scribbler.setLineStyle_(style);
        });
        this._inputLinewidth.onChange_((value: string) => {
            if (value == "1") {
                value = "1.05";
            }
            const width = An.parseDouble_(value, ScribblerDefault.LINE_WIDTH);
            this._scribbler.setLineWidth_(width);
        });
        An.onContextmenuMatching_(ret, `td[${ATTR.xTooltips}]`, (target, e) => {
            if (this._tooltipsCallback == null) return;
            this._tooltipsCallback(target, e);
        });
        return ret;
    }

    private _menurow(b: DomBuilderEx): HTMLElement {
        const ret = b.peek_().tr_({
            "class": CSS.AnMenurow,
            "style": `border-top:${DEF.themeBorder}`
        }).cursor_();
        b.td_({ "colspan": "6" });
        return ret;
    }

    private _updateContextmenuState(): void {
        const action = this._scribbler.getAction_();
        const setting = this._scribbler.getScribblerSetting_();
        const textsetting = this._scribbler.getTextSetting_();
        const linewidth = (setting.x_lineWidth < 1.9 ? "1" : Math.round(setting.x_lineWidth).toString());
        const fontsize = An.binarySearchIntValue_(this._fontSizes, 0, this._fontSizes.length, textsetting.x_fontSize);
        if (fontsize != textsetting.x_fontSize) {
            this._scribbler.setFont_(textsetting.x_fontFamily, fontsize);
        }
        this._inputGrid.setValue_(setting.x_grid.toString());
        this._inputLineheight.setValue_(`${setting.x_lineHeight}`);
        this._inputLinestyle.setValue_(setting.x_lineStyle);
        this._inputLinewidth.setValue_(linewidth);
        this._inputCorner.setValue_(setting.x_cornerRadius.toString());
        this._inputCornering.setValue_(Math.floor(setting.x_cornering * 100).toString());
        this._inputFontcat.setValue_("All");
        const namestyle = FontUtil.splitNameStyle_(textsetting.x_fontFamily);
        DialogUt.populateFontName_(this._inputFontname, [], this._settings.fontFamilies_(), FontCategories.All, namestyle[0]);
        DialogUt.populateFontStyle_(this._inputFontstyle, [], this._settings.fontInfo_(namestyle[0]), namestyle[1]);
        this._inputFontsize.setValue_(fontsize.toString());
        this._inputAlignment.setValue_(setting.x_textAlign);
        this._inputFontsample.style.fontFamily = textsetting.x_fontFamily;
        this._inputFontsample.textContent = textsetting.x_fontFamily;
        this._inputFillcolor.style.backgroundColor = setting.x_fillColor.toCSSString_();
        this._inputStrokecolor.style.backgroundColor = setting.x_strokeColor.toCSSString_();
        this._inputTextcolor.style.backgroundColor = setting.x_textColor.toCSSString_();
        if (action != ScribblerAction.TEXT) {
            this._inputTexting.classList.remove(CSS.AnDisabled);
        } else {
            An.classlist_(this._inputTexting)
                .add_(CSS.AnDisabled)
                .remove_(CSS.FaClose)
                .add_(CSS.FaCheck);
        }
        if (action != ScribblerAction.CURVE) {
            this._inputStroke.classList.remove(CSS.AnDisabled);
        } else {
            An.classlist_(this._inputStroke)
                .remove_(CSS.FaClose)
                .addAll_(CSS.AnDisabled, CSS.FaCheck);
        }
        this._updatecheckbox(this._inputTexting, setting.x_texting);
        this._updatecheckbox(this._inputFill, setting.x_fill);
        this._updatecheckbox(this._inputStroke, setting.x_stroke);
        switch (action) {
            case ScribblerAction.more:
                this._showmenu([ScribblerContextActions.GRID, ScribblerContextActions.more]);
                break;
            case ScribblerAction.export:
                this._showmenu([
                    ScribblerContextActions.GRID,
                ]);
                break;
            case ScribblerAction.TEXT:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.LINE_HEIGHT,
                    ScribblerContextActions.TEXT_ALIGN,
                    ScribblerContextActions.TEXT_COLOR,
                    ScribblerContextActions.FONT_CAT,
                    ScribblerContextActions.FONT_NAME,
                    ScribblerContextActions.FONT_SIZE,
                    ScribblerContextActions.FONT_SAMPLE,
                ]);
                break;
            case ScribblerAction.CURVE:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.STROKE_COLOR,
                    ScribblerContextActions.LINE_WIDTH,
                    ScribblerContextActions.LINE_STYLE,
                    ScribblerContextActions.CORNERING,
                ]);
                break;
            case ScribblerAction.POLYCURVE:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.FILL_COLOR,
                    ScribblerContextActions.STROKE_COLOR,
                    ScribblerContextActions.LINE_WIDTH,
                    ScribblerContextActions.LINE_STYLE,
                    ScribblerContextActions.CORNERING
                ]);
                break;
            case ScribblerAction.POLYGON:
            case ScribblerAction.IMAGE:
            case ScribblerAction.EMBEDED_IMAGE:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.FILL_COLOR,
                    ScribblerContextActions.STROKE_COLOR,
                    ScribblerContextActions.LINE_WIDTH,
                    ScribblerContextActions.LINE_STYLE,
                ]);
                break;
            case ScribblerAction.ELLIPSE:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.FILL_COLOR,
                    ScribblerContextActions.STROKE_COLOR,
                    ScribblerContextActions.LINE_WIDTH,
                    ScribblerContextActions.LINE_STYLE,
                ]);
                break;
            case ScribblerAction.RECTANGLE:
                this._showmenu([
                    ScribblerContextActions.GRID,
                    ScribblerContextActions.FILL_COLOR,
                    ScribblerContextActions.STROKE_COLOR,
                    ScribblerContextActions.LINE_WIDTH,
                    ScribblerContextActions.LINE_STYLE,
                    ScribblerContextActions.CORNER_RADIUS,
                ]);
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _updatecheckbox(elm: HTMLElement, enable: boolean): boolean {
        const classes = elm.classList;
        if (!classes.contains(CSS.AnDisabled)) {
            const checked = classes.contains(CSS.FaCheck);
            if (enable != checked) {
                An.classlist_(classes).toggleAll_(CSS.FaClose, CSS.FaCheck);
                return true;
            }
        }
        return false;
    }

    private _getButtonForAction(action: string): HTMLElement {
        const button = this._buttons.get(action);
        return button !== undefined ? button : this._buttons.get(ScribblerAction.CURVE)!;
    }

    setAction_(action: string, td: HTMLElement): boolean {
        const oaction = this._scribbler.getAction_();
        if (action == oaction) {
            return false;
        }
        if (oaction != null) {
            this._getButtonForAction(oaction).classList.remove(CSS.AnSelected);
        }
        td.classList.add(CSS.AnSelected);
        this._scribbler.setAction_(action);
        this._updateContextmenuState();
        return true;
    }

    private _setfont0(fontsample: HTMLElement, family: string, size: string): void {
        fontsample.style.fontFamily = family;
        fontsample.textContent = family + " " + size;
        this._setfont(family, size);
    }

    private _setfont(family: string, size: string): void {
        this._scribbler.setFont_(family, An.parseInt_(size, ScribblerDefault.FONT_SIZE));
    }

    private _showmenu(enables: string[]): void {
        const set = new Set(enables);
        for (let [key, elm] of this._submenus) {
            An.show_(elm, set.has(key) ? "block" : "none");
        }
    }

    private _createbuttons(table: Map<string, HTMLElement>, b: DomBuilderEx, infos: Array<Array<SStringMap>>): void {
        b.push_();
        for (let row of infos) {
            b.peek_().tr_().push_();
            this._createbuttonrow(table, b, row);
            b.pop_();
        }
        b.pop_();
    }

    private _createbuttonrow(table: Map<string, HTMLElement>, b: DomBuilderEx, row: Array<SStringMap>): void {
        for (let info of row) {
            this._createbutton(table, b, info);
        }
    }

    private _createbutton(table: Map<string, HTMLElement>, b: DomBuilderEx, info: SStringMap): void {
        const action = info[ATTR.AnAction];
        if (action == DEF.NOOP) {
            b.peek_().td_(
                ["class", `${CSS.AnContextButton} ${CSS.AnDisabled}`],
                [ATTR.AnAction, DEF.NOOP],
            );
        } else {
            const td = b.peek_().td_(
                ["class", CSS.AnContextButton],
                [ATTR.xTooltips, info[ATTR.xTooltips]],
                [ATTR.AnAction, action],
            ).cursor_();
            b.span1_(...(info["class"] ?? "").split(RX.Spaces));
            table.set(action, td);
        }
    }
}

class PromptScribblerHistory extends FixedSizeDialogBase {
    private _promptEditTextCallback: PromptEditTextCallback | null = null;
    private _content!: HTMLElement;
    private _selected: HTMLElementX = null;
    private _contextmenu: Contextmenu | null = null;
    private _selectedIndex: numberX = null;
    private _width: number = 0;

    constructor(
        container: HTMLElement,
        buttonsize: number,
        private _scribbler: Scribbler
    ) {
        super(container, buttonsize);
        super.init_(this.create_(container));
        An.onClickMatching_(this._content, `div[${ATTR.AnInfo}]`, (elm, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(elm.getAttribute(ATTR.AnInfo), -1);
            this._select(elm as HTMLElement, index);
        });
        this._onShowDialogCallback = (dialog, _sm) => {
            this._refresh();
            this._updateToolbarState();
            An.setVisible_(dialog);
        };
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infos_(
                BUT.Contextmenu,
                BUT.Remove,
                BUT.Up,
                BUT.Down,
            ),
            (action, e) => this._toolbarActions(action, e)
        );
    }

    private _createContent(content: HTMLElement): void {
        this._width = Math.min(window.innerWidth - this._buttonSize * 4, this._buttonSize * 8);
        this._content = new DomBuilderEx(content)
            .div1_(CSS.AnVerticalViewportWide)
            .div1_(CSS.AnTextList, CSS.AnZebra)
            .cursor_();
    }

    close_() {
        this._promptEditTextCallback = null;
        super.close_();
    }

    onEditText_(callback: PromptEditTextCallback | null): this {
        this._promptEditTextCallback = callback;
        return this;
    }

    getContentWidth_(): number {
        return this._width;
    }

    private _select(elm: HTMLElement, index: number): void {
        this._scribbler.highlight_(index);
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelected);
            if (this._selectedIndex == index) {
                this._selected = null;
                this._selectedIndex = null;
                this._updateToolbarState();
                return;
            }
        }
        elm.classList.add(CSS.AnSelected);
        this._selected = elm;
        this._selectedIndex = index;
        this._updateToolbarState();
    }

    private _toolbarActions(action: string, e: MouseEvent): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Remove: {
                if (this._selected != null) {
                    let index = this._selectedIndex;
                    const len = this._scribbler.history_().history_().length;
                    if (index != null && (index >= 0 && index < len)) {
                        this._scribbler.history_().remove_(index);
                        this._scribbler.refresh_();
                        this._selected = null;
                        this._selectedIndex = null;
                        this._refresh();
                        if (len > 1) {
                            const children = this._content.children;
                            let n = len - index - 1;
                            if (index == len - 1) {
                                --index;
                            } else if (index == 0) {
                                --n;
                            }
                            this._select(children[n] as HTMLElement, index);
                        } else {
                            this._updateToolbarState();
                        }
                    }
                }
                break;
            }
            case BUT.Up: {
                let index = this._selectedIndex;
                if (index != null) {
                    const len = this._scribbler.history_().history_().length;
                    index = this._scribbler.down_(index);
                    this._selectedIndex = null;
                    this._selected = null;
                    this._refresh();
                    const elm = this._content.children[len - index - 1] as HTMLElement;
                    this._select(elm, index);
                }
                break;
            }
            case BUT.Down: {
                let index = this._selectedIndex;
                if (index != null) {
                    const len = this._scribbler.history_().history_().length;
                    index = this._scribbler.up_(index);
                    this._selectedIndex = null;
                    this._selected = null;
                    this._refresh();
                    const elm = this._content.children[len - index - 1] as HTMLElement;
                    this._select(elm, index);
                }
                break;
            }
            case BUT.Contextmenu: {
                Timer.sleep1_(() => {
                    if (this._contextmenu == null) {
                        this._contextmenu = this._createContextmenu();
                    }
                    this._contextmenu.show_(e);
                });
                break;
            }
            default:
                this.actionInvalid_(action);
                return;
        }
    }

    private _updateToolbarState(): void {
        const len = this._scribbler.history_().history_().length;
        this._toolbar!.enableButton_(BUT.Remove, this._selectedIndex != null);
        this._toolbar!.enableButton_(BUT.Up, this._selectedIndex != null && len > 1);
        this._toolbar!.enableButton_(BUT.Down, this._selectedIndex != null && len > 1);
    }

    private _editable(): ScribblerCmd | null {
        if (this._selectedIndex == null) return null;
        const cmd = this._scribbler.history_().get_(this._selectedIndex);
        return (cmd != null && cmd.action$ == ScribblerAction.TEXT) ? cmd : null;
    }

    private _createContextmenu(): Contextmenu {
        const menu = new Contextmenu(this._container, An.above_(this._dialog), [
            BUT.infos_(BUT.Edit, BUT.Move, BUT.CloneObject),
        ]);
        menu.onTooltips_(toasters$.onTooltipsKey_);
        menu.onDrag_(Contextmenu.contextmenuDragOK_);
        menu.onAction_((action) => this._contextActions(action));
        menu.onShow_(() => {
            menu.enableButton_(BUT.Edit, this._editable() != null);
            menu.enableButton_(BUT.Move, this._selectedIndex != null);
            menu.enableButton_(BUT.CloneObject, this._selectedIndex != null);
        });
        return menu;
    }

    private _contextActions(action: string): void {
        this.clearStatus_();
        this._contextmenu?.hide_();
        if (this._selectedIndex == null) {
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        switch (action) {
            case BUT.Edit:
                this._edit();
                break;
            case BUT.Move:
                this.close_();
                this._scribbler.move_(this._selectedIndex);
                break;
            case BUT.CloneObject:
                this.close_();
                this._scribbler.cloneObject_(this._selectedIndex);
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _edit(): void {
        const cmd = this._editable();
        if (cmd == null) return;
        const setting = cmd.setting$;
        this._promptEditTextCallback?.(
            setting.x_data ?? "",
            setting.x_fontFamily,
            An.above_(this._dialog),
            (dialog: PromptEditText) => {
                dialog.onOK_((_d, value, _offset, done) => {
                    done(true);
                    setting.x_data = value;
                    this._scribbler.refresh_();
                    this._refresh();
                });
                dialog.show_();
            });
    }

    private _refresh(): void {
        const b = new DomBuilderEx(this._content).empty_();
        this._scribbler.history_().populate_(b);
    }

    showDialog_(resizer: Fun10<DialogBase>): void {
        An.showHidden_(this._dialog, "block");
        this._smokescreen = new Smokescreen(this._container, An.below_(this._dialog));
        this._smokescreen.on_("click", (e) => {
            An.stopevent_(e);
            this._scribbler.clearOverlay_();
            this.close_();
            this._cancelCallback?.();
        });
        for (let elm of DomUt.queryAll_(this._dialog, "input, textarea, select")) {
            if (elm.getAttribute(ATTR.AnNoClick) != null) continue;
            An.onClick_(elm, () => {
                this.clearStatus_();
            });
        }
        if (resizer != null) {
            resizer(this);
            this._onWindowResize(() => {
                resizer(this);
            });
        }
        this._smokescreen.show_();
        if (this._onShowDialogCallback != null) {
            this._onShowDialogCallback(this._dialog, this._smokescreen);
        } else {
            An.setVisible_(this._dialog);
            Timer.sleep0_(() => this.setInitialFocus_());
        }
        if (this._dragger == null && this._dragHandler != null) {
            this._dragger = new Dragger(this._dialog, this._dragHandler).bind_();
        }
    }
}

class ImageAnnotator extends FullscreenDialogBase {
    static readonly PADDING = 10;

    static readonly XMARGIN = "#X76";

    private _content!: HTMLElement;
    private _canvas!: HTMLCanvasElement;
    private _bgColor: ColorValue | null = ScribblerDefault.BG_COLOR;
    private _bgImageCallback: CanvasCallback | null = null;
    private _promptColorCallback: PromptColorCallback | null = null;
    private _promptEditTextCallback: PromptEditTextCallback | null = null;
    private _okCallback: ImageAnnotatorCallback | null = null;
    private _srcPath: stringX = null;
    private _history: ScribblerCmd[] | null = null;
    private _scribbler: Scribbler | null = null;
    private _contextmenu: ScribblerContextmenu | null = null;
    private _showing: boolean = false;
    #destroyed = false;

    /**
       * @param bgUri A context relative Uri for the background image being annotated, null to start with a blank background.
       */
    constructor(
        container: HTMLElement,
        gesturehandler: IGestureHandler,
        private _buttonSize: number,
        private _width: number,
        private _height: number,
        private _handler: IScribblerHandler
    ) {
        super(container, gesturehandler);
        super.init_(this.create_(container));
        An.onLoad_(this._canvas, () => {
            this.onResize_();
        });
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createFullscreenDialog_(
            container,
            (b) => this._createFullscreenToolbar(b),
            (b) => this._createFullscreenContent(b));
    }

    private _createFullscreenToolbar(b: DomBuilderEx): Toolbar {
        const toolbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, null, BUT.infos_(
            BUT.Contextmenu,
            BUT.Move,
            BUT.Undo,
            BUT.Redo,
            BUT.OK,
            BUT.Cancel,
        ));
        toolbar.onAction_((action, e) => this._toolbarActions(action, e));
        toolbar.enableButton_(BUT.Undo, false);;
        toolbar.enableButton_(BUT.Redo, false);
        return toolbar;
    }

    private _createFullscreenContent(b: DomBuilderEx): void {
        this._content = b.div_({
            "class": CSS.AnViewport,
        }).cursor_();
        this._content.parentElement!.style.padding = `${ImageAnnotator.PADDING}px`;
        const attrs = {
            "class": CSS.AnImageAnnotator,
            "width": `${this._width}`,
            "height": `${this._height}`,
        };
        this._canvas = b.child_("canvas", attrs).cursor_() as HTMLCanvasElement;
    }

    close_(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this._content.remove();
        this._canvas.remove();
        if (this._contextmenu != null) {
            this._contextmenu?.destroy_();
            this._contextmenu = null;
        }
        if (this._scribbler != null) {
            this._scribbler?.destroy_();
            this._scribbler = null;
        }
        this._bgImageCallback = null;
        this._promptColorCallback = null;
        this._promptEditTextCallback = null;
        this._okCallback = null;
        super.close_();
    }

    bgColor_(c: ColorValue | null): this {
        this._bgColor = c;
        return this;
    }

    bgImage_(callback: CanvasCallback): this {
        this._bgImageCallback = callback;
        return this;
    }

    onPromptColor_(callback: PromptColorCallback): this {
        this._promptColorCallback = callback;
        return this;
    }

    onEditText_(callback: PromptEditTextCallback): this {
        this._promptEditTextCallback = callback;
        return this;
    }

    onOK_(callback: ImageAnnotatorCallback): this {
        this._okCallback = callback;
        return this;
    }

    path_(path: stringX): void {
        this._srcPath = path;
    }

    history_(history: ScribblerCmd[] | null): void {
        this._history = history;
    }

    private _toolbarActions(action: string, e: MouseEvent): void {
        if (this._scribbler == null) return;
        this.clearStatus_();
        switch (action) {
            case BUT.Contextmenu:
                this._contextmenu?.show_(e);
                break;
            case BUT.Move: {
                const index = this._scribbler.history_().length_() - 1;
                if (index >= 0) {
                    this._scribbler.highlight_(index);
                    this._scribbler.move_(index);
                }
                break;
            }
            case BUT.Undo:
                this._scribbler.undo_();
                break;
            case BUT.Redo:
                this._scribbler.redo_();
                break;
            case BUT.OK: {
                this._okCallback!(this._canvas, this._scribbler.history_(), (ok) => {
                    if (ok) {
                        this.close_();
                    }
                });
                break;
            }
            case BUT.Cancel: {
                DialogUt.confirmKeySmall_(this._container, RS.ConfirmDiscard, An.above_(this._dialog), (yes) => {
                    if (!yes) return;
                    this.cancel_();
                });
                break;
            }
        }
    }

    cancel_(): void {
        this._cancelCallback?.();
        this.close_();
    }

    private _updateToolbarState(history: ScribblerHistory): void {
        An.enableButton_(this._toolbar!.button_(BUT.Redo), history.redoOK_());
        An.enableButton_(this._toolbar!.button_(BUT.Undo), history.undoOK_());
        An.enableButton_(this._toolbar!.button_(BUT.Move), !history.isEmpty_());
    }

    showFullscreen_(): void {
        this._showing = true;
        const origin = this.onResize_();
        if (this._scribbler == null) {
            this._scribbler = new Scribbler(this._canvas, origin, this._handler);
            this._scribbler.addHistoryListener_((history) => this._updateToolbarState(history));
            this._scribbler.onExport_((action, rect) => this._onScribblerExport(action, rect));
            this._scribbler.setBGColor_(this._bgColor);
            this._scribbler.setBGImage_(this._bgImageCallback);
            this._contextmenu = new ScribblerContextmenu(
                this._container,
                this._buttonSize,
                this._handler.getSettings_(),
                this._scribbler);
            this._contextmenu.onAction_((action) => this._contextActions(action));
            this._contextmenu.onPromptColor_(this._promptColorCallback);
            this._contextmenu.onTooltips_(toasters$.onTooltipsKey_);
            this._scribbler.setStateChangeListener_((stat) => this._onScribblerStateChange(stat));
        }
        if (this._history != null) {
            this._scribbler.addHistory_(this._history);
        }
        this._scribbler.refresh_();
        this._updateToolbarState(this._scribbler.history_());
        //// but none works.
    }

    private _onScribblerStateChange(state: number): void {
        switch (state) {
            case ScribblerState.IDLE:
                this._toolbar!.enable_(true);
                break;
            case ScribblerState.MOVE:
            case ScribblerState.TEXT:
                this._toolbar!.enable_(false);
                break;
            default:
                throw Assert.notReach_(`${state}`);
        }
    }

    private _onScribblerExport(action: string, rect: MutRect): void {
        if (this._contextmenu == null || action != ScribblerContextActions.export) return;
        
        let path: string;
        if (this._srcPath != null) {
            const b = new Basepath(this._srcPath);
            const name = PathUtil.createOutputImageFilename(b);
            path = b.sibling_(name).path$;
        } else {
            path = PathUtil.getHomeDir() + An.simpleDateTimeString_() + ".jpg";
        }
        this._handler.promptExportImage_(
            path,
            this._srcPath,
            rect.w,
            rect.h,
            An.above_(this._contextmenu.element_()),
            (info: ImageOutputInfo) => {
                let dataurl: string;
                const mime = MimeUtil.imageMimeFromPath_(info.filepath);
                if (mime == null) {
                    toasters$.warn_(MSG.string1_(RS.UnsupportedOutputFormat_, Basepath.suffix_(info.filepath ?? "")));
                    return;
                }
                if (rect.w == this._canvas.width
                    && rect.h == this._canvas.height
                    && info.width == this._canvas.width
                    && info.height == this._canvas.height
                    && info.rotation == 0) {
                    dataurl = this._canvas.toDataURL(mime, info.quality / 100.0);
                } else {
                    let c: HTMLCanvasElement;
                    const doc = this._canvas.ownerDocument;
                    switch (info.rotation) {
                        case 0: {
                            c = doc.createElement("canvas");
                            c.width = info.width;
                            c.height = info.height;
                            c.getContext("2d")!
                                .drawImage(this._canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, info.width, info.height);
                            break;
                        }
                        case 90: {
                            c = doc.createElement("canvas");
                            c.width = info.height;
                            c.height = info.width;
                            const sx = info.width / rect.w;
                            const sy = info.height / rect.h;
                            const ctx = c.getContext("2d")!;
                            ctx.translate(info.height, 0);
                            ctx.rotate(Math.PI / 2);
                            ctx.scale(sx, sy);
                            ctx.drawImage(this._canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
                            break;
                        }
                        case 180: {
                            c = doc.createElement("canvas");
                            c.width = info.width;
                            c.height = info.height;
                            const sx = info.width / rect.w;
                            const sy = info.height / rect.h;
                            const ctx = c.getContext("2d")!;
                            ctx.translate(info.width, info.height);
                            ctx.rotate(Math.PI);
                            ctx.scale(sx, sy);
                            ctx.drawImage(this._canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
                            break;
                        }
                        case 270: {
                            c = doc.createElement("canvas");
                            c.width = info.height;
                            c.height = info.width;
                            const sx = info.width / rect.w;
                            const sy = info.height / rect.h;
                            const ctx = c.getContext("2d")!;
                            ctx.translate(0, info.width);
                            ctx.rotate(-Math.PI / 2);
                            ctx.scale(sx, sy);
                            ctx.drawImage(this._canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
                            break;
                        }
                        default:
                            throw Assert.notReach_(`${info.rotation}`);
                    }
                    dataurl = c.toDataURL(mime, info.quality / 100.0);
                }
                this._handler.saveImage_(info.cpath!, dataurl, (ret) => {
                    const errors = ret[Key.errors];
                    if (errors != null) {
                        this._handler.warn_(errors);
                    } else {
                        this._contextmenu?.hide_();
                        this._handler.ok_(MSG.string_(RS.Scribbler_ExportImageOK));
                    }
                });
            });
    }

    onResize_(): Point<number> {
        const iwidth = this._width;
        const iheight = this._height;
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        const top = this._toolbar!.element_().clientHeight;
        const maxwidth = winwidth - ImageAnnotator.PADDING * 2;
        const maxheight = winheight - top - ImageAnnotator.PADDING * 2;
        An.setRectangle_(this._content, ImageAnnotator.PADDING, top + ImageAnnotator.PADDING, maxwidth, maxheight);
        const style = this._canvas.style;
        const marginbottom = (winheight * 3 / 4);
        style.marginBottom = `${marginbottom}px`;
        let left = 1;
        if (maxwidth > iwidth + 2) {
            left = (maxwidth - iwidth) / 2;
        }
        style.marginTop = "1px";
        style.marginRight = "1px";
        style.marginLeft = `${left}px`;
        const origin = new Point(left, -(iheight + marginbottom));
        if (this._scribbler != null) {
            this._scribbler.onresize_(origin);
        }
        if (this._showing) {
            this._showing = false;
            An.setVisible_(this._dialog);
        }
        return origin;
    }

    setInitialFocus_(): void { }

    private _contextActions(action: string): void {
        if (this._scribbler == null || this._contextmenu == null) return;
        switch (action) {
            case DEF.NOOP:
                return;
            case ScribblerContextActions.fit: {
                this._contextmenu.hide_();
                const rect = this._scribbler.history_().getBoundingRect_();
                const d = new CompositeDialog(this._container, [
                    new InputSelectField(
                        RS.Margin,
                        ImageAnnotator.XMARGIN,
                        "50",
                        RS.PlaceholderRequired,
                        CSSLength.PX,
                        [CSSLength.PX],
                        (host) => host.actionOK_(),
                    ),
                ]);
                d.titleKey_(RS.Fit);
                d.message_(MSG.string_(RS.Dimensions) + `: ${Math.round(rect.w)}x${Math.round(rect.h)}`);
                d.above_(this._contextmenu.element_());
                d.onOK_((dialog, done) => {
                    const xmargin = dialog.getValueAt_(0);
                    const margin = An.parseIntPx_(xmargin, -1);
                    const errors = sarray_();
                    if (margin < 0) {
                        errors.push(MSG.format2_(RS.invalidNameValue, MSG.string_(RS.Margin), xmargin));
                    }
                    if (errors.length > 0) {
                        dialog.warn_(errors);
                        done(false);
                        return;
                    }
                    done(true);
                    const left = (rect.x - margin);
                    const top = (rect.y - margin);
                    const width = Math.round(rect.w) + margin * 2;
                    const height = Math.round(rect.h) + margin * 2;
                    this._scribbler?.history_().shift_(-left, -top);
                    this._width = width;
                    this._height = height;
                    this._canvas.width = width;
                    this._canvas.height = height;
                    this._scribbler?.resize_();
                    this.onResize_();
                    this._setaction(ScribblerAction.CURVE);
                });
                d.show_();
                return;
            }
            case ScribblerContextActions.shift: {
                this._contextmenu.hide_();
                Timer.sleep1_(() => {
                    this._scribbler?.shift_(() => {
                        this._setaction(ScribblerAction.CURVE);
                    });
                });
                return;
            }
            case ScribblerContextActions.resize: {
                this._contextmenu.hide_();
                const XHEIGHT = "#XeY";
                const XWXH = "#XWQ";
                const XWIDTH = "#Xja";
                const d = new CompositeDialog(this._container, [
                    new Input2FIeld(
                        "",
                        XWXH,
                        ",",
                        this._buttonSize,
                        RS.PlaceholderRequired,
                        XWIDTH,
                        `${this._width}`,
                        "x",
                        RS.PlaceholderRequired,
                        XHEIGHT,
                        `${this._height}`,
                        CSSLength.PX
                    ),
                ]);
                d.titleKey_(RS.Resize);
                d.message_(MSG.string_(RS.OriginalSize) + `: ${this._width}x${this._height}`);
                d.above_(this._contextmenu.element_());
                d.onOK_((dialog, done) => {
                    const errors = sarray_();
                    const widthvalue = dialog.getValueAt_(0, 0);
                    const heightvalue = dialog.getValueAt_(0, 1);
                    let width = An.parseInt_(widthvalue, -1);
                    let height = An.parseInt_(heightvalue, -1);
                    if (width < 0) {
                        errors.push(MSG.format2_(RS.invalidNameValue, MSG.string_(RS.Width), widthvalue));
                    }
                    if (height < 0) {
                        errors.push(MSG.format2_(RS.invalidNameValue, MSG.string_(RS.Height), heightvalue));
                    }
                    if (errors.length > 0) {
                        dialog.warn_(errors);
                        done(false);
                    }
                    done(true);
                    if (width * height > DEF.maxOutputImageArea) {
                        const limited = MediaUtil.limitImageArea_(width, height);
                        width = limited.x;
                        height = limited.y;
                        this._handler.warn_(MSG.string1_(RS.imageDimensionLimit_, `${width}x${height}`));
                    }
                    if (this._canvas.width != width || this._canvas.height != height) {
                        this._width = width;
                        this._height = height;
                        this._canvas.width = width;
                        this._canvas.height = height;
                        this._scribbler?.resize_();
                        this.onResize_();
                        this._setaction(ScribblerAction.CURVE);
                    }
                });
                d.show_();
                return;
            }
            case ScribblerContextActions.export: {
                this._contextmenu.hide_();
                this._handler.info_(MSG.string_(RS.Tooltips_SelectAnAreaToExport));
                this._setaction(action);
                return;
            }
            case ScribblerContextActions.clear: {
                DialogUt.confirmKeySmall_(this._container, RS.ImageAnnotator_ConfirmClearMessage,
                    An.above_(this._contextmenu.element_()), (yes: boolean) => {
                        if (!yes) return;
                        this._scribbler?.clear_();
                        this._contextmenu?.hide_();
                        this._setaction(ScribblerAction.CURVE);
                    });
                return;
            }
            case ScribblerContextActions.history: {
                this._contextmenu.hide_();
                new PromptScribblerHistory(this._container, this._buttonSize, this._scribbler)
                    .titleKey_(RS.PromptScribblerHistoryTitle)
                    .zindex_(DEF.zindexPrompt)
                    .onEditText_(this._promptEditTextCallback)
                    .show_();
                return;
            }
            case ScribblerContextActions.BG: {
                if (this._promptColorCallback == null) return;
                const d = this._promptColorCallback(
                    this._buttonSize,
                    An.above_(this._contextmenu.element_()),
                    this._scribbler.getBGColor_().toRgbaString_(),
                    ColorValue.X_TRANSPARENT);
                d.onOK_((color, _format) => {
                    if (color != null) {
                        this._contextmenu?.hide_();
                        this._scribbler?.setBGColor_(color);
                        this._scribbler?.refresh_();
                    }
                });
                d.show_();
                return;
            }
            case ScribblerContextActions.EMBEDED_IMAGE:
            case ScribblerContextActions.IMAGE: {
                this._contextmenu.hide_();
                this._handler.info_(MSG.string_(RS.Tooltips_SelectAnAreaForImport));
                this._setaction(action);
                return;
            }
            case ScribblerContextActions.CURVE:
            case ScribblerContextActions.ELLIPSE:
            case ScribblerContextActions.POLYCURVE:
            case ScribblerContextActions.POLYGON:
            case ScribblerContextActions.RECTANGLE:
            case ScribblerContextActions.TEXT:
            case ScribblerContextActions.more:
                this._setaction(action);
                return;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _setaction(action: string): void {
        const td = this._contextmenu?.getButton_(action) ?? null;
        if (td != null) {
            if (!this._contextmenu?.setAction_(action, td)) {
                return;
            }
            this._canvas.style.cursor = "default";
        }
    }
}

////////////////////////////////////////////////////////////////////////

/// Like PormptOK but with known size.
class PromptOKFixedSize extends FixedSizeDialogBase {
    private _okCallback: ValidatorCallback | null = null;

    constructor(
        container: HTMLElement,
        private _width: number,
        buttonsize: number) {
        super(container, buttonsize);
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutStatus(
            container,
            (content) => this._createContent(content),
            BUT.infosOKCancel,
            (action) => this._toolbarActions(action)
        );
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    private _createContent(content: HTMLElement): void {
        new DomBuilderEx(content).div_({ "style": `width:${this._width}px` });
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: ValidatorCallback): this {
        this._okCallback = callback;
        return this;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                this._okCallback!((ok) => {
                    if (ok) {
                        this.close_();
                    }
                });
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class PromptCalc extends FixedSizeDialogBase {
    static readonly _plus = 0x2b;
    static readonly _minus = 0x2d;
    static readonly _mult = 0x2a;
    static readonly _div = 0x2f;
    static readonly _dot = 0x2e;
    static readonly _clear = 0x43;
    static readonly _negate = 0x7e;
    static readonly _equal = 0x3d;
    static readonly _int = 0x23;
    static readonly _dollar = 0x24;

    static readonly _zero = 0x30;
    static readonly _nine = 0x39;
    static readonly _ue = 0x45;
    static readonly _le = 0x65;

    //// Button labels
    static readonly _CLEAR = "C";
    static readonly _PASTE = " ";
    static readonly _CLEAR_LC = "c";
    static readonly _NAGATE = "~";
    static readonly _EQUAL = "=";
    static readonly _BACKSPACE = "<=";
    static readonly _INT = "#";
    static readonly _DOLLAR = "\$";
    static readonly _OK = "OK";
    static readonly _ZERO_DOT_ZERO = RegExp("^0*\\.0*\$");
    private _input!: HTMLTextAreaElement;
    private _width!: number;
    private _x: numberX = null;
    private _y: numberX = null;
    private _okCallback: String2Callback | null = null;
    private _initialValue: boolean = false;

    protected _allowTouchmove(): boolean {
        return true;
    }

    constructor(container: HTMLElement, buttonsize: number) {
        super(container, buttonsize);
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithContentOnly(container, (content) => this._createContent(content));
    }

    private _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content);
        const x7 = this._buttonSize * 7;
        const x5 = this._buttonSize * 5;
        this._width = x5;
        b
            .push_()
            .div_({
                "class": CSS.AnFlex,
                "style": `flex-flow:column nowrap; width:${this._width}px;`,
            })
            .push_()
            .cursor_();
        this._input = b.textarea_({
            "class": CSS.AnCalcDisplay,
        }).cursor_() as HTMLTextAreaElement;
        const c = b
            .peek_()
            .div_({
                "class": CSS.AnFlex,
                "style": `flex-flow: row wrap; width: ${x5}px; height: ${x7}px; margin:5px 10px 0px 10px;`,
            })
            .push_()
            .cursor_();
        const labels = [
            [
                PromptCalc._CLEAR,
                PromptCalc._PASTE,
                PromptCalc._NAGATE,
                PromptCalc._BACKSPACE,
            ],
            ["7", "8", "9", "/"],
            ["4", "5", "6", "*"],
            ["1", "2", "3", "-"],
            ["e", "0", ".", "+"],
            [
                PromptCalc._EQUAL,
                PromptCalc._INT,
                PromptCalc._DOLLAR,
                PromptCalc._OK,
            ],
        ];
        const digit = `${CSS.AnCalcCell} ${CSS.AnCalcDigit}`;
        const op = `${CSS.AnCalcCell} ${CSS.AnCalcOp}`;
        for (let r = 0; r < 6; ++r) {
            for (let c = 0; c < 4; ++c) {
                const label = labels[r][c];
                if (label.length == 0) {
                    continue;
                }
                if (label == PromptCalc._PASTE) {
                    const disable = clipboard$.isEmpty_();
                    b.peek_()
                        .div1_(CSS.AnCalcCell, CSS.AnCalcOp)
                        .span1_(CSS.Fa, CSS.FaPaste, (disable ? CSS.AnDisabled : ""))
                        .text_(PromptCalc._PASTE);
                } else {
                    const isop = (label.length > 1 || "1234567890".indexOf(label) < 0);
                    b.peek_().div_({
                        "class": isop ? op : digit,
                    }).text_(label);
                }
            }
        }
        this._input.value = "";
        new Flash(c, `div.${CSS.AnCalcCell}`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        //// Stop the click event instead to prevent selection but allow scrolling.
        An.onClick_(this._input, (e) => {
            An.stopevent_(e);
        });
        An.onEventMatching_(c, Conf.pointerstart$, `div.${CSS.AnCalcCell}`, (target, e) => {
            An.stopevent_(e);
            const label = target.textContent ?? "";
            this._handle(label, e);
        });
        An.onInput_(this._input, () => {
            const offset = this._getstart() - 1;
            const value = this._input.value;
            const expr = this._validateExpr(value);
            if (expr != value) {
                this._input.value = expr;
                this._input.setSelectionRange(offset, offset);
            }
        });
    }

    private _validateExpr(s: string): string {
        let ret = "";
        Ut.chars_(s).forEach((s) => {
            if ("0123456789Ee.+-*/~".includes(s)) ret += s;
        });
        return ret;
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    value_(value: string): void {
        this._input.value = PromptCalc._ZERO_DOT_ZERO.test(value) ? "0" : value;
        this._initialValue = true;
    }

    /**
       * @param x, y Offsets from smokescreen, ie. page offset - scroll offsets.
       */
    at_(x: numberX, y: numberX): void {
        this._x = x;
        this._y = y;
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: String2Callback): this {
        this._okCallback = callback;
        return this;
    }

    private _actionOK(value: string, format: string): void {
        let ret: stringX = null;
        if (value.length > 0) {
            try {
                const result = new _Calculator(value).run();
                if (result != null) {
                    switch (format) {
                        case PromptCalc._INT:
                            ret = Math.round(result).toString();
                            break;
                        case PromptCalc._DOLLAR:
                            ret = result.toFixed(2);
                            break;
                        default:
                            ret = result.toString();
                    }
                }
            } catch (e) {
                this._onerror(e);
                return;
            }
        }
        const callback = this._okCallback!;
        this.close_();
        callback(ret == null ? "" : ret, value);
    }

    onSmokescreenCreated_(sm: Smokescreen): void {
        super.onSmokescreenCreated_(sm);
        sm.on_(Conf.pointerstart$, (e) => {
            An.stopevent_(e);
            this._actionOK("", "");
        });
    }

    show_(): this {
        return this.showAt_(this._x, this._y);
    }

    private _handle(label: string, e: Event): void {
        if (this._busy) {
            Timer.sleep0_(() => {
                this._handle(label, e);
            });
        } else {
            this._handle1(label, e);
            this._initialValue = false;
        }
    }

    private _getstart() {
        return Ut.num_(this._input.selectionStart, this._input.value.length);
    }

    private _getend() {
        return Ut.num_(this._input.selectionEnd, this._input.value.length);
    }

    private _handle1(label: string, e: Event): void {
        this._busy = true;
        try {
            this._input.classList.remove(CSS.xRed);
            const handle2 = (label: string) => {
                const offset = this._getstart();
                switch (label) {
                    case PromptCalc._NAGATE: {
                        let value = this._input.value;
                        let i = offset - 1;
                        for (; i >= 0; --i) {
                            const c = value.codePointAt(i);
                            if (c == PromptCalc._dot
                                || c == PromptCalc._le
                                || c == PromptCalc._ue
                                || (c !== undefined && c >= PromptCalc._zero && c <= PromptCalc._nine)) {
                                continue;
                            }
                            if ((c == PromptCalc._plus || c == PromptCalc._minus) && i > 0) {
                                const c1 = value.codePointAt(i - 1);
                                if (c1 == PromptCalc._le || c1 == PromptCalc._ue) {
                                    continue;
                                }
                            }
                            break;
                        }
                        const c = ((i >= 0 ? value.codePointAt(i) : null) ?? null);
                        const c1 = ((i > 0 ? value.codePointAt(i - 1) : null) ?? null);
                        if (i < 0 || c != 0x2d && this._isoperator(c) || i > 0 && c == 0x2d && !this._isoperator(c1)) {
                            this._input.setRangeText("-", i + 1, i + 1, "end");
                        } else if (i == 0 || this._isoperator(c1)) {
                            this._input.setRangeText("", i, i + 1, "end");
                        }
                        break;
                    }
                    case "+":
                    case "-":
                    case "*":
                    case "/":
                    case "e": {
                        this._input.setRangeText(label, offset, offset, "end");
                        break;
                    }
                    default: {
                        if (this._initialValue) {
                            this._initialValue = false;
                            if (offset == this._input.value.length) {
                                const c = label.codePointAt(0) ?? null;
                                if (c == PromptCalc._dot || (c != null && c >= PromptCalc._zero && c <= PromptCalc._nine)) {
                                    this._input.setRangeText(label, 0, this._input.value.length, "end");
                                }
                                break;
                            }
                        }
                        this._input.setRangeText(label, offset, offset, "end");
                        break;
                    }
                }
            };
            switch (label) {
                case PromptCalc._INT:
                case PromptCalc._DOLLAR:
                case PromptCalc._OK: {
                    //// Allow default action would let the click make a selection after exit,
                    //// which in many case popup the calculator at another x-calc-cell.
                    //// Stop default event on exit for now, which means no flash on these buttons.
                    An.stopevent_(e);
                    this._actionOK(this._input.value.replace(RX.Spaces, ""), label);
                    break;
                }
                case PromptCalc._BACKSPACE: {
                    let start = this._getstart();
                    const end = this._getend();
                    if (start == end) {
                        if (start == 0) {
                            break;
                        }
                        --start;
                    }
                    this._input.setRangeText("", start, end, "end");
                    break;
                }
                case PromptCalc._CLEAR:
                case PromptCalc._CLEAR_LC: {
                    this._input.value = "";
                    this._input.setSelectionRange(0, 0);
                    break;
                }
                case PromptCalc._EQUAL: {
                    try {
                        const result = new _Calculator(this._input.value).run();
                        if (result != null) {
                            //// HACK: Javascript double arithmatic often result in something like 1.00000000000000006.
                            //// Keep result at 6 fractional digit precision.
                            const value = this._rounding(result).toString();
                            this._input.value = value;
                            this._input.setSelectionRange(value.length, value.length);
                        }
                        break;
                    } catch (e) {
                        this._onerror(e);
                    }
                    break;
                }
                case PromptCalc._PASTE: {
                    const content = clipboard$.get_();
                    if (content != null) {
                        const value = native$.getClipboardText_(content);
                        if (value != null) {
                            const expr = this._validateExpr(value);
                            const start = this._getstart();
                            const end = this._getend();
                            this._input.setRangeText(expr, start, end, "end");
                        }
                    }
                    break;
                }
                default: {
                    handle2(label);
                    break;
                }
            }
        } finally {
            this._busy = false;
        }
    }

    private _rounding(result: number): number {
        return Math.round(result * 1000000) / 1000000;
    }

    setInitialFocus_(): void {
        if (this._input != null) this._input.blur();
    }

    private _isoperator(c: numberX): boolean {
        return c == 0x2a || c == 0x2b || c == 0x2d || c == 0x2f;
    }

    private _onerror(e: any): void {
        toasters$.warn_((e instanceof Error) ? e.message : `${e}`);
        this._input.classList.add(CSS.xRed);
    }
}

class _Calculator {
    static readonly OPERATOR: RegExp = new RegExp("([-+*/]*)");
    static readonly OPERAND: RegExp = new RegExp("([\\d.]+([eE][-+]?\\d+)?)");
    static readonly FASTPATH: RegExp = new RegExp("^(-+)?([\\d.]+([eE][-+]?\\d+)?)$");
    _scanner: StringScanner;
    _operandStack: number[] = [];
    _operatorStack: string[] = [];
    _positionStack: number[] = [];

    constructor(
        private _value: string
    ) {
        this._scanner = new StringScanner(_value);
    }

    run(): numberX {
        if (this._value.length == 0) {
            return null;
        }
        const m = _Calculator.FASTPATH.exec(this._value);
        if (m != null) {
            let v = An.parseDouble_(m[2], null);
            if (v == null) {
                throw new Error("Invalid value");
            }
            if ("-" == m[1]) {
                v = -v;
            }
            return v;
        }
        let first = true;
        for (; !this._scanner.isDone$; first = false) {
            this._scanner.expect_(_Calculator.OPERATOR, MSG.string_(RS.Operator));
            const ops = this._scanner.lastMatch$![1];
            let nag = false;
            let op = null;
            if (ops.length > 0) {
                op = ops[0];
                for (let i = 1, len = ops.length; i < len; ++i) {
                    if ("-" != ops[i]) {
                        this._scanner.error_(MSG.string_(RS.InvalidOperator));
                    }
                    nag = !nag;
                }
                if (first && "-" == op) {
                    nag = !nag;
                    op = null;
                }
            } else if (!first) {
                this._scanner.error_(MSG.string_(RS.ExpectingAnOperator));
            }
            this._scanner.expect_(_Calculator.OPERAND, MSG.string_(RS.Operand));
            const operand = this._scanner.lastMatch$![1];
            let v = An.parseDouble_(operand, null);
            if (v == null) {
                throw new Error(MSG.string_(RS.InvalidOperand) + ": " + operand);
            }
            v = nag ? -v : v;
            if (op == null) {
                this._operandStack.push(v);
                continue;
            }
            switch (op) {
                case "*":
                case "/": {
                    const v0 = this._getoperand(op, this._scanner.position$);
                    if (op == "/" && v == 0) {
                        this._scanner.error_(MSG.string_(RS.DivideByZeroError));
                    }
                    this._operandStack.push(op == "*" ? v0 * v : v0 / v);
                    break;
                }
                case "+":
                case "-": {
                    this._flush();
                    this._operatorStack.push(op);
                    this._positionStack.push(this._scanner.position$);
                    this._operandStack.push(v);
                    break;
                }
            }
        }
        this._flush();
        if (this._operandStack.length == 1) {
            return this._operandStack[0];
        }
        throw new Error(MSG.string_(RS.InvalidExpression));
    }

    private _flush(): void {
        while (this._operatorStack.length != 0) {
            const lop = this._operatorStack.pop()!;
            const position = this._positionStack.pop()!;
            const v1 = this._getoperand(lop, position);
            const v0 = this._getoperand(lop, position);
            this._operandStack.push(lop == "+" ? v0 + v1 : v0 - v1);
        }
    }

    private _getoperand(op: string, position: number): number {
        if (this._operandStack.length == 0) {
            throw new Error(MSG.string1_(RS.MissingOperandFor_, op) + `: position=${position}`);
        }
        return this._operandStack.pop()!;
    }
}

////////////////////////////////////////////////////////////////////////

class PromptDate extends FixedSizeDialogBase {
    static readonly ALL = 0x7;
    static readonly DATE = 1;
    static readonly TIME = 2;
    static readonly FORMAT = 4;

    /* now() with zero second. */
    private _width!: number;
    private _tabPanel!: TabPanel;
    private _dateTab!: HTMLElement;
    private _timeTab!: HTMLElement;
    private _formatTab!: HTMLElement;
    private _datePanel!: _DatePanel;
    private _timePanel!: _TimePanel;
    private _formatPanel!: _DateFormatPanel;
    private _dateFormat: string = DateFormat.DEF;
    private _timeFormat: string = TimeFormat.DEF;
    private _preferredDateFormat: stringX = null;
    private _preferredTimeFormat: stringX = null;
    private _allowAuto = true;
    private _okCallback: DateCallback | null = null;
    #destroyed = false;

    get hasDatePanel$(): boolean {
        return (this._tabs & PromptDate.DATE) != 0;
    }

    get hasTimePanel$(): boolean {
        return (this._tabs & PromptDate.TIME) != 0;
    }

    get datePanel$(): _DatePanel {
        return this._datePanel;
    }

    get timePanel$(): _TimePanel {
        return this._timePanel;
    }

    get dateFormat$(): string {
        return this._dateFormat;
    }

    get timeFormat$(): string {
        return this._timeFormat;
    }

    get preferredDateFormat$(): string {
        return this._preferredDateFormat ?? this.dateFormat$;
    }

    get preferredTimeFormat$(): string {
        return this._preferredTimeFormat ?? "";
    }

    get allowAuto$(): boolean {
        return this._allowAuto;
    }

    constructor(
        container: HTMLElement,
        private _now: DateTime,
        private _initialDate: DateTime,
        private _tabs: number,
        buttonsize: number
    ) {
        super(container, buttonsize);
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infos_(
                BUT.Today,
                BUT.TargetDate,
                BUT.OK,
                BUT.Cancel,
            ),
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content);
        this._width = this._buttonSize * 7;
        b
            .push_()
            .div_({
                "class": CSS.AnFlex,
                "style": `flex-flow: column nowrap;  width: ${this._width}px;`
                    + ` padding-top: 5px; border-top:${DEF.themeBorder};`,
            })
            .push_()
            .cursor_();
        this._createTabpanel(b);
    }

    close_(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this._timePanel.destroy();
        this._okCallback = null;
        super.close_();
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: DateCallback): this {
        this._okCallback = callback;
        return this;
    }

    dateFormat_(dateformat: string): this {
        this._dateFormat = DateFormat.validate_(dateformat, DateFormat.DEF);
        return this;
    }

    timeFormat_(timeformat: string): this {
        this._timeFormat = TimeFormat.validate_(timeformat, TimeFormat.DEF);
        return this;
    }

    preferredDateFormat_(format: string): this {
        this._preferredDateFormat = format;
        return this;
    }

    preferredTimeFormat_(format: string): this {
        this._preferredTimeFormat = format;
        return this;
    }

    allowAuto(b: boolean): this {
        this._allowAuto = b;
        return this;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Today:
                this._datePanel.refresh(this._now);
                this._timePanel.refresh(this._now);
                this._formatPanel.refresh();
                break;
            case BUT.TargetDate:
                this._datePanel.refresh(this._initialDate);
                this._timePanel.refresh(this._initialDate);
                this._formatPanel.refresh();
                break;
            case BUT.OK:
                this._actionOK();
                break;
            case BUT.Cancel:
                this.actionCancel_();
                this.close_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _actionOK(): void {
        const date = (this.hasDatePanel$ ? this._datePanel.selectedDate$ : null);
        const time = (this.hasTimePanel$ ? this._timePanel._date : null);
        const ret = DateTime.local_(
            (date == null ? 0 : date.year$),
            (date == null ? 1 : date.month$),
            (date == null ? 1 : date.day$),
            (time == null ? 0 : time.hour$),
            (time == null ? 0 : time.minute$),
            0);
        let dateformat = "";
        let timeformat = "";
        let formatted = "";
        if ((this._tabs & PromptDate.FORMAT) != 0) {
            this._formatPanel.refresh();
            const datestr = this._formatPanel._inputDateFormat.getLabel_("");
            const timestr = (datestr == "auto") ? "" : this._formatPanel._inputTimeFormat.getLabel_("");
            dateformat = this._formatPanel._inputDateFormat.getValue_("");
            timeformat = (dateformat == "auto") ? "" : this._formatPanel._inputTimeFormat.getValue_("");
            formatted = (datestr == "auto" ? An.autoDateString_(DateTime.now_(), ret)
                : datestr.length == 0 ? timestr
                    : timestr.length == 0 ? datestr
                        : datestr + " " + timestr);
        }
        const callback = this._okCallback!;
        this.close_();
        callback(ret, dateformat, timeformat, formatted);
    }

    private _hourFormatter(h: number): string {
        const f = (this._timeFormat.length == 0 ? TimeFormat.DEF : this._timeFormat);
        return TimeFormat.hourString_(f, h);
    }

    private _createTabpanel(b: DomBuilderEx): void {
        const top = b.peek_().div_({}).cursor_();
        this._tabPanel = new TabPanel(top, true);
        let tab: HTMLElementX = null;
        if ((this._tabs & PromptDate.DATE) != 0) {
            this._dateTab = this._tabPanel.addTab(RS.Tooltips_DatePicker, `${CSS.Fa} ${CSS.FaCalendar}`, (elm) => {
                return this._datePanel = new _DatePanel(elm, this._now, this._initialDate, this._buttonSize, () => this._actionOK());
            });
            tab = this._dateTab;
        }
        if ((this._tabs & PromptDate.TIME) != 0) {
            this._timeTab = this._tabPanel.addTab(RS.Tooltips_TimePicker, `${CSS.Fa} ${CSS.FaClockO}`, (elm) => {
                return this._timePanel = new _TimePanel(elm, this._initialDate, (h) => this._hourFormatter(h), this._buttonSize);
            });
            if (tab == null) {
                tab = this._timeTab;
            }
        }
        if ((this._tabs & PromptDate.FORMAT) != 0) {
            this._formatTab = this._tabPanel.addTab(RS.Tooltips_DateFormat, `${CSS.Fa} ${CSS.FaQuoteLeft}`, (elm) => {
                return this._formatPanel = new _DateFormatPanel(elm, this);
            });
            if (tab == null) {
                tab = this._formatTab;
            }
        }
        this._tabPanel.onTooltips(toasters$.onTooltipsKey_);
        this._tabPanel.activeTab(tab);
    }

    showTab_(tab: number): this {
        if (tab == PromptDate.FORMAT) {
            this._tabPanel.selectTab(this._formatTab);
        } else if (tab == PromptDate.TIME) {
            this._tabPanel.selectTab(this._timeTab);
        } else {
            this._tabPanel.selectTab(this._dateTab);
        }
        if (this._formatPanel != null) {
            this._formatPanel.refresh();
            this._formatPanel._inputDateFormat.setValue_(this.preferredDateFormat$);
            this._formatPanel._inputTimeFormat.setValue_(this.preferredTimeFormat$);
        }
        return super.show_();
    }

    show_(): this {
        this._tabPanel.activePanel()?.show_();
        return super.show_();
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.OK));
    }
}

class _DatePanel extends UIPanelBase {
    private _startDate: DateTime;
    private _selectedDate: DateTime;
    private _dateContainer!: HTMLElement;
    private _inputYear!: HTMLTextAreaElement;
    private _inputMonth!: HTMLTextAreaElement;
    private _buttonPrevYear: HTMLElement;
    private _buttonNextYear: HTMLElement;
    private _buttonPrevMonth: HTMLElement;
    private _buttonNextMonth: HTMLElement;
    private _selectedCell: HTMLElementX = null;

    constructor(
        private _container: HTMLElement,
        private _today: DateTime,
        private _initialDate: DateTime,
        buttonsize: number,
        okcallback: Fun00X = null
    ) {
        super();
        this._selectedDate = this._initialDate;
        this._startDate = this._getstartdate(this._selectedDate);
        const x1 = buttonsize;
        const x2 = buttonsize * 2;
        const x6 = buttonsize * 6;
        const x7 = buttonsize * 7;
        const b = new DomBuilderEx(_container).push_();
        b.div_({
            "class": CSS.AnFlex,
            "style": "padding-top: 5px; padding-bottom:5px; "
        }).push_();
        this._buttonPrevYear = b.div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronLeft)
            .cursor_();
        this._inputYear = b.peek_().child_(Conf.input$, {
            "class": CSS.AnPromptInput,
            "style": `width: ${x2}px;text-align:center;`,
            "rows": "1",
            "tabindex": "1",
        }).cursor_() as AnInputElement;
        this._buttonNextYear = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronRight)
            .cursor_();
        this._buttonPrevMonth = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronLeft)
            .cursor_();
        this._inputMonth = b.peek_().child_(Conf.input$, {
            "class": CSS.AnPromptInput,
            "style": `width: ${x1}px;text-align:center;`,
            "rows": "1",
            "tabindex": "2",
        }).cursor_() as AnInputElement;
        this._buttonNextMonth = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronRight)
            .cursor_();
        b.pop_();
        this._dateContainer = b
            .peek_()
            .div_({
                "class": CSS.AnCalBody,
                "style": `flex-flow: row wrap; width: ${x7}px; height: ${x6}px; padding-bottom: 4px;`,
            })
            .push_()
            .cursor_();
        An.onClickMatching_(this._dateContainer, "div", (elm, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(elm.getAttribute(ATTR.AnInfo), -1);
            if (index >= 0) {
                const doubleclick = elm == this._selectedCell;
                if (this._selectedCell != null) {
                    this._selectedCell.classList.remove(CSS.AnDateSelected);
                }
                this._selectedCell = elm;
                this._selectedCell.classList.add(CSS.AnDateSelected);
                this._selectedDate = this._startDate.add_(index * DateTime.DAY);
                this._inputYear.value = `${this._selectedDate.year$}`;
                this._inputMonth.value = `${this._selectedDate.month$}`;
                if (doubleclick && okcallback != null) {
                    const callback = okcallback;
                    okcallback = null;
                    callback();
                }
            }
        });
        An.onInputChange_(An.onInputFocusSelect_(this._inputYear), (e) => {
            An.stopevent_(e);
            const year = this._selectedDate.year$;
            const y = An.parseInt_(this._inputYear.value, year);
            this._inputYear.value = `${year}`;
            if (y != year) {
                this.refresh(DateTime.local_(
                    y,
                    this._selectedDate.month$,
                    this._selectedDate.day$,
                    this._selectedDate.hour$,
                    this._selectedDate.minute$,
                    this._selectedDate.second$));
            }
        });
        An.onInputChange_(An.onInputFocusSelect_(this._inputMonth), (e) => {
            An.stopevent_(e);
            const month = this._selectedDate.month$;
            const m = An.parseInt_(this._inputMonth.value, month);
            this._inputMonth.value = `${month}`;
            if (m != month) {
                this.refresh(DateTime.local_(
                    this._selectedDate.year$,
                    m,
                    this._selectedDate.day$,
                    this._selectedDate.hour$,
                    this._selectedDate.minute$,
                    this._selectedDate.second$));
            }
        });
        An.onClick_(this._buttonNextYear, (e) => {
            An.stopevent_(e);
            this.refresh(DateTime.local_(
                this._selectedDate.year$ + 1,
                this._selectedDate.month$,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonPrevYear, (e) => {
            An.stopevent_(e);
            this.refresh(DateTime.local_(
                this._selectedDate.year$ - 1,
                this._selectedDate.month$,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonNextMonth, (e) => {
            An.stopevent_(e);
            this.refresh(DateTime.local_(
                this._selectedDate.year$,
                this._selectedDate.month$ + 1,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonPrevMonth, (e) => {
            An.stopevent_(e);
            this.refresh(DateTime.local_(
                this._selectedDate.year$,
                this._selectedDate.month$ - 1,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
    }

    get selectedDate$(): DateTime {
        return this._selectedDate;
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this.refresh(this._selectedDate);
            An.show_(this._container);
        }
    }

    refresh(date: DateTime): void {
        this._selectedDate = date;
        this._inputYear.value = this._selectedDate.year$.toString();
        this._inputMonth.value = An.to02d_(this._selectedDate.month$);
        this._startDate = this._getstartdate(this._selectedDate);
        this._selectedCell = _DatePanel.populate(this._dateContainer, this._today, this._selectedDate, this._startDate);
    }

    private _getstartdate(date: DateTime): DateTime {
        let d = date.subtract_((date.day$ - 1) * DateTime.DAY);
        return (d.weekday$ == 7 ? d : d.subtract_(d.weekday$ * DateTime.DAY));
    }

    static populate(container: HTMLElement, today: DateTime, selecteddate: DateTime, fromdate: DateTime): HTMLElementX {
        const todaystring = An.simpleDateString_(today);
        const selectedstring = selecteddate == null ? null : An.simpleDateString_(selecteddate);
        const month = selecteddate.month$;
        const aday = DateTime.DAY;
        const b = new DomBuilderEx(container).empty_().push_();
        let selectedCell = null;
        for (let r = 0; r < 6; ++r) {
            for (let c = 0; c < 7; ++c) {
                const index = r * 7 + c;
                const classes = sarray_();
                const weekday = fromdate.weekday$;
                if (fromdate.month$ == month) {
                    if (weekday == 0 || weekday == 6) {
                        classes.push(CSS.AnDateHoliday);
                    }
                } else {
                    classes.push(CSS.AnGray);
                }
                const datestring = An.simpleDateString_(fromdate);
                if (datestring == todaystring) {
                    ArrayUt.delete_(classes, CSS.AnDateHoliday);
                    classes.push(CSS.AnBold);
                }
                if (datestring == selectedstring) {
                    classes.push(CSS.AnDateSelected);
                }
                const elm = b
                    .peek_()
                    .div_(
                        ["class", classes.join(" ")],
                        [ATTR.AnInfo, index.toString()],
                    )
                    .text_(fromdate.day$.toString())
                    .cursor_();
                if (datestring == selectedstring) {
                    selectedCell = elm;
                }
                fromdate = fromdate.add_(aday);
            }
        }
        return selectedCell;
    }
}

class _TimePanel extends UIPanelBase {
    _container: HTMLElement;
    _date: DateTime;
    _hourFormatter: HourFormatter;
    _buttonsize: number;

    _hourInput!: HTMLElement;
    _minuteInput!: HTMLElement;
    _hourSlider!: Slider;
    _minuteSlider!: Slider;
    _x4: number;
    _d2: number;
    _shown: boolean = false;
    #destroyed = false;

    constructor(container: HTMLElement, date: DateTime, formatter: HourFormatter, buttonsize: number) {
        super();
        this._container = container;
        this._date = date;
        this._hourFormatter = formatter;
        this._buttonsize = buttonsize;
        this._x4 = buttonsize * 4;
        const b = new DomBuilderEx(container).push_();
        this._d2 = buttonsize / 2;
        const x1 = buttonsize;
        const x2 = buttonsize * 2;
        const x5 = buttonsize * 5;
        const x6 = buttonsize * 6;
        const x7 = buttonsize * 7;
        b.peek_().div_({
            "class": CSS.AnFlexCenter,
            "style": "padding-top: 5px; padding-bottom:5px; "
        }).push_();
        b.peek_().div1_(CSS.AnFlex11Auto);
        this._hourInput = b.peek_().div_({
            "style": `width:${x2}px;text-align:center`,
        }).cursor_();
        b.peek_().div_({
            "class": CSS.AnFlexCenter,
            "style": `width:${this._d2}px;height:${x1}px;`
        }).text_(":");
        this._minuteInput = b.peek_().div_({
            "style": `width:${x2}px;text-align:center`,
        }).cursor_();
        b.peek_().div1_(CSS.AnFlex11Auto);
        b.pop_();
        b.peek_().div_({
            "class": CSS.AnFlex,
            "style": `width:${x7}px;height:${x6}px;padding-top:${this._d2}px; padding-bottom:${x1 -
                this._d2 + 4}px;`,
        }).push_();
        b.peek_().div_({ "style": `flex:1 1 ${this._d2}px` }).peek_();
        this._hourSlider = new Slider(b.cursor_(), x5, this._d2, this._d2, this._d2, true);
        this._marker(b);
        this._minuteSlider = new Slider(b.cursor_(), x5, this._d2, this._d2, this._d2, true);
        b.peek_().div_({ "style": `flex:1 1 ${this._d2}px` });
        b.pop_();
        this._hourSlider.onDrag_((delta: number) => {
            this._sethour1(this._date.hour$ + delta);
        });
        this._hourSlider.onClick_((y: number) => {
            const value = Math.round(y * 23 / this._x4);
            y = this._pxfrompx(23, y);
            this._sethour(value, y);
        });
        this._minuteSlider.onDrag_((delta: number) => {
            this._setminute1(this._date.minute$ + delta);
        });
        this._minuteSlider.onClick_((y: number) => {
            y = this._pxfrompx(59, y);
            const value = Math.round(y * 59 / this._x4);
            this._setminute(value, y);
        });
    }

    private _sethour1(value: number): void {
        if (value == null) {
            return;
        }
        value = (value < 0 ? 0 : value > 23 ? 23 : value);
        const y = this._pxfromvalue(23, value);
        this._sethour(value, y);
    }

    private _sethour(value: number, y: number): void {
        this._date = DateTime.local_(
            this._date.year$,
            this._date.month$,
            this._date.day$,
            value,
            this._date.minute$,
            this._date.second$);
        this._hourSlider.setPosition_(y);
        this._sethourvalue(value);
    }

    private _sethourvalue(h: number): void {
        this._hourInput.textContent = this._hourFormatter(h);
    }

    private _setminute1(value: number): void {
        value = Math.max(0, Math.min(59, value));
        const y = this._pxfromvalue(59, value);
        this._setminute(value, y);
    }

    private _setminute(value: number, y: number): void {
        this._date = DateTime.local_(
            this._date.year$,
            this._date.month$,
            this._date.day$,
            this._date.hour$,
            value,
            this._date.second$);
        this._minuteInput.textContent = `${value}`;
        this._minuteSlider.setPosition_(y);
    }

    private _pxfrompx(range: number, y: number): Int {
        const step = this._x4 / range;
        return Math.round(y / step) * step;
    }

    private _pxfromvalue(range: number, value: number): Int {
        const y = Math.round(value * this._x4 / range);
        return y;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this.refresh(this._date);
            An.show_(this._container);
        }
    }

    destroy(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this._hourSlider.destroy_();
        this._minuteSlider.destroy_();
    }

    element_(): HTMLElement {
        return this._container;
    }

    refresh(date: DateTime): void {
        this._date = date;
        this._sethourvalue(this._date.hour$);
        this._minuteInput.textContent = An.to02d_(this._date.minute$);
        const h = Math.round(this._date.hour$ * this._x4 / 23);
        const m = Math.round(this._date.minute$ * this._x4 / 59);
        this._hourSlider.setPosition_(h);
        this._minuteSlider.setPosition_(m);
    }

    private _marker(b: DomBuilderEx): void {
        const d2 = this._buttonsize / 2;
        const x2 = this._buttonsize * 2;
        const x4 = this._buttonsize * 4;
        b.peek_().push_().div_({
            "class": CSS.AnFlex,
            "style": `flex-basis:${x2 -
                d2}px;flex-flow:column nowrap;align-items:stretch;height:${x4}px`,
        }).push_();
        for (let i = 0; i < 3; ++i) {
            b.peek_().div_({
                "style": `flex-basis:${DEF.BASIS_25}%;box-sizing: border-box;border-top:${DEF.themeBorder};`
            });
        }
        b.peek_().div_({
            "style": `flex-basis:${DEF
                .BASIS_25}%;box-sizing:border-box;border-top:${DEF.themeBorder};border-bottom:${DEF.themeBorder};`
        });
        b.pop_(2);
    }
}

////////////////////////////////////////////////////////////////////////

class _DateFormatPanel extends UIPanelBase {
    static readonly _PADDING = 5;
    _inputDateFormat!: SelectOptions;
    _inputTimeFormat!: SelectOptions;
    _shown: boolean = false;

    constructor(
        private _container: HTMLElement,
        private _dialog: PromptDate
    ) {
        super();
        const buttonsize = _dialog.buttonSize$;
        const b = new DomBuilderEx(_container).push_();
        const x1 = buttonsize;
        const x7 = buttonsize * 7;
        b.peek_().div_({
            "class": CSS.AnFlex,
            "style": `width:${x7}px; height:${x7 + _DateFormatPanel._PADDING * 2}px;` +
                `padding-bottom:${x1 + 4}px;` +
                "flex-wrap:wrap;" +
                "align-items:flex-start;" +
                "align-content:flex-start;",
        }).push_();
        b.peek_().div_({
            "class": CSS.AnHeading,
            "sytle": `width:${x7}px;overflow:hidden;`,
        }).text_(MSG.string_(RS.DateFormat));
        this._inputDateFormat = new SelectOptions(accessories$, b.peek_().div_({
            "class": `${CSS.AnPromptSelect} ${CSS.AnMarginTop5}`,
            "style": `width:${x7}px;margin: 5px 1px;`
        }).cursor_());
        this._inputTimeFormat = new SelectOptions(accessories$, b.peek_().div_({
            "class": `${CSS.AnPromptSelect} ${CSS.AnMarginTop5}`,
            "style": `width:${x7}px;margin: 5px 1px;`
        }).cursor_());
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this.refresh();
            An.show_(this._container);
        }
    }

    refresh(): void {
        let datetime: DateTime | null = null;
        if (this._dialog.hasDatePanel$) {
            datetime = this._dialog.datePanel$.selectedDate$;
            _DateFormatPanel._populateDateFormat(this._inputDateFormat, datetime, this._dialog.preferredDateFormat$, this._dialog.allowAuto$);
        } else {
            this._inputDateFormat.setOptions_([]);
        }
        if (this._dialog.hasTimePanel$) {
            datetime = this._dialog.timePanel$._date;
            _DateFormatPanel._populateTimeFormat(this._inputTimeFormat, datetime, this._dialog.preferredTimeFormat$);
        } else {
            this._inputTimeFormat.setOptions_([]);
        }
    }

    static _populateDateFormat(select: SelectOptions, date: DateTime, preferreddateformat: string, allowauto: boolean): void {
        const oindex = select.getSelectedIndex_();
        const labels = sarray_();
        let selectedindex = -1;
        const full = settings$.dateFormat_();
        const list = DateFormat.formatsOf_(full, allowauto);
        for (let format of list) {
            if (!allowauto && format == preferreddateformat || allowauto && format == "auto") {
                selectedindex = labels.length;
            }
            if (format == "auto") {
                labels.push("auto");
            } else {
                labels.push(DateFormat.dateString_(format, date));
            }
        }
        if (oindex >= 0 && oindex < list.length) {
            selectedindex = oindex;
        }
        select.setOptions_(list, labels, selectedindex);
    }

    static _populateTimeFormat(select: SelectOptions, time: DateTime, preferredtimeformat: string): void {
        const labels = sarray_();
        const list = TimeFormat.formatsOf_(settings$.timeFormat_());
        for (let fmt of list) {
            labels.push(TimeFormat.timeString_(fmt, time));
        }
        let selectedindex = select.getSelectedIndex_();
        if (selectedindex < 0 || selectedindex >= labels.length) {
            selectedindex = list.indexOf(preferredtimeformat);
        }
        select.setOptions_(list, labels, selectedindex);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptCalendar extends FixedSizeDialogBase {
    private _today: DateTime = DateTime.now_();

    private _width!: number;
    private _tabPanel!: TabPanel;
    private _dateTab!: HTMLElement;
    private _datePanel!: _DatePanel;
    private _formatPanel!: _CalendarFormatPanel;

    private _okCallback: PromptCalendarCallback | null = null;
    private _dateFormat: string = DateFormat.DEF;
    #destroyed = false;

    constructor(container: HTMLElement, buttonsize: number) {
        super(container, buttonsize);
        super.init_(this.create_(container));
    }

    get dateFormat$(): string {
        return this._dateFormat;
    }

    get datePanel$(): _DatePanel {
        return this._datePanel;
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infos_(BUT.Today, BUT.OK, BUT.Cancel),
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        const b = new DomBuilderEx(content);
        this._width = this._buttonSize * 7;
        b
            .push_()
            .div_({
                "class": CSS.AnFlex,
                "style": "flex-flow:column nowrap;padding-top:5px;" +
                    `width:${this._width}px;border-top:${DEF.themeBorder};`,
            })
            .push_()
            .cursor_();
        this._createTabpanel(b);
    }

    private _createTabpanel(b: DomBuilderEx): void {
        const top = b.peek_().div_({}).cursor_();
        this._tabPanel = new TabPanel(top, true);
        let tab: HTMLElementX = null;
        this._dateTab = this._tabPanel.addTab(RS.Tooltips_DatePicker, `${CSS.Fa} ${CSS.FaCalendar}`, (elm) => {
            return this._datePanel = new _DatePanel(elm, this._today, this._today, this._buttonSize, this._actionOK);
        });
        tab = this._dateTab;
        this._tabPanel.addTab(RS.Tooltips_DateFormat, `${CSS.Fa} ${CSS.FaQuoteLeft}`, (elm) => {
            return this._formatPanel = new _CalendarFormatPanel(elm, this);
        });
        this._tabPanel.onTooltips(toasters$.onTooltipsKey_);
        this._tabPanel.activeTab(tab);
    }

    show_(): this {
        this._tabPanel.activePanel()?.show_();
        return super.show_();
    }

    close_(): void {
        if (this.#destroyed) return;
        this.#destroyed = true;
        this._okCallback = null;
        super.close_();
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: PromptCalendarCallback): this {
        this._okCallback = callback;
        return this;
    }

    dateFormat_(dateformat: string): this {
        this._dateFormat = dateformat;
        return this;
    }

    width(value: string, unit: string): this {
        DialogUt.setValueUnit_(this._formatPanel._widthValueUnit, value, unit);
        return this;
    }

    height(value: string, unit: string): this {
        DialogUt.setValueUnit_(this._formatPanel._heightValueUnit, value, unit);
        return this;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Today:
                this._datePanel.refresh(this._today);
                this._formatPanel.refresh();
                break;
            case BUT.OK:
                this._actionOK();
                break;
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _actionOK(): void {
        const date = this._datePanel.selectedDate$;
        const ret = DateTime.local_(
            (date == null ? 0 : date.year$),
            (date == null ? 1 : date.month$),
            (date == null ? 1 : date.day$),
            1,
            1,
            1);
        this._formatPanel.refresh();
        const datestring = this._formatPanel._inputDateFormat.getLabel_("");
        const width = DialogUt.getValueUnit_(this._formatPanel._widthValueUnit);
        const height = DialogUt.getValueUnit_(this._formatPanel._heightValueUnit);
        let callback = this._okCallback!;
        this.close_();
        callback(ret, width, height, datestring);
    }

    setInitialFocus_(): void {
        An.focus_(this._toolbar!.button_(BUT.OK));
    }
}

class _CalendarFormatPanel extends UIPanelBase {
    static readonly _WIDTH = "18";
    static readonly _HEIGHT = "28";
    _container: HTMLElement;
    _dialog: PromptCalendar;
    _inputDateFormat: SelectOptions;
    _widthValueUnit: [HTMLTextAreaElement, SelectOptions];
    _heightValueUnit: [HTMLTextAreaElement, SelectOptions];
    _shown: boolean = false;

    constructor(container: HTMLElement, dialog: PromptCalendar) {
        super();
        this._container = container;
        this._dialog = dialog;
        const buttonsize = dialog.buttonSize$;
        const x7 = buttonsize * 7;
        container.style.width = `${x7}px`;
        container.style.height = `${x7 + _DateFormatPanel._PADDING * 2}px`;
        const b = new DomBuilderEx(container).push_();
        this._inputDateFormat = _DialogUt.flexTextSelect_(
            accessories$, b.peek_(), DEF.BASIS_34, MSG.string_(RS.Caption), _DialogUt.placeholder_(RS.Caption));
        this._inputDateFormat.element_().parentElement!.style.paddingTop = `${_DateFormatPanel._PADDING}px`;
        const widthlabel = MSG.string_(RS.Width);
        const heightlabel = MSG.string_(RS.Height);
        this._widthValueUnit = _DialogUt.flexTextInputSelect_(
            accessories$,
            b.peek_(),
            DEF.BASIS_34,
            DEF.BASIS_60,
            widthlabel,
            _CalendarFormatPanel._WIDTH,
            widthlabel,
            "2",
            CSSLength.EM,
            CSSLengths);
        b.addClass_(CSS.AnMarginV5);
        this._heightValueUnit = _DialogUt.flexTextInputSelect_(
            accessories$,
            b.peek_(),
            DEF.BASIS_34,
            DEF.BASIS_60,
            heightlabel,
            _CalendarFormatPanel._HEIGHT,
            heightlabel,
            "3",
            CSSLength.EX,
            CSSLengths);
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this.refresh();
            An.show_(this._container);
        }
    }

    refresh(): void {
        const date = this._dialog.datePanel$.selectedDate$;
        const dateformat = this._dialog.dateFormat$;
        _DateFormatPanel._populateDateFormat(this._inputDateFormat, date, dateformat, false);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptEvent extends CompositeDialogBase {
    static readonly _Desc = "#XWZ";
    static readonly _Repeat = "#X5H";
    static readonly _Color = "#XSo";
    static readonly _Url = "#XwU";
    static readonly _Date = "#XxH";
    static readonly _DoneDesc = "#XxD";
    private _doneMs: LongX = null;
    private _okCallback: JSONCallback | null = null;
    constructor(
        container: HTMLElement,
        buttonsize: number,
        dateformat: string,
        timeformat: string,
        private readonly _baseuri: BaseUri,
        private readonly _event: EventInfo,
    ) {
        super(container, [
            new MillisecondsField(
                "",
                PromptEvent._Date,
                _event.ms$,
                buttonsize,
                RS.PlaceholderRequired,
                dateformat,
                timeformat,
                PromptDate.DATE,
            ),
            new SelectFIeld(
                "", PromptEvent._Repeat, PromptEvent._validateRepeat(_event.repeat$), RS.Repeat,
                MSG.stringArray_(RS.RepeatEvents)
            ),
            new TextAreaField(
                "",
                PromptEvent._Desc,
                _event.desc$,
                RS.Description,
                `${CSS.AnPromptTextarea} ${CSS.AnHalf}`,
            ),
            new ColorField(
                "",
                PromptEvent._Color,
                _event.color$,
                buttonsize,
                RS.Color,
            ),
            new UriFolderField(
                "",
                PromptEvent._Url,
                HumanLink.fromHref_(_event.url$),
                RS.URL,
                _baseuri,
                Callbacks.onLinkFolderButton_,
            ),
            new InputButtonField(
                "",
                PromptEvent._DoneDesc,
                PromptEvent._donestring(_event),
                RS.PlaceholderOptional,
                BUT.Date1,
                () => {
                    new PromptDate(
                        accessories$,
                        DateTime.now_(),
                        DateTime.fromMs_(this._doneMs ?? DateTime.ms_()),
                        PromptDate.DATE | PromptDate.TIME,
                        buttonsize)
                        .zindex_(An.zindexOf_(this.element_(), DEF.zindexAbove10, DEF.zindexPrompt + DEF.zindexAbove10))
                        .dateFormat_(dateformat)
                        .timeFormat_(timeformat)
                        .allowAuto(false)
                        .onOK_((ret: DateTime) => {
                            this._doneMs = ret.millisecondsSinceEpoch$;
                        })
                        .showTab_(PromptDate.DATE);
                }),
        ]);
        if (!_event.done$) this.setVisible_(PromptEvent._DoneDesc, false);
        else this._doneMs = _event.doneMs$ ?? DateTime.ms_();
        this.titleText_(_event.id$);
    }

    static _donestring(event: EventInfo) {
        return An.notempty_(event.doneDesc$) ? event.doneDesc$ : MSG.string_(RS.Done);
    }

    static _validateRepeat(repeat: string): string {
        const a = MSG.stringArray_(RS.RepeatEvents);
        if (repeat != null && a.indexOf(repeat) >= 0) {
            return repeat;
        }
        return a[0];
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    setInitialFocus_(): void {
        this.blurAll();
    };

    onOK_(callback: JSONCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(okcallback: BoolCallback): void {
        const errors = sarray_();
        const ms = this.getIntValue(PromptEvent._Date) ?? -1;
        if (ms < 0) {
            errors.push(MSG.string_(RS.inputMustNotBeEmpty_) + MSG.string_(RS.Date));
        }
        let href = this.getValue_(PromptEvent._Url);
        if (href.length > 0) {
            const uri = An.parseUriSafe_(href, this._baseuri);
            href = uri == null ? "" : uri.toAbsolute_().toString();
        }
        if (errors.length > 0) {
            this.warn_(errors);
            okcallback(false);
            return;
        }
        const ret = new EventInfo(this._event.copy_(
            [EventKey.Ms, ms],
            [EventKey.Lastms, -1],
            [EventKey.Repeat, this.getValue_(PromptEvent._Repeat)],
            [EventKey.Description, this.getValue_(PromptEvent._Desc)],
            [EventKey.Color, this.getValue_(PromptEvent._Color)],
            [EventKey.Url, href],
        )).filterx_();
        if (this._event.done$) {
            ret[EventKey.DoneMs] = this._doneMs ?? this._event.doneMs$ ?? DateTime.ms_();
            ret[EventKey.DoneDesc] = this.getValue_(PromptEvent._DoneDesc);
        }
        const callback = this._okCallback!;
        okcallback(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptCSSLength extends CompositeDialogBase {
    _okCallback: StringCallback | null = null;

    constructor(container: HTMLElement, titlekey: StringId, sizeunit: DoubleStringUnit, placeholder: string = titlekey) {
        super(container, [
            new InputSelectField(
                "",
                "",
                sizeunit[0],
                placeholder,
                sizeunit[1],
                CSSLengths),
        ]);
        this.titleKey_(titlekey);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: StringCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback) {
        const ret = this.getValueAt_(0);
        const callback = this._okCallback!;
        done(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptBorder1 extends CompositeDialogBase {
    private static readonly WIDTH = "#XJ4";
    private static readonly STYLE = "#XDB";
    private static readonly COLOR = "#XDC";
    private static readonly SAMPLE = "#XDS";
    _sample!: HTMLElement;
    _okCallback: StringCallback | null = null;

    constructor(container: HTMLElement, buttonsize: number, width: DoubleStringUnit, style: string, color: string) {
        super(container, [
            new InputSelectField(
                "",
                PromptBorder1.WIDTH,
                width[0],
                RS.PlaceholderRequired,
                width[1],
                CSSLengths
            ),
            new SelectFIeld(
                "",
                PromptBorder1.STYLE,
                style,
                RS.Style,
                [
                    "none",
                    "",
                    "dashed",
                    "dotted",
                    "double",
                    "groove",
                    "hidden",
                    "inset",
                    "outset",
                    "ridge",
                    "solid"
                ]
            ),
            new ColorField("", PromptBorder1.COLOR, color, buttonsize, RS.Color),
            new SampleField(PromptBorder1.SAMPLE, "height:6ex;"),
        ]);
        this._sample = new DomBuilderEx(this.getFieldAt_(3).element_()).div_({
            "style": `border-bottom:${width[0]}${width[1]} ${style} ${color};`
                + "width:50%;height:0;margin-top:20px;",
        }).cursor_();
        this.onChange_((field, _input) => {
            const key = field.spec$.key$;
            const value = field.getValue_();
            if (PromptBorder1.WIDTH == key) {
                this._sample.style.borderBottomWidth = value;
            } else if (PromptBorder1.STYLE == key) {
                this._sample.style.borderBottomStyle = value;
                if (value == "" || value == "none") {
                    this._sample.style.borderBottomWidth = "";
                    this._sample.style.borderBottomColor = "";
                }
            } else if (PromptBorder1.COLOR == key) {
                this._sample.style.borderBottomColor = value;
            }
        });
    }

    onOK_(callback: StringCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const cssstyle = this._sample.style;
        const ret = cssstyle.borderBottom;
        const callback = this._okCallback!;
        done(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class _PromptBordersPanel extends UIPanelBase {
    private _center: HTMLElement;
    constructor(
        private readonly _container: HTMLElement,
        private readonly _buttonSize: Int,
        width: Int,
        styles: Map<string, string>,
        onclick: Fun20<HTMLElement, MouseEvent>,
    ) {
        super();
        const x2 = this._buttonSize * 2;
        const x4 = this._buttonSize * 4;
        const x6 = this._buttonSize * 6;
        const outer = "box-sizing:border-box;background-color:rgba(0, 0, 0, 0.1)";
        const b = new DomBuilderEx(this._container);
        this._container.style.width = `${x6}px`;
        const top = b.div_({
            "class": `${CSS.AnFlexCenter} ${CSS.AnLink}`,
            "style": `width:${width}px;height:${width}px;`,
        }).cursor_();
        this._center = b.div_({
            "class": CSS.AnFlexCenter,
            "style": `${outer};width:${x4}px;height:${x4}px;`,
        }).cursor_();
        b.div_(smap_(
            ["style", `width:${x2}px;height:${x2}px;background-color:rgba(0, 0, 0, 0.1);`],
            [ATTR.AnInfo, "5"],
        ));
        const style = this._center.style;
        if (styles.has(PK.Border)) {
            style.border = styles.get(PK.Border) ?? "";
        } else {
            style.borderTop = styles.get(PK.BorderTop) ?? "";
            style.borderRight = styles.get(PK.BorderRight) ?? "";
            style.borderBottom = styles.get(PK.BorderBottom) ?? "";
            style.borderLeft = styles.get(PK.BorderLeft) ?? "";
        }
        if (styles.has(PK.BorderRadius)) {
            style.borderRadius = styles.get(PK.BorderRadius) ?? "";
        } else {
            style.borderTopLeftRadius = styles.get(PK.BorderTopLeftRadius) ?? "";
            style.borderTopRightRadius = styles.get(PK.BorderTopRightRadius) ?? "";
            style.borderBottomRightRadius = styles.get(PK.BorderBottomRightRadius) ?? "";
            style.borderBottomLeftRadius = styles.get(PK.BorderBottomLeftRadius) ?? "";
        }
        style.boxShadow = styles.get(PK.BoxShadow) ?? "";
        An.onClickMatching_<MouseEvent>(top, `div.${CSS.AnLink}`, (_elm, e) => {
            onclick(this._center, e);
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    center_(): HTMLElement {
        return this._center;
    }
}

class _PromptBordersSamplesPanel extends UIPanelBase {
    constructor(
        private readonly _container: HTMLElement,
        buttonsize: Int,
        samples: SamplesSpec,
        private _onClick: JSONCallback
    ) {
        super();
        const x2 = `${buttonsize * 2}px`;
        const x6 = `${buttonsize * 6}px`;
        const x8 = `${buttonsize * 8}px`;
        const margin = "8px";
        const margin2 = "16px";
        const b = new DomBuilderEx(this._container);
        this._container.style.width = x6;
        b.div_({
            "class": CSS.AnFlex,
            "style": "flex-flow:column nowrap;" + `padding:${margin} ${margin} ${margin} 0;max-height:${x8};overflow:auto;`,
        }).push_();
        for (const e of Object.entries(samples)) {
            const title = e[0];
            const array = e[1];
            b.peek_().div_({ "style": `margin:${margin} auto;` }).text_(title);
            b.peek_().div1_(CSS.AnFlexCenter).push_();
            for (let index = 0; index < array.length; ++index) {
                const [label, styles] = array[index];
                let border = "";
                for (const e of Object.entries(styles)) {
                    border += `${e[0]}:${e[1]};`;
                }
                b.peek_().div_(
                    ["class", `${CSS.AnLink} ${CSS.AnFlexCenter}`],
                    ["style", `margin:${margin};width:calc(${x2} - ${margin2});height:calc(${x2} - ${margin2});${border};`
                        + "box-sizing:border-box;flex:0 0 auto;background-color:rgba(0, 0, 0, 0.1);overflow:hidden;"
                    ],
                    [ATTR.AnInfo, JSON.stringify(styles)],
                ).text_(label);
            }
            b.pop_();
        }
        An.onClickMatching_(this._container, `div.${CSS.AnLink}`, (elm) => {
            const styles = An.parseJSONObjectOrNull_(elm.getAttribute(ATTR.AnInfo));
            if (styles != null) this._onClick(styles);
        });
    }
    destroy(): void {
    }
    element_(): HTMLElement {
        return this._container;
    }
}

class PromptBorders extends CompositeDialogBase {
    static readonly KEYS: string[] = [
        PK.BorderTop,
        PK.BorderRight,
        PK.BorderBottom,
        PK.BorderLeft,
        PK.BorderTopWidth,
        PK.BorderTopStyle,
        PK.BorderRightWidth,
        PK.BorderRightStyle,
        PK.BorderBottomWidth,
        PK.BorderBottomStyle,
        PK.BorderLeftWidth,
        PK.BorderLeftStyle,
        PK.BorderTopLeftRadius,
        PK.BorderTopRightRadius,
        PK.BorderBottomRightRadius,
        PK.BorderBottomLeftRadius,
        PK.BoxShadow,
    ];

    private static readonly SAMPLES: SamplesSpec = smap_(
        [MSG.string_(RS.Border), [
            [MSG.string_(RS.None), smap1_(PK.Border, "none")],
            ["", smap1_(PK.Border, "1px solid rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.Border, "1px dotted rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.Border, "1px dashed rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderBottom, "1px solid rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderBottom, "1px dotted rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderBottom, "1px dashed rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderBottom, "3px double rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderLeft, "5px solid rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderRight, "5px solid rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderTop, "5px solid rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BorderBottom, "5px solid rgba(0, 0, 0, 0.5)")],
        ]],
        [MSG.string_(RS.BorderRadius), [
            [MSG.string_(RS.None), smap1_(PK.BorderRadius, "0px")],
            ["5px", smap1_(PK.BorderRadius, "5px")],
            ["10px", smap1_(PK.BorderRadius, "10px")],
            ["20px", smap1_(PK.BorderRadius, "20px")],
            ["10% 50%", smap1_(PK.BorderRadius, "10%/50%")],
            ["50%", smap1_(PK.BorderRadius, "50%")],
        ]],
        [MSG.string_(RS.BoxShadow), [
            [MSG.string_(RS.None), smap1_(PK.BoxShadow, "none")],
            ["", smap1_(PK.BoxShadow, "2px 2px 5px rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BoxShadow, "2px 2px 10px rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BoxShadow, "0px 0px 10px rgba(0, 0, 0, 0.5)")],
            ["", smap1_(PK.BoxShadow, "2px 2px 5px rgba(0, 0, 0, 0.5) inset")],
            ["", smap1_(PK.BoxShadow, "2px 2px 5px rgba(255, 255, 255,0.5)")],
            ["", smap1_(PK.BoxShadow, "2px 2px 10px rgba(255, 255, 255, 0.5)")],
            ["", smap1_(PK.BoxShadow, "0px 0px 10px rgba(255, 255, 255, 0.5)")],
            ["", smap1_(PK.BoxShadow, "2px 2px 5px rgba(255, 255, 255,0.5) inset")],
        ]],
    );

    private _width: number;
    private _tabPanel!: TabPanel;
    private _center!: HTMLElement;
    private _okCallback: OKCallback1<IDialog, Map<string, string>> | null = null;

    constructor(
        container: HTMLElement,
        private _buttonSize: number,
        styles: Map<string, string>,
    ) {
        super(container, [
            new TabbedPanelField("", [
                new TabField(RS.ActionAddBorderTooltips, `${CSS.Fa} ${CSS.FaSquareO}`, (_ret, _host, container) => {
                    return new _PromptBordersPanel(container, _buttonSize, _buttonSize * 6, styles, (center, e) => {
                        this._onClick(center, e);
                    });
                }),
                new TabField(RS.Tooltips_PickFromSamples, `${CSS.Fa} ${CSS.FaTh}`, (_ret, _host, container) => {
                    return new _PromptBordersSamplesPanel(container, _buttonSize, PromptBorders.SAMPLES, (styles) => {
                        this._onSample(styles);
                    });
                }),
            ]),
        ]);
        this._width = (this._buttonSize * 6);
        this._tabPanel = (this.getFieldAt_(0) as ITabbedPanelField).tabPanel_();
        const panel = this._tabPanel.getPanelAt(0) as _PromptBordersPanel;
        this._center = panel.center_();
        this.onShowDialog_(() => {
            const table = DomUt.query_(this._dialog, `table.${CSS.AnDialog}`);
            if (table != null) table.style.width = "";
            An.setVisible_(this._dialog);
            Timer.sleep0_(() => this.setInitialFocus_());
        });
        this._tabPanel.selectTabAt(0);
    }

    static getBorderStyles_(node: HTMLElement): Map<string, string> {
        return native$.getComputedStylesOf_(node, null, PromptBorders.KEYS);
    }

    private _onSample(styles: JSONObject) {
        this.updateSample_(styles);
        this._tabPanel.selectTabAt(0);
    }

    private updateSample_(styles: JSONObject) {
        const style = this._center.style;
        for (const [name, value] of Object.entries(styles)) {
            style.setProperty(name, value);
        }
    }

    private _onClick(center: HTMLElement, e: MouseEvent) {
        An.stopevent_(e);
        const x = e.clientX;
        const y = e.clientY;
        const rect = center.getBoundingClientRect();
        
        
        
        
        
        const dx = x - rect.left;
        const dy = y - rect.top;
        const x1 = this._buttonSize;
        const x3 = this._buttonSize * 3;
        const x4 = this._buttonSize * 4;
        if (dx < 0 || dy < 0 || dx > x4 || dy > x4) {
            this._promptBoxShadow();
            return;
        }
        if (dy < x1) {
            if (dx < x1) {
                this._promptRadius("1");
            } else if (dx < x3) {
                this._promptBorder("2");
            } else {
                this._promptRadius("3");
            }
        } else if (dy < x3) {
            if (dx < x1) {
                this._promptBorder("4");
            } else if (dx < x3) {
                this._promptBorder("5", () => {
                    this._promptRadius("5");
                });
            } else {
                this._promptBorder("6");
            }
        } else if (dy > x3) {
            if (dx < x1) {
                this._promptRadius("7");
            } else if (dx < x3) {
                this._promptBorder("8");
            } else {
                this._promptRadius("9");
            }
        }
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: OKCallback1<IDialog, Map<string, string>>): this {
        this._okCallback = callback;
        return this;
    }

    private _promptBorder(info: string, next: Fun00 | null = null): void {
        const cssstyle = this._center.style;
        let width = DEF.themeBorderWidthPx;
        let style = "solid";
        let color = DEF.themeBorderColor;
        switch (info) {
            case "1":
            case "2":
            case "3": {
                if (DialogUt.hasBorder_(cssstyle.borderTopWidth, cssstyle.borderTopStyle)) {
                    width = cssstyle.borderTopWidth;
                    style = cssstyle.borderTopStyle;
                    color = cssstyle.borderTopColor;
                }
                break;
            }
            case "4": {
                if (DialogUt.hasBorder_(cssstyle.borderLeftWidth, cssstyle.borderLeftStyle)) {
                    width = cssstyle.borderLeftWidth;
                    style = cssstyle.borderLeftStyle;
                    color = cssstyle.borderLeftColor;
                }
                break;
            }
            case "6": {
                if (DialogUt.hasBorder_(cssstyle.borderRightWidth, cssstyle.borderRightStyle)) {
                    width = cssstyle.borderRightWidth;
                    style = cssstyle.borderRightStyle;
                    color = cssstyle.borderRightColor;
                }
                break;
            }
            case "5":
            case "7":
            case "8":
            case "9": {
                if (DialogUt.hasBorder_(cssstyle.borderBottomWidth, cssstyle.borderBottomStyle)) {
                    width = cssstyle.borderBottomWidth;
                    style = cssstyle.borderBottomStyle;
                    color = cssstyle.borderBottomColor;
                }
                break;
            }
            default:
        }
        let sizeunit = An.doubleStringSizeUnit_(width);
        if (sizeunit == null || !CSSLengths.includes(sizeunit[1])) {
            sizeunit = ["0.00", CSSLength.PX];
        }
        const d = new PromptBorder1(this._container, this._buttonSize, sizeunit, style, color);
        d.titleKey_(RS.Border);
        d.above_(this.element_());
        d.onOK_((style) => {
            switch (info) {
                case "1": {
                    this.updateSample_(smap_(
                        [PK.BorderTop, style],
                        [PK.BorderLeft, style],
                    ));
                    break;
                }
                case "2": {
                    this.updateSample_(smap1_(PK.BorderTop, style));
                    break;
                }
                case "3": {
                    this.updateSample_(smap_(
                        [PK.BorderTop, style],
                        [PK.BorderRight, style],
                    ));
                    break;
                }
                case "4": {
                    this.updateSample_(smap1_(PK.BorderLeft, style));
                    break;
                }
                case "5": {
                    this.updateSample_(smap1_(PK.Border, style));
                    break;
                }
                case "6": {
                    this.updateSample_(smap1_(PK.BorderRight, style));
                    break;
                }
                case "7": {
                    this.updateSample_(smap_(
                        [PK.BorderLeft, style],
                        [PK.BorderBottom, style],
                    ));
                    break;
                }
                case "8": {
                    this.updateSample_(smap1_(PK.BorderBottom, style));
                    break;
                }
                case "9": {
                    this.updateSample_(smap_(
                        [PK.BorderRight, style],
                        [PK.BorderBottom, style],
                    ));
                    break;
                }
                default:
            }
            next?.();
        });
        d.onCancel_(() => {
            next?.();
        });
        d.show_();
    }

    private _promptRadius(info: string, next: Fun00 | null = null): void {
        const cssstyle = this._center.style;
        let radius = DEF.themeBorderRadius;
        switch (info) {
            case "1":
            case "2":
            case "5":
                radius = cssstyle.borderTopLeftRadius;
                break;
            case "3":
            case "6":
                radius = cssstyle.borderTopRightRadius;
                break;
            case "8":
            case "9":
                radius = cssstyle.borderBottomRightRadius;
                break;
            case "4":
            case "7":
                radius = cssstyle.borderBottomLeftRadius;
                break;
            default:
        }
        let values = InputSelect2Field.splitValue(radius, " ");
        if (values == null || !CSSLengths.includes(values[1]) || !CSSLengths.includes(values[3])) {
            values = ["", CSSLength.PX, "", CSSLength.PX];
        }
        const d = new PromptCorner1(this._container, this._buttonSize, values[0], values[1], values[2], values[3]);
        d.titleKey_(RS.Corner);
        d.above_(this.element_());
        d.onOK_((style) => {
            switch (info) {
                case "1": {
                    this.updateSample_(smap1_(PK.BorderTopLeftRadius, style));
                    break;
                }
                case "2": {
                    this.updateSample_(smap_(
                        [PK.BorderTopLeftRadius, style],
                        [PK.BorderTopRightRadius, style]
                    ));
                    break;
                }
                case "3": {
                    this.updateSample_(smap1_(PK.BorderTopRightRadius, style));
                    break;
                }
                case "4": {
                    this.updateSample_(smap_(
                        [PK.BorderTopLeftRadius, style],
                        [PK.BorderBottomLeftRadius, style],
                    ));
                    break;
                }
                case "5": {
                    this.updateSample_(smap1_(PK.BorderRadius, style));
                    break;
                }
                case "6": {
                    this.updateSample_(smap_(
                        [PK.BorderTopRightRadius, style],
                        [PK.BorderBottomRightRadius, style],
                    ));
                    break;
                }
                case "7": {
                    this.updateSample_(smap1_(PK.BorderBottomLeftRadius, style));
                    break;
                }
                case "8": {
                    this.updateSample_(smap_(
                        [PK.BorderBottomLeftRadius, style],
                        [PK.BorderBottomRightRadius, style],
                    ));
                    break;
                }
                case "9": {
                    this.updateSample_(smap1_(PK.BorderBottomRightRadius, style));
                    break;
                }
                default:
            }
            next?.();
        });
        d.onCancel_(() => {
            next?.();
        });
        d.show_();
    }

    private _promptBoxShadow(next: Fun00 | null = null): void {
        let shadow = this._center.style.boxShadow;
        const d = new PromptShadow(this._container, this._buttonSize, PK.BoxShadow, shadow);
        d.titleKey_(RS.BoxShadow);
        d.above_(this.element_());
        d.onOK_((style) => {
            this.updateSample_(smap1_(PK.BoxShadow, style));
            next?.();
        });
        d.onCancel_(() => {
            next?.();
        });
        d.show_();
    }

    protected _onOK(done: BoolCallback): void {
        const style = this._center.style;
        const ret = PromptBorders.normalizeBorderStyles_((name) => style.getPropertyValue(name));
        this._okCallback!(this, ret, done);
    }

    actionCancelConfirmed_() {
        super.actionCancelConfirmed_();
    }

    static normalizeBorderStyles_(getter: Fun11<string, string>): Map<string, string> {
        function normalizeBorder_(
            ret: Map<string, string>,
            top: string,
            right: string,
            bottom: string,
            left: string,
            topwidth: string,
            topstyle: string,
            rightwidth: string,
            rightstyle: string,
            bottomwidth: string,
            bottomstyle: string,
            leftwidth: string,
            leftstyle: string
        ): Map<string, string> {
            if (!DialogUt.hasBorder_(topwidth, topstyle)) {
                top = (topstyle == "" ? "" : "none");
            }
            if (!DialogUt.hasBorder_(rightwidth, rightstyle)) {
                right = (rightstyle == "" ? "" : "none");
            }
            if (!DialogUt.hasBorder_(bottomwidth, bottomstyle)) {
                bottom = (bottomstyle == "" ? "" : "none");
            }
            if (!DialogUt.hasBorder_(leftwidth, leftstyle)) {
                left = (leftstyle == "" ? "" : "none");
            }
            if (top == right && top == bottom && top == left) {
                ret.set(PK.Border, top);
            } else {
                ret.set(PK.BorderTop, top);
                ret.set(PK.BorderRight, right);
                ret.set(PK.BorderBottom, bottom);
                ret.set(PK.BorderLeft, left);
            }
            return ret;
        }

        function normalizeBorderRadius_(topleft: string, topright: string, bottomright: string, bottomleft: string): string {
            const tl = topleft.split(" ");
            const tr = topright.split(" ");
            const bl = bottomleft.split(" ");
            const br = bottomright.split(" ");
            if (tl.length == 1 && tr.length == 1 && bl.length == 1 && br.length == 1) {
                if (topleft == topright && topleft == bottomleft && topleft == bottomright) {
                    return topleft;
                }
                return `${topleft} ${topright} ${bottomright} ${bottomleft}`;
            }
            const tl1 = tl.length == 2 ? tl[1] : tl[0];
            const tr1 = tr.length == 2 ? tr[1] : tr[0];
            const bl1 = bl.length == 2 ? bl[1] : bl[0];
            const br1 = br.length == 2 ? br[1] : br[0];
            return `${tl[0]} ${tr[0]} ${br[0]} ${bl[0]}/${tl1} ${tr1} ${br1} ${bl1}`;
        }

        const ret = normalizeBorder_(
            new Map<string, string>(),
            getter(PK.BorderTop),
            getter(PK.BorderRight),
            getter(PK.BorderBottom),
            getter(PK.BorderLeft),
            getter(PK.BorderTopWidth),
            getter(PK.BorderTopStyle),
            getter(PK.BorderRightWidth),
            getter(PK.BorderRightStyle),
            getter(PK.BorderBottomWidth),
            getter(PK.BorderBottomStyle),
            getter(PK.BorderLeftWidth),
            getter(PK.BorderLeftStyle),
        );
        ret.set(PK.BorderRadius, normalizeBorderRadius_(
            getter(PK.BorderTopLeftRadius),
            getter(PK.BorderTopRightRadius),
            getter(PK.BorderBottomRightRadius),
            getter(PK.BorderBottomLeftRadius),
        ));
        ret.set(PK.BoxShadow, getter(PK.BoxShadow));
        return ret;
    }

    static reduceBorderStyles_(styles: Map<string, string>, inherited: Map<string, string>): Map<string, string> {
        
        
        if (styles.has(PK.Border)) {
            if ((styles.get(PK.Border) ?? "") == (inherited.get(PK.Border) ?? "")) {
                styles.delete(PK.Border);
            }
        } else {
            for (const key of [PK.BorderTop, PK.BorderRight, PK.BorderBottom, PK.BorderLeft]) {
                if ((styles.get(key) ?? "") == (inherited.get(key) ?? "")) {
                    styles.delete(key);
                }
            }
        }
        if ((styles.get(PK.BorderRadius) ?? "") == inherited.get(PK.BorderRadius) ?? "") {
            styles.delete(PK.BorderRadius);
        }
        if ((styles.get(PK.BoxShadow) ?? "") == (inherited.get(PK.BoxShadow) ?? "")) {
            styles.delete(PK.BoxShadow);
        }
        
        return styles;
    }
}

////////////////////////////////////////////////////////////////////////

class PromptCorner1 extends CompositeDialogBase {
    static readonly _XSAMPLE = "#XxD";
    static readonly _HORZ = "#XX8";
    static readonly _VERT = "#XqN";

    _sample!: HTMLElement;
    _okCallback: StringCallback | null = null;

    constructor(container: HTMLElement, buttonsize: number, radius1: string, unit1: string, radius2: string, unit2: string) {
        super(container, [
            new InputSelectField(
                "",
                PromptCorner1._HORZ,
                radius1,
                RS.Horizontal,
                unit1,
                CSSLengths),
            new InputSelectField(
                "",
                PromptCorner1._VERT,
                radius2,
                RS.Vertical,
                unit2,
                CSSLengths,
            ),
            new SampleField(PromptCorner1._XSAMPLE, ""),
        ]);
        const b = buttonsize;
        let value = `${radius1}${unit1}`;
        if (radius2.length > 0) value += ` ${radius2}${unit2}`;
        this._sample = new DomBuilderEx(this.getFieldAt_(2).element_()).div_({
            "style": `width:${b * 2}px;height:${b * 3 / 2}px;margin:30px 0 10px 0;background-color:rgba(0, 0, 0, 0.1);`
                + `border-right:${DEF.themeBorder};`
                + `border-bottom:${DEF.themeBorder};`
                + `border-bottom-right-radius: ${value}`,
        }).cursor_();
        this.onChange_((field, _input) => {
            const key = field.spec$.key$;
            if (PromptCorner1._HORZ == key || PromptCorner1._VERT == key) {
                const value = field.getValue_();
                this._sample.style.borderBottomRightRadius = value;
            }
        });
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: StringCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const h = this.getValue_(PromptCorner1._HORZ);
        const v = this.getValue_(PromptCorner1._VERT);
        let ret = "";
        if (h == "") {
            ret = v;
        } else if (v == "") {
            ret = h;
        } else if (h == v) {
            ret = h;
        } else {
            this._sample.style.borderBottomRightRadius = [h, v].join(" ");
            ret = this._sample.style.borderBottomRightRadius;
        }
        const callback = this._okCallback!;
        done(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptShadow extends CompositeDialogBase {
    static readonly _XSHADOW = "#X71";
    static readonly _XSAMPLE = "#XJv";

    _sample!: HTMLElement;
    _okCallback: StringCallback | null = null;

    constructor(container: HTMLElement, buttonsize: number, property: string, shadow: string) {
        super(container, [
            new InputButtonField(
                "",
                PromptShadow._XSHADOW,
                shadow,
                RS.BoxShadow,
                BUT.Color1,
                () => this._shadowCallback(buttonsize, property),
            ),
            new SampleField(PromptShadow._XSAMPLE, ""),
        ]);
        this._sample = new DomBuilderEx(this.getFieldAt_(1).element_()).div_({
            "style": `width:${buttonsize}px;height:${buttonsize}px;border:${DEF.themeBorder};${property}:${shadow};`
                + "margin:30px 0 10px 0;background-color:rgba(0, 0, 0, 0.1);",
        }).cursor_();
        this.setValue_(PromptShadow._XSHADOW, this._sample.style.getPropertyValue(property));
        this.onChange_((field, _input) => {
            const key = field.spec$.key$;
            if (PromptShadow._XSHADOW == key) {
                this._sample.style.setProperty(property, this.getValue_(key));
            }
        });
    }

    private _shadowCallback(buttonsize: Int, property: string) {
        let value = this.getValue_(PromptShadow._XSHADOW);
        if (An.isempty_(value) || "none" == value || "unset" == value || "inherit" == value) {
            value = DEF.themeBoxShadow;
        }
        const m = RX.CSSColorValue.exec(value);
        const color = (m == null ? "rgba(0,0,0,0.5)" : m[2]);
        const d = Callbacks.promptColor_(buttonsize, An.above_(this.element_()), color, ColorValue.X_TRANSPARENT_DARK);
        d.onOK_((c, format) => {
            if (c != null) {
                const formatted = ColorUtil.formatCSSString_(format, c);
                if (m == null) {
                    this._sample.style.setProperty(property, `${value} ${formatted}`.trim());
                } else {
                    this._sample.style.setProperty(property, (m[1] + formatted + m[3]).trim());
                }
                this.setValue_(PromptShadow._XSHADOW, this._sample.style.getPropertyValue(property));
            }
        });
        d.show_();
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: StringCallback): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        this._sample.style.boxShadow = this.getValue_(PromptShadow._XSHADOW);
        const ret = this._sample.style.boxShadow;
        const callback = this._okCallback!;
        done(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptDoubleUnit extends CompositeDialogBase {

    _okCallback: OKCallback1<IDialog, string> | null = null;

    constructor(container: HTMLElement, labelkey: StringId, sizeunit: DoubleUnit) {
        super(container, [
            new InputSelectField(
                labelkey,
                "",
                `${sizeunit[0]}`,
                RS.PlaceholderRequired,
                sizeunit[1],
                CSSLengths
            ),
        ]);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: OKCallback1<IDialog, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        const ret = this.getValueAt_(0);
        this._okCallback!(this, ret, (ok) => {
            done(ok);
        });
    }
}

////////////////////////////////////////////////////////////////////////

class PromptFont extends DialogBase {
    static readonly W$ = 240;
    static readonly H$ = 48;
    static readonly Y$ = 16;
    private _okCallback: StringCallback | null = null;
    private _viewport!: HTMLElement;
    private _image!: HTMLImageElement;

    constructor(
        container: HTMLElement,
        private _buttonSIze: number,
        ofamilystyle: string,
        familystyles: string[],
        url: string
    ) {
        super(container);
        super.init_(this.create_(container));
        this._onShowDialogCallback = () => {
            An.onLoad_(this._image, () => {
                An.showHidden_(this._dialog, "block");
                this._promptFontResizer();
                if (!An.isempty_(ofamilystyle)) {
                    const index = familystyles.indexOf(ofamilystyle);
                    if (index > 0) {
                        const y = Math.round(index * PromptFont.H$ * PromptFont.W$ / this._image.naturalWidth);
                        this._viewport.scrollTop = (y <= 0 ? 0 : y);
                    }
                }
                this._promptFontResizer();
                An.onClick_(this._image, (e) => {
                    const offset = An.documentOffset_(this._image);
                    const y = Math.round(e.pageY) - Math.round(offset.y) + this._viewport.scrollTop;
                    const index = Math.floor((y * this._image.naturalWidth / PromptFont.W$ - PromptFont.Y$) / PromptFont.H$);
                    if (index < familystyles.length) {
                        const familystyle = familystyles[index];
                        
                        const callback = this._okCallback!;
                        this.close_();
                        callback(familystyle);
                        return;
                    }
                });
                An.setVisible_(this._dialog);
                Timer.sleep0_(() => this.setInitialFocus_());
            });
            this._image.src = url;
        };
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithContentOnly(container, (content) => {
            const b = new DomBuilderEx(content);
            this._viewport = content;
            this._image = b.img_({ "style": `width:${PromptFont.W$}px` }).cursor_() as HTMLImageElement;
        });
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    protected _allowTouchmove(): boolean {
        return true;
    }

    onSmokescreenCreated_(sm: Smokescreen): void {
        super.onSmokescreenCreated_(sm);
        sm.on_(Conf.pointerend$, (e) => {
            An.stopevent_(e);
            this.actionCancel_();
        });
    }

    protected _onResize(): void {
        this._promptFontResizer();
    }

    private _promptFontResizer() {
        const winheight = window.innerHeight;
        const winwidth = window.innerWidth;
        const width = PromptFont.W$;
        const height = (this._image.naturalHeight * width) / this._image.naturalWidth;
        const h = Math.round(Math.min(
            height,
            Math.min(
                winheight - 40 - DEFUtil.dialogChromeHeight_(this._buttonSIze),
                height + 4)));
        const w = width;
        const x = Math.round((winwidth - PromptFont.W$ - DEFUtil.dialogChromeWidth_(this._buttonSIze)) / 2);
        const y = 20;
        const table = DomUt.query_(this._dialog, `table.${CSS.AnDialog}`);
        With.optional_(table?.style, (style) => {
            style.paddingRight = "0";
            style.minWidth = "0";
            style.width = "";
        });
        this._viewport.style.height = `${h}px`;
        this._viewport.style.width = `${w}px`;
        this._dialog.style.left = `${x}px`;
        this._dialog.style.top = `${y}px`;
    }

    onOK_(cb: StringCallback): this {
        this._okCallback = cb;
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

interface IPromptSymbolHandler {
    readonly category$: string;
    readonly recents$: JSONObject[];
    settings(): Settings;
    getGestureHandler(): IGestureHandler;
    updateSymbolCategory(family: stringX, callback: Fun00): void;
    updateRecentsSymbol(fontfamily: string, name: string, text: string): void;
    showSpinner(show: boolean): void;
}

class PromptSymbol extends FullscreenDialogBase {
    static recents: string = MSG.string_(RS.Recents);
    _settings: Settings;
    _buttonSize: number;
    _fontSize: number;
    _searchbox!: AnInputElement;
    _selectFontname!: SelectOptions;
    _symbolList!: HTMLElement;

    _okCallback: PromptSymbolCallback | null = null;
    _oCategory: stringX = null;
    _category: stringX = null;
    _ulStore = new Map<string, HTMLElement>();
    _tooltipsTimer: Timer | null = null;
    _tooltipsShown: boolean = false;

    constructor(
        container: HTMLElement,
        private _handler: IPromptSymbolHandler
    ) {
        super(container, _handler.getGestureHandler());
        this._settings = _handler.settings();
        this._buttonSize = this._settings.current_().buttonSize$;
        this._fontSize = this._buttonSize * 5 / 8;
        super.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createFullscreenDialog_(
            container,
            (b) => this._createFullscreenToolbar(b),
            (b) => this._createFullscreenContent(b));
    }

    private _createFullscreenToolbar(b: DomBuilderEx): Toolbar {
        const toolbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, null, [
            smap_(
                ["rows", "1"],
                ["class", CSS.AnSearchbox],
                ["placeholder", MSG.string_(RS.Filter)],
                ["tabindex", "1"],
                [ATTR.autocapitalize, "none"],
                [ATTR.autocomplete, "off"],
                [ATTR.autocorrect, "off"],
                [ATTR.spellcheck, "false"],
            ),
            BUT.info_(BUT.Cancel),
        ]);
        toolbar.onAction_((action) => this._toolbarActions(action));
        this._searchbox = toolbar.element_().querySelector<HTMLTextAreaElement>(Conf.input$)!;
        An.onInputFocusSelect_(this._searchbox).addEventListener("input", () => {
            this._filter();
        });
        this._container.addEventListener("contextmenu", (e) => {
            An.stopevent_(e);
        });
        return toolbar;
    }

    private _createFullscreenContent(b: DomBuilderEx): void {
        b.div_().push_().div_({
            "class": CSS.AnFlex,
            "style": "padding: 5px;"
        });
        this._selectFontname = new SelectOptions(accessories$, b.div_({
            "class": CSS.AnPromptSelect,
            "style": "flex-basis:100%",
        }).cursor_());
        this._selectFontname.onChange_((value: string) => {
            Timer.sleep0_(() => {
                this._show1(value, this._buttonSize);
            });
        });
        const values = [PromptSymbol.recents];
        const labels = [PromptSymbol.recents];
        const family = this._handler.category$;
        let selectedindex = 0;
        for (let info of this._settings.symbolFamilies_()) {
            const name = info.fontname$;
            if (DEF.Emoji == name) {
                continue;
            }
            let label = name[0].toUpperCase() + name.substring(1);
            if (label.endsWith("-Regular")) {
                label = label.substring(0, label.length - 8);
            }
            if (name == family) {
                selectedindex = values.length;
            }
            values.push(name);
            labels.push(label);
        }
        this._selectFontname.setOptions_(values, labels, selectedindex);
        this._symbolList = b.peek_().div_({
            "class": CSS.AnViewport,
            "style": "padding: 5px;"
        }).cursor_();
        b.pop_();
    }

    showFullscreen_(): void {
        this.onResize_();
        const family = this._selectFontname.getValue_("");
        this._show1(family, this._buttonSize);
        An.setVisible_(this._dialog);
        Timer.sleep0_(() => { host$.hideKeyboard0_(); });
    }

    close_(): void {
        this._stopTooltipsTimer();
        for (let e of this._ulStore.values()) {
            e.remove();
        }
        this._ulStore.clear();
        this._okCallback = null;
        super.close_();
    }

    setInitialFocus_() {
        An.focus_(this._selectFontname.element_());
    }

    /// @param callback(bool)
    onOK_(callback: PromptSymbolCallback): this {
        this._okCallback = callback;
        return this;
    }

    onResize_(): void {
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        const rect = this._symbolList.getBoundingClientRect();
        const top = Math.round(rect.top);
        const maxwidth = winwidth - 5 * 2;
        const maxheight = winheight - top - 5;
        An.setRectangle_(this._symbolList, 0, top, maxwidth, maxheight);
    }

    private _show1(category: string, _buttonsize: number): void {
        this._oCategory = this._category;
        this._category = category;
        if (category != this._oCategory) {
            if (this._oCategory != null) {
                const oul = this._ulStore.get(this._oCategory)!;
                An.hide_(oul);
            }
            const ul = this._ulStore.get(category);
            if (ul !== undefined) {
                An.show_(ul);
            } else if (category == PromptSymbol.recents) {
                this._showrecents();
            } else {
                this._showsymbols(this._symbolinfo(this._settings.symbolFamilies_(), category));
            }
            this._filter();
        }
    }

    private _symbols(): Element[] {
        const ul = this._category == null ? undefined : this._ulStore.get(this._category);
        if (ul === undefined) {
            return [];
        }
        
        return Array.from(ul.children);
    }

    private _filter(): void {
        const searchtext = this._searchbox.value.toLowerCase();
        const lis = this._symbols();
        if (searchtext.length == 0) {
            for (let li of lis) {
                An.show_(li as HTMLElement);
            }
        } else {
            for (let li of lis) {
                const lcname = li.getAttribute(ATTR.xTooltips);
                if (lcname != null && lcname.includes(searchtext)) {
                    An.show_(li as HTMLElement);
                } else {
                    An.hide_(li as HTMLElement);
                }
            }
        }
    }

    private _symbolinfo(families: FontInfo[], name: string): FontInfo | null {
        for (const info of families) {
            if (info.fontname$ == name) {
                return info;
            }
        }
        return null;
    }

    private _showrecents(): void {
        const infos = this._handler.recents$.map<[string, JSONObject]>((info) => {
            return [SymbolInfo.family_(info) + FS + SymbolInfo.name_(info), info];
        }).sort((a, b) => a[0].localeCompare(b[0]))
            .map(([_key, value]) => value);
        const b = DomBuilderEx.offline_(this._symbolList.ownerDocument, "ul", {
            "class": CSS.AnSymbolList,
            "style": `font-size:${this._fontSize}px;`,
        }).push_();
        for (let info of infos) {
            if (!info) continue;
            const family = SymbolInfo.family_(info);
            const name = SymbolInfo.name_(info);
            const text = SymbolInfo.text_(info);
            b.peek_().li_(
                [ATTR.xTooltips, name],
                ["style", `font-family: \"${family}\"`],
            ).text_(text);
        }
        const ul = b.pop_().cursor_();
        new DomBuilderEx(this._symbolList).appendNodes_(ul);
        this._ulStore.set(PromptSymbol.recents, ul);
        this._setupHandlers(ul);
    }

    private _showsymbols(info: FontInfo | null): void {
        if (info == null) { return; }
        const glyphs = info.glyphs$;
        if (glyphs == null) { return; }
        const family = info.fontname$;
        const glyphnames = info.glyphnames$;
        const b = DomBuilderEx.offline_(this._symbolList.ownerDocument, "ul", {
            "class": CSS.AnSymbolList,
            "style": `font-family:${family}; font-size:${this._fontSize}px;`,
        }).push_();
        for (let i = 0; i < glyphs.length; ++i) {
            const c = glyphs[i];
            b.peek_().li_(
                [ATTR.xTooltips, (glyphnames != null ? glyphnames[i] : An.xhex_(c, 4))],
                //// Currently, only Fontawesome has names and all names are in lowercase.
                //// So we don't need to put a lowercase text in ATTR.xInfo. But in case display name
                //// may have uppercase letters, the search should match against the lowercase
                //// ATTR.xInfo instead.
            ).text_(String.fromCharCode(c));
        }
        const ul = b.pop_().cursor_();
        new DomBuilderEx(this._symbolList).appendNodes_(ul);
        this._ulStore.set(family, ul);
        this._setupHandlers(ul);
    }

    private _setupHandlers(ul: HTMLElement): void {
        An.onClickMatching_(ul, "li", (elm, e) => {
            An.stopevent_(e);
            this._ok(elm);
        });
        if (Conf.useFlash$) {
            new Flash(ul, "li", CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        An.onEventMatching_(ul, Conf.pointerstart$, "li", (target, e) => {
            this._stopTooltipsTimer();
            this._tooltipsShown = false;
            this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                An.stopevent_(e);
                this._tooltipsTimer = null;
                this._tooltipsShown = true;
                this._showTooltips(target);
            });
        });
        ul.addEventListener(Conf.pointerend$, (e) => {
            this._stopTooltipsTimer();
            if (this._tooltipsShown) {
                An.stopevent_(e);
                toasters$.hideInfo_();
                this._tooltipsShown = false;
            }
        });
    }

    private _stopTooltipsTimer(): void {
        if (this._tooltipsTimer != null) {
            this._tooltipsTimer.cancel_();
            this._tooltipsTimer = null;
        }
    }

    private _showTooltips(elm: HTMLElement, attop: boolean = true): void {
        if (elm == null) {
            return;
        }
        const name = elm.getAttribute(ATTR.xTooltips);
        if (name == null) {
            return;
        }
        toasters$.info_(name, { attop: attop });
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Cancel:
                toasters$.hideInfo_();
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _ok(elm: HTMLElement): void {
        const text = elm.textContent ?? "";
        const name = elm.getAttribute(ATTR.xTooltips);
        const fontfamily = An.getComputedStyle_(elm)?.fontFamily ?? null;
        if (fontfamily != null && name != null) {
            this._handler.updateRecentsSymbol(fontfamily, name, text);
        }
        this._handler.updateSymbolCategory(this._category, () => {
            toasters$.hideInfo_();
            const callback = this._okCallback!;
            this.close_();
            callback(text, name, smap1_("font-family", fontfamily));
        });
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class PromptUndo extends DialogBase {
    _okCallback: IntXCallback | null = null;
    _content!: HTMLElement;
    _selected: HTMLElementX = null;
    _selectedIndex: numberX = null;

    constructor(
        container: HTMLElement,
        private _history: ICommandHistory
    ) {
        super(container);
        super.init_(this.create_(container));
        An.onClickMatching_(this._content, `div[${ATTR.AnInfo}]`, (elm, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(elm.getAttribute(ATTR.AnInfo), -1);
            this._select(elm as HTMLElement, index);
        });
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infos_(BUT.Undo, BUT.Cancel),
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        this._content = content;
        const style = content.style;
        style.minHeight = "25vh";
        style.border = DEF.themeBorder;
        style.marginTop = "5px";
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: IntXCallback): this {
        this._okCallback = callback;
        return this;
    }

    private _select(elm: HTMLElement, index: number): void {
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelected);
            if (this._selectedIndex == index) {
                this._selected = null;
                this._selectedIndex = null;
                return;
            }
        }
        elm.classList.add(CSS.AnSelected);
        this._selected = elm;
        this._selectedIndex = index;
    }

    private _refresh(): void {
        const b = new DomBuilderEx(this._content)
            .div1_(CSS.AnTextList, CSS.AnZebra).push_();
        const len = this._history.length_();
        for (let i = len - 1; i >= 0; --i) {
            const label = An.truncate_(this._history.getDescription_(i), DEF.historyTextLength);
            b.peek_().div_(
                [ATTR.AnInfo, `${len - i}`],
            ).text_(label);
            if (this._selected == null) {
                this._select(b.cursor_(), 1);
            }
        }
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Cancel:
                const cb = this._cancelCallback;
                this.close_();
                cb?.();
                break;
            case BUT.Undo:
                const index = this._selectedIndex;
                const callback = this._okCallback!;
                this.close_();
                callback(index);
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    showDialog_(resizer: Fun10<DialogBase>): void {
        An.showHidden_(this._dialog, "block");
        this._smokescreen = new Smokescreen(this._container, An.zindexOf_(this._dialog, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
        this._smokescreen.on_("click", (e) => {
            An.stopevent_(e);
            const cb = this._cancelCallback;
            this.close_();
            cb?.();
        });
        if (resizer != null) {
            resizer(this);
            this._onWindowResize(() => {
                resizer(this);
            });
        }
        this._smokescreen.show_();
        this._refresh();
        An.setVisible_(this._dialog);
        if (this._dragger == null && this._dragHandler != null) {
            this._dragger = new Dragger(this._dialog, this._dragHandler).bind_();
        }
    }
}

//////////////////////////////////////////////////////////////////////////

/// Public utilities.
abstract class DialogUt {
    /// @return The select element, cursor stay the same.
    static flexSelect1_(container: HTMLElement, b: DomBuilderEx): SelectOptions {
        return new SelectOptions(container, b.push_().div1_(CSS.AnPromptSelect).cursorPop_());
    }

    static textSelect_(container: HTMLElement, b: DomBuilderEx, text: string, placeholder: string): SelectOptions {
        b.div1_(CSS.AnFlex, CSS.AnMarginV5);
        return this.flexTextSelect1_(container, b, DEF.BASIS_40, text, placeholder);
    }

    /// @return The select element, cursor stay the same.
    static flexTextSelect1_(container: HTMLElement, b: DomBuilderEx, textbasis: number, text: string, placeholder: string): SelectOptions {
        b.push_();
        if (textbasis > 0) {
            b.div_({
                "class": CSS.AnRightAlignLabel,
                "style": `flex-basis:${textbasis}%`,
            }).text_(text);
        }
        const ret = new SelectOptions(container, b.peek_().div_(
            ["class", CSS.AnPromptSelect],
            ["style", `flex-basis:${100 - textbasis}%`],
            [ATTR.placeholder, placeholder],
        ).cursor_());
        b.pop_();
        return ret;
    }

    static populateFileInfoList_(
        b: DomBuilderEx,
        labels: FileInfo[],
        listener: UIUt$.CheckboxSelectListener,
        updateheader: Fun30X<HTMLElement, Int, Int>,
        selectcallback: Fun11<string, boolean>,
    ) {
        this.populateCheckboxList1_(b, listener, updateheader, () => {
            return DialogUt.createFileInfoList_(b, labels, selectcallback);
        });
    }

    static populateDeleteInfoList_(
        b: DomBuilderEx,
        labels: Map<string, DeleteInfo>,
        listener: UIUt$.CheckboxSelectListener,
        updateheader: Fun30X<HTMLElement, Int, Int>,
        selectcallback: Fun11<string, boolean>,
    ) {
        this.populateCheckboxList1_(b, listener, updateheader, () => {
            return DialogUt.createDeleteInfoList_(b, labels, selectcallback);
        });
    }

    static populateNotCopyingInfoList_(
        b: DomBuilderEx,
        notcopying: Map<string, Array<string>>,
        titlecallback: Fun11<Int, string>,
    ): void {
        if (notcopying.size > 0) {
            let count = 0;
            const heading = b.peek_().div1_(CSS.AnHeading).cursor_();
            b.peek_().div1_(CSS.AnPromptList).push_();
            for (const [k, v] of notcopying.entries()) {
                const len = v.length;
                count += len;
                b.peek_().div_().text_(`${k} : ${len}`);
                b.peek_().ul_().push_();
                for (let i = 0; i < len; ++i) {
                    b.peek_().li_().text_(v[i]);
                }
                b.pop_();
            }
            b.pop_();
            const msg = titlecallback(count);
            new DomBuilderEx(heading).text_(msg);
        }
    }

    static populateOverwritingInfoList_(
        b: DomBuilderEx,
        labels: Map<string, CopyInfo>,
        listener: UIUt$.CheckboxSelectListener,
        updateheader: Fun30X<HTMLElement, Int, Int>,
        selectcallback: Fun11<string, boolean>,
    ) {
        this.populateCheckboxList1_(b, listener, updateheader, () => {
            return labels.size > 0 ? DialogUt.createCopyInfoList_(b, labels, selectcallback) : [0, 0];
        });
    }

    static populateCheckboxList1_(
        b: DomBuilderEx,
        listener: UIUt$.CheckboxSelectListener,
        updateheader: Fun30X<HTMLElement, Int, Int>,
        createCheckboxList: Fun01<[Int, Int]>,
    ): HTMLElement {
        const update = (header: HTMLElement, checked: Int, total: Int) => {
            updateheader?.(header, checked, total);
        };
        b.peek_().div_(
            ["class", `${CSS.AnHeading} ${CSS.AnFlexRowNoWrap}`],
            [ATTR.xTooltips, MSG.string_(RS.ToggleAll)],
        ).push_();
        const toggleallbutton = b.child_("input", {
            "type": "checkbox",
            "style": "margin-left:0.5em;margin-right:0.75em;",
        }).cursor_() as HTMLInputElement;
        const header = b.pop_().span_({
            "style": "flex:1 1 auto;",
        }).text_("").cursor_();
        const checklist = b.peek_().div_({
            "class": CSS.AnPromptChecklist,
            "style": "margin-bottom: 1.5ex;",
        }).push_().cursor_();
        const [selected, total] = createCheckboxList();
        b.pop_();
        update(header, selected, total);
        toggleallbutton.checked = (selected != 0);
        const toggleall = (selectall: boolean) => {
            let checked = 0;
            let total = 0;
            for (let e of DomUt.queryAll_<HTMLInputElement>(checklist, "input[type=checkbox], input[type=radio]")) {
                ++total;
                if (!e.disabled) e.checked = selectall;
                if (e.checked) checked += 1;
            }
            update(header, checked, total);
        };
        An.onClick_(header, (e) => {
            An.stopevent_(e);
            toggleallbutton.checked = !toggleallbutton.checked;
            toggleall(toggleallbutton.checked);
        });
        An.onChange_(toggleallbutton, () => {
            toggleall(toggleallbutton.checked);
        });
        An.onClickMatching_(checklist, `input`, (_div, e) => {
            An.stopevent_(e);
        });
        listener.addSelector_(new UIUt$.CheckboxSelector(checklist, () => {
            if (updateheader == null) return;
            let checked = 0;
            let total = 0;
            for (let e of DomUt.queryAll_<HTMLInputElement>(checklist, "input[type=checkbox], input[type=radio]")) {
                ++total;
                if (e.checked) checked += 1;
            }
            update(header, checked, total);
        }));
        return header;
    }

    private static createCopyInfoList_(
        b: DomBuilderEx,
        labels: Map<string, CopyInfo>,
        selectcallback: Fun11<string, boolean>
    ): [Int, Int] {
        const df = new AutoDateFormatter();
        let selected = 0;
        for (const [label, [sdir, ddir, size, date]] of labels.entries()) {
            const styles = sdir ? [CSS.xBold] : [];
            if (ddir != sdir) styles.push(CSS.xBlue);
            if (this.createFileInfoCheckbox_(b, selectcallback, df, styles, sdir, size, date, label)) {
                ++selected;
            }
        }
        return [selected, labels.size];
    }

    private static createFileInfoList_(
        b: DomBuilderEx,
        infos: FileInfo[],
        selectcallback: Fun11<string, boolean>
    ): [Int, Int] {
        const df = new AutoDateFormatter();
        let selected = 0;
        for (const info of infos) {
            const styles = info.isdir$ ? [CSS.xBold] : [];
            if (this.createFileInfoCheckbox_(b, selectcallback, df, styles, info.isdir$, info.size$, info.date$, info.name$)) {
                ++selected;
            }
        }
        return [selected, infos.length];
    }

    private static createDeleteInfoList_(
        b: DomBuilderEx,
        labels: Map<string, DeleteInfo>,
        selectcallback: Fun11<string, boolean>
    ): [Int, Int] {
        const df = new AutoDateFormatter();
        let selected = 0;
        for (const [label, [isdir, size, date]] of labels.entries()) {
            const styles = isdir ? [CSS.xBold] : [];
            if (DialogUt.createFileInfoCheckbox_(b, selectcallback, df, styles, isdir, size, date, label)) {
                ++selected;
            }
        }
        return [selected, labels.size];
    }

    private static createCheckbox_(
        b: DomBuilderEx,
        styles: string[],
        stat: string,
        label: string,
        name: stringX = null,
        value: stringX = null) {
        const attrs = smap_(
            ["type", "checkbox"],
            [ATTR.AnInfo, value ?? label],
        );
        if (name != null) attrs[ATTR.name$] = name;
        const e = b.peek_().div_().push_().div1_(CSS.AnPromptCheckboxInput).input_(attrs).cursor_() as HTMLInputElement;
        b.peek_().child1_("code", CSS.AnGray).text_(stat);
        b.pop_().child_("span").addClasses_(styles).text_(label);
        return e;
    }

    static createRadioButton_(
        b: DomBuilderEx,
        styles: string[],
        stat: string,
        label: string,
        name: string,
        value: stringX = null) {
        const e = b.peek_().div_().push_().div1_(CSS.AnPromptCheckboxInput).input_(smap_(
            ["type", "radio",],
            ["name", name],
            [ATTR.AnInfo, value ?? label]
        )).cursor_() as HTMLInputElement;
        b.peek_().child1_("code", CSS.AnGray).text_(stat);
        b.pop_().child_("span").addClasses_(styles).text_(label);
        return e;
    }

    static createCheckboxRow_(b: DomBuilderEx, attrs: [[string, string]], text: string): HTMLInputElement {
        const input = b.input_(ssmap_(
            ["type", "checkbox"],
            ...attrs,
        )).cursor_() as HTMLInputElement;
        const label = b.siblingAfter_("span", {
            "style": "margin-left:0.75em;flex:1 1 auto;"
        }).text_(text).cursor_();
        An.onClick_(label, (e) => {
            An.stopevent_(e);
            input.checked = !input.checked;
        });
        return input;
    }

    static createFileInfoCheckbox_(
        b: DomBuilderEx,
        selectcallback: Fun11<string, boolean>,
        df: AutoDateFormatter,
        styles: string[],
        isdir: boolean,
        size: Long,
        date: Long,
        label: string,
        name: stringX = null,
        value: stringX = null,
    ) {
        const stat = df.format(date) + (isdir ? "" : FileInfo._sizeunit7(size)) + "\u00a0";
        const e = this.createCheckbox_(b, styles, stat, label, name, value);
        if (selectcallback(label)) {
            e.checked = true;
            return true;
        }
        return false;
    }

    /// @param values The font names to starts with, either [] or [""].
    static populateFontName_(
        select: SelectOptions,
        values: string[],
        families: FontInfo[],
        cat: string,
        selected: string
    ): void {
        const selectedindex = FontUtil.getFontNames_(values, families, cat, selected);
        select.setOptions_(values, null, selectedindex);
    }

    static populateFontStyle_(
        select: SelectOptions,
        values: string[],
        fontinfo: FontInfo | null,
        fontstyle: string
    ): stringX {
        const selectedindex = FontUtil.getFontStyles_(values, fontinfo, fontstyle);
        select.setOptions_(values, null, selectedindex);
        return selectedindex < 0 ? null : values[selectedindex];
    }

    static setTooltipsHandler_(elm: HTMLElement): void {
        elm.addEventListener("contextmenu", (e) => { toasters$.onTooltipsKey_(elm, e); });
    }

    static setButtonTooltipsHandler_(e: HTMLElement): void {
        An.onContextmenuMatching_(e, `button[${ATTR.xTooltips}]`, toasters$.onTooltipsKey_);
    }

    static promptOK_(container: HTMLElement, titlekey: StringId, msg: TestResult, callback: BoolCallback): PromptOK {
        const d = new PromptOK(container, titlekey, msg, DEF.zindexConfirm);
        d.onOK_(() => {
            callback(true);
        });
        d.onCancel_(() => {
            callback(false);
        });
        return d;
    }

    static warnSmall_(container: HTMLElement, titlekey: StringId, msgkey: StringId, zindex: number, callback: BoolCallback) {
        DialogUt.promptOK_(container, titlekey, MSG.string_(msgkey), callback)
            .smallWidth_()
            .zindex_(zindex)
            .showWarning_();
    }

    static errorSmall_(container: HTMLElement, titlekey: StringId, msgkey: StringId, zindex: number, callback: BoolCallback) {
        DialogUt.promptOK_(container, titlekey, MSG.string_(msgkey), callback)
            .smallWidth_()
            .zindex_(zindex)
            .showError_();
    }

    static confirm_(container: HTMLElement, msg: TestResult, callback: BoolCallback): PromptOK {
        return DialogUt.promptOK_(container, RS.Confirm, msg, callback);
    }

    static confirmKeySmall_(container: HTMLElement, msgkey: StringId, zindex: number, callback: BoolCallback) {
        this.confirmSmall_(container, MSG.string_(msgkey), zindex, callback);
    }

    static confirmSmall_(container: HTMLElement, msg: TestResult, zindex: number, callback: BoolCallback) {
        this.confirm_(container, msg, callback)
            .smallWidth_()
            .zindex_(zindex)
            .showWarning_();
    }

    static confirmOverwriting_(msg: TestResult, callback: BoolCallback): void {
        DialogUt.promptOK_(accessories$, RS.ConfirmOverwriting, msg, callback)
            .smallWidth_()
            .showWarning_();
    }

    static getValueUnit_(valueunit: [HTMLTextAreaElement, SelectOptions]): string {
        let value = valueunit[0].value;
        if (!An.isempty_(value)) {
            const unit = valueunit[1].getValue_("");
            value += unit;
        }
        return value;
    }

    static setValueUnit_(valueunit: [HTMLTextAreaElement, SelectOptions], value: string, unit: string): void {
        valueunit[0].value = value;
        valueunit[1].setValue_(unit);
    }

    static setPathKind_(button: HTMLElement, absolute: boolean) {
        An.classlist_(button)
            .add_(absolute ? CSS.AnButtonDown : CSS.AnButtonFlat)
            .remove_(absolute ? CSS.AnButtonFlat : CSS.AnButtonDown);
    }

    static getPathKind_(button: HTMLElementX | undefined): boolean {
        return button === null || button === undefined || button.classList.contains(CSS.AnButtonDown);
    }

    static onFilepathKindButton_(pathkind: HTMLElement, filepath: string, basedir: string,): [string, boolean] {
        const absolute = An.classlist_(pathkind).toggleAll_(CSS.AnButtonDown, CSS.AnButtonFlat).contains_(CSS.AnButtonDown);
        const path = Callbacks.getFilepathOfKind_(absolute, filepath, basedir);
        return [path, absolute];
    }

    static promptColorInput_(
        b: DomBuilderEx, placeholder: stringX, tabindex: string, color: string, csscolor: string): [input: HTMLTextAreaElement, cell: HTMLElement] {
        b.push_();
        const colorinput = b.flexInput_(100, placeholder, tabindex);
        const colorcell = b.peek_().div1_(CSS.AnFlex0, CSS.AnColorCell).cursor_();
        b.pop_();
        colorinput.value = color;
        colorcell.style.backgroundColor = csscolor;
        return [colorinput, colorcell];
    }

    static promptColorStopsInput_(b: DomBuilderEx, colors: ColorStops): HTMLElement[] {
        const ret: HTMLElement[] = [];
        b.push_();
        for (let index = 0; index < colors.length; ++index) {
            const stop = colors[index];
            const e = b.peek_().div_({
                "class": `${CSS.AnFlex11Auto} ${CSS.AnSmall} ${CSS.AnFlexCenter}`,
                "style": "overflow:hidden;line-height:3ex;",
            }).text_("\u00a0").cursor_();
            ret.push(e);
            if (stop != null) {
                const c = ColorValue.from_(stop.color);
                if (c != null) e.style.backgroundColor = c.toCSSString_();
                const pos = stop.position;
                if (pos.length > 0) e.textContent = pos;
            }
        }
        b.pop_();
        return ret;
    }

    /**
       * @dialog @nullable Dialog is used to calculate the zindex, if null, DEF.zindexPrompt is used.
       */
    static createInputSlider_(
        b: DomBuilderEx,
        min: number,
        max: number,
        step: number,
        mark: number,
        height: string,
        value: number,
        placeholder: string,
        tabindex: string,
        onchange: Fun00,
    ): HTMLInputElement {
        b.push_();
        const slider = b.peek_().flexInputSlider_(100, height, `${min}`, `${max}`, `${step}`, `${value}`,
            _DialogUt.placeholder_(placeholder), tabindex);
        slider.style.boxSizing = "border-box";
        if (mark > 0) {
            const id = `slider${tabindex}`;
            slider.setAttribute("list", id);
            b.child2_("datalist", "id", id).push_();
            for (let value = min + mark; value < max; value += mark) {
                b.peek_().option2_("value", `${value}`);
            }
            b.pop_();
        }
        b.pop_();
        const rateLimiter = new FrameLimiter(10);
        const sliderhandler = () => {
            rateLimiter.queue_(() => {
                onchange();
            });
        };
        An.onInput_(slider, sliderhandler);
        An.onChange_(slider, sliderhandler);
        return slider;
    }

    static toggleButtonStyle_(buttonsize: number): string {
        const margin = buttonsize / 8;
        return `min-width:${buttonsize - margin}px;`
            + `min-height:${buttonsize - margin}px;`
            + `margin-right:${margin}px;`
            + `border:${DEF.lightBorder};`
            + "border-radius:50%;"
            + "flex:0 0 auto;"
            + "align-self:stretch;"
            + "box-sizing:border-box;"
            + "overflow:hidden;";
    }

    static toggleButtonFlexStyle_(buttonsize: number, align: string): string {
        return DialogUt.toggleButtonStyle_(buttonsize)
            + `align-items:${align};`
            + `justify-content:${align};`;
    }

    static toggleButtonInnerSize_(buttonsize: number): number {
        const margin = buttonsize / 8;
        return (buttonsize - margin) * 2 / 3;
    }

    static createBorderButton_(b: DomBuilderEx, buttonsize: number, on: boolean): HTMLElement {
        const b2 = DialogUt.toggleButtonInnerSize_(buttonsize);
        return b
            .push_()
            .div_(
                ["class", `${CSS.AnButton} ${on ? CSS.AnButtonDown : CSS.AnButtonFlat}`],
                ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "flex-start")],
                [ATTR.xTooltips, RS.Border],
            )
            .push_()
            .div_({
                "style": `width:${b2}px;height:${b2}px;background-color:rgba(0, 0, 0, 0.1);`
                    + `border-right:${DEF.themeBorder};border-bottom:${DEF.themeBorder};`
            })
            .pop_()
            .cursorPop_() as HTMLElement;
    }

    static createRoundCornersButton_(b: DomBuilderEx, buttonsize: number, on: boolean): HTMLElement {
        const b2 = DialogUt.toggleButtonInnerSize_(buttonsize);
        return b
            .push_()
            .div_(
                ["class", `${CSS.AnButton} ${on ? CSS.AnButtonDown : CSS.AnButtonFlat}`],
                ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "flex-start")],
                [ATTR.xTooltips, RS.RoundCorners],
            )
            .push_()
            .div_({
                "style": `width:${b2}px;height:${b2}px;background-color:rgba(0, 0, 0, 0.1);`
                    + `border-right:${DEF.themeBorder};border-bottom:${DEF.themeBorder};`
                    + `border-radius:0 0 ${DEF.themeBorderRadius} 0`,
            })
            .pop_()
            .cursorPop_() as HTMLElement;
    }

    static createBoxShadowButton_(b: DomBuilderEx, buttonsize: number, on: boolean): HTMLElement {
        const b2 = DialogUt.toggleButtonInnerSize_(buttonsize);
        return b
            .push_()
            .div_(
                ["class", `${CSS.AnButton} ${on ? CSS.AnButtonDown : CSS.AnButtonFlat}`],
                ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "flex-start")],
                [ATTR.xTooltips, RS.BoxShadow],
            )
            .push_()
            .div_({
                "style": `width:${b2}px;height:${b2}px;background-color:rgba(0, 0, 0, 0.1);`
                    + `border-right:${DEF.themeBorder};border-bottom:${DEF.themeBorder};`
                    + `box-shadow:${DEF.themeBoxShadow}`,
            })
            .pop_()
            .cursorPop_() as HTMLElement;
    }

    static createHeaderButton_(b: DomBuilderEx, buttonsize: number, on: boolean): HTMLElement {
        const b1 = DialogUt.toggleButtonInnerSize_(buttonsize) / 2;
        return b
            .push_()
            .div_(
                ["class", `${CSS.AnButton} ${on ? CSS.AnButtonDown : CSS.AnButtonFlat}`],
                ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "flex-start") + "flex-direction:column;"],
                [ATTR.xTooltips, RS.Subject],
            )
            .push_()
            .div_({
                "style": `width:100%;height:${b1}px;box-sizing:border-box;`
                    + "background-color:rgba(0, 0, 0, 0.1);"
                    + `border-bottom:${DEF.themeBorder};`,
            })
            .peek_()
            .div_({
                "style": "width:100%;align-self:stretch;background-color:rgba(0, 0, 0, 0.0);",
            })
            .pop_()
            .cursorPop_() as HTMLElement;
    }

    static createOrientationButton_(b: DomBuilderEx, buttonsize: number, vertical: boolean): HTMLElement {
        b.push_().div_(
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat}`],
            ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "stretch")],
            [ATTR.xTooltips, RS.Orientation],
        );
        DialogUt.updateOrientationButton_(b, vertical);
        return b.cursorPop_();
    }

    static updateOrientationButton_(b: DomBuilderEx, vertical: boolean): void {
        (b.push_().cursor_()).style.flexDirection = (vertical ? "column" : "row");
        b
            .div_({
                "style": "flex:1 1 100%;"
                    + "background-color:rgba(0, 0, 0, 0.1);"
                    + `${vertical ? "border-bottom:${DEF.themeBorder};" : "border-right:${DEF.themeBorder};"}`,
            })
            .peek_()
            .div_({
                "style": "flex:1 1 100%;"
                    + "background-color:rgba(0, 0, 0, 0.0);",
            })
            .pop_();
    }

    static createGutterButton_(b: DomBuilderEx, buttonsize: number, vertical: boolean): HTMLElement {
        b.push_().div_(
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat}`],
            ["style", DialogUt.toggleButtonFlexStyle_(buttonsize, "stretch")],
            [ATTR.xTooltips, RS.Orientation],
        );
        DialogUt.updateGutterButton_(b, vertical);
        return b.cursorPop_();
    }

    static updateGutterButton_(b: DomBuilderEx, vertical: boolean): void {
        (b.push_().cursor_()).style.flexDirection = (vertical ? "column" : "row");
        b
            .div_({
                "style": "flex:1 1 100%;background-color:rgba(0, 0, 0, 0.1);"
            })
            .peek_()
            .div_({
                "style": "flex:0 0 5px;"
                    + "background-color:#eee;"
                    + `border:${DEF.themeBorder};`
                    + `${vertical ? "border-width:1px 0;" : "border-width:0 1px"}`,
            })
            .peek_()
            .div_({
                "style": "flex:1 1 100%;"
                    + "background-color:rgba(0, 0, 0, 0.1);",
            })
            .pop_();
    }

    static createColorButton_(b: DomBuilderEx, buttonsize: number, bgcolor: string): HTMLElement {
        return b.push_().div_(
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat} ${CSS.Fa} ${CSS.FaSpinner}`],
            ["style", DialogUt.toggleButtonStyle_(buttonsize)
                + `background-color:${bgcolor};`
                + "text-shadow:0 0 1px #fff;"],
            [ATTR.xTooltips, RS.Tooltips_SetBackgroundColor],
        ).cursorPop_() as HTMLElement;
    }

    static createSymbolButton_(b: DomBuilderEx, buttonsize: number, fa: string, tooltips: string): HTMLElement {
        return b.push_().div_(
            ["class", `${CSS.AnButton} ${CSS.AnButtonFlat} ${CSS.Fa} ${fa}`],
            ["style", DialogUt.toggleButtonStyle_(buttonsize) + "text-shadow:0 0 1px #fff;"],
            [ATTR.xTooltips, tooltips],
        ).cursorPop_() as HTMLElement;
    }

    static createClientActionButton_(b: DomBuilderEx, buttonsize: number, fa: string, on: boolean): HTMLElement {
        return b.push_().div_(
            ["class", `${CSS.AnButton} ${on ? CSS.AnButtonDown : CSS.AnButtonFlat} ${CSS.Fa} ${fa}`],
            ["style", DialogUt.toggleButtonStyle_(buttonsize)],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
        ).cursorPop_() as HTMLElement;
    }

    static hasBorder_(width: stringX, style: stringX): boolean {
        if (style == "" || style == "none") return false;
        const sizeunit = An.doubleSizeUnit_(width);
        return sizeunit != null && sizeunit[0] != 0;
    }

    static defaultCanvasDimension_(toolbarheight: number): Point<number> {
        const winwidth = window.innerWidth;
        const margins = ImageAnnotator.PADDING * 2 + 2 /* borders */ + 4;
        const width = An.multipleOf_(16, winwidth - margins);
        const height = An.multipleOf_(16, window.innerHeight - toolbarheight - margins);
        return MediaUtil.limitImageArea_(width, height);
    }
}

abstract class _DialogUt {

    static placeholder_(key: string): string {
        return MSG.string_(key);
    }

    /// @param dialog @notnull.
    static createFilepathInput_(
        b: DomBuilderEx,
        host: IDialog,
        spec: IFilepathFieldSpec,
        foldercallback: Fun00,
        pathkindcallback: Fun00,
    ): [top: HTMLElement, input: HTMLTextAreaElement, pathkind: HTMLElementX, buttons: Map<string, HTMLButtonElement>] {
        const textbasis = (spec.label$.length > 0 ? host.labelWidth$ : 0);
        const tabindex = host.tabIndex_();
        const label = MSG.string_(spec.label$);
        const value = spec.value$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const buttons = spec.buttons$;
        const top = b.peek_().div1_(CSS.AnMarginV5).push_().cursor_();
        const buttonbar = _DialogUt.createButtonBar_(b, textbasis);
        const input = _DialogUt.flexTextInput_(b, textbasis, label, placeholder, tabindex);
        b.setCursor_(buttonbar).push_();
        const buttonelements = _DialogUt.createButtonBarButtons_(b, buttons);
        b.pop_(2);
        const pathkind = buttonelements.get(BUT.PathKind) ?? null;
        const folder = buttonelements.get(BUT.Folder) ?? null;
        value.updateInput_(input);
        if (pathkind !== null) {
            DialogUt.setPathKind_(pathkind, value.isAbsolute$);
            pathkind.addEventListener("click", (e) => {
                An.stopevent_(e);
                host.clearStatus_();
                pathkindcallback();
            });
        }
        if (folder !== null) {
            folder.addEventListener("click", (e) => {
                An.stopevent_(e);
                host.clearStatus_();
                Timer.sleep0_(foldercallback);
            });
        }
        return [top, input, pathkind, buttonelements];
    }

    /// @param dialog @notnull.
    static createFilepathFolderInput_(
        b: DomBuilderEx,
        host: IDialog,
        spec: IFilepathFieldSpec,
        foldercallback: Fun00,
    ): [top: HTMLElement, input: AnInputElement, button: HTMLButtonElement] {
        const textbasis = (spec.label$.length > 0 ? host.labelWidth$ : 0);
        const tabindex = host.tabIndex_();
        const label = MSG.string_(spec.label$);
        const value = spec.value$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        const input = _DialogUt.flexTextInput_(b, textbasis, label, placeholder, tabindex);
        const folder = _DialogUt.createActionButton_(b.push_(), BUT.Folder1);
        b.pop_(2);
        input.style.marginRight = "5px";
        folder.addEventListener("click", (e) => {
            An.stopevent_(e);
            host.clearStatus_();
            Timer.sleep0_(foldercallback);
        });
        value.updateInput_(input);
        return [top, input, folder];
    }

    static createImageFilepathFolderInput_(
        b: DomBuilderEx,
        host: IDialog,
        spec: IFilepathFieldSpec,
        foldercallback: Fun00,
        dataurlcallback: Fun00,
    ): [top: HTMLElement, input: AnInputElement, button: HTMLButtonElement, dataurlbutton: HTMLButtonElement] {
        const textbasis = (spec.label$.length > 0 ? host.labelWidth$ : 0);
        const tabindex = host.tabIndex_();
        const label = MSG.string_(spec.label$);
        const value = spec.value$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        const input = _DialogUt.flexTextInput_(b, textbasis, label, placeholder, tabindex);
        const folder = _DialogUt.createActionButton_(b.push_(), BUT.Folder1);
        const dataurl = _DialogUt.createActionButton_(b.peek_(), BUT.DataUrl1);
        b.pop_(2);
        input.style.marginRight = "5px";
        folder.addEventListener("click", (e) => {
            An.stopevent_(e);
            host.clearStatus_();
            Timer.sleep0_(foldercallback);
        });
        dataurl.addEventListener("click", (e) => {
            An.stopevent_(e);
            host.clearStatus_();
            Timer.sleep0_(dataurlcallback);
        });
        value.updateInput_(input);
        return [top, input, folder, dataurl];
    }

    static createBasenameInput_(
        b: DomBuilderEx,
        host: IDialog,
        spec: IBasenameFieldSpec,
        foldercallback: Fun00
    ): [top: HTMLElement, input: HTMLTextAreaElement, ext: SelectOptions, buttons: Map<string, HTMLButtonElement>] {
        const textbasis = (spec.label$.length > 0 ? host.labelWidth$ : 0);
        const tabindex = host.tabIndex_();
        const inputbasis = DEF.BASIS_60;
        const label = MSG.string_(spec.label$);
        const name = spec.filename$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const top = b.peek_().div1_(CSS.AnMarginV5).push_().cursor_();
        _DialogUt.flexTextContainer_(b, textbasis, label);
        const input = b.flexInput_(100, placeholder, tabindex);
        b.up_().push_();
        const basepath = name == null ? null : new Basepath(name);
        const suffix = basepath == null ? "" : basepath.suffix$;
        const options = sarray_();
        options.push(suffix);
        if (suffix.toLowerCase() != suffix) { options.push(suffix.toLowerCase()); }
        if (suffix.toUpperCase() != suffix) { options.push(suffix.toUpperCase()); }
        const select = new SelectOptions(accessories$, b.peek_().div_({
            "class": `${CSS.AnPromptSelect} ${CSS.AnMarginLeft5}`,
            "style": `flex-basis:${100 - inputbasis}%`,
        }).cursor_());
        select.setOptions_(options, null, 0);
        const folder = _DialogUt.createActionButton_(b.peek_(), BUT.Folder1);
        folder.style.marginLeft = "5px";
        folder.addEventListener("click", (e) => {
            An.stopevent_(e);
            host.clearStatus_();
            Timer.sleep0_(foldercallback);
        });
        b.pop_(2);
        if (basepath != null) {
            input.value = basepath.stem$;
            select.setValue_(basepath.suffix$, 0);
        }
        return [top, input, select, map1_(BUT.Folder1, folder)];
    }

    /**
       * @param dialog @notnull.
       * @return [top, pathkind, folder, input] where pathkind and folder may be null.
       */
    static createUrlInput_(
        b: DomBuilderEx,
        dialog: IDialog,
        spec: IUriFieldSpec,
        foldercallback: Fun00X,
        pathkindcallback: Fun00X,
    ): [top: HTMLElement, input: HTMLTextAreaElement, pathkind: HTMLElementX, buttons: Map<string, HTMLButtonElement>] {
        const textbasis = (spec.label$.length > 0 ? dialog.labelWidth$ : 0);
        const tabindex = dialog.tabIndex_();
        const label = MSG.string_(spec.label$);
        const value = spec.value$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const buttons = spec.buttons$;
        const top = b.peek_().div1_(CSS.AnMarginV5).push_().cursor_();
        const buttonbar = _DialogUt.createButtonBar_(b, textbasis);
        const input = _DialogUt.flexTextInput_(b, textbasis, label, placeholder, tabindex);
        value.updateInput_(input);
        b.setCursor_(buttonbar).push_();
        const added = _DialogUt.createButtonBarButtons_(b, buttons);
        b.pop_(2);
        const pathkind = added.get(BUT.PathKind) ?? null;
        const folder = added.get(BUT.Folder) ?? null;
        if (pathkind !== null) {
            if (pathkindcallback == null) { Assert.fail_(); }
            DialogUt.setPathKind_(pathkind, value.isAbsolute$);
            pathkind.addEventListener("click", (e) => {
                An.stopevent_(e);
                dialog.clearStatus_();
                pathkindcallback();
            });
        }
        if (folder !== null) {
            if (foldercallback == null) { Assert.fail_(); }
            folder.addEventListener("click", (e) => {
                An.stopevent_(e);
                dialog.clearStatus_();
                Timer.sleep0_(foldercallback);
            });
        }
        return [top, input, pathkind, added];
    }

    static createUrlFolderInput_(
        b: DomBuilderEx,
        dialog: IDialog,
        spec: IUriFieldSpec,
        foldercallback: Fun00,
    ): [top: HTMLElement, input: HTMLTextAreaElement, button: HTMLButtonElement] {
        const textbasis = (spec.label$.length > 0 ? dialog.labelWidth$ : 0);
        const tabindex = dialog.tabIndex_();
        const label = MSG.string_(spec.label$);
        const value = spec.value$;
        const placeholder = _DialogUt.placeholder_(spec.placeholder$);
        const top = b.peek_().div1_(CSS.AnMarginV5).cursor_();
        const input = _DialogUt.flexTextInput_(b, textbasis, label, placeholder, tabindex);
        const folder = _DialogUt.createActionButton_(b.push_(), BUT.Folder1);
        b.pop_(2);
        input.style.marginRight = "5px";
        value.updateInput_(input);
        folder.addEventListener("click", (e) => {
            An.stopevent_(e);
            dialog.clearStatus_();
            Timer.sleep0_(foldercallback);
        });
        return [top, input, folder];
    }

    static createInputButton_(b: DomBuilderEx, placeholder: stringX, tabindex: string, value: string, button: string)
        : [input: AnInputElement, button: HTMLButtonElement] {
        b.push_();
        const input = b.flexInput_(100, placeholder, tabindex);
        input.style.marginRight = "5px";
        const but = this.createActionButton_(b.peek_(), button);
        b.pop_();
        if (value != null) input.value = value;
        return [input, but];
    }

    static createInputButtons_(
        b: DomBuilderEx,
        placeholder: stringX,
        tabindex: string,
        value: string,
        buttons: string[],
        callback: Fun10<string>,
    ): [input: HTMLTextAreaElement, buttons: StringMap<HTMLButtonElement>] {
        b.push_();
        const input = b.flexInput_(100, placeholder, tabindex);
        input.style.marginRight = "5px";
        const buts = smap_<HTMLButtonElement>();
        for (const button of buttons) {
            const but = this.createActionButton_(b.peek_(), button);
            An.onClick_(but, (e) => {
                An.stopevent_(e);
                callback(button);
            });
            buts[button] = but;
        }
        b.pop_();
        if (value != null) input.value = value;
        return [input, buts];
    }

    static createLeftToggleButton_(b: DomBuilderEx, info: SStringMap): HTMLButtonElement {
        return this._createLeftToggleButton1(b, info["class"], info[ATTR.xTooltips]);
    }

    private static _createLeftToggleButton1(b: DomBuilderEx, classes: string, tooltips: string): HTMLButtonElement {
        return b.peek_().childBeforeFirst_("button", smap_(
            ["class", classes],
            [ATTR.xTooltips, tooltips],
            ["style", "margin-right: 5px;"],
        )).cursor_() as HTMLButtonElement;
    }

    static createActionButton_(b: DomBuilderEx, action: string): HTMLButtonElement {
        const info = BUT._INFOS[action];
        return this._createActionButton1(b, info["class"], info[ATTR.xTooltips]);
    }

    private static _createActionButton1(b: DomBuilderEx, classes: string, tooltips: string): HTMLButtonElement {
        return b.peek_().button_(
            ["class", classes],
            [ATTR.xTooltips, tooltips],
        ).cursor_() as HTMLButtonElement;
    }

    static createLeftActionButton_(b: DomBuilderEx, action: string): HTMLButtonElement {
        const info = BUT._INFOS[action];
        return this._createLeftActionButton1(b, info["class"], info[ATTR.xTooltips]);
    }

    private static _createLeftActionButton1(b: DomBuilderEx, classes: string, tooltips: string): HTMLButtonElement {
        return b.peek_().childBeforeFirst_("button", smap_(
            ["class", classes],
            [ATTR.xTooltips, tooltips],
        )).cursor_() as HTMLButtonElement;
    }

    static createFolderButton_(b: DomBuilderEx): HTMLButtonElement {
        return _DialogUt.createActionButton_(b, BUT.Folder);
    }

    static createButtonBar_(b: DomBuilderEx, textbasis: number): HTMLElement {
        const ret = b.peek_().flexTextContainer_(textbasis, "").push_().div1_(CSS.AnButtonPadding).text_("").pop_().cursor_();
        DialogUt.setButtonTooltipsHandler_(ret);
        return ret;
    }

    static createButtonBarButtons_(
        b: DomBuilderEx,
        buttons: string[]
    ): Map<string, HTMLButtonElement> {
        const ret = new Map<string, HTMLButtonElement>();
        for (let button of buttons) {
            switch (button) {
                case BUT.PathKind:
                    ret.set(button, _DialogUt.createLeftToggleButton_(b, BUT._INFOS[button]));
                    break;
                case BUT.CreateLink:
                    ret.set(button, _DialogUt.createLeftToggleButton_(b, BUT._INFOS[button]));
                    break;
                case BUT.ImageSource:
                    ret.set(button, _DialogUt.createLeftActionButton_(b, button));
                    break;
                case BUT.CreateThumbnail:
                    ret.set(button, _DialogUt.createActionButton_(b, button));
                    break;
                case BUT.Folder:
                    ret.set(button, _DialogUt.createFolderButton_(b));
                    break;
                default:
                    throw Assert.notReach_(button);
            }
        }
        return ret;
    }

    static flexSelect_(container: HTMLElement, b: DomBuilderEx, textbasis: number, text: string, placeholder: string): SelectOptions {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return DialogUt.flexTextSelect1_(container, b, textbasis, text, placeholder);
    }

    static flexTextSelect_(container: HTMLElement, b: DomBuilderEx, textbasis: number, text: string, placeholder: string): SelectOptions {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return DialogUt.flexTextSelect1_(container, b, textbasis, text, placeholder);
    }

    static flexTextInput_(b: DomBuilderEx, textbasis: number, text: string, placeholder: stringX, tabindex: string = "1"): HTMLTextAreaElement {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return b.flexTextInput1_(textbasis, text, placeholder, tabindex);
    }

    static flexTextTextarea_(b: DomBuilderEx, textbasis: number, text: string, attrs: SStringMap): HTMLTextAreaElement {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return b.flexTextTextarea1_(textbasis, text, attrs);
    }

    static flexTextDiv_(b: DomBuilderEx, textbasis: number, text: string): DomBuilderEx {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return b.flexTextDiv1_(textbasis, text);
    }

    static flexTextContainer_(b: DomBuilderEx, textbasis: number, text: string): DomBuilderEx {
        b.peek_().div1_(CSS.AnFlex, CSS.AnMarginV5);
        return b.flexTextContainer1_(textbasis, text);
    }

    /**
       * Create an dialog input field with a text label, an input element and a select element in a row.
       * Typically, used for a value+unit input.
       * @param b On return, the cursor is the textInputSelect field, the grandparent of the input and select element.
       * @param textbasis AnFlexnn for text label.
       * @param inputbasis AnFlexnn for the input control.
       * @return The (HTMLTextAreaElement, SelectOptions) pair.
       */
    static flexTextInputSelect_(
        container: HTMLElement,
        b: DomBuilderEx,
        textbasis: number,
        inputbasis: number,
        label: string,
        inputvalue: string,
        placeholder: stringX,
        tabindex: string,
        selectvalue: string,
        selectoptions: string[]
    ): [input: HTMLTextAreaElement, select: SelectOptions] {
        b.flexTextContainer_(textbasis, label).push_();
        const input = b.flexInput_(inputbasis, placeholder, tabindex);
        const selectedindex = (selectvalue != null ? selectoptions.indexOf(selectvalue) : null);
        const select = new SelectOptions(container, b.peek_().div_(
            ["class", `${CSS.AnPromptSelect} ${CSS.AnMarginLeft5}`],
            ["style", `flex-basis:${100 - inputbasis}%`],
            [ATTR.placeholder, (placeholder ?? "")],
        ).cursor_());
        select.setOptions_(selectoptions, null, selectedindex);
        if (inputvalue != null) {
            input.value = inputvalue;
        }
        b.pop_();
        b.up_();
        return [input, select];
    }

    /**
       * Create an dialog input field with a text label, an input element and a select element in a row.
       * Typically, used for a value+unit input.
       * @param b On return, the cursor is the textInputSelect field, the grandparent of the input and select element.
       * @param textbasis AnFlexnn for text label.
       * @param inputbasis AnFlexnn for the input control.
       * @return The (HTMLTextAreaElement, SelectOptions) pair.
       */
    static flexTextSelectInput_(
        container: HTMLElement,
        b: DomBuilderEx,
        textbasis: number,
        inputbasis: number,
        label: string,
        inputvalue: string,
        placeholder: stringX,
        tabindex: string,
        selectvalue: string,
        selectoptions: string[]
    ): [select: SelectOptions, input: AnInputElement] {
        b.flexTextContainer_(textbasis, label).push_();
        const selectedindex = (selectvalue != null ? selectoptions.indexOf(selectvalue) : null);
        const select = new SelectOptions(container, b.peek_().div_(
            ["class", `${CSS.AnPromptSelect} ${CSS.AnMarginLeft5}`],
            ["style", `flex-basis:${100 - inputbasis}%`],
            [ATTR.placeholder, (placeholder ?? "")],
        ).cursor_());
        const input = b.peek_().flexInput_(inputbasis, placeholder, tabindex);
        b.pop_();
        b.up_();
        select.setOptions_(selectoptions, null, selectedindex);
        if (inputvalue != null) {
            input.value = inputvalue;
        }
        return [select, input];
    }

    /**
       * Create an dialog input field with a text label, and two input/select element pairs in a row.
       * Typically, used for a value+unit, value+unit input.
       * @param b On return, the cursor is the textInputSelect field, the grandparent of the input and select element.
       * @param textbasis AnFlexnn for text label.
       * @param inputbasis AnFlexnn for the input control.
       * @return The (HTMLTextAreaElement, SelectOptions) pair.
       */
    static flexTextInputSelect2_(
        container: HTMLElement,
        b: DomBuilderEx,
        textbasis: number,
        inputbasis: number,
        tabindex1: string,
        tabindex2: string,
        spec: InputSelect2Field,
    ): [input1: HTMLTextAreaElement, select1: SelectOptions, input2: HTMLTextAreaElement, select2: SelectOptions] {
        b.flexTextContainer_(textbasis, MSG.string_(spec.label$)).addStyles_(smap1_("flex-flow", "row nowrap")).push_();
        const input1 = b.flexInput_(inputbasis, _DialogUt.placeholder_(spec.placeholder1$), tabindex1);
        const select1 = new SelectOptions(container, b.peek_().div_({
            "class": `${CSS.AnPromptSelect} ${CSS.AnMarginH5}`,
            "style": `flex-basis:${100 - inputbasis}%`,
        }).cursor_());
        const input2 = b.peek_().flexInput_(inputbasis, _DialogUt.placeholder_(spec.placeholder2$), tabindex2);
        const select2 = new SelectOptions(container, b.peek_().div_({
            "class": `${CSS.AnPromptSelect} ${CSS.AnMarginLeft5}`,
            "style": `flex-basis:${100 - inputbasis}%`,
        }).cursor_());
        const selectedindex1 = (spec.selectvalue1$ != null ? spec.options1$.indexOf(spec.selectvalue1$) : null);
        select1.setOptions_(spec.options1$, null, selectedindex1);
        input1.value = spec.value1$ ?? "";
        const selectedindex2 = (spec.selectvalue2$ != null ? spec.options2$.indexOf(spec.selectvalue2$) : null);
        select2.setOptions_(spec.options2$, null, selectedindex2);
        input2.value = spec.value2$ ?? "";
        b.pop_();
        b.up_();
        return [input1, select1, input2, select2];
    }

    /**
       * Create an dialog input field with a text label, two input elements in a row.
       * @param b On return, the cursor is the textInputInput field, the grandparent of the input and select element.
       * @param textbasis AnFlexnn for text label.
       * @param label The text label.
       * @param tabindex1 The tabindex for input1.
       * @param tabindex2 The tabindex for input2.
       * @param info List<String> The info for the INPUT2 field
       * where the info options are placeholder1, value1 unit1, placeholder2, value2, unit2.
       * @return The input element.
       */
    static flexTextInput2_(
        b: DomBuilderEx,
        buttonsize: number,
        labelbasis: number,
        label: string,
        inputbasis: number,
        tabindex1: string,
        placeholder1: stringX,
        value1: string,
        unit1: string,
        tabindex2: string,
        placeholder2: stringX,
        value2: string,
        unit2: string
    ): [input1: HTMLTextAreaElement, input2: HTMLTextAreaElement] {
        b.flexTextContainer_(labelbasis, label).push_();
        let input1 = b.flexInput_(inputbasis, placeholder1, tabindex1);
        b.peek_().span_({
            "class": CSS.AnFlex01Auto,
            //// To match button with 5px margin, eg. in PromptValueType.Color.
            "style": "margin:0 5px",
        }).text_(unit1);
        let input2 = b.peek_()
            .flexInput_(inputbasis, placeholder2, tabindex2);
        b.peek_().span_({
            "class": CSS.AnFlex01Auto,
            "style": `min-width:${buttonsize + 5}px`,
        }).text_(unit2);
        input1.value = value1;
        input2.value = value2;
        b.pop_();
        b.up_();
        return [input1, input2];
    }

    static onValidateFragment_(errors: string[], fragment: string): void {
        if (fragment == null) {
            return;
        }
        for (let i = 0, len = fragment.length; i < len; ++i) {
            const c = fragment[i];
            if (DEF.xmlNameChars.indexOf(c) < 0) {
                errors.push(MSG.string_(RS.InvalidCharacter_) + c);
            }
        }
    }

    static confirmCancel_(dialog: DialogBase, modified: boolean, yescallback: Fun00): void {
        if (modified) {
            DialogUt.confirmKeySmall_(dialog.container_(), RS.ConfirmDiscard, An.above_(dialog.element_()), (yes: boolean) => {
                if (!yes) return;
                yescallback();
            });
        } else {
            yescallback();
        }
    }
}

class PromptGradient extends CompositeDialogBase {

    static readonly _SAMPLE = "#Xvo";
    static readonly _SIZE_POSITION = "#XdZ";
    static readonly _KIND = "#Xaa";
    static readonly _CUSTOM = "#XS6";
    static readonly _COLORS = "#X70";
    static readonly _ANGLE = "#XGh";

    static readonly _KindLinear = 0;
    static readonly _KindRadial = 1;
    static readonly _KindRadialEllipse = 2;
    static readonly _KindRadialCircle = 3;
    static readonly _KindRepeatingLinear = 4;
    static readonly _KindRepeatingRadial = 5;
    static readonly _KindRepeatingRadialEllipse = 6;
    static readonly _KindRepeatingRadialCircle = 7;

    static readonly Kinds$: string[] = [
        MSG.string_(RS.GradientLinear),
        MSG.string_(RS.GradientRadial),
        MSG.string_(RS.GradientRadialEllipse),
        MSG.string_(RS.GradientRadialCircle),
        MSG.string_(RS.GradientRepeatingLinear),
        MSG.string_(RS.GradientRepeatingRadial),
        MSG.string_(RS.GradientRepeatingRadialEllipse),
        MSG.string_(RS.GradientRepeatingRadialCircle),
    ];

    _sample!: HTMLElement;
    _okCallback: Fun10<string> | null = null;

    constructor(container: HTMLElement, buttonsize: number, gradient: Gradient) {
        super(container, [
            new SelectFIeld(
                "",
                PromptGradient._KIND,
                PromptGradient.Kinds$[An.gradientKindOf(gradient.name, 0)], RS.Gradient,
                PromptGradient.Kinds$
            ),
            new InputField(
                "",
                PromptGradient._ANGLE,
                gradient.position,
                RS.Orientation,
            ),
            new InputField(
                "",
                PromptGradient._SIZE_POSITION,
                gradient.position,
                RS.SizePosition,
            ),
            new ColorStopsField(
                "",
                PromptGradient._COLORS,
                buttonsize,
                gradient.colorstops,
            ),
            new SampleField(PromptGradient._SAMPLE, ""),
        ]);
        this.titleKey_(RS.Gradient);
        this.setVisible_(PromptGradient._SIZE_POSITION, false);
        const x2 = buttonsize * 2;
        this._sample = new DomBuilderEx(this.getField_(PromptGradient._SAMPLE).element_()).div_(
            ["class", CSS.AnFlex],
            ["style", `width:50%;height:${x2}px;margin:20px 0 10px 0;background-image:${this._gradient()};`],
        ).cursor_();
        An.onClick_(this._sample, () => {
            this.blurAll();
        });
        this.onChange_((field, input) => {
            const key = field.spec$.key$;
            if (key == PromptGradient._KIND) {
                this._setupKind(this._gradientKind());
            } else if (key == PromptGradient._ANGLE) {
                const ta = (input as HTMLTextAreaElement);
                const value = ta.value.trim();
                if (RX.Decimals.test(value)) {
                    ta.value = `${value}deg`;
                } else if (RX.Sides2.test(value)) {
                    ta.value = `to ${value}`;
                }
            }
            this._sample.style.backgroundImage = "";
            Timer.sleep0_(() => {
                const gradient = this._gradient();
                this._sample.style.backgroundImage = gradient;
            });
        });
    }

    onOK_(callback: Fun10<string>): this {
        this._okCallback = callback;
        return this;
    }

    private _setupKind(kind: number): void {
        switch (kind) {
            case PromptGradient._KindLinear:
            case PromptGradient._KindRepeatingLinear:
                this.setVisible_(PromptGradient._ANGLE, true);
                this.setVisible_(PromptGradient._SIZE_POSITION, false);
                break;
            case PromptGradient._KindRadial:
            case PromptGradient._KindRadialEllipse:
            case PromptGradient._KindRadialCircle:
            case PromptGradient._KindRepeatingRadial:
            case PromptGradient._KindRepeatingRadialEllipse:
            case PromptGradient._KindRepeatingRadialCircle:
                this.setVisible_(PromptGradient._ANGLE, false);
                this.setVisible_(PromptGradient._SIZE_POSITION, true);
                break;
            default:
        }
    }

    private _gradientKind(): number {
        const select = this.getField_(PromptGradient._KIND).getValueElement_(0) as SelectOptions;
        if (select == null) {
            return -1;
        }
        return select.getSelectedIndex_();
    }

    private _gradient(): string {
        switch (this._gradientKind()) {
            case PromptGradient._KindLinear:
                return this._linearGradient("");
            case PromptGradient._KindRadial:
                return this._radialGradient("", "");
            case PromptGradient._KindRadialEllipse:
                return this._radialGradient("", "ellipse");
            case PromptGradient._KindRadialCircle:
                return this._radialGradient("", "circle");
            case PromptGradient._KindRepeatingLinear:
                return this._linearGradient("repeating-");
            case PromptGradient._KindRepeatingRadial:
                return this._radialGradient("repeating-", "");
            case PromptGradient._KindRepeatingRadialEllipse:
                return this._radialGradient("repeating-", "ellipse");
            case PromptGradient._KindRepeatingRadialCircle:
                return this._radialGradient("repeating-", "circle");
            default:
                return "";
        }
    }

    private _linearGradient(repeating: string): string {
        const s = An.joinNotEmpty_(", ", [this.getValue_(PromptGradient._ANGLE), this.getValue_(PromptGradient._COLORS)]);
        return `${repeating}linear-gradient(${s})`;
    }

    private _radialGradient(repeating: string, shape: string): string {
        const sizeposition = this.getValue_(PromptGradient._SIZE_POSITION);
        const colors = this.getValue_(PromptGradient._COLORS);
        let s = An.joinNotEmpty_(" ", [shape, sizeposition]);
        s = An.joinNotEmpty_(", ", [s, colors]);
        return `${repeating}radial-gradient(${s})`;
    }

    protected _onOK(done: BoolCallback): void {
        const ret = this._gradient();
        const callback = this._okCallback!;
        done(true);
        callback(ret);
    }
}

////////////////////////////////////////////////////////////////////////

class PromptBarcode extends CompositeDialogBase {
    static readonly QRCODE = MSG.string_(RS.BarcodeKindQRCode);

    _okCallback: Fun40<string, string, number, string> | null = null;

    constructor(container: HTMLElement, basepath: Basepath) {
        super(container, [
            new BasenameFIeld("", "", basepath.filename$, RS.PlaceholderRequiredFilepath, basepath.dir$, Callbacks.onBasenameFolderButton_),
            new SelectFIeld("", "", PromptBarcode.QRCODE, RS.PlaceholderRequired, [PromptBarcode.QRCODE]),
            new InputField(RS.Scale, "", "4", RS.PlaceholderRequired),
            new TextAreaField(RS.Text, "", "", RS.PlaceholderRequired, `${CSS.AnPromptTextarea} ${CSS.AnFull}`),
        ], DEF.BASIS_25);
        this.titleKey_(RS.BarcodeGenerateTitle);
    }

    onOK_(callback: Fun40<string, string, number, string>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): boolean {
        const filename = this.getValueAt_(0);
        const type = this.getValueAt_(1);
        const scale = Math.round(An.parseDouble_(this.getValueAt_(2), 1.0));
        const text = this.getValueAt_(3);
        if (An.isempty_(text)) {
            this.warnKey_(RS.TextIsRequired);
            done(false);
        } else if (An.isempty_(filename) || An.isempty_(Basepath.stem_(filename))) {
            this.warnKey_(RS.FilenameMustNotBeEmpty);
            done(false);
        } else {
            const callback = this._okCallback!;
            done(true);
            callback(filename, type, scale, text);
        }
        return true;
    }
}

////////////////////////////////////////////////////////////////////////

type FilepickerResizer = (self: FilepickerBase) => void;
type FilepickerOKCallback = (okcallback: Fun10<boolean>, cpath: string, fileinfo: FileInfo) => void;

abstract class FilepickerDelegate {

    abstract getSuffixes_(): Map<string, stringX>;

    abstract includes_(path: string, fileinfo: FileInfo): boolean;

    abstract validate_(path: string, info: FileInfo, callback: JSONCallback): void;
}

abstract class FilepickerSuffixesDelegate extends FilepickerDelegate {
    protected _suffixes: Map<string, stringX> = map1_("", null);

    constructor(mapping: [string, stringX][]) {
        super();
        for (const e of mapping) {
            this._suffixes.set(e[0], e[1]);
        }
    }

    getSuffixes_(): Map<string, stringX> {
        return this._suffixes;
    }

    includes_(path: string, fileinfo: FileInfo): boolean {
        if (fileinfo.isdir$) return false;
        const suffix = Basepath.lcSuffix_(path);
        return this.getSuffixes_().has(suffix);
    }

    validate_(path: string, info: FileInfo, callback: JSONCallback): void {
        if (this.includes_(path, info)) {
            callback({});
            return;
        }
        const keys = Array.from(this.getSuffixes_().keys());
        ArrayUt.delete_(keys, "");
        callback(An.jsonError_(RS.ExpectingFileExt_, ...keys));
    }
}

class FilepickerKind {
    static readonly ANY: FilepickerKind = new FilepickerKind();
    static readonly ANY_FILE: FilepickerKind = new FilepickerKind();
    static readonly ANY_DIR: FilepickerKind = new FilepickerKind();
    static readonly EXISTING_ANY: FilepickerKind = new FilepickerKind();
    static readonly EXISTING_FILE: FilepickerKind = new FilepickerKind();
    static readonly EXISTING_DIR: FilepickerKind = new FilepickerKind();
    static readonly MOVE_FILE: FilepickerKind = new FilepickerKind();
    static readonly NEW_FILE: FilepickerKind = new FilepickerKind();
    static readonly WRITE_DIR: FilepickerKind = new FilepickerKind();
    static readonly WRITE_FILE: FilepickerKind = new FilepickerKind();
}

////////////////////////////////////////////////////////////////////////

class PromptRename extends CompositeDialogBase {
    private _okCallback: OKCallback2<ICompositeDialog, string, boolean> | null = null;
    constructor(
        container: HTMLElement,
        specs: IDialogFIeldSpec[],
        private _usexrefs: boolean,
        labelwidth: IntX = null) {
        super(container, specs, labelwidth);
        if (!_usexrefs) {
            An.hide_(this._toolbar!!.button_(BUT.FixXrefs));
        }
    }
    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infos_(
                BUT.FixXrefs,
                BUT.OK,
                BUT.Cancel,
            )),
            (action) => this._toolbarActions(action)
        );
    }

    protected _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.FixXrefs: {
                this._actionOK(this._usexrefs);
                break;
            }
            case BUT.OK: {
                this._actionOK(false);
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    onOK_(callback: OKCallback2<ICompositeDialog, string, boolean>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(_done: BoolCallback): void {
        Assert.unsupportedOperation_();
    }

    private _actionOK(fixxrefs: boolean) {
        const cpath = this.getValueAt_(0).trim();
        this._okCallback!(this, cpath, fixxrefs, (ok) => {
            if (ok) this.close_();
        });
    }
}

abstract class FilepickerBase {

    protected _rootDir: string[];
    protected _filenameInput!: HTMLTextAreaElement;
    protected _suffixSelect: SelectOptions | null = null;
    protected _rootButton!: HTMLElement;
    protected _upButton!: HTMLElement;
    protected _dirpathPanel!: HTMLElement;
    protected _dirtreePanel!: HTMLElement;
    protected _contextmenu: Contextmenu | null = null;

    protected _currentDir = FS;
    protected _suffices = new Map<string, stringX>();
    protected _dirpath: FileInfo[] | null = null;
    protected _dirtree: FileInfo[] | null = null;
    protected _localClipboard = new AnClipboard();
    protected _clipboardGetter: ClipboardGetter | null = null;
    protected _clipboardSetter: ClipboardSetter | null = null;
    protected _fileSelectedCallback: StringCallback | null = null;
    protected _filterRootsCallback: JSONCallback | null = null;
    protected _viewCallback: ViewMediaCallback | null = Callbacks.onViewLocalImage_;
    protected _delegate: FilepickerDelegate | null = null;
    protected _canChangeDir: boolean;
    protected _selected: HTMLElementX = null;
    protected _history = new LRU(DEF.filepickerHistorySize);
    #refreshing = false;

    /**
         * @container The container element for creating dialogs.
         * @top The top element that host this filepicker.
         * @handler IFilepickerHandler.
         */
    constructor(
        protected _container: HTMLElement,
        protected _mode: FilepickerKind,
        rootdir: stringX,
        protected _handler: IFileinfoUtil,
    ) {
        let rootdir1 = rootdir == null ? null : An.removeTrailingSlashes_(Basepath.cleanFilepath_(rootdir));
        if (rootdir1 == null || rootdir1.length == 0 || rootdir1 == FS) {
            this._rootDir = [];
        } else {
            if (rootdir1.startsWith(FS)) {
                rootdir1 = rootdir1.substring(1);
            }
            this._rootDir = rootdir1.split(FS);
        }
        this._canChangeDir = (this._rootDir.length == 0);
    }

    abstract element_(): HTMLElement;

    abstract createContextmenu_(): Contextmenu;

    abstract fileDateString_(lastyear: DateTime, yesterday: DateTime, now: DateTime, date: number): string;

    abstract onFileInfo_(filename: string): void;

    abstract toClipboard_(path: string): void;

    abstract renameFile_(frompath: string): void;

    abstract renameDir_(dirpath: string): void;

    clearLocalClipboard_(): void {
        this._localClipboard.clear_();
    }

    abstract pasteFile1_(
        cut: boolean,
        preservetimestamp: boolean,
        msg: string,
        dstdir: string,
        dstfilename: string,
        srcpath: string,
        callback: JSONCallback): void;

    abstract updateToolbarState_(_dirtree: FileInfo[] | null): void;

    canChangeDir_(b: boolean): void {
        this._canChangeDir = b;
    }

    private useShortcut_(): boolean {
        return true;
    }

    populateFilepicker_(
        rootbutton: HTMLElement,
        upbutton: HTMLElement,
        filename: HTMLTextAreaElement,
        suffixselect: SelectOptions | null,
        dirpath: HTMLElement,
        dirtree: HTMLElement
    ): void {
        this._rootButton = rootbutton;
        this._upButton = upbutton;
        this._filenameInput = filename;
        this._suffixSelect = suffixselect;
        this._dirpathPanel = dirpath;
        this._dirtreePanel = dirtree;
        new UIUt$.TooltipsListener(this._dirpathPanel, toasters$.onTooltipsKey_);
    }

    get currentDir$(): string {
        return this._currentDir;
    }

    get filenameInput$(): HTMLTextAreaElement {
        return this._filenameInput;
    }

    get rootButton$(): HTMLElement {
        return this._rootButton;
    }

    get upButton$(): HTMLElement {
        return this._upButton;
    }

    get dirpathPanel$(): HTMLElement {
        return this._dirpathPanel;
    }

    get dirtreePanel$(): HTMLElement {
        return this._dirtreePanel;
    }

    get contextmenu$(): Contextmenu | null {
        return this._contextmenu;
    }

    get suffices$(): Map<string, stringX> {
        return this._suffices;
    }

    /// @return Absolute path with leading /.
    currentPath_(name: string): string {
        if (name == null || name.length == 0) return this._currentDir;
        if (name.startsWith(FS)) return name;
        return Basepath.joinPath_(this._currentDir, name);
    }

    isRoot_(names: string[]): boolean {
        return this._dirpath != null && this._dirpath.length > 0 && names.includes(this._dirpath[0].name$);
    }

    rootInfo_(): FileInfo | null {
        return (this._dirpath != null && this._dirpath.length > 0)
            ? this._dirpath[0] ?? null
            : null;
    }

    currentDirInfo_(): FileInfo | null {
        return (this._dirpath != null && this._dirpath.length > 0)
            ? ArrayUt.last_(this._dirpath) ?? null
            : null;
    }

    _parentDirInfo(): FileInfo | null {
        return (this._dirpath != null && this._dirpath.length > 1)
            ? this._dirpath[this._dirpath.length - 2] ?? null
            : null;
    }

    protected setSuffixes_(suffixes: Map<string, stringX>): void {
        this._suffices = new Map(suffixes.entries());
        if (this._suffixSelect == null) { return; }
        this._suffixSelect.setOptions_(Array.from(suffixes.keys()).sort(suffixSorter));
        this._suffixSelect.element_().style.display = "block";
        this.updateToolbarState_(this._dirtree);
    }

    showContextmenu_(e: MouseEvent): void {
        if (this._contextmenu == null) {
            //// Lazy creation to make sure that _dialog has a valid z-index.
            this._contextmenu = this.createContextmenu_();
        }
        this._contextmenu.show_(e);
    }

    hideContextmenu_(): void {
        
        if (this._contextmenu != null) {
            this._contextmenu.hide_();
        }
    }

    recreateContextmenu_(): void {
        if (this._contextmenu != null) {
            
            this._contextmenu.destroy_();
            this._contextmenu = this.createContextmenu_();
        }
    }

    onDirInfo_(filename: string): void {
        const cpath = this.currentPath_(filename);
        this._showDirInfo(cpath);
    }

    private _showDirInfo(cpath: string): void {
        this._handler.dirInfo_(cpath, (ret) => {
            if (toasters$.warn_(ret)) return;
            const [files, dirs, size] = ret[Key.result];
            FilepickerBase.showDirInfo_(cpath, files, dirs, size);
        });
    }

    static showDirInfo_(cpath: string, files: Long, dirs: Long, size: Long) {
        toasters$.modal_((t, b) => {
            new ToasterInfoBuilder(t, b).build_((ib) => {
                ib.tr1_(Basepath.filename_(cpath), { "colspan": "2", "style": "font-weight:bold;" });
                ib.tr1_("", { "colspan": "2", "style": "height: 5px;" });
                ib.trKey_(RS.Files, `${files}`);
                ib.trKey_(RS.Dirs, `${dirs}`);
                ib.trKey_(RS.Size, An.filesizeUnit4_(size));
            });
        });
    }

    private _showFileInfo(cpath: string, fileinfo: FileInfo): void {
        const lcsuffix = Basepath.lcSuffix_(fileinfo.name$);
        host$.getXrefs_(cpath, (ret) => {
            const xrefs = toasters$.warn_(ret) ? null : ret[Key.result];
            if (MimeUtil.isImageLcSuffix_(lcsuffix) || lcsuffix == Suffix.PDF$) {
                host$.localImageInfo_(cpath, true, (ret) => {
                    this._showFileInfo1(lcsuffix, fileinfo, xrefs, MediaInfo.of_(ret[Key.result]));
                });
            } else if (lcsuffix == Suffix.IBACKUP$ || lcsuffix == Suffix.BACKUP$) {
                host$.getBackupFileInfo_(cpath, (ret) => {
                    const info = toasters$.warn_(ret) ? null : BackupFileInfo.of_(ret);
                    this._showFileInfo1(lcsuffix, fileinfo, xrefs, null, info);
                });
            } else this._showFileInfo1(lcsuffix, fileinfo, xrefs);
        });
    }

    private _showFileInfo1(
        lcsuffix: string,
        fileinfo: FileInfo,
        xrefsinfo: JSONArrayX,
        mediainfo: MediaInfo | null = null,
        backupfileinfo: BackupFileInfo | null = null,
    ): void {
        const size = An.toCommaSeparatedString(fileinfo.size$);
        const datestring = (ms: Long) => {
            return An.datetimeString_(settings$.dateFormat_(), settings$.timeFormat_(), new DateTime(ms));
        };
        const durationstr = (sec: Double) => {
            if (sec < 60.0) return `${sec} s`;
            return `${sec} s (${TimeFormat.hms_(sec)})`;
        };
        toasters$.modal_((t, b) => {
            new ToasterInfoBuilder(t, b).build_((ib) => {
                ib.tr1_(fileinfo.name$, { "colspan": "2", "style": "font-weight:bold;padding-bottom:0.25ex" });
                ib.trKey_(RS.Size, `${size} B`);
                ib.trKey_(RS.Date, `${datestring(fileinfo.date$)}`);
                ib.trKey_(RS.FilePermission, fileinfo.perm$);
                With.notnull_(fileinfo.checksum$, (value) => {
                    ib.trKey_(RS.Checksum, value.replace(RX.Word8_g, "$1 ").trim().split(" ").join("-"));
                });
                if (xrefsinfo != null) {
                    if (lcsuffix == Suffix.HTML$ || lcsuffix == Suffix.CSS$) {
                        const len = xrefsinfo[0]?.length ?? 0;
                        if (len > 0) {
                            ib.trAction_(RS.XrefsRefTo, `${len}`, () => {
                                this.showfilelist_(MSG.string1_(RS.XrefsRefTo, ` ${fileinfo.name$}: ${len}`), xrefsinfo[0]);
                            });
                        }
                    }
                    const len = xrefsinfo[1]?.length ?? 0;
                    if (len > 0) {
                        ib.trAction_(RS.XrefsRefBy, `${len}`, () => {
                            this.showfilelist_(MSG.string1_(RS.XrefsRefBy, ` ${fileinfo.name$}: ${len}`), xrefsinfo[1]);
                        });
                    }
                }
                if (mediainfo != null) {
                    if (mediainfo.isImage$) {
                        if (mediainfo.resolution$ != null) ib.trKey_(RS.WxH, mediainfo.resolution$);
                        if (mediainfo.rotation$ != null) ib.trKey_(RS.Orientation, `${mediainfo.rotation$}`);
                    } else if (mediainfo.isAudio$) {
                        ib.trKey_(RS.Duration, durationstr(mediainfo.duration$));
                        if (mediainfo.bitrate$ != null) ib.trKey_(RS.BitPerSecond, `${mediainfo.bitrate$}`);
                        if (mediainfo.channels$ != null) ib.trKey_(RS.AudioChannels, `${mediainfo.channels$}`);
                        if (mediainfo.creationDate$ != null) ib.trKey_(RS.CreationDate, `${datestring(mediainfo.creationDate$)}`);
                    } else if (mediainfo.isVideo$) {
                        ib.trKey_(RS.Duration, durationstr(mediainfo.duration$));
                        if (mediainfo.resolution$ != null) ib.trKey_(RS.WxH, mediainfo.resolution$);
                        if (mediainfo.channels$ != null) ib.trKey_(RS.AudioChannels, `${mediainfo.channels$}`);
                        if (mediainfo.creationDate$ != null) ib.trKey_(RS.CreationDate, `${datestring(mediainfo.creationDate$)}`);
                    }
                }
                if (backupfileinfo != null) {
                    const warns = backupfileinfo.warns$;
                    if (warns.length > 0) toasters$.warn_(warns);
                    ib.trKey_(RS.Version, `${backupfileinfo.version$}`);
                    ib.trKey_(RS.Key, `${backupfileinfo.keyAlias$} [${backupfileinfo.keyExpire$}] ${backupfileinfo.keyChecksum$}`);
                    ib.trKey_(RS.Recipients, `${backupfileinfo.aliasCount$}`);
                }
                ib.tn_(mediainfo?.tnDataUrl$);
            });
        });
    }

    showfilelist_(header: string, paths: JSONArray): void {
        toasters$.modal_((t, b) => {
            new ToasterInfoBuilder(t, b).build_((ib) => {
                ib.trb1_(header, ssmap1_("style", "padding-bottom: 0.25ex"));
                for (const apath of paths.sort()) {
                    ib.tr1_(apath, ssmap1_(ATTR.AnInfo, apath), ssmap1_("style", "cursor:pointer"));
                }
                An.onClickMatching_(b.peek_().cursor_(), `td[${ATTR.AnInfo}]`, (target) => {
                    const apath = target.getAttribute(ATTR.AnInfo);
                    if (apath != null) {
                        if (apath.endsWith(Suffix.CSS$)) {
                            fileinfoUt$.fileInfo1_(toasters$, apath, (fileinfo) => {
                                _Util._showCSSEditor(apath, fileinfo.writable$, false);
                            });
                        } else {
                            _Util.browseFile_(apath);
                        }
                    }
                });
            });
        });
    }

    actionShowFileInfo_(): void {
        const cpath = this.currentPath_(this.getFilename_());
        this._handler.fileInfo1_(toasters$, cpath, (info) => {
            if (!info.exists$) toasters$.warnKey_(RS.FileNotFound);
            else if (info.isdir$) this._showDirInfo(cpath);
            else this._showFileInfo(cpath, info);
        });
    }

    gotoDir_(apath: string, callback: Fun00): void {
        this._handler.listDir_(apath, ret => {
            if (toasters$.warn_(ret)) return;
            this.refresh_(ret, callback);
        });
    }

    protected _actionBackward() {
        const path = this._history.backward_();
        if (path != null) {
            this.gotoDir_(path, () => { });
        }
    }

    protected _actionForward() {
        const path = this._history.forward_();
        if (path != null) {
            this.gotoDir_(path, () => { });
        }
    }

    promptDirname(titlekey: StringId, msg: TestResult, value: string, usexrefs: boolean): PromptRename {
        return new PromptRename(
            accessories$,
            [
                new InputButtonField(
                    "",
                    "",
                    value,
                    RS.Directory,
                    BUT.Today,
                    (field) => { field.setValue_(An.simpleDateString_()); },
                    (host) => host.actionOK_(),
                ),
            ],
            usexrefs,
            DEF.BASIS_25)
            .titleKey_(titlekey)
            .message_(msg)
            .zindex_(DEF.zindexPrompt);
    }

    protected promptRename_(titlekey: StringId, msg: string, opath: Basepath): PromptRename {
        const _KEY = "#XaU";
        const suffix = opath.suffix$;
        const lcsuffix = suffix.toLowerCase();
        const ucsuffix = suffix.toUpperCase();
        const suffices = [suffix];
        if (lcsuffix != suffix) {
            suffices.push(lcsuffix);
        }
        if (ucsuffix != suffix) {
            suffices.push(ucsuffix);
        }
        return new PromptRename(this._container, [
            new InputSelectField(
                "",
                _KEY,
                opath.stem$,
                RS.Filename,
                suffix,
                suffices,
                null //(host) => host.actionOK_()
            ),
        ], true)
            .titleKey_(titlekey)
            .message_(msg);
    }

    setupEventHandlers(): void {
        An.onKeypress_(this.filenameInput$, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this._handler.listDir_(this.currentPath_(this.getFilename_()), ret => {
                    this.refresh_(ret);
                });
            }
        });
        An.listeners_(this.filenameInput$)
            .add_("focus", () => {
                this.clearStatus_();
                Timer.sleep0_(() => {
                    An.select_(this.filenameInput$);
                });
            })
            .add_("click", () => {
                this.clearStatus_();
            });
        this.rootButton$.addEventListener("click", e => {
            An.stopevent_(e);
            if (this._rootDir.length > 0) {
                return;
            }
            this._handler.listDir_("", ret => {
                this._filterRootsCallback?.(ret);
                ret[Key.filename] = null;
                this.refresh_(ret);
            });
        });
        this.upButton$.addEventListener("click", e => {
            An.stopevent_(e);
            if (this._rootDir.length > 0) {
                return;
            }
            this._handler.listDir_(Basepath.dir_(this._currentDir) ?? "", ret => {
                ret[Key.filename] = null;
                this.refresh_(ret);
            });
        });
        An.onClickMatching_(this.dirpathPanel$, "a", (target, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(target.getAttribute(ATTR.AnInfo), -1);
            const b = Array.from(this._rootDir);
            if (this._dirpath != null) {
                for (let i = this._rootDir.length; i <= index && i < this._dirpath.length; ++i) {
                    b.push(this._dirpath[i].name$);
                }
            }
            this._currentDir = FS + b.join(FS);
            this._handler.listDir_(this._currentDir, ret => {
                ret[Key.filename] = null;
                this.refresh_(ret);
            });
        });
        const onclick = (target: HTMLElement) => {
            const classes = target.classList;
            if (this.useShortcut_() && classes.contains(CSS.AnFileInfo)) {
                const name = this._getname(target);
                if (name != null) {
                    this.onFileInfo_(name);
                }
            } else if (this.useShortcut_() && classes.contains(CSS.AnDirInfo)) {
                const name = this._getname(target);
                if (name != null) {
                    this.onDirInfo_(name);
                }
            } else if (classes.contains(CSS.AnDir)) {
                const name = this._getname(target);
                if (name != null) {
                    this._handler.listDir_(this.currentPath_(name), ret => {
                        ret[Key.filename] = null;
                        this.refresh_(ret);
                    });
                }
            } else if (classes.contains(CSS.AnFile)) {
                const filename = this.select_(target);
                if (this._fileSelectedCallback != null) {
                    this._fileSelectedCallback(filename);
                }
            } else if (classes.contains(CSS.AnDisabled)
                && this._mode != FilepickerKind.EXISTING_ANY
                && this._mode != FilepickerKind.EXISTING_DIR
                && this._mode != FilepickerKind.EXISTING_FILE
            ) {
                if (this._selected != null) {
                    this._selected.classList.remove(CSS.AnSelectedHighlight);
                    this._selected = null;
                }
                const filename = (this._getname(target)?.trim()) ?? "";
                if (filename.length > 0)
                    this.setFilename_(filename);
            }
        };
        An.onClickMatching_(this.dirtreePanel$, `div.${CSS.AnPromptContent}>div`, (target, e) => {
            An.stopevent_(e);
            const t = DomUt.asHTMLElement_(e.target);
            if (t != null && let_(t.classList, (list) => list.contains(CSS.AnFileInfo) || list.contains(CSS.AnDirInfo) || list.contains(CSS.AnDisabled))) {
                onclick(t);
            } else {
                const a = DomUt.query_(target, `.${CSS.AnFile}, .${CSS.AnDisabled}, a.${CSS.AnDir}`);
                if (a != null) {
                    onclick(a);
                }
            }
        });
    }

    onFilterRoots_(callback: Fun10<FileInfo | null>): this {
        this._filterRootsCallback = (ret) => {
            const dirtree: JSONObject[] | null = ret[Key.dirtree];
            if (dirtree == null) return;
            ret[Key.dirtree] = dirtree.filter((json) => {
                return callback(FileInfo.of_(json));
            });
        };
        return this;
    }

    protected _actionPickImage(host: HTMLElement): void {
        const filename = this.filenameInput$.value.trim();
        const d = new Imagepicker(
            accessories$,
            RS.PickImage,
            gestureHandler$,
            new LocalMediaInfoHandler(this.currentDir$, this._handler));
        d.above_(host);
        d.setFilename_(filename);
        d.onResize_(() => {
            d.cancel_();
        });
        d.onView_(this._viewCallback);
        d.onOK_(imageinfo => {
            this.setFilename_((imageinfo.title$?.trim()) ?? "");
        });
        d.show_();
    }

    protected select_(target: HTMLElement): string {
        let filename = (this._getname(target)?.trim()) ?? "";
        const elm = target.parentElement?.parentElement;
        if (elm != null) {
            if (this._selected != null) this._selected.classList.remove(CSS.AnSelectedHighlight);
            if (elm == this._selected) {
                this._selected = null;
                filename = "";
            } else {
                elm.classList.add(CSS.AnSelectedHighlight);
                this._selected = elm;
            }
        }
        this.setFilename_(filename);
        return filename;
    }

    protected deselect_() {
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelectedHighlight);
            this._selected = null;
        }
    }

    onFileSelected_(callback: StringCallback): this {
        this._fileSelectedCallback = callback;
        return this;
    }

    onPaste(getter: ClipboardGetter): this {
        this._clipboardGetter = getter;
        return this;
    }

    onCopy(setter: ClipboardSetter): this {
        this._clipboardSetter = setter;
        return this;
    }

    private _getname(a: HTMLElement): stringX {
        const index = An.parseInt_(a.getAttribute(ATTR.AnInfo), -1);
        if (this._dirtree != null && index >= 0 && index < this._dirtree.length) {
            return this._dirtree[index].name$;
        }
        return null;
    }

    updateContextmenuState_(): void {
        const updateContextmenuState1 = () => {
            if (this._dirtree == null) return;
            let parentinfo: FileInfo | null = null;
            if (this._dirpath != null) {
                const len = this._dirpath.length;
                parentinfo = (len > 1 ? this._dirpath[len - 2] : null);
            }
            if (this._viewCallback != null) {
                let hasimage = false;
                for (const info of this._dirtree) {
                    if (MimeUtil.isImageLcSuffix_(Basepath.lcSuffixOfFilename_(info.name$)) && info.readable$) {
                        hasimage = true;
                        break;
                    }
                }
                this._contextmenu?.enableButton_(BUT.PickImage, hasimage);
            }
            const filename = this.getFilename_();
            if (filename.length == 0) {
                const dirinfo = this.currentDirInfo_();
                this.updateContextmenuStateWithoutFilename(parentinfo, dirinfo, this._currentDir);
                return;
            }
            const fileinfo = this.dirtreeFind_(filename);
            const dirinfo = this.currentDirInfo_();
            this.updateContextmenuStateWithFilename(parentinfo, dirinfo, fileinfo, this._currentDir);
        };
        const filename = this.getFilename_();
        if (filename.includes(FS)) {
            this._handler.listDir_(this.currentPath_(filename), ret => {
                this.refresh_(ret, () => {
                    updateContextmenuState1();
                });
            });
        }
        updateContextmenuState1();
    }

    /**
         * @dirinfo @nullable In case current directory is ROOT.
         * @fileinfo @nullable In case specified file do not exists.
         */
    protected updateContextmenuStateWithFilename(
        parentinfo: FileInfo | null,
        dirinfo: FileInfo | null,
        fileinfo: FileInfo | null,
        _dir: string
    ): void {
        const menu = this._contextmenu;
        if (menu == null) { return; }
        if (dirinfo == null || dirinfo.notexists$) {
            //// At ROOT, no file operation is allowed.
            //// If current directory not exists, which should not happend, no file operations allowed.
            menu.enableButtons_([
                BUT.CopyFile,
                BUT.CutFile,
                BUT.PasteFile,
                BUT.Mkdir,
                BUT.RenameFile,
                BUT.DeleteFile,
                BUT.DeleteEmptyDirs,
            ], false);
            menu.enableButtonIfExists_(BUT.CloneFile, false);
        } else {
            const fileexists = (fileinfo != null && fileinfo.exists$);
            //// - Note that we don't allow cut/delete/rename a subdirectory.
            //// We need the directory content, eg for dirtreeFind() in various occassions.
            //// So all file actions should perform at the current directory only.
            //// We may allow copying a subdirectory, but we don't to avoid confusion.
            //// - The paste action always paste to the current directory,
            //// regardless of the filename and whether it specified a directory or not.
            const isdir = (fileinfo != null && fileinfo.isdir$);
            const dirwritable = dirinfo.writable$;
            const cancopy = fileexists && !isdir;
            const cancut = fileexists && !isdir && dirwritable;
            const canpaste = dirwritable && !this._localClipboard.isEmpty_();
            const canmkdir = dirwritable;
            const dirempty = (this._dirtree == null || this._dirtree.length == 0);
            const parentwritable = parentinfo != null && parentinfo.writable$;
            const candelete = (dirempty && parentwritable)
                || (!dirempty && dirwritable);
            const canrename = fileexists && !isdir && dirwritable;
            menu.enableButton_(BUT.CopyFile, cancopy);
            menu.enableButton_(BUT.CutFile, cancut);
            menu.enableButton_(BUT.PasteFile, canpaste);
            menu.enableButton_(BUT.Mkdir, canmkdir);
            menu.enableButton_(BUT.RenameFile, canrename);
            menu.enableButton_(BUT.DeleteFile, candelete);
            menu.enableButton_(BUT.DeleteEmptyDirs, candelete);
            menu.enableButtonIfExists_(BUT.CloneFile, canpaste);
        }
    }

    /**
         * @parentinfo @nullable In case current directory is ROOT or a top directory.
         * @dirinfo @nullable In case current directory is ROOT.
         */
    protected updateContextmenuStateWithoutFilename(parentinfo: FileInfo | null, dirinfo: FileInfo | null, _dir: string): void {
        const menu = this._contextmenu;
        if (menu == null) { return; }
        if (dirinfo == null || dirinfo.notexists$) {
            //// At ROOT, no file operation allowed.
            //// If current directory not exists, which should not happend, no file operations allowed.
            menu.enableButtons_([
                BUT.CopyFile,
                BUT.CutFile,
                BUT.PasteFile,
                BUT.Mkdir,
                BUT.RenameFile,
                BUT.DeleteFile,
                BUT.DeleteEmptyDirs,
            ], false);
            menu.enableButtonIfExists_(BUT.CloneFile, false);
        } else {
            const dirempty = (this._dirtree == null || this._dirtree.length == 0);
            const dirwritable = dirinfo.writable$;
            const parentwritable = (parentinfo != null && parentinfo.writable$);
            const cancopy = !dirempty;
            const cancut = !dirempty && dirwritable;
            const canpaste = !this._localClipboard.isEmpty_() && dirwritable;
            const canmkdir = dirwritable;
            //// NOTE: Delete without a filename may delete files under the directory,
            //// delete recursive or delete an empty directory.
            //// NOTE that everything under /Restore is not writable but deletable.
            const candelete = (dirempty && parentwritable) ||
                (!dirempty && dirwritable);
            const canrename = parentwritable;
            menu.enableButton_(BUT.CopyFile, cancopy);
            menu.enableButton_(BUT.CutFile, cancut);
            menu.enableButton_(BUT.PasteFile, canpaste);
            menu.enableButton_(BUT.DeleteFile, candelete);
            menu.enableButton_(BUT.Mkdir, canmkdir);
            menu.enableButton_(BUT.RenameFile, canrename);
            menu.enableButton_(BUT.DeleteEmptyDirs, candelete);
            menu.enableButtonIfExists_(BUT.CloneFile, canpaste);
        }
    }

    dirtreeFind_(filename: string): FileInfo {
        if (this._dirtree != null) {
            for (const info of this._dirtree) {
                if (filename == info.name$) {
                    return info;
                }
            }
        }
        return FileInfo.NOT_EXISTS;
    }

    private _sanitizeDirpath(dirpath: FileInfo[]): boolean {
        const rootlen = this._rootDir.length;
        if (rootlen == 0) {
            return true;
        }
        if (dirpath == null || dirpath.length < rootlen) {
            return false;
        }
        for (let i = 0, len = rootlen; i < len; ++i) {
            if (this._rootDir[i] != dirpath[i].name$) {
                return false;
            }
        }
        return true;
    }

    protected refreshCurrentDir_(): void {
        Timer.sleep0_(() => {
            this._handler.listDir_(this.currentDir$, (ret) => this.refresh_(ret));
        });
    }

    protected refresh_(ret: JSONObject, oncomplete: Fun00X = null): void {
        let _refresh1 = (ret: JSONObject) => {
            if (this.element_() == null) {
                ///#NOTE It may be possible that result returns after dialog is closed in testing.
                return;
            }
            if (ret == null) {
                
                return;
            }
            
            if (toasters$.warn_(ret)) {
                
                return;
            }
            toasters$.warn_(ret[Key.warns]);
            const dirpath = FileInfo.arrayOf_(ret[Key.dirpath]);
            if (dirpath == null || !this._sanitizeDirpath(dirpath)) {
                return;
            }
            const p = ret[Key.path];
            const dirtree = FileInfo.arrayOf_(ret[Key.dirtree]);
            if (p == null || dirtree == null) {
                return;
            }
            this._currentDir = An.ensureLeadingSlash_(p);
            this._history.put_(this._currentDir);
            this._dirpath = dirpath;
            this._dirtree = dirtree;
            const filename = ret[Key.filename]?.trim() ?? null;
            if (this.filenameInput$ != null && filename != null && filename !== undefined) {
                this.setFilename_(filename);
            }
            this._refreshdirtree(new DomBuilderEx(this.dirtreePanel$), this._dirtree);
            if (this.dirpathPanel$ != null) {
                this._refreshdirpath(new DomBuilderEx(this.dirpathPanel$), this._dirpath);
            }
        };
        if (this.#refreshing) return;
        this.#refreshing = true;
        _refresh1(ret);
        this.updateToolbarState_(this._dirtree);
        this.#refreshing = false;
        oncomplete?.();
    }

    private _refreshdirpath(b: DomBuilderEx, dirpath: FileInfo[] | null): void {
        b.empty_();
        if (dirpath == null) { return; }
        b.push_();
        const rootlen = this._rootDir.length;
        const len = dirpath.length;
        for (let i = 0; i < len; ++i) {
            const dirinfo = dirpath[i];
            const name = dirinfo.name$;
            const readable = dirinfo.readable$;
            if (i > 0) {
                b.text_(" / ");
            }
            if (!readable || i == len - 1 || !this._canChangeDir || this._canChangeDir && i < rootlen - 1) {
                b.text_(name);
            } else {
                b.a_(
                    ["class", CSS.AnDirpathDir],
                    [ATTR.AnInfo, i.toString()],
                )
                    .text_(name)
                    .up_();
            }
        }
        b.pop_();
    }

    private _refreshdirtree(ret: DomBuilderEx, fileinfos: FileInfo[] | null): void {
        this._selected = null;
        const filename = this.getFilename_();
        ret.empty_();
        if (fileinfos == null) { return; }
        const b = DomBuilderEx.offline1_(document, "div", CSS.AnViewportContent);
        b.push_().div_({
            "class": `${CSS.AnPromptContent} ${CSS.AnZebra}`,
            "style": `border-bottom:${DEF.themeBorder}`,
        }).push_();
        const len = fileinfos.length;
        const now = DateTime.now_();
        const lastyear = DateTime.local_(now.year$ - 1, now.month$, now.day$, now.hour$, now.minute$, now.second$);
        const yesterday = DateTime.fromMs_(now.millisecondsSinceEpoch$ - 23 * DateTime.HOUR);
        for (let i = 0; i < len; ++i) {
            const fileinfo = fileinfos[i];
            const readable = fileinfo.readable$;
            const isdir = fileinfo.isdir$;
            const name = fileinfo.name$;
            const sizeunit = isdir ? FileInfo.SIZEUNIT_DIR : fileinfo.sizeunit$;
            const date = this.fileDateString_(lastyear, yesterday, now, fileinfo.date$);
            const e = b.peek_().div_().cursor_();
            if (name == filename) {
                e.classList.add(CSS.AnSelectedHighlight);
                this._selected = e;
            }
            b.div_().push_();
            const index = i.toString();
            if (!readable) {
                if (fileinfo.notexists$) {
                    b.addClass_(CSS.AnNot);
                } else {
                    b.addClass_(CSS.AnErr);
                }
                b.code_().text_(sizeunit + date).pop_().text_(name);
            } else if (!isdir && this._delegate != null && !this._delegate.includes_(name, fileinfo) || isdir && !this._canChangeDir) {
                b.code_().text_(sizeunit + date).pop_().span_(
                    ["class", CSS.AnDisabled],
                    [ATTR.AnInfo, index],
                ).text_(name);
            } else if (isdir) {
                if (this.useShortcut_()) {
                    b.a_(
                        ["class", CSS.AnDirInfo],
                        [ATTR.AnInfo, index],
                    )
                        .text_(sizeunit)
                        .peek_()
                        .code_()
                        .text_(date);
                } else {
                    b.addClass_(CSS.AnLink).code_().text_(sizeunit + date);
                }
                b.pop_().a_(
                    ["class", CSS.AnDir],
                    [ATTR.AnInfo, index],
                ).text_(name);
            } else {
                if (this.useShortcut_()) {
                    b.a_(
                        ["class", CSS.AnFileInfo],
                        [ATTR.AnInfo, index],
                    )
                        .text_(sizeunit)
                        .peek_()
                        .code_()
                        .text_(date);
                } else {
                    b.code_().text_(sizeunit + date);
                }
                b.pop_().span_(
                    ["class", CSS.AnFile],
                    [ATTR.AnInfo, index],
                ).text_(name);
            }
        }
        ret.appendNodes_(b.pop_(2).cursor_());
        this.dirtreePanel$.scrollTo(0, 0);
    }

    clearStatus_(): void {
        toasters$.hideAll_();
    }

    setFilename_(filename: string): void {
        filename = filename.trim();
        if (this._suffixSelect != null) {
            const basepath = new Basepath(filename);
            const suffix = basepath.suffix$;
            const lcsuffix = suffix.toLowerCase();
            if (this._suffices != null && this._suffices.has(lcsuffix)) {
                if (!this._suffices.has(suffix)) {
                    this._suffices.set(suffix, this._suffices.get(lcsuffix)!);
                    this._suffixSelect.setOptions_(Array.from(this._suffices.keys()).sort(suffixSorter));
                }
                this._suffixSelect.setValue_(suffix);
                this.filenameInput$.value = basepath.stem$;
            } else {
                this.filenameInput$.value = basepath.stem$;
            }
        } else {
            this.filenameInput$.value = filename;
        }
        this.updateToolbarState_(this._dirtree);
    }

    getFilename_(): string {
        if (this._filenameInput == null) {
            return "";
        }
        const filename = this._filenameInput.value.trim();
        if (filename.length == 0) {
            return "";
        }
        if (this._suffices == null) {
            return filename;
        }
        return filename + (this._suffixSelect?.getValue_("") ?? "");
    }

    protected _actionMkdir(host: HTMLElement): void {
        const name = this.getFilename_();
        const obase = new Basepath(name);
        const d = this.promptDirname(
            RS.MkdirTitle,
            null,
            obase.stem$,
            false)
            .onOK_((_d, toname, _fixxrefs, okcallback) => {
                toname = toname.trim();
                if (toname.length == 0 || toname == ".") {
                    d.warn_(MSG.string_(RS.InputMustNotBeEmpty));
                    okcallback(false);
                    return;
                }
                if (An.isDotOnly_(toname) || toname.indexOf(FS) >= 0) {
                    d.warn_(MSG.string_(RS.InvalidDirectoryName_) + toname);
                    okcallback(false);
                    return;
                }
                okcallback(true);
                //// If confirmed overwriting, delete the file first, before rename.
                const info = this.dirtreeFind_(toname);
                if (info != null && info.exists$) {
                    toasters$.warnKey_(RS.DestinationAlreadyExists);
                    return;
                }
                const path = this.currentPath_(toname);
                this._handler.mkDirs_(path, ret => {
                    if (toasters$.warn_(ret)) {
                        return;
                    }
                    this.refresh_(ret);
                });
            });
        d.zindex_(An.above_(host));
        d.show_();
    }

    protected _actionDelete(): void {
        if (this._dirtree == null) { return; }
        const filecount = this._dirtree.length;
        if (filecount == 0) {
            this._delete1(this._currentDir, MSG.format1_(RS.deleteEmptyDirectory, this._currentDir));
            return;
        }
        //// Prompt file/dir to delete.
        this._handler.deleteInfo_(this._currentDir, (ret) => {
            if (toasters$.warn_(ret[Key.errors])) {
                return;
            }
            const toast = (ret: JSONObject) => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                //// There are wanings instead of errors if delete failed on part or all files.
                toasters$.warn_(ret[Key.warns]);
                const result = (ret[Key.result] as Array<string>);
                if (result == null) {
                    toasters$.ok_(MSG.format1_(RS.deletedEverything, this._currentDir), { attop: true });
                } else {
                    toasters$.ok_(MSG.format1_(RS.deletedFiles, `${result.length}`), { attop: true });
                }
                this.refresh_(ret);
            };
            const name = this.getFilename_();
            new PromptDelete(this._container, name, ret)
                .titleKey_(RS.Confirm)
                .zindex_(Math.max(DEF.zindexPrompt, An.above_(this.element_())))
                .onOK_(todelete => {
                    if (todelete.length > 0) {
                        const spinner = new Spinner(this._container);
                        spinner.show_(() => {
                            Timer.sleep0_(() => {
                                this._handler.deleteAll_(this._currentDir, todelete, (ret) => {
                                    spinner.destroy_();
                                    toast(ret);
                                });
                            });
                        });
                    } else {
                        toast(json1_(Key.errors, "Deleted 0 files"));
                    }
                })
                .show_();
        });
    }

    protected _actionShred(): void {
        if (this._dirtree == null) { return; }
        const filecount = this._dirtree.length;
        if (filecount == 0) {
            this._delete1(this._currentDir, MSG.format1_(RS.deleteEmptyDirectory, this._currentDir));
            return;
        }
        //// Prompt file/dir to delete.
        this._handler.deleteInfo_(this._currentDir, (ret) => {
            if (toasters$.warn_(ret[Key.errors])) {
                return;
            }
            const toast = (ret: JSONObject) => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                //// There are wanings instead of errors if delete failed on part or all files.
                if (!toasters$.warn_(ret[Key.warns])) {
                    toasters$.ok_(MSG.actionOK_(RS.ActionShredTitle));
                }
                this.refresh_(ret);
            };
            const name = this.getFilename_();
            new PromptDelete(this._container, name, ret)
                .titleKey_(RS.Confirm)
                .zindex_(Math.max(DEF.zindexPrompt, An.above_(this.element_())))
                .onOK_(todelete => {
                    if (todelete.length > 0) {
                        _Util.confirmKeySmall_(RS.ActionShredConfirm, DEF.zindexPrompt, (yes) => {
                            if (!yes) return;
                            Timer.sleep0_(() => {
                                this._handler.shred_(this._currentDir, todelete, (ret) => {
                                    toast(ret);
                                });
                            });
                        });
                    } else {
                        toast(json1_(Key.errors, "Deleted 0 files"));
                    }
                })
                .show_();
        });
    }

    private _delete1(path: string, msg: string): void {
        DialogUt.confirmSmall_(this._container, msg, An.above_(this.element_()), (yes: boolean) => {
            if (!yes) return;
            this._handler.delete_(path, (ret) => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                toasters$.warn_(ret[Key.warns]);
                this.refresh_(ret);
            });
        });
    }

    protected _actionDeleteEmptyDirs(): void {
        DialogUt.confirmSmall_(this._container, MSG.string_(RS.ConfirmDeletingEmptyDirectories), An.above_(this.element_()), (yes: boolean) => {
            if (!yes) return;
            this._handler.deleteEmptyDirs_(this.currentDir$, ret => {
                if (!toasters$.warn_(ret)) {
                    toasters$.ok_(ret[Key.result], { attop: true });
                    this.refresh_(ret);
                }
            });
        });
    }

    protected _actionRename(): void {
        const name = this.getFilename_();
        const hasfilename = (name.length > 0);
        let info: FileInfo | null = null;
        if (hasfilename) {
            info = this.dirtreeFind_(name);
            if (info == null || !info.exists$) {
                toasters$.warn_([MSG.string_(RS.SourceNotFound), name]);
                return;
            }
        }
        const from = (hasfilename ? this.currentPath_(name) : this._currentDir);
        if (!hasfilename || info != null && info.isdir$) {
            this.renameDir_(from);
        } else {
            this.renameFile_(from);
        }
    }

    protected rename1_(frompath: string, toname: string, fixxrefs: boolean): void {
        this._handler.rename_(frompath, toname, fixxrefs, ret => {
            if (toasters$.warn_(ret)) {
                return;
            }
            this.refresh_(ret);
        });
    }

    protected _actionCopy(): void {
        const path = this._actionCopy1();
        toasters$.info_(MSG.string_(RS.Copy_) + path, { attop: false });
    }

    private _actionCopy1(): string {
        const name = this.getFilename_();
        const path = this.currentPath_(name) + (name.length == 0 ? FS : "");
        this._localClipboard.map_(map_(
            [ATTR.AnAction, BUT.CopyFile],
            ["path", path],
        ));
        this.toClipboard_(path);
        return path;
    }

    protected _actionCutFile(): void {
        const path = this._actionCutFile1();
        toasters$.info_(MSG.string_(RS.Cut_) + path, { attop: false });
    }

    private _actionCutFile1(): string {
        const name = this.getFilename_();
        const path = this.currentPath_(name) + (name.length == 0 ? FS : "");
        this._localClipboard.map_(map_(
            [ATTR.AnAction, BUT.CutFile],
            ["path", path],
        ));
        this.toClipboard_(path);
        return path;
    }

    protected _actionPaste(preservetimestamp: boolean): void {
        const content = this._localClipboard.get_();
        if (content == null || content.get(MapClipboardKey.kind) != MapClipboardKind.map) {
            toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
            return;
        }
        const op = content.get(ATTR.AnAction);
        const srcpath = content.get("path");
        if (op != BUT.CopyFile && op != BUT.CutFile || srcpath === undefined) {
            toasters$.warnKey_(RS.PromptCopyInvalidClipboardContent);
            return;
        }
        const cut = (op == BUT.CutFile);
        this._handler.copyInfo_(cut, this._currentDir, srcpath, ret => {
            if (toasters$.warn_(ret)) {
                return;
            }
            const overwriting = Object.keys(ret[Key.overwriting] ?? {});
            const copying = Object.keys(ret[Key.copying] ?? {});
            const notcopying = (ret[Key.notcopying] ?? {}) as StringMap<string[]>;
            const notcopyinglen = An.keysLength(notcopying);
            const single = !srcpath.endsWith(FS) && (copying.length + notcopyinglen + overwriting.length) == 1;
            const overwrite1 = single && (copying.length == 0 && notcopyinglen == 0 && overwriting.length == 1);
            const notcopyingnotwritable = notcopying[MSG.string_(RS.DestinationNotWritable)];
            const notwritable1 = single
                && copying.length == 0
                && overwriting.length == 0
                && notcopyinglen == 1
                && notcopyingnotwritable !== undefined
                && notcopyingnotwritable.length == 1;
            if (single) {
                const oname = (overwrite1
                    ? overwriting[0]
                    : notwritable1 && notcopyingnotwritable !== undefined
                        ? notcopyingnotwritable[0]
                        : copying[0]);
                const msg = (notwritable1 ? MSG.string_(RS.PromptCopyNotWritable1) : (overwrite1 ? MSG.string_(
                    RS.PromptCopyOverwrite1) : MSG.string_(
                        RS.PromptCopy1)));
                this.pasteFile1_(
                    cut,
                    preservetimestamp,
                    msg,
                    this._currentDir,
                    oname,
                    srcpath, ret => {
                        if (toasters$.warn_(ret)) {
                            return;
                        }
                        if (!toasters$.warn_(ret[Key.warns])) {
                            toasters$.okKey_((cut ? RS.Moved1file : RS.Copied1file), { attop: true });
                        }
                        if (cut) {
                            this._localClipboard.clear_();
                        }
                        this.refresh_(ret);
                    });
                return;
            }
            const d = new PromptCopy(
                this._container,
                this._handler,
                cut,
                preservetimestamp,
                this._currentDir,
                srcpath,
                ret);
            d.titleKey_(RS.PromptPasteTitle);
            d.zindex_(Math.max(DEF.zindexPrompt, An.above_(this.element_())));
            d.onCancel_(() => {
                toasters$.infoKey_(RS.PromptCopyCancelled);
            });
            d.onOK_(ret => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                toasters$.warn_(ret[Key.warns]);
                const oks = (ret[Key.result] as Array<string>);
                const n = oks != null ? oks.length : 0;
                const msg = (cut ? (n == 1 ? MSG.string_(RS.Moved1file) : MSG.format1_(RS.Moved_files, `${n}`))
                    : n == 1 ? MSG.string_(RS.Copied1file) : MSG.format1_(RS.Copied_files, `${n}`));
                toasters$.ok_(msg, { attop: true });
                const count = ret[Key.count] ?? -1;
                if (cut && count == 0) {
                    this._localClipboard.clear_();
                }
                this.refresh_(ret);
            });
            d.show_();
        });
    }

    protected _renameFileValidator(newname: string, srcpath: Basepath, callback: StringValidatorCallback): void {
        if (newname == srcpath.filename$) {
            callback(MSG.string_(RS.CannotRenameToSelf), newname);
            return;
        }
        if (newname.includes(FS)) {
            callback(MSG.string_(RS.ExpectingSimpleFilename), newname);
            return;
        }
        if (Basepath.lcSuffixOfFilename_(newname) != srcpath.lcSuffix$) {
            callback(MSG.string_(RS.CannotChangeFileExt), newname);
            return;
        }
        const info = this.dirtreeFind_(newname);
        if (info != null && info.isdir$) {
            callback(MSG.string_(RS.DestinationExpectingAFile), newname);
            return;
        }
        if (info != null && info.exists$) {
            DialogUt.confirmOverwriting_(newname, (yes: boolean) => {
                const msg = (yes ? null : MSG.string_(RS.DestinationExistsNotOverwriting));
                callback(msg, newname);
            });
            return;
        }
        callback(null, newname);
    }

    protected _pasteFileValidator(newname: string, dstdir: string, srcpath: string, callback: StringValidatorCallback): void {
        const base = new Basepath(dstdir == null ? newname : dstdir + FS + newname);
        if (base.path$ == srcpath) {
            callback(MSG.string_(RS.CannotCopyToSelf), srcpath);
            return;
        }
        if (newname.includes(FS)) {
            callback(MSG.string_(RS.ExpectingSimpleFilename), newname);
            return;
        }
        if (base.lcSuffix$ != Basepath.lcSuffix_(srcpath)) {
            callback(MSG.string_(RS.CannotChangeFileExt), newname);
            return;
        }
        const fileinfo = this.dirtreeFind_(newname);
        if (fileinfo != null && fileinfo.isdir$) {
            callback(MSG.string_(RS.DestinationExpectingAFile), newname);
            return;
        }
        if (fileinfo != null && fileinfo.exists$) {
            DialogUt.confirmOverwriting_(newname, (yes: boolean) => {
                const msg = (yes ? null : MSG.string_(RS.DestinationExistsNotOverwriting));
                callback(msg, newname);
            });
            return;
        }
        callback(null, newname);
    }

    protected static _renameDirValidator(name: string, oname: string): stringX {
        if (name == oname) {
            return MSG.string_(RS.CannotRenameToSelf);
        }
        if (name.indexOf(FS) >= 0) {
            return MSG.string_(RS.ExpectingSimpleFilename);
        }
        return null;
    }

    static addSuffixes_(ret: Map<string, stringX>, exts: Iterable<string>, value: stringX): void {
        for (const ext of exts) {
            ret.set("." + ext, value);
        }
    }

    protected static cleanContextPath_(cpath: string): string {
        cpath = Basepath.cleanFilepath_(cpath);
        if (!cpath.startsWith(FS)) {
            cpath = FS + cpath;
        }
        return cpath;
    }

}

////////////////////////////////////////////////////////////////////////

abstract class FilepickerDialogBase extends FilepickerBase {

    protected _dateFormat: string = DateFormat.DEF;
    protected _docDir: stringX = null;
    protected _startDir: string;
    protected _dialog!: HTMLElement;
    protected _toolbar!: Toolbar;
    protected _clearButton!: HTMLElement;
    protected _todayButton!: HTMLElement;
    protected _smokescreen: Smokescreen | null = null;
    protected _maxWidth: number = DEF.filepickerMaxWidth;
    protected _cancelCallback: Fun00X = null;
    protected _helpCallback: ToasterCallback | null = null;
    protected _resizer: Fun00 | null = null;
    protected _dragger: Dragger | null = null;
    protected _dragstartCallback: DragstartCallback | null = null;
    protected _resizeSubscription: StreamSubscription | null = null;
    protected _zindex: number = DEF.zindexPrompt;
    #destroyed = false;

    /**
     * Filepicker constructor.
     * @param container The DOM element to host the Filepicker.
     * @param mode The FilepickerKind flag for type of flie to return.
     * @param root A context relative path with or without leading /. Allow selection of path under this root directory only. Empty string or / allow all.
     * @param docdir The directory that contains the current iframe document.
     * @param startdir The initial directory, must exists or filepicker would use root.
     * @param startFilename The initial filename, can be null.
     * @param gestureHandler IGestureHandler.
     * @param handler IFileinfoUtil.
     */
    constructor(
        container: HTMLElement,
        mode: FilepickerKind,
        rootdir: stringX,
        docdir: stringX,
        startdir: string,
        private _startFilename: string,
        handler: IFileinfoUtil,
    ) {
        super(container, mode, rootdir, handler);
        this._docDir = docdir == null ? null : An.removeTrailingSlashes_(docdir);
        this._startDir = An.removeTrailingSlashes_(Basepath.cleanFilepath_(startdir));
        this._currentDir = An.ensureLeadingSlash_(this._startDir);
    }

    protected createDialog_(title: string) {
        const b = new DomBuilderEx(this._container);
        this._dialog = b.div1_(CSS.AnDialog, CSS.AnFilepicker).cursor_();
        b.table1_(CSS.AnFilepicker);
        this._toolbar = this.createToolbar_(b, title);
        this._createFilepicker(b);
        this._resizer = () => this.defaultResizeFunction_();
        this._dragstartCallback = (_dragger: Dragger, target: EventTarget) => {
            const elm = DomUt.asHTMLElement_(target);
            return elm != null &&
                elm.nodeName == "TABLE" &&
                elm.classList.contains(CSS.AnFilepicker);
        };
        this._todayButton.addEventListener("click", (e) => {
            An.stopevent_(e);
            this.deselect_();
            this._filenameInput.value = An.simpleDateString_();
        });
        An.onClick_(this._clearButton, () => {
            this._filenameInput.value = "";
            if (this._suffixSelect != null) {
                this._suffixSelect.setValue_("");
            }
            this.deselect_();
        });
        if (this._mode == FilepickerKind.EXISTING_FILE) {
            An.hide_(this._clearButton);
            this._clearButton.style.display = "none";
            if (this._suffixSelect != null) {
                this._suffixSelect.element_().style.marginRight = "0px";
            }
        }
        if (this._mode != FilepickerKind.EXISTING_FILE
            && this._mode != FilepickerKind.EXISTING_DIR
            && this._mode != FilepickerKind.EXISTING_ANY) {
            An.show_(this._todayButton, "block");
        }
        this.setupEventHandlers();
    }

    protected abstract createToolbar_(b: DomBuilderEx, title: string): Toolbar;

    private _createFilepicker(b: DomBuilderEx): void {
        b.push_().tr_().td_();
        const filenameinput = b.div_({
            "class": CSS.AnFlexStretch,
            "style": "margin-top: 1ex;",
        }).child_(Conf.input$, smap_(
            ["class", `${CSS.AnFilename} ${CSS.AnFlex11Auto}`],
            ["rows", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )).cursor_() as AnInputElement;
        const readonly = (this._mode == FilepickerKind.EXISTING_FILE
            || this._mode == FilepickerKind.EXISTING_DIR
            || this._mode == FilepickerKind.EXISTING_ANY);
        const suffixselect = new SelectOptions(
            this._container,
            b.up_().div_({
                "class": CSS.AnPromptSelectExt,
                "style": "display:none;margin-left:5px;margin-right:5px",
            }).cursor_(),
            readonly || this._mode == FilepickerKind.MOVE_FILE);
        if (readonly) {
            filenameinput.readOnly = true;
            filenameinput.classList.add(CSS.AnDisabled);
            suffixselect.element_().classList.add(CSS.AnDisabled);
        } else if (this._mode == FilepickerKind.MOVE_FILE) {
            suffixselect.element_().classList.add(CSS.AnDisabled);
        } else {
            suffixselect.onChange_((value: string) => {
                const tooltipskey = this._suffices.get(value) ?? null;
                if (tooltipskey != null) {
                    toasters$.infoKey_(tooltipskey, { attop: false });
                }
            });
        }
        this._todayButton = b.up_().button_(
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaFlag}`],
            ["style", "min-height:unset;display:none"],
            [ATTR.xTooltips, RS.Tooltips_Today],
        ).cursor_();
        this._clearButton = b.up_().button_(
            ["class", `${CSS.AnButton1} ${CSS.Fa} ${CSS.FaTimesCircle}`],
            ["style", "min-height:unset"],
            [ATTR.xTooltips, RS.Tooltips_Clear],
        ).cursor_();
        b.pop_();
        b.push_().tr_().td_().push_();
        b.peek_().div_({
            "class": CSS.AnDirpath,
            "style": "padding-left:0;margin:0.5ex 0;",
        }).push_();
        const rootbutton = b.div_(
            ["class", `${CSS.AnFlexButton} ${CSS.AnLink} ${CSS.Fa} ${CSS.FaBookmarkO}`
                + (this._rootDir.length == 0 ? "" : " " + CSS.AnDisabled)
            ],
            ["style", "align-self: baseline; line-height: normal; padding-left: 10px;"],
            [ATTR.xTooltips, RS.Tooltips_RootFolder],
        ).cursor_();
        const upbutton = b.peek_().div_(
            ["class", `${CSS.AnFlexButton} ${CSS.AnLink} ${CSS.Fa} ${CSS.FaAngleDoubleUp}`
                + (this._rootDir.length == 0 ? "" : " " + CSS.AnDisabled)
            ],
            ["style", "align-self: baseline; line-height: normal; margin-left: -5px; margin-right: 10px;"],
            [ATTR.xTooltips, RS.ActionGotoParentDirTooltips],
        ).cursor_();
        const dirpathpanel = b.pop_().div1_(CSS.AnDirpathDir).cursor_();
        b.pop_().pop_();
        const dirtreepanel = b.push_().tr_().td_().div_(
            ["class", CSS.AnDirtree],
        ).cursor_();
        b.pop_();
        this.populateFilepicker_(rootbutton, upbutton, filenameinput, suffixselect, dirpathpanel, dirtreepanel);
    }

    readonlySuffix_(): this {
        if (this._suffixSelect != null) {
            this._suffixSelect?.element_().classList.add(CSS.AnDisabled);
        }
        return this;
    }

    ////////////////////////////////////////////////////////////////////////

    createContextmenu_(): Contextmenu {
        const d = new Contextmenu(this._container, An.above_(this._dialog), [
            BUT.infos_(
                BUT.CopyFile,
                BUT.CutFile,
                BUT.PasteFile,
                BUT.CloneFile,
            ),
            BUT.infos_(
                BUT.DeleteFile,
                BUT.ShredFile,
                BUT.Mkdir,
                BUT.RenameFile
            ),
            BUT.infos_(
                BUT.Noop,
                BUT.Noop,
                BUT.Noop,
                BUT.PickImage,
            ),
            BUT.infos_(
                BUT.Info,
                BUT.DeleteEmptyDirs,
                BUT.CurrentDocument,
                BUT.TargetDocument,
            ),
        ]);
        d.onTooltips_(toasters$.onTooltipsKey_);
        d.onDrag_(Contextmenu.contextmenuDragOK_);
        d.onShow_(() => this.updateContextmenuState_());
        d.onAction_((action) => this.contextActions_(action));
        return d;
    }

    fileDateString_(lastyear: DateTime, yesterday: DateTime, now: DateTime, date: number): string {
        return "\u00a0" + An.autoFileDatetimeString2_(lastyear, yesterday, now, DateTime.fromMs_(date)) + "\u00a0";
    }

    toClipboard_(_path: string): void { }

    renameDir_(frompath: string): void {
        const oname = Basepath.stem_(frompath);
        const d = this.promptDirname(RS.RenameTitle, MSG.string_(RS.RenameMessage), oname, true)
            .onOK_((d, name, fixxrefs, okcallback) => {
                name = name.trim();
                if (d.warn_(FilepickerBase._renameDirValidator(name, oname))) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                this.rename1_(frompath, name, fixxrefs);
            });
        d.zindex_(An.above_(this._dialog));
        d.show_();
    }

    renameFile_(frompath: string): void {
        const opath = new Basepath(frompath);
        const d = this.promptRename_(
            RS.RenameTitle,
            MSG.string_(RS.RenameMessage),
            opath)
            .onOK_((d, toname, fixxrefs, okcallback) => {
                toname = toname.trim();
                this._renameFileValidator(toname, opath, (error: any, toname: string) => {
                    if (d.warn_(error)) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    //// If confirmed overwriting, delete the file first, before rename.
                    const info = this.dirtreeFind_(toname);
                    if (info != null && info.exists$ && !info.isdir$) {
                        const newpath = opath.changeFilename_(toname).path$;
                        this._handler.delete_(newpath, ret => {
                            if (toasters$.warn_(ret)) {
                                //// Delete failed.
                                return;
                            }
                            this.rename1_(frompath, toname, fixxrefs);
                        });
                    } else {
                        this.rename1_(frompath, toname, fixxrefs);
                    }
                });
            });
        d.above_(this._dialog);
        d.show_();
    }

    pasteFile1_(
        cut: boolean,
        preservetimestamp: boolean,
        msg: string,
        dstdir: string,
        dstfilename: string,
        srcpath: string,
        callback: JSONCallback
    ): void {
        const d = this.promptRename_(
            RS.PromptPasteTitle, msg, new Basepath(dstfilename))
            .onOK_((d, name, fixxrefs, okcallback) => {
                name = name.trim();
                this._pasteFileValidator(name, dstdir, srcpath, (error: any, toname: string) => {
                    if (d.warn_(error)) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    const topath = this.currentPath_(toname);
                    this._handler.copy_(cut, preservetimestamp, fixxrefs, topath, srcpath, null, callback);
                });
            });
        d.above_(this._dialog);
        d.show_();
    }

    updateContextmenuState_(): void {
        With.optional_(this.contextmenu$, menu => {
            menu.enableButton_(BUT.CurrentDocument, this._docDir != null);
            menu.enableButton_(BUT.TargetDocument, this._startDir != null);
        });
        super.updateContextmenuState_();
    }

    updateToolbarState_(dirtree: FileInfo[] | null): void {
        if (dirtree == null) { return; }
        this._toolbar.enableButton_(BUT.Forward, this._history.canForward_());
        this._toolbar.enableButton_(BUT.Backward, this._history.canBackward_());
    }

    ////////////////////////////////////////////////////////////////////////

    element_(): HTMLElement {
        return this._dialog;
    }

    disableContextmenu_(): this {
        this._toolbar.enableButton_(BUT.Contextmenu, false);
        return this;
    }

    onHelp_(callback: ToasterCallback): this {
        this._helpCallback = callback;
        this._toolbar.showButton_(BUT.Help, true);
        return this;
    }

    zindex_(zindex: number): this {
        this._zindex = zindex;
        this._dialog.style.zIndex = `${zindex}`;
        return this;
    }

    above_(host: HTMLElement, delta: number = DEF.zindexAbove10): this {
        return this.zindex_(An.zindexOf_(host, delta, DEF.zindexUnder + delta));
    }

    dateFormat_(dateformat: string): this {
        this._dateFormat = dateformat;
        return this;
    }

    setDelegate_(d: FilepickerDelegate): this {
        this._delegate = d;
        this.setSuffixes_(d.getSuffixes_());
        return this;
    }

    /// @param callback().
    onCancel_(callback: Fun00): this {
        this._cancelCallback = callback;
        return this;
    }

    onView_(callback: ViewMediaCallback): this {
        this._viewCallback = callback;
        return this;
    }

    onResize_(f: FilepickerResizer): this {
        this._resizer = () => {
            f(this);
        };
        return this;
    }

    /**
         * Note that this is optional.
         * There is a default callback that should be good for most cases.
         * @param dragstartcallback (dragger, target, x, y)
         */
    onDragstart_(dragstartcallback: DragstartCallback): this {
        this._dragstartCallback = dragstartcallback;
        return this;
    }

    maxWidth_(w: number): this {
        this._maxWidth = w;
        return this;
    }

    show_(): this {
        Assert.assertionKey_(this._zindex != null, RS.ZIndex);
        Assert.assertionKey_(this._delegate != null, RS.ADelegateIsRequired);
        const style = this.dirtreePanel$.style;
        style.height = "0px";
        style.maxHeight = "0px";
        An.showHidden_(this._dialog, "block");
        this.updateToolbarState_(this._dirtree);
        const resizer = this._resizer;
        if (resizer == null) { Assert.fail_(); }
        this._resizeSubscription = An.subscriptEvent_(window, "resize", () => resizer());
        this._smokescreen = new Smokescreen(this._container, An.zindexOf_(this._dialog, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
        this._smokescreen.on_("click", e => {
            resizer();
            An.stopevent_(e);
        });
        this._smokescreen.show_();
        this._handler.listDir_(this._currentDir, ret => {
            if (An.hasResult_(ret[Key.errors])) {
                this._handler.listDir_("", ret => {
                    ret[Key.filename] = null;
                    this.show1_(ret, resizer);
                });
                return;
            }
            this.show1_(ret, resizer);
        });
        return this;
    }

    private show1_(ret: JSONObject, resizer: Fun00): void {
        if (this._dialog != null) {
            ///#NOTE In case dialog closed before result returns, eg. in testing.
            if (this.filenameInput$.readOnly) {
                host$.hideKeyboard0_();
            }
            ret[Key.filename] = this._startFilename;
            if (this._mode == FilepickerKind.MOVE_FILE) {
                this._suffixSelect?.setValue_(Basepath.suffix_(this._startFilename));
            }
            this.refresh_(ret);
            An.setVisible_(this.element_());
            resizer();
            if (this._dragger == null && this._dragstartCallback != null) {
                this._dragger = new Dragger(this._dialog, new VerticalDraggerHandler(this._dragstartCallback))
                    .bind_();
            }
        }
    }

    defaultResizeFunction_(): void {
        const dialog = this.element_();
        if (dialog == null) return;
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        const minxmargin = winwidth / 16;
        const toolbarheight = Math.round(this._toolbar
            .element_()
            .getBoundingClientRect()
            .height);
        const dragborder = toolbarheight / DEF.dragBorderDivider;
        const xextra = DEF.dialogPaddingWidth * 2 /* + 0.5 left border */ + dragborder;
        let maxwidth = winwidth - minxmargin * 2 /* dialog margin */ - xextra;
        if (this._maxWidth != null) {
            maxwidth = Math.min(this._maxWidth + xextra, maxwidth);
        }
        const xmargin = winwidth - (maxwidth + xextra);
        let left = minxmargin;
        if (xmargin > minxmargin * 2) {
            left = xmargin / 2;
        }
        An.setLeftTop_(dialog, left, toolbarheight * 2);
        const div = DomUt.query_(dialog, `div.${CSS.AnDirtree}`);
        if (div == null) return;
        const top = An.documentOffset_(div).y;
        const treeheight = winheight -
            top -
            toolbarheight /* bottom margin */ -
            10 /* table bottom padding */ -
            (dragborder / 2) /* table bottom border */ -
            8 /* td top and bottom paddings */ -
            2 /* td top and bottom borders */;
        
        const maxwidthpx = `${maxwidth}px`;
        for (const td of Array.from(DomUt.queryAll_(dialog, `table.${CSS.AnFilepicker} > tr > td`))) {
            const style = td.style;
            style.width = maxwidthpx;
            style.maxWidth = maxwidthpx;
        }
        const treeheightpx = `${treeheight}px`;
        const style = div.style;
        style.height = treeheightpx;
        style.maxHeight = treeheightpx;
    }

    /// Without the dialog frame.
    defaultResizeViewFunction_(_e: Event, _self: Filepicker): void {
        const dialog = this.element_();
        if (dialog == null) return;
        const winwidth = window.innerWidth;
        const winheight = window.innerHeight;
        An.setLeftTop_(dialog, 0, 0);
        const maxwidth = winwidth;
        const div = DomUt.query_(dialog, `div.${CSS.AnDirtree}`);
        if (div == null) return;
        const top = An.documentOffset_(div).y;
        const treeheight =
            winheight - top - 10 /* table bottom padding */ - 1 /* table bottom border */ - 8 /* td top and bottom paddings */ -
            2 /* td top and bottom borders */;
        
        const maxwidthpx = `${maxwidth}px`;
        for (const td of Array.from(DomUt.queryAll_(dialog, `table.${CSS.AnFilepicker} > tr > td`))) {
            const style = td.style;
            style.width = maxwidthpx;
            style.maxWidth = maxwidthpx;
        }
        const treeheightpx = `${treeheight}px`;
        const style = div.style;
        style.height = treeheightpx;
        style.maxHeight = treeheightpx;
    }

    /* @return The DOM element for the toolbar button with the given action. */
    getButton_(action: string): HTMLElement {
        return this._toolbar.button_(action);
    }

    ////////////////////////////////////////////////////////////////////////

    close_(): void {
        if (this.#destroyed) { return; }
        this.#destroyed = true;
        An.hide_(this._dialog);
        if (this._smokescreen != null) {
            this._smokescreen.destroy_();
            this._smokescreen = null;
        }
        if (this._dragger != null) {
            this._dragger.destroy_();
            this._dragger = null;
        }
        if (this._resizeSubscription != null) {
            this._resizeSubscription.cancel_();
            this._resizeSubscription = null;
        }
        if (this._contextmenu != null) {
            this._contextmenu.destroy_();
            this._contextmenu = null;
        }
        this._dialog.remove();
        this._cancelCallback = null;
        this._helpCallback = null;
        this._viewCallback = null;
        this._dragstartCallback = null;
        this._fileSelectedCallback = null;
    }

    private contextActions_(action: string): void {
        With.optional_(this.contextmenu$, menu => {
            menu.hide_();
            menu.enableButtons_([BUT.DeleteFile, BUT.Mkdir, BUT.RenameFile], false);
        });
        switch (action) {
            case BUT.CopyFile:
                this._actionCopy();
                break;
            case BUT.CutFile:
                this._actionCutFile();
                break;
            case BUT.PasteFile:
                this._actionPaste(false);
                break;
            case BUT.CloneFile:
                this._actionPaste(true);
                break;
            case BUT.DeleteFile:
                this._actionDelete();
                break;
            case BUT.ShredFile:
                this._actionShred();
                break;
            case BUT.Mkdir:
                this._actionMkdir(this._dialog);
                break;
            case BUT.RenameFile:
                this._actionRename();
                break;
            case BUT.DeleteEmptyDirs:
                this._actionDeleteEmptyDirs();
                break;
            case BUT.Info:
                this.actionShowFileInfo_();
                break;
            case BUT.PickImage:
                this._actionPickImage(this._dialog);
                break;
            case BUT.CurrentDocument:
                if (this._docDir != null) {
                    this._handler.listDir_(this._docDir + FS + this.getFilename_(), ret => {
                        if (toasters$.warn_(ret)) {
                            return;
                        }
                        this.refresh_(ret);
                    });
                }
                break;
            case BUT.TargetDocument:
                this._handler.listDir_(this._startDir + FS + this.getFilename_(), ret => {
                    if (toasters$.warn_(ret)) {
                        return;
                    }
                    this.refresh_(ret);
                });
                break;
            default:
                Assert.invalidAction_(action);
        }
    }

    protected actionPaste_(): void {
        if (this._clipboardGetter == null) {
            return;
        }
        this._clipboardGetter(ret => {
            if (!toasters$.warn_(ret[Key.errors])) {
                const v = this.getFilename_();
                const start = this.filenameInput$.selectionStart;
                const end = this.filenameInput$.selectionEnd;
                
                const offset = (start <= end ? start : end);
                const before = v.substring(0, offset);
                const after = v.substring(offset);
                const result = ret[Key.result];
                this.setFilename_((before + result + after).trim());
            }
        });
    }

    protected actionHelp_(): void {
        if (this._helpCallback == null) {
            return;
        }
        toasters$.modal_(this._helpCallback);
    }
}

class Filepicker extends FilepickerDialogBase {

    _okCallback: FilepickerOKCallback | null = null;
    _validateCallback: Fun40<string, FileInfo, FilepickerKind, Fun10<boolean>> = (path, info, mode, okcallback) => {
        this.defaultValidator_(path, info, mode, okcallback);
    };

    static withTitleKey_(
        container: HTMLElement,
        titlekey: StringId,
        mode: FilepickerKind,
        rootdir: stringX,
        docdir: stringX,
        startdir: string,
        startFilename: string,
        fileinfoutil: IFileinfoUtil,
    ) {
        return new Filepicker(
            container,
            MSG.string_(titlekey),
            mode,
            rootdir,
            docdir,
            startdir,
            startFilename,
            fileinfoutil,
        );
    }

    constructor(
        container: HTMLElement,
        title: string,
        mode: FilepickerKind,
        rootdir: stringX,
        docdir: stringX,
        startdir: string,
        startFilename: string,
        fileinfoutil: IFileinfoUtil,
    ) {
        super(
            container,
            mode,
            rootdir,
            docdir,
            startdir,
            startFilename,
            fileinfoutil,
        );
        super.createDialog_(title);
    }

    /// @param callback(path)
    ///  where path would be a context relative path with leading /.
    onOK_(callback: FilepickerOKCallback): this {
        this._okCallback = callback;
        return this;
    }

    /// This override the default FILEPICKER_KIND validation.
    /// @param callback Call filepicker.defaultValidator() for the default FILEPICKER_KIND validation.
    onValidate_(callback: Fun40<string, FileInfo, FilepickerKind, Fun10<boolean>>): this {
        this._validateCallback = callback;
        return this;
    }

    onFileInfo_(name: string): void {
        this._actionOK(name.trim());
    }

    defaultValidator_(path: string, fileinfo: FileInfo, mode: FilepickerKind, okcallback: Fun10<boolean>) {
        if ((mode == FilepickerKind.EXISTING_ANY
            || mode == FilepickerKind.EXISTING_FILE
            || mode == FilepickerKind.EXISTING_DIR
            || mode == FilepickerKind.WRITE_DIR)
            && fileinfo.notexists$) {
            toasters$.warnKey_(RS.SpecifiedFileDoesNotExistsPleaseTryAgain);
            okcallback(false);
            return;
        }
        if (mode == FilepickerKind.ANY_FILE
            || mode == FilepickerKind.EXISTING_FILE
            || mode == FilepickerKind.NEW_FILE
            || mode == FilepickerKind.MOVE_FILE
            || mode == FilepickerKind.WRITE_FILE) {
            if (fileinfo.exists$ && !fileinfo.isfile$) {
                toasters$.warnKey_(RS.DestinationExpectingAFile);
                okcallback(false);
                return;
            }
        }
        if (mode == FilepickerKind.ANY_DIR
            || mode == FilepickerKind.EXISTING_DIR
            || mode == FilepickerKind.WRITE_DIR) {
            if (fileinfo.exists$ && !fileinfo.isdir$) {
                toasters$.warnKey_(RS.DestinationExpectingADir);
                okcallback(false);
                return;
            }
        }
        if (mode == FilepickerKind.WRITE_DIR) {
            if (fileinfo.exists$ && !fileinfo.isdir$) {
                toasters$.warnKey_(RS.DestinationNotWritable);
                okcallback(false);
                return;
            }
        }
        if (mode == FilepickerKind.NEW_FILE || mode == FilepickerKind.MOVE_FILE || mode == FilepickerKind.WRITE_FILE) {
            const dir = Basepath.dir_(path);
            if (dir == null) {
                toasters$.warnKey_(RS.InvalidFilepath);
                okcallback(false);
                return;
            }
            this._handler.fileInfo_(dir, ret => {
                if (toasters$.warn_(ret)) {
                    
                    okcallback(false);
                    return;
                }
                const dirinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (dirinfo == null) {
                    toasters$.warnKey_(RS.InvalidFilepath);
                    okcallback(false);
                    return;
                }
                if ((mode == FilepickerKind.WRITE_FILE || mode == FilepickerKind.MOVE_FILE)
                    && (!dirinfo.writable$ || fileinfo.exists$ && !fileinfo.writable$)
                    || (mode == FilepickerKind.NEW_FILE && !dirinfo.writable$)) {
                    toasters$.warnKey_(RS.DestinationNotWritable);
                    okcallback(false);
                    return;
                }
                if (mode == FilepickerKind.NEW_FILE && fileinfo.exists$) {
                    toasters$.warnKey_(RS.SpecifiedFileAlreadyExistsPleaseTryAgain);
                    okcallback(false);
                    return;
                }
                if ((mode == FilepickerKind.WRITE_FILE || mode == FilepickerKind.MOVE_FILE) && fileinfo.exists$) {
                    DialogUt.promptOK_(this._container, RS.ConfirmOverwriting, fileinfo.name$, (yes: boolean) => {
                        okcallback(yes);
                    })
                        .above_(this._dialog)
                        .showWarning_();
                    return;
                }
                okcallback(true);
            });
            return;
        }
        okcallback(true);
    }

    protected createToolbar_(b: DomBuilderEx, title: string): Toolbar {
        b.push_().tr_().td_();
        const toolbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.Help,
            BUT.Contextmenu,
            BUT.Backward,
            BUT.Forward,
            BUT.OK,
            BUT.Cancel,
        ));
        toolbar.onAction_(this._toolbarActions);
        toolbar.onTooltips_(toasters$.onTooltipsKey_);
        toolbar.titleText_(title);
        b.pop_();
        return toolbar;
    }

    readonly _toolbarActions = (action: string, e: MouseEvent) => {
        switch (action) {
            case BUT.OK:
                this._actionOK(this.getFilename_());
                break;
            case BUT.Cancel:
                const callback = this._cancelCallback;
                this.close_();
                Timer.optional0_(callback, (callback) => callback());
                break;
            case BUT.Backward:
                this._actionBackward();
                break;
            case BUT.Forward:
                this._actionForward();
                break;
            case BUT.PickImage:
                this._actionPickImage(this._dialog);
                break;
            case BUT.Contextmenu:
                this.showContextmenu_(e);
                break;
            case BUT.PasteFromLocalClipboard:
                this.actionPaste_();
                break;
            case BUT.Help:
                this.actionHelp_();
                break;
            default:
                Assert.invalidAction_(action);
        }
    };

    private _actionOK(name: string): void {
        const path = this.currentPath_(name);
        this._handler.fileInfo_(path, ret => {
            if (toasters$.warn_(ret)) {
                
                return;
            }
            const info = FileInfo.of_(ret[Key.fileinfo]);
            if (info == null) {
                toasters$.warnKey_(RS.InvalidFilepath);
                return;
            }
            this._delegate?.validate_(path, info, ret => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                this._validateCallback(path, info, this._mode, (ok) => {
                    if (ok) this._ok0(path, info);
                });
            });
        });
    }

    private _ok0(path: string, info: FileInfo): void {
        this._ok1(path, info);
    }

    private _ok1(path: string, info: FileInfo): void {
        this._okCallback?.((ok) => {
            if (!ok) return;
            this.close_();
            this._okCallback = null;
        }, FilepickerBase.cleanContextPath_(path), info);
    }
}

class ZipFilepicker extends Filepicker {
    constructor(
        container: HTMLElement,
        title: string,
        kind: FilepickerKind,
        fileinfoutil: IFileinfoUtil,
    ) {
        super(container, title, kind, "", null, "", "", /* gesturehandler, */ fileinfoutil);
    }
}

class HistoryFilepicker extends CompositeDialogBase {

    private okCallback$: Fun10X<string> = null;
    private dirpath$: string = "";
    private dirtree$ = Array<DeletedFileStat>();
    private rows$ = Array<HTMLElement>();
    private selected$ = new Set<Int>();

    /// @startpath Contex relative path with or without leading /, but with trailing / for directory.
    constructor(
        container: HTMLElement,
        startpath: string,
        private fileinfoutil$: IFileinfoUtil,
        private historyutil$: IFileinfoUtil,
        private dateFormat$: string,
    ) {
        super(
            container,
            [
                new FilterField(
                    "", "", RS.PlacholderRegexSearch, (regex) => {
                        this.search_(regex.trim());
                    }
                ),
                new DirpathField(
                    "", "", "", (target) => {
                        if (target == null) {
                            this.deselect_();
                            if (this.dirpath$.length == 0) {
                                this._showDirInfo("");
                            } else {
                                this.refresh("");
                            }
                        } else {
                            const path = target?.getAttribute(ATTR.AnInfo) ?? "";
                            if (path.length > 0) {
                                this.deselect_();
                                this.refresh(path);
                            }
                        }
                    }
                ),
                new DirtreeField(
                    "", (target) => {
                        const classes = target.classList;
                        const index = An.parseInt_(target.getAttribute(ATTR.AnInfo), -1);
                        if (index < 0 || index >= this.dirtree$.length) return;
                        if (classes.contains(CSS.AnDir)
                            || classes.contains(CSS.AnFile)) {
                            this.deselect_();
                            const info = this.dirtree$[index];
                            let cpath = Basepath.trim_(Basepath.joinRpath_(info.dir_(), info.name$));
                            this.refresh1("", (info.isdir$ && cpath.indexOf(FS) >= 0 || this.dirpath$.length == 0) ? cpath + FS : cpath);
                            return;
                        }
                        if (classes.contains(CSS.AnFileInfo)) {
                            const info = this.dirtree$[index];
                            if (info.isdir$) {
                                let cpath = Basepath.joinRpath_(info.dir_(), info.name$);
                                this._showDirInfo(this.dirpath$.length == 0 ? cpath + FS : cpath);
                            } else {
                                this.actionRecover_(Array.of(info));
                            }
                            return;
                        }
                        this.select_(index);
                    },
                    (dirtree) => {
                        const top = An.documentOffset_(dirtree).y;
                        const winheight = window.innerHeight;
                        const toolbarheight = cache$.ui$.toolbarHeight_();
                        const dragborder = toolbarheight / DEF.dragBorderDivider;
                        const treeheight = winheight -
                            top -
                            toolbarheight /* bottom margin */ -
                            10 /* table bottom padding */ -
                            (dragborder / 2) /* table bottom border */ -
                            8 /* td top and bottom paddings */ -
                            2 /* td top and bottom borders */;
                        const treeheightpx = `${treeheight}px`;
                        const style = dirtree.style;
                        style.height = treeheightpx;
                        style.maxHeight = treeheightpx;
                        style.border = DEF.themeBorder;
                    },
                ),
            ],
        );
        this.largeWidth_();
        this.refresh(startpath);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infos_(
                BUT.PickImage,
                BUT.CleanupTrash,
                BUT.DeleteFile,
                BUT.Recover,
                BUT.Cancel,
            )).enableButton_(BUT.PickImage, false)
                .titleKey_(RS.Trash),
            (action) => this._toolbarActions(action)
        );
    }

    private _showDirInfo(cpath: string) {
        this.historyutil$.dirInfo_(cpath, (ret) => {
            if (toasters$.warn_(ret)) return;
            const [files, dirs, size] = ret[Key.result];
            FilepickerBase.showDirInfo_(cpath, files, dirs, size);
        });
    }

    private deselect_() {
        this.selected$.forEach(index => {
            this.rows$[index]?.classList?.remove(CSS.AnSelectedHighlight);
        });
        this.selected$.clear();
    }

    private select_(index: Int) {
        if (index < 0 || index >= this.rows$.length) return;
        if (this.selected$.delete(index)) {
            this.rows$[index]?.classList?.remove(CSS.AnSelectedHighlight);
            return;
        }
        const info = this.dirtree$[index];
        if (info != null && info.isfile$) {
            this.rows$[index]?.classList?.add(CSS.AnSelectedHighlight);
            this.selected$.add(index);
        }
    }

    private getSelection_(): ArrayX<DeletedFileStat> {
        if (this.dirtree$ == null || this.selected$.size == 0) return null;
        return [...this.selected$].map((index) => this.dirtree$[index]);
    }

    /// @cpath Context relative path with or without leading /, but with trailing / for directory.
    private refresh(cpath: string) {
        this.refresh1(this.getValueAt_(0).trim(), cpath);
    }

    private refresh1(pat: string, cpath: string) {
        let cleanpath = Basepath.trimLeading_(Basepath.cleanFilepath_(cpath));
        if (pat.length > 0) {
            this.historyutil$.listRecursive_(json_(
                [Key.path, cleanpath],
                [Key.text, pat],
            ), (ret) => this.refresh2(true, ret));
        } else {
            this.historyutil$.fileInfo_(cleanpath, (ret) => this.refresh2(false, ret));
        }
    }

    private refresh2(searchresult: boolean, ret: JSONObject): void {
        if (toasters$.warn_(ret)) {
            if (searchresult) {
                this.getFieldAt_(0)?.getInput_(0)?.classList?.add(CSS.AnErr);
            }
            return;
        }
        this.refreshDirpath(ret);
        this.refreshDirtree(searchresult, ret);
        if (this.dirtree$.length == 0) {
            this.deselect_();
        } else if (this.selected$.size > 0) {
            const len = this.dirtree$.length;
            [...this.selected$].forEach((index) => {
                if (index < len) {
                    this.select_(index);
                    return;
                }
                this.selected$.delete(index);
                if (!this.selected$.has(len - 1)) {
                    this.selected$.add(len - 1);
                    this.select_(len - 1);
                }
            });
        }
        this.updateToolbarState();
    }

    private updateToolbarState() {
    }

    private refreshDirpath(ret: JSONObject) {
        const createlink = (b: DomBuilderEx, name: string, xinfo: string) => {
            b.a_(
                ["class", CSS.AnDirpathDir],
                [ATTR.AnInfo, xinfo],
            ).text_(name)
                .up_()
                .text_(` ${FS} `);
        };
        const createroot = (b: DomBuilderEx, path: string, callback: Fun10<string>) => {
            const index = path.indexOf(FS);
            if (index < 0) {
                createlink(b, path, path + FS);
            } else {
                const root = path.substring(0, index);
                const dir = path.substring(index + 1);
                createlink(b, root, root + FS);
                callback(dir);
            }
        };
        const elm = this.getFieldAt_(1).getValueElement_(0) as HTMLElement;
        const b = new DomBuilderEx(elm).empty_();
        this.dirpath$ = ret[Key.path] ?? "";
        if (this.dirpath$.length == 0) return;
        if (this.dirpath$.endsWith(FS)) {
            createroot(b, this.dirpath$, (dir) => {
                if (dir.length > 0)
                    b.text_(Basepath.trimTrailing_(dir) + ` ${FS} `);
            });
        } else {
            let [dir, name] = Basepath.splitPath_(this.dirpath$);
            if (dir.length == 0) {
                createlink(b, name, name + FS);
            } else {
                createroot(b, dir, (d) => {
                    createlink(b, d, dir + FS);
                });
                b.text_(name);
            }
        }
    }

    private refreshDirtree(searchresult: boolean, ret: JSONObject) {
        let elm = this.getFieldAt_(2).getValueElement_(0) as HTMLElement;
        let bb = new DomBuilderEx(elm).empty_();
        this.rows$ = Array<HTMLElement>();
        this.dirtree$ = DeletedFileStat.arrayOf_(ret[Key.dirtree]) ?? Array<DeletedFileStat>();
        if (this.dirtree$.length == 0) return;
        const b = DomBuilderEx.offline1_(document, "div", CSS.AnViewportContent);
        b.push_().div_({
            "class": `${CSS.AnPromptContent} ${CSS.AnZebra}`,
            "style": `border-bottom:${DEF.themeBorder}`,
        }).push_();
        const len = this.dirtree$.length;
        for (let i = 0; i < len; ++i) {
            const fileinfo = this.dirtree$[i];
            const isdir = fileinfo.isdir$;
            const rpath = Basepath.joinRpath_(fileinfo.dir_(), fileinfo.name$);
            const sizeunit = fileinfo.sizeunit$;
            const date = this.fileDateString(fileinfo.lastDeleted_());
            const index = i.toString();
            const row = b.peek_().div_(
                ["class", CSS.AnRow],
                [ATTR.AnInfo, index],
            ).push_().cursor_();
            this.rows$.push(row);
            const create = (tag: string, attr: string, index: string, text: string) => {
                return b.peek_().child_(tag, smap_(
                    ["class", attr],
                    [ATTR.AnInfo, index]
                ))
                    .text_(text);
            };
            const code = (text: string) => {
                return b.peek_().code_().text_(text);
            };
            if (searchresult) {
                create("a", CSS.AnFileInfo, index, sizeunit);
                code(date);
                if (rpath != this.dirpath$) {
                    create("a", CSS.AnFile, index, rpath.substring(this.dirpath$.length));
                } else {
                    create("a", CSS.AnFile, index, Basepath.filename_(rpath));
                }
            } else if (isdir) {
                const dir = (this.dirpath$.length == 0)
                    ? rpath
                    : (rpath.indexOf(FS) >= 0)
                        ? Basepath.splitFirst_(rpath)[1]
                        : ".";
                create("a", CSS.AnFileInfo, index, sizeunit);
                b.code_().text_(date);
                create("a", CSS.AnDir, index, dir);
            } else {
                create("a", CSS.AnFileInfo, index, sizeunit);
                code(date);
                if (rpath != this.dirpath$) {
                    create("a", CSS.AnFile, index, fileinfo.name$);
                } else {
                    create("span", CSS.AnFile, index, fileinfo.name$);
                }
            }
            b.pop_();
        }
        bb.appendNodes_(b.pop_(2).cursor_());
        elm.scrollTo(0, 0);
    }

    fileDateString(ms: number): string {
        let datetime = DateTime.fromMs_(ms);
        return "\u00a0" + DateFormat.dateString_(this.dateFormat$, datetime) + "\u00a0"
            + TimeFormat.longString_(TimeFormat.HH_MM, datetime) + "\u00a0";
    }

    /**
     * @param callback(path)
     * where path would be a context relative path with leading /.
     */
    onOK_(callback: Fun10<string>): this {
        this.okCallback$ = callback;
        return this;
    }

    protected _toolbarActions(action: string) {
        switch (action) {
            case BUT.PickImage:
                this._pickImage();
                break;
            case BUT.CleanupTrash:
                this.actionCleanupTrash_();
                break;
            case BUT.DeleteFile:
                this.actionDeleteFile_(this.getSelection_());
                break;
            case BUT.Recover:
                this.actionRecover_(this.getSelection_());
                break;
            case BUT.Cancel:
                const callback = this._cancelCallback;
                super.close_();
                Timer.optional0_(callback, (callback) => callback());
                break;
            default:
                Assert.invalidAction_(action);
        }
    }

    private search_(pat: string): void {
        const classlist = this.getFieldAt_(0).getInput_(0)?.classList;
        classlist?.remove(CSS.AnErr);
        if (pat.length > 0) {
            const regex = RX.regexOrNull(pat);
            if (regex == null) {
                toasters$.warn_(MSG.string1_(RS.InvalidRegex_, pat));
                classlist?.add(CSS.AnErr);
                return;
            }
        }
        this.refresh1(pat, this.dirpath$);
    }

    private _pickImage() {
        throw new Error("TODO");
    }

    private actionCleanupTrash_(): void {
        host$.cleanupTrash_("", (ret) => {
            toasters$.warn_(ret, { hold: true }) || toasters$.info_(ret[Key.result], { attop: true });
            host$.updateSessionPreferences_(smap1_(
                SessionPreferencesKey.trashAutoCleanupTimestamp, DateTime.now_().millisecondsSinceEpoch$,
            ), () => {
                this.refresh(this.dirpath$);
            });
        });
    }

    private actionDeleteFile_(infos: ArrayX<DeletedFileStat>): void {
        const action = (infos: Array<DeletedFileStat>) => {
            const array = infos.map((info) => info.toJSON_());
            const params = json_(
                [Key.path, this.dirpath$],
                [Key.infos, array],
            );
            if (this.dirpath$.endsWith(FS)) {
                this.historyutil$.deleteDirSubtree_(JSON.stringify(params), (ret) => this.deleteResult_(ret));
            } else {
                this.historyutil$.delete_(JSON.stringify(params), (ret) => this.deleteResult_(ret));
            }
        };
        if (infos == null) {
            DialogUt.confirmKeySmall_(this.container_(), RS.ConfirmDeletingRecursively,
                An.above_(this.element_()), (yes) => {
                    if (!yes) return;
                    action(this.dirtree$);
                });
        } else {
            DialogUt.confirmSmall_(this.container_(), MSG.format1_(RS.ConfirmDeleting_Items, `${infos.length}`),
                An.above_(this.element_()), (yes) => {
                    if (!yes) return;
                    action(infos);
                });
        }
    }

    private deleteResult_(ret: JSONObject) {
        if (!toasters$.warn_(ret, { hold: true })) {
            toasters$.ok_(ret[Key.result], { attop: true });
        }
        this.refresh(this.dirpath$);
    }

    private actionRecover_(infos: ArrayX<DeletedFileStat>): void {
        if (infos == null || infos.length == 0) {
            if (this.dirpath$.endsWith(FS) && this.dirtree$.length > 0 && this.dirtree$[0].isfile$) {
                DialogUt.confirmKeySmall_(this.container_(), RS.RecoverEveryDeletedFileInThisDirectory_Confirmation,
                    An.above_(this.element_()), (yes) => {
                        if (!yes) return;
                        this.recover(this.dirtree$);
                    });
                return;
            }
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        if (infos.length > 1) {
            this.recover(infos);
        } else {
            this.recover1(infos[0]);
        }
    }

    private recover(infos: DeletedFileStat[]) {
        const info = infos[0];
        this.prepareToWrite((info.dir_() ?? ""), () => {
            const d = Filepicker.withTitleKey_(
                this.container_(),
                RS.DestinationDir,
                FilepickerKind.EXISTING_DIR,
                "",
                null,
                (info.dir_() ?? ""),
                "",
                this.fileinfoutil$)
                .above_(this.element_())
                .setDelegate_(FilepickerDirDelegate.singleton$)
                .onOK_((okcallback, cpath, fileinfo) => {
                    if (fileinfo.exists$ && !fileinfo.isdir$) {
                        toasters$.warn_(MSG.string_(RS.DestinationExpectingADir));
                        okcallback(false);
                        return;
                    }
                    this.checkOverwriting(cpath, infos, (list) => {
                        if (list.length > 0) {
                            DialogUt.promptOK_(this.container_(), RS.ConfirmOverwriting, list, (yes) => {
                                if (!yes) {
                                    okcallback(false);
                                    return;
                                }
                                okcallback(true);
                                this.recover2(cpath, infos);
                            })
                                .above_(d.element_())
                                .showWarning_();
                            return;
                        }
                        okcallback(true);
                        this.recover2(cpath, infos);
                    });
                })
                .show_();
        });
    }

    private recover2(cpath: string, infos: DeletedFileStat[]) {
        this.historyutil$.rename_(stringify_(
            [Key.src, this.dirpath$],
            [Key.infos, infos.map((info) => info.toJSON_())],
            [Key.dst, cpath],
        ), "", false, (ret) => this.recoverResult(ret, cpath));
    }

    private checkOverwriting(dstdir: string, infos: DeletedFileStat[], callback: Fun10<string[]>) {
        const overwriting = Array<string>();
        An.iterateList_(infos, (info, _index, next) => {
            this.fileinfoutil$.fileInfo_(Basepath.joinPath_(dstdir, info.name$), (ret) => {
                const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (fileinfo != null && fileinfo.exists$) {
                    overwriting.push(info.name$);
                }
                next(false);
            });
        }, () => callback(overwriting));
    }

    private prepareToWrite(dstdir: string, callback: Fun00) {
        this.fileinfoutil$.fileInfo1_(toasters$, dstdir, (dirinfo) => {
            if (dirinfo.exists$) {
                callback();
                return;
            }
            DialogUt.confirmKeySmall_(this.container_(),
                RS.ConfirmCreateDestinationDirectory, An.above_(this.element_()), (yes) => {
                    if (!yes) {
                        callback();
                        return;
                    }
                    this.fileinfoutil$.mkDirs_(dstdir, (ret) => {
                        toasters$.warn_(ret);
                        callback();
                    });
                });
        });
    }

    private recover1(info: DeletedFileStat) {
        const dir = (info.dir_() ?? "");
        this.prepareToWrite(dir, () => {
            Filepicker.withTitleKey_(
                this.container_(),
                RS.DestinationFile,
                FilepickerKind.WRITE_FILE,
                "",
                null,
                dir,
                info.name$,
                this.fileinfoutil$)
                .above_(this.element_())
                .setDelegate_(new FilepickerSameSuffixDelegate(Basepath.suffix_(info.name$)))
                .onOK_((okcallback, cpath) => {
                    okcallback(true);
                    this.historyutil$.rename_(stringify_(
                        [Key.src, this.dirpath$],
                        [Key.infos, [info.toJSON_()]],
                        [Key.dst, cpath],
                    ), "", false, (ret) => this.recoverResult(ret, cpath));
                })
                .show_();
        });
    }

    private recoverResult(ret: JSONObject, cpath: string) {
        if (toasters$.warn_(ret, { hold: true })) {
            this.refresh(this.dirpath$);
        } else {
            this.close_();
            this.okCallback$?.(cpath);
            this.okCallback$ = null;
        }
    }

    protected _onOK(_done: BoolCallback): void {
        throw new Error();
    }
}

class LocalMediaInfoHandler implements IMediaInfoHandler {

    constructor(private _path: string, private _handler: IFilepickerHandler) { }

    infos_(callback: JSONCallback): void {
        this._handler.localImageInfos_(this._path, callback);
    }

    thumbnails_(size: Int, quality: Int, infos: Array<MediaInfo | null>, callback: JSONCallback): void {
        this._handler.localImageThumbnails_(size, quality, infos.map((value) => {
            return value == null ? null : value.json$;
        }), callback);
    }
}

abstract class PromptImportExportKey extends CompositeDialogBase {
    private _okCallback: Fun30X<string, string, BoolCallback> = null;
    protected abstract promptKeyPath(path: string, dateformat: string): void;
    constructor(container: HTMLElement, dateformat: string, cpath: string, basedir: BasedirX, alias: string) {
        super(container, [
            new InputField("", RS.KeyAlias, alias, RS.KeyAlias),
            new FilepathFolderField(
                "",
                RS.PlaceholderOptionalFilepath,
                new HumanFilepath(cpath),
                RS.PlaceholderOptionalFilepath,
                basedir,
                (path) => this.promptKeyPath(path, dateformat)),
        ]);
        this.onChange_((field) => {
            if (field.spec$.key$ == RS.KeyAlias && field.getValue_().startsWith(DEF.backupKeyPrefix)) {
                toasters$.warnKey_(RS.InvalidKeyAlias);
            } else if (field.spec$.key$ == RS.PlaceholderOptionalFilepath) {
                const value = Basepath.stem_(field.getValue_());
                this.setValueAt_(0, value);
            }
        });
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infosOKCancel),
            (action) => this._toolbarActions(action)
        );
    }

    onOK_(callback: Fun30<string, string, BoolCallback>): this {
        this._okCallback = callback;
        return this;
    }

    protected _onOK(done: BoolCallback): void {
        done(true);
    }

    protected _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                this._okCallback?.(this.getValueAt_(0), this.getValueAt_(1), (ok) => {
                    if (ok) {
                        this.close_();
                        this._okCallback = null;
                    }
                });
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

class PromptImportKey extends PromptImportExportKey {
    constructor(container: HTMLElement, dateformat: string, cpath: string, basedir: BasedirX, alias: string) {
        super(container, dateformat, cpath, basedir, alias);
        this.titleKey_(RS.Import);
    }
    protected promptKeyPath(path: string, dateformat: string) {
        const zindex = An.above_(this.element_());
        _SystemActionsHelper.promptInputKeyFile(path, dateformat, zindex).onOK_((okcallback, cpath) => {
            okcallback(true);
            this.setValueAt_(1, cpath);
            if (this.getValueAt_(0).trim().length == 0) {
                this.setValueAt_(0, Basepath.stem_(cpath));
            }
        }).show_();
    }
}

class PromptExportKey extends PromptImportExportKey {
    constructor(container: HTMLElement, dateformat: string, cpath: string, basedir: BasedirX, alias: string, sig: string) {
        super(container, dateformat, Basepath.joinRpath_(cpath, `${sig.substring(0, 17)}.pem`), basedir, alias);
        this.titleKey_(RS.Export);
        const input = this.getFieldAt_(0).getInput_(0)!!;
        input.readOnly = true;
        input.classList.add(CSS.AnDisabled);
    }
    protected promptKeyPath(path: string, dateformat: string) {
        const zindex = An.above_(this.element_());
        _SystemActionsHelper.promptOutputKeyFile(path, dateformat, zindex).onOK_((okcallback, cpath) => {
            okcallback(true);
            this.setValueAt_(1, cpath);
        }).show_();
    }
}

class PromptBackupKeyManager extends CompositeDialogBase {
    private _backupKeyField: HTMLElementX = null;
    constructor(container: HTMLElement, private _dateformat: string, private _aliases: StringMap<string[]>) {
        super(container, []);
        const a = _aliases[DEF.backupKeyAlias];
        if (a != null) {
            this._addField(new LabelButtonsField("", DEF.backupKeyAlias, RS.Key, [BUT.ExportKey1, BUT.RegenerateKey1], (b) => {
                this._backupKeyField = this._createlabel(b, a);
            }, (_, button) => {
                if (button == BUT.ExportKey1) this._exportKey(DEF.backupKeyAlias, a[2]);
                if (button == BUT.RegenerateKey1) this._regenerateKey();
            })) as IDialogField;
        }
        for (const [alias, a] of Object.entries(this._aliases).sort((a, b) => a[0].localeCompare(b[0]))) {
            if (alias != DEF.backupKeyAlias) {
                this._addfield(alias, a);
            }
        }
    }

    private _addfield(alias: string, a: string[]) {
        this._addField(new LabelButtonsField("", alias, RS.Key, [BUT.ExportKey1, BUT.DeleteKey1],
            (b) => this._createlabel(b, a), (field, button) => {
                if (button == BUT.ExportKey1) this._exportPublicKey(alias, a[2].substring(0, 17));
                if (button == BUT.DeleteKey1) this._deleteKey(field);
            }));
    }

    private _createlabel(b: DomBuilderEx, a: string[]): HTMLElement {
        this._createlabel1(b.div1_(CSS.AnFlex, CSS.AnOverflowAuto).push_(), a);
        return b.pop_().cursor_();
    }

    private _createlabel1(b: DomBuilderEx, a: string[]) {
        const alias = a[0];
        const expire = a[1];
        const signature = a[2];
        b.peek_().div1_(CSS.AnOverflowAuto, CSS.AnMarginLeft10).indent_(
            b.push_().span1_(CSS.AnNoWrap).b_().text_(`${alias} [${expire}]`),
            b.peek_().br_(),
            b.pop_().span1_(CSS.AnNoWrap).text_(signature));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infos_(
                BUT.ImportKey,
                BUT.OK,
            )),
            (action) => this._toolbarActions(action)
        );
    }

    private _regenerateKey() {
        const field = this._backupKeyField;
        if (field == null) return;
        const zindex = An.above_(this.element_());
        DialogUt.errorSmall_(this.container_(), RS.BackupKeyRegenerateTitle, RS.BackupKeyRegenerateMessage, zindex, (yes) => {
            if (!yes) return;
            DialogUt.confirmKeySmall_(this.container_(), RS.AreYouSureToContinue, zindex, (yes) => {
                if (!yes) return;
                host$.deleteBackupKey_(DEF.backupKeyAlias, (ret) => {
                    if (toasters$.warn_(ret)) return;
                    host$.getBackupKeyAliases_((ret) => {
                        if (toasters$.warn_(ret)) return;
                        const aliases = ret[Key.result] as StringMap<string[]>;
                        this._createlabel1(new DomBuilderEx(field).empty_().push_(), aliases[DEF.backupKeyAlias]);
                    });
                });
            });
        });
    }

    private _deleteKey(field: IDialogField) {
        const zindex = An.above_(this.element_());
        DialogUt.confirmKeySmall_(this.container_(), RS.BackupKeyDeleteConfirmMesesage, zindex, (yes) => {
            if (!yes) return;
            const alias = field.spec$.key$;
            host$.deleteBackupKey_(alias, (ret) => {
                if (toasters$.warn_(ret)) return;
                this._removeField(field);
                delete this._aliases[alias];
            });
        });
    }

    private _importKey() {
        const d = new PromptImportKey(this.container_(), this._dateformat, PATH._Internal_, native$.getIFrameDir_(), "")
            .above_(this.element_())
            .onOK_((alias, cpath, okcallback) => {
                host$.importBackupKey_(alias, cpath, (ret) => {
                    if (d.warn_(ret)) return okcallback(false);
                    okcallback(true);
                    const desc = ret[Key.result];
                    this._aliases[alias] = desc;
                    this._addfield(alias, desc);
                    toasters$.ok_(MSG.actionOK_(RS.Import));
                });
            })
            .show_();
        toasters$.infoKey_(RS.BackupKeyImportFilepickerHelp, { attop: false });
    }

    private _exportKey(alias: string, sig: string) {
        const d = new PromptExportKey(this.container_(), this._dateformat, PATH._Internal_, native$.getIFrameDir_(), alias, sig)
            .above_(this.element_())
            .onOK_((alias, cpath, okcallback) => {
                host$.exportBackupKey_(alias, cpath, (ret) => {
                    if (d.warn_(ret)) return okcallback(false);
                    okcallback(true);
                    toasters$.ok_(MSG.actionOK_(RS.Export));
                });
            })
            .show_();
        toasters$.infoKey_(RS.BackupKeyExportFilepickerHelp, { attop: false });
    }

    private _exportPublicKey(alias: string, sig: string) {
        const d = new PromptExportKey(this.container_(), this._dateformat, PATH._Internal_, native$.getIFrameDir_(), alias, sig)
            .above_(this.element_())
            .onOK_((alias, cpath, okcallback) => {
                host$.exportBackupKey_(alias, cpath, (ret) => {
                    if (d.warn_(ret)) return okcallback(false);
                    okcallback(true);
                    toasters$.ok_(MSG.actionOK_(RS.Export));
                });
            })
            .show_();
        toasters$.infoKey_(RS.BackupKeyExportFilepickerHelp, { attop: false });
    }

    protected _onOK(done: BoolCallback): void {
        done(true);
    }

    protected _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.ImportKey:
                this._importKey();
                break;
            case BUT.OK: {
                this.close_();
                break;
            }
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class PromptAliases extends ChecklistDialogBase {
    private _okCallback: StringListCallback | null = null;
    private _onInputChanged: Fun10<HTMLInputElement> | null = null;

    constructor(
        container: HTMLElement,
        private _aliases: SStringMap,
        private _selected: string[],
        zindex: number,
        private _radio: boolean = false) {
        super(container);
        super.init_(this.create_(container));
        this.titleKey_(RS.Recipients);
        this.zindex_(zindex);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createChecklistDialog(container, BUT.infosOKCancel, (action) => this._toolbarActions(action));
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.OK: {
                this._toolbar!.enableButton_(BUT.OK, false);
                const selected = this._foreachChecked((ret, checkbox) => {
                    const text = checkbox.getAttribute(ATTR.AnInfo);
                    if (text != null) ret.push(text);
                });
                const callback = this._okCallback!;
                this.close_();
                callback(selected);
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    protected _populate(viewport: HTMLElement, _dialog: HTMLElement) {
        const entries = Object.entries(this._aliases);
        const b = new DomBuilderEx(viewport).empty_().push_();
        DialogUt.populateCheckboxList1_(b, this._checkboxListener,
            (header, checked, total) => this._updateHeader(header, checked, total),
            () => {
                let selected = 0;
                for (const [alias, a] of entries.sort((a, b) => a[0].localeCompare(b[0]))) {
                    const e = b.peek_().div_().push_().div1_(CSS.AnPromptCheckboxInput).input_(
                        ["type", (this._radio ? "radio" : "checkbox")],
                        ["name", "alias"],
                        [ATTR.AnInfo, alias],
                    ).cursor_() as HTMLInputElement;
                    if (!this._radio && alias == DEF.backupKeyAlias) e.disabled = true;
                    const checked = this._selected.includes(alias);
                    e.checked = checked;
                    if (checked) ++selected;
                    b.pop_().span_().push_().b_().text_(a[0]).pop_().text_(` [${a[1]}] ${a[2]}`);
                    An.onInputChange_(e, () => this._onInputChanged?.(e));
                }
                return [selected, entries.length];
            });
    }

    private _updateHeader(header: HTMLElement, checked: Int, total: Int) {
        header.textContent = `${MSG.string_(RS.Recipients)}: ${checked} / ${total}`;
    }

    onInputChanged_(callback: Fun10<HTMLInputElement>): this {
        this._onInputChanged = callback;
        return this;
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    onOK_(callback: StringListCallback): this {
        this._okCallback = callback;
        return this;
    }
}

class PromptBackup extends CompositeDialogBase {
    private static readonly _recipientsAll = MSG.string_(RS.RecipientsAll);
    private static readonly _recipientsSelected = MSG.string_(RS.RecipientsSelected);
    private static readonly _recipientsSelf = MSG.string_(RS.RecipientsSelf);
    private _recipients: SelectOptions;
    private _selected: string[] = [];
    constructor(container: HTMLElement, dateformat: string, backupfilepath: string, srcdir: string, aliases: SStringMap, private _doneCallback: Fun00) {
        super(container, [
            new InputButtonField(
                RS.BackupFile,
                "",
                backupfilepath,
                RS.PlaceholderRequiredFilepath,
                BUT.Folder1,
                () => this._promptBackupFile(dateformat),
            ),
            new SelectFIeld(
                RS.Recipients,
                "",
                "",
                RS.Recipients,
                [],
            ),
            new InputButtonField(
                RS.SourceDirectory,
                "",
                srcdir,
                RS.SourceDirectory,
                BUT.Folder1,
                () => this._promptSourceDir(dateformat),
            ),
        ]);
        this.titleKey_(RS.Backup);
        this.zindex_(DEF.zindexPrompt);
        this.largeWidth_();
        this._recipients = (this.getFieldAt_(1).getValueElement_(0) as SelectOptions);
        this._recipients.onClick_((e) => {
            An.stopevent_(e);
            new PromptAliases(this.container_(), aliases, this._selected, An.above_(this.element_()))
                .onOK_((selected) => {
                    this._setRecipients(aliases, selected);
                })
                .show_();
        });
        this._setRecipients(aliases, [...Object.keys(aliases)].sort());
    }
    private _promptBackupFile(dateformat: string) {
        _SystemActionsHelper.promptOutputBackupFile(this.getValueAt_(0), dateformat, An.above_(this.element_()))
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                this.setValueAt_(0, cpath);
                this.setVisibleAt_(1, !cpath.endsWith(Suffix.ZIP$));
            })
            .show_();
    }
    private _setRecipients(aliases: SStringMap, selected: string[]) {
        this._selected = selected;
        const len = selected.length;
        const value = (len == 1) ? PromptBackup._recipientsSelf
            : ((len == An.keysLength(aliases)) ? PromptBackup._recipientsAll : PromptBackup._recipientsSelected) + `(${len})`;
        this._recipients.setOptions_([value], [value], 0);
    }
    private _promptSourceDir(dateformat: string) {
        _SystemActionsHelper.promptDir_(RS.SourceDirectory, this.getValueAt_(2), dateformat, An.above_(this.element_()))
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                this.setValueAt_(2, cpath);
            })
            .show_();
    }
    protected _onOK(done: BoolCallback): void {
        const backupfile = this.getValueAt_(0);
        const srcdir = this.getValueAt_(2);
        _Util.checkFileWritableAndConfirmOverwrite_(backupfile, An.above_(this.element_()), (ret) => {
            if (this.warn_(ret)) {
                done(false);
                return;
            }
            done(true);
            host$.backupRestore_(_JOF.actionBackupData, [backupfile, this._selected, srcdir], (ret) => {
                _SystemActionsHelper.backupRestoreResult(ret);
                this._doneCallback();
            });
        });
    }
    actionCancelConfirmed_() {
        toasters$.info_(MSG.actionCancelled_(RS.Backup));
        super.actionCancelConfirmed_();
    }
}

class PromptBackupConversion extends CompositeDialogBase {
    private static readonly _recipientsAll = MSG.string_(RS.RecipientsAll);
    private static readonly _recipientsSelected = MSG.string_(RS.RecipientsSelected);
    private static readonly _recipientsSelf = MSG.string_(RS.RecipientsSelf);
    private _recipients: SelectOptions;
    private _selected: string[] = [];
    constructor(
        container: HTMLElement,
        dateformat: string,
        dstpath: string,
        private _srcfilepath: Basepath,
        aliases: SStringMap,
        private okcallback: JSONCallback) {
        super(container, [
            new InputButtonField(
                RS.DestinationFile,
                "",
                dstpath,
                RS.PlaceholderRequiredFilepath,
                BUT.Folder1,
                () => this._promptBackupFile(dateformat, new FilepickerSuffixDelegate([Suffix.BACKUP$, Suffix.ZIP$])),
            ),
            new SelectFIeld(
                RS.Recipients,
                "",
                "",
                RS.Recipients,
                [],
            ),
            new CheckboxField(
                "",
                "",
                "",
                MSG.string_(RS.ActionConvertDeleteSource)
            )
        ]);
        this.titleKey_(RS.Backup);
        this.zindex_(DEF.zindexPrompt);
        this.largeWidth_();
        this._recipients = (this.getFieldAt_(1).getValueElement_(0) as SelectOptions);
        this._recipients.onClick_((e) => {
            An.stopevent_(e);
            new PromptAliases(this.container_(), aliases, this._selected, An.above_(this.element_()))
                .onOK_((selected) => {
                    this._setRecipients(aliases, selected);
                })
                .show_();
        });
        this._setRecipients(aliases, [...Object.keys(aliases)]);
        this.setVisibleAt_(1, !dstpath.endsWith(Suffix.ZIP$));
    }

    private _promptBackupFile(dateformat: string, delegate: FilepickerDelegate = OutputBackupFileDelegate.singleton$) {
        _SystemActionsHelper.promptOutputBackupFile(this.getValueAt_(0), dateformat, An.above_(this.element_()), delegate)
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                this.setValueAt_(0, cpath);
                this.setVisibleAt_(1, !cpath.endsWith(Suffix.ZIP$));
            })
            .show_();
    }
    private _setRecipients(aliases: SStringMap, selected: string[]) {
        this._selected = selected;
        const len = selected.length;
        const value = (len == 1) ? PromptBackupConversion._recipientsSelf
            : ((len == Object.keys(aliases).length) ? PromptBackupConversion._recipientsAll
                : PromptBackupConversion._recipientsSelected) + `(${len})`;
        this._recipients.setOptions_([value], [value], 0);
    }
    protected _onOK(done: BoolCallback): void {
        const backupfile = this.getValueAt_(0);
        _Util.checkFileWritableAndConfirmOverwrite_(backupfile, An.above_(this.element_()), (ret) => {
            if (this.warn_(ret)) {
                done(false);
                return;
            }
            const cut = this.getValueAt_(2) == "true";
            done(true);
            host$.actionBackupConversion_(backupfile, this._srcfilepath.path$, this._selected, cut, (ret) => {
                _SystemActionsHelper.backupRestoreResult(ret);
                this.okcallback(ret);
            });
        });
    }
    actionCancelConfirmed_() {
        toasters$.info_(MSG.actionCancelled_(RS.Backup));
        super.actionCancelConfirmed_();
    }
}

class PromptRestore extends CompositeDialogBase {
    private _sync = false;
    constructor(
        container: HTMLElement,
        dateformat: string,
        backupfilepath: string,
        dstdirpath: string,
        private _callback: JSONCallback | null = null
    ) {
        super(container, [
            new InputButtonField(
                RS.BackupFile,
                "",
                backupfilepath,
                RS.PlaceholderRequiredFilepath,
                BUT.Folder1,
                () => this._promptBackupFile(dateformat),
            ),
            new InputButtonField(
                RS.SourcePath,
                "",
                "",
                RS.PlaceholderOptionalFilepath,
                BUT.Folder1,
                () => {
                    const backupfile = this.getFieldAt_(0).getValue_(0);
                    if (Basepath.lcSuffix_(backupfile) == Suffix.ZIP$) {
                        _Util.promptZipEntry_(backupfile, DEF.zindexPrompt, (src) => {
                            this.setValueAt_(1, Basepath.trimLeading_(src));
                        });
                        return;
                    }
                    this._readfiletree(1, backupfile);
                }
            ),
            new InputButtonField(
                RS.DestinationDir,
                "",
                dstdirpath,
                RS.PlaceholderRequiredFilepath,
                BUT.Folder1,
                () => this._promptDestDir(dateformat),
            ),
        ]);
        this.titleKey_(RS.Restore);
        this.zindex_(DEF.zindexPrompt);
        this.largeWidth_();
        this.setVisibleAt_(1, backupfilepath.length > 0);
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this.createDialog_(
            container,
            (elm) => this.createContent(elm),
            (elm) => new Toolbar(elm, BUT.infos_(BUT.Sync, BUT.OK, BUT.Cancel)),
            (action) => this._toolbarActions(action)
        );
    }

    private _promptBackupFile(dateformat: string) {
        _SystemActionsHelper.promptInputBackupFile(this.getValueAt_(0), dateformat, An.above_(this.element_()))
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                this.setValueAt_(0, cpath);
                this.setVisibleAt_(1, cpath.length > 0);
            })
            .show_();
    }

    private _promptDestDir(dateformat: string) {
        _SystemActionsHelper.promptDir_(RS.DestinationDir, this.getValueAt_(2), dateformat, An.above_(this.element_()))
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                this.setValueAt_(2, cpath);
            })
            .show_();
    }

    protected _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Sync: {
                this._sync = true;
                this._onOK((yes) => {
                    if (yes) this.close_();
                });
                break;
            }
            case BUT.OK: {
                this._sync = false;
                this._onOK((yes) => {
                    if (yes) this.close_();
                });
                break;
            }
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    private _readfiletree(index: Int, backupfile: string) {
        host$.readBackupFiletree_(backupfile, (ret) => {
            if (toasters$.warn_(ret)) return;
            Filepicker.withTitleKey_(
                accessories$,
                RS.Restore,
                FilepickerKind.EXISTING_ANY,
                null,
                PATH.Home,
                PATH.Home,
                "",
                new FileInfoUtil(new RestoreDataFilepickerHandler(ret[Key.result])))
                .zindex_(An.above_(this.element_()))
                .setDelegate_(FilepickerRestoreDataDelegate.singleton$)
                .onOK_((okcallback, cpath) => {
                    okcallback(true);
                    this.setValueAt_(index, Basepath.trimLeading_(cpath));
                })
                .show_();
        });
    }
    protected _onOK(done: BoolCallback): void {
        const backupfile = this.getValueAt_(0);
        const source = this.getValueAt_(1);
        const destination = this.getValueAt_(2);
        if (backupfile.length == 0 || destination.length == 0) {
            this.warnKey_(backupfile.length == 0
                ? RS.BackupPleaseSpecifyABackupFile
                : RS.PleaseSpecifyADestinationDirectory);
            done(false);
            return;
        }
        done(true);
        host$.backupRestore_(_JOF.actionRestoreData, [backupfile, this._sync, source, destination], (ret) => {
            _SystemActionsHelper.backupRestoreResult(ret);
            this._callback?.(ret);
        });
    }
    actionCancel_(): void {
        toasters$.info_(MSG.actionCancelled_(RS.Restore));
        const cb = this._cancelCallback;
        this.close_();
        cb?.();
    }
}

////////////////////////////////////////////////////////////////////////

class FilepickerSuffixDelegate extends FilepickerSuffixesDelegate {
    constructor(suffices: string[]) {
        super(suffices.map(s => [s, null]));
    }
}

class FilepickerHtmlDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerHtmlDelegate = new FilepickerHtmlDelegate();
    constructor() {
        super([Suffix.HTML$]);
    }
}

class FilepickerCssDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerCssDelegate = new FilepickerCssDelegate();
    constructor() {
        super([Suffix.CSS$]);
    }
}

class FilepickerWriteImageDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerWriteImageDelegate = new FilepickerWriteImageDelegate();
    constructor() {
        super(MimeUtil.writableImageSuffices_());
    }
}

class FilepickerReadImageDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerReadImageDelegate = new FilepickerReadImageDelegate();
    constructor() {
        super(MimeUtil.imageSuffices_());
    }
}

class FilepickerPngImageDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerPngImageDelegate = new FilepickerPngImageDelegate();
    constructor() {
        super([Suffix.PNG$]);
    }
}

class FilepickerAudioPlaybackDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerAudioPlaybackDelegate = new FilepickerAudioPlaybackDelegate();
    constructor() {
        super(MimeUtil.audioPlaybackSuffices_());
    }
}

class FilepickerAudioRecordDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerAudioRecordDelegate = new FilepickerAudioRecordDelegate();
    constructor() {
        super([MimeUtil.audioRecordingSuffix_()]);
    }
}

class FilepickerVideoPlaybackDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerVideoPlaybackDelegate = new FilepickerVideoPlaybackDelegate();
    constructor() {
        super(MimeUtil.videoPlaybackSuffices_());
    }
}

class FilepickerVideoRecordingDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerVideoRecordingDelegate = new FilepickerVideoRecordingDelegate();
    constructor() {
        super([MimeUtil.videoRecordingSuffix_()]);
    }
}

class FilepickerLinkDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerLinkDelegate = new FilepickerLinkDelegate();
    constructor() {
        super(MimeUtil.importableSuffices_());
    }
}

class FilepickerDirDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerDirDelegate = new FilepickerDirDelegate();
    constructor() {
        super([]);
    }

    includes_(_path: string, fileinfo: FileInfo): boolean {
        return fileinfo.isdir$;
    }

    validate_(_cpath: string, info: FileInfo, callback: JSONCallback): void {
        if (info == null || !info.isdir$) {
            callback(An.jsonError_(RS.DestinationExpectingADir));
            return;
        }
        callback({});
    }
}

class FilepickerRestoreDataDelegate extends FilepickerSuffixDelegate {
    static singleton$: FilepickerRestoreDataDelegate = new FilepickerRestoreDataDelegate();
    constructor() {
        super(MimeUtil.importableSuffices_());
    }

    includes_(path: string, fileinfo: FileInfo): boolean {
        return fileinfo.isdir$ || (fileinfo.isfile$ && this.getSuffixes_().has(Basepath.lcSuffix_(path)));
    }

    validate_(_cpath: string, info: FileInfo, callback: JSONCallback): void {
        if (info == null || !info.exists$) {
            callback(An.jsonError_(RS.DestinationNotExists));
            return;
        }
        callback({});
    }
}

class FilepickerSameSuffixDelegate extends FilepickerSuffixDelegate {

    constructor(private suffix$: string) {
        super([suffix$]);
    }

    includes_(path: string, fileinfo: FileInfo): boolean {
        return fileinfo.isfile$ && Basepath.suffix_(path) == this.suffix$;
    }

    validate_(cpath: string, info: FileInfo, callback: JSONCallback): void {
        if (info == null || info.exists$ && !info.isfile$) {
            callback(An.jsonError_(RS.DestinationExpectingAFile));
            return;
        }
        if (Basepath.suffix_(cpath) != this.suffix$) {
            callback(An.jsonError_(RS.CannotChangeFileExt));
            return;
        }
        callback({});
    }
}

class OutputBackupFileDelegate extends FilepickerSuffixesDelegate {
    static singleton$ = new OutputBackupFileDelegate();
    constructor() {
        super([
            [Suffix.IBACKUP$, RS.Tooltips_CreateIncrementalDataBackup],
            [Suffix.BACKUP$, RS.Tooltips_CreateFullDataBackup],
            [Suffix.ZIP$, RS.Tooltips_ExportDirectoryAsZip],
        ]);
    }
}

class OutputZipFileDelegate extends FilepickerSuffixesDelegate {
    static singleton$: OutputZipFileDelegate = new OutputZipFileDelegate();
    constructor() {
        super([
            [Suffix.ZIP$, RS.ZipTooltips]
        ]);
    }
}

class ExportKeyDelegate extends FilepickerSuffixesDelegate {
    static singleton$ = new ExportKeyDelegate();
    constructor() {
        super([
            ["", RS.BackupKeyShowAsQRCodeTooltips],
            [Suffix.PEM$, RS.ExportPublicKeyForSelf],
            [Suffix.DER$, RS.ExportPublicKeyForSelf],
        ]);
    }

    validate_(path: string, info: FileInfo, callback: JSONCallback): void {
        if (info.isdir$) {
            callback({});
            return;
        }
        super.validate_(path, info, callback);
    }
}

class ImportKeyDelegate extends FilepickerSuffixesDelegate {
    static singleton$ = new ImportKeyDelegate();
    constructor() {
        super([
            ["", RS.BackupKeyImportFromCameraTooltips],
            [Suffix.PEM$, RS.BackupKeyImportTooltips],
            [Suffix.DER$, RS.BackupKeyImportTooltips],
            ...MimeUtil.writableImageSuffices_().map<[string, stringX]>(suffix => {
                return [suffix, RS.BackupKeyImportFromQRCodeTooltips];
            })
        ]);
    }
    validate_(path: string, info: FileInfo, callback: JSONCallback): void {
        if (info.isdir$) return callback({});
        super.validate_(path, info, callback);
    }
}

////////////////////////////////////////////////////////////////////////

class LayoutData {
    CELL_WIDTH: number = DEF.thumbnailSizeMicro;
    CELL_HEIGHT: number = DEF.thumbnailSizeMicro;
    CELL_PADDINGx2: number = 8;
    CONTENT_PADDINGx2: number = 16;
    STATUS_YPADDINGx2: number = 8;
}

class _Layout {
    winWidth: number;
    winHeight: number;
    dialogWidth: number;
    dialogHeight: number;
    contentWidth: number;
    contentHeight: number;
    cellWidth: number;
    cellHeight: number;
    rows: number;
    cols: number;
    statusMaxWidth: number;

    constructor(data: LayoutData, toolbarheight: number, maxrows: numberX, maxcols: numberX) {
        this.winWidth = window.innerWidth;
        this.winHeight = window.innerHeight;
        this.dialogWidth = this.winWidth;
        this.dialogHeight = this.winHeight;
        this.contentWidth = this.winWidth - data.CONTENT_PADDINGx2;
        this.contentHeight = this.winHeight - toolbarheight - data.CONTENT_PADDINGx2;
        this.cellWidth = data.CELL_WIDTH;
        this.cellHeight = data.CELL_HEIGHT;
        this.rows = Math.floor(this.contentHeight / (data.CELL_HEIGHT + data.CELL_PADDINGx2));
        this.cols = Math.floor(this.contentWidth / (data.CELL_WIDTH + data.CELL_PADDINGx2));
        if (maxrows != null && this.rows > maxrows) {
            this.rows = maxrows;
        }
        if (maxcols != null && this.cols > maxcols) {
            this.cols = maxcols;
        }
        this.statusMaxWidth = this.contentWidth - data.STATUS_YPADDINGx2;
        
    }
}

class Sort {
    static readonly ByName: number = 0;
    static readonly ByDate: number = 1;
    static readonly Asc: number = 0;
    static readonly Desc: number = 1;
}

class MediapickerConfig {
    _layoutdata: LayoutData = new LayoutData();
    _zindex: numberX = null;
    _maxrows: numberX = null;
    _maxcols: numberX = null;

    layoutdata(layoutdata: LayoutData): void {
        this._layoutdata = layoutdata;
    }

    zindex(zindex: number): void {
        this._zindex = zindex;
    }

    maxrows(n: numberX): void {
        this._maxrows = n;
    }

    maxcols(n: numberX): void {
        this._maxcols = n;
    }
}

////////////////////////////////////////////////////////////////////////

type ViewMediaCallback = (host: HTMLElement, mediainfo: MediaInfo, done: BoolCallback) => void;

abstract class _MediapickerBase {
    protected _dialog: HTMLElement;
    protected _content: HTMLElement;
    protected _toolbar: Toolbar;
    protected _searchbar: Toolbar;
    protected _searchbox: HTMLTextAreaElement;
    protected _propertyToaster: Toaster;
    protected _viewCallback: ViewMediaCallback | null = null;
    protected _sortby: number = Sort.ByName;
    protected _sortdir: number = Sort.Asc;
    protected _filtered: MediaInfo[] = [];
    protected _sorted: MediaInfo[] = [];
    protected _infos: MediaInfo[] = [];
    private _resizeCallback: Fun00X = null;
    private _okCallback: MediaInfoCallback | null = null;
    private _cancelCallback: Fun00 | null = null;
    private _dateFormat: string = DateFormat.DEF;
    private _resizeSubscription: StreamSubscription | null = null;
    protected _layout: _Layout | null = null;
    protected _selected: numberX = null;
    protected _offset: number = 0;
    protected _count: number = 0;
    private _config: MediapickerConfig = new MediapickerConfig();
    #closed: boolean = false;

    /**
         * MediapickerBase constructor.
         */
    constructor(
        protected _container: HTMLElement,
        titlekey: StringId,
        protected _gestureHandler: IGestureHandler | null,
        protected _handler: IMediaInfoHandler) {
        this._okCallback = null;
        this._cancelCallback = null;
        const b = new DomBuilderEx(_container);
        this._propertyToaster = new Toaster(_container, 0, 10000);
        this._dialog = b
            .push_()
            .table_({
                "class": CSS.AnWindow,
                "style": "display: none; visibility: hidden",
            })
            .push_()
            .cursor_();
        b.peek_().tr_().td_().push_();
        this._toolbar = this.createtoolbar_(b.peek_().cursor_(), MSG.string_(titlekey));
        this._searchbar = this.createsearchbar_(b.peek_().cursor_());
        this._searchbox = this._searchbar.querySelector_(Conf.input$) as AnInputElement;
        this._content = this.createcontent_(b.pop_(2).cursor_()) as HTMLElement;
        this._toolbar.onAction_((action) => this._toolbaractions(action));
        this._searchbar.onAction_((action) => this._toolbaractions(action));
        An.onInputFocusSelect_(this._searchbox);
        this._resizeSubscription = An.subscriptEvent_(window, "resize", () => {
            if (this._resizeCallback == null) {
                this._relayout();
                this.refreshnow_();
            } else {
                this._resizeCallback();
            }
        });
        An.onClickMatching_(this._content, `td.${CSS.AnGalleryCell}`, (td) => {
            this._hideToaster();
            if (this._sorted == null) { return; }
            const index = An.parseInt_(td.getAttribute(ATTR.AnInfo), -1);
            if (index < 0 || index >= this._sorted.length) {
                const selected = this._content.querySelector(`td.${CSS.AnGalleryCell}.${CSS.AnSelected}`);
                if (selected != null) {
                    selected.classList.remove(CSS.AnSelected);
                }
                this._selected = null;
                this._onSelectionChange(this._selected);
            } else if (index != this._selected) {
                const selected = this._content.querySelector(`td.${CSS.AnGalleryCell}.${CSS.AnSelected}`);
                if (selected != null) {
                    selected.classList.remove(CSS.AnSelected);
                }
                const info = this._sorted[index];
                const tooltips = td.getAttribute(ATTR.xTooltips);
                if (tooltips != null) {
                    const error = info.error$;
                    if (error != null) {
                        toasters$.warn_(error, { attop: false });
                    }
                    this._selected = null;
                } else {
                    this._selected = index;
                    td.classList.add(CSS.AnSelected);
                    
                    this._briefInfo(info);
                }
                this._onSelectionChange(this._selected);
            }
            if (this._selected != null) {
                this.viewMedia_(this._sorted[this._selected]);
            }
        });
        An.onContextmenuMatching_(this._content, `td.${CSS.AnGalleryCell}`, (td) => {
            this._hideToaster();
            if (this._sorted == null) { return; }
            const index = An.parseInt_(td.getAttribute(ATTR.AnInfo), -1);
            if (index < 0 || index >= this._sorted.length) {
                return;
            }
            const tooltips = td.getAttribute(ATTR.xTooltips);
            if (tooltips != null) {
                return;
            }
            this.viewMedia_(this._sorted[index]);
        });
    }

    protected _briefInfo(info: MediaInfo): void {
        this._propertyToaster.showInfo_((_toaster: Toaster, b: DomBuilderEx) => {
            b.div_().text_(MediaInfo.briefMessage_(this._dateFormat, info))
                ;
        }, false);
    }

    dateFormat_(dateformat: string): void {
        this._dateFormat = dateformat;
    }

    onResize_(callback: Fun00): void {
        this._resizeCallback = callback;
    }

    protected _relayout(): void {
        this._layout = new _Layout(
            this._config._layoutdata,
            Math.round(this._toolbar
                .element_()
                .getBoundingClientRect()
                .height),
            this._config._maxrows,
            this._config._maxcols);
        An.setWidthHeight_(this._dialog, this._layout.dialogWidth, this._layout.dialogHeight);
        if (this._config._zindex == null) { throw Error(); }
        this._dialog.style.zIndex = this._config._zindex.toString();
        An.setWidthHeight_(this._content, this._layout.contentWidth, this._layout.contentHeight);
    }

    protected _onSelectionChange(_selected: numberX): void { }

    protected abstract createtoolbar_(container: HTMLElement, prompt: string): Toolbar;

    protected abstract createsearchbar_(container: HTMLElement): Toolbar;

    protected abstract createcontent_(container: HTMLElement): HTMLElement;

    protected abstract _toolbarAction(action: string): void;

    protected abstract filter_(): void;

    protected abstract sort_(): void;

    protected abstract shownow_(spinner: Spinner): void;

    protected abstract refreshWithSpinner_(): void;

    protected abstract refresh_(spinner: Spinner): void;

    protected abstract refreshnow_(): void;

    protected abstract viewMedia_(info: MediaInfo): void;

    protected abstract _handleGesture(event: string, data: JSONObject): boolean;

    dialog_(): HTMLElement {
        return this._dialog;
    }

    /// @param callback(info) where info is the MediaInfo for the selected media.
    onOK_(callback: MediaInfoCallback): this {
        this._okCallback = callback;
        return this;
    }

    /// @param callback()
    onCancel_(callback: Fun00): this {
        this._cancelCallback = callback;
        return this;
    }

    onView_(callback: ViewMediaCallback): this {
        this._viewCallback = callback;
        return this;
    }

    /// @return The number of cells possible in the content area.
    cells_(): number {
        const layout = new _Layout(new LayoutData(), 0, null, null);
        return layout.rows * layout.cols;
    }

    config_(): MediapickerConfig {
        return this._config;
    }

    show_(): this {
        
        const spinner = new Spinner(this._container);
        spinner.show_(() => {
            Timer.sleep0_(() => {
                this._handler.infos_(ret => {
                    if (toasters$.warn_(ret[Key.errors])) {
                        
                        this._infos = [];
                    } else {
                        this._infos = MediaInfo.arrayOf_(ret[Key.result]) ?? [];
                    }
                    if (this._infos.length == 0) {
                        toasters$.okKey_(RS.NoImageFound, { attop: true });
                    }
                    if (this._gestureHandler != null) {
                        this._gestureHandler.push_(GestureEvent.leftInward, this._handleGesture);
                        this._gestureHandler.push_(GestureEvent.leftOutward, this._handleGesture);
                        this._gestureHandler.push_(GestureEvent.rightInward, this._handleGesture);
                        this._gestureHandler.push_(GestureEvent.rightOutward, this._handleGesture);
                    }
                    this.shownow_(spinner);
                });
            });
        });
        return this;
    }

    private _toolbaractions(action: string): void {
        this._hideToaster();
        this._toolbarAction(action);
    }

    ok_(): void {
        if (this._selected == null) {
            toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
            return;
        }
        const info = (this._sorted?.[this._selected]) ?? null;
        if (info == null) {
            toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
            return;
        }
        this.close_();
        if (this._okCallback != null) {
            this._okCallback(info);
        }
        this._close2();
    }

    cancel_(): void {
        this.close_();
        if (this._cancelCallback != null) {
            this._cancelCallback();
        }
        this._close2();
    }

    private close_(): void {
        if (this.#closed) return;
        this.#closed = true;
        if (this._gestureHandler != null) {
            this._gestureHandler.pop_(GestureEvent.leftInward);
            this._gestureHandler.pop_(GestureEvent.leftOutward);
            this._gestureHandler.pop_(GestureEvent.rightInward);
            this._gestureHandler.pop_(GestureEvent.rightOutward);
        }
        if (this._resizeSubscription != null) {
            this._resizeSubscription.cancel_();
        }
        toasters$.hideModal_();
        An.hide_(this._dialog);
        this._viewCallback = null;
        this._infos = [];
        this._filtered = [];
        this._sorted = [];
        this._dialog.remove();
    }

    private _close2(): void {
        this._okCallback = null;
        this._cancelCallback = null;
    }

    protected _search(): void {
        this.filter_();
        this.sort_();
        this.refreshWithSpinner_();
    }

    protected _hideToaster(): void {
        this._propertyToaster.hide_();
        toasters$.hideAll_();
    }
}

////////////////////////////////////////////////////////////////////////

type _MediaInfoComparator = (a: any, b: any) => number;

class Imagepicker extends _MediapickerBase {
    static _sortByNameAsc(a: MediaInfo, b: MediaInfo): number {
        const aa = a.title$;
        const bb = b.title$;
        if (aa == null) return bb != null ? 1 : 0;
        if (bb == null) return -1;
        return aa > bb ? 1 : aa < bb ? -1 : 0;
    }

    static _sortByDateAsc(a: MediaInfo, b: MediaInfo): number {
        const aa = a.fileDate$;
        const bb = b.fileDate$;
        if (aa == null) return bb != null ? -1 : 0;
        if (bb == null) return 1;
        return aa > bb ? 1 : bb > aa ? -1 : 0;
    }

    static _sortByNameDesc(a: MediaInfo, b: MediaInfo): number {
        return Imagepicker._sortByNameAsc(b, a);
    }

    static _sortByDateDesc(a: MediaInfo, b: MediaInfo): number {
        return Imagepicker._sortByDateAsc(b, a);
    }

    static sortFunctions: Array<Array<_MediaInfoComparator>> = [
        [Imagepicker._sortByNameAsc, Imagepicker._sortByNameDesc],
        [Imagepicker._sortByDateAsc, Imagepicker._sortByDateDesc]
    ];

    _filename: stringX = null;

    /**
         * Imagepicker constructor
         * @container The container element to host the picker. It should not be modified.
         */
    constructor(
        container: HTMLElement,
        titlekey: StringId,
        gestureHandler: IGestureHandler | null,
        handler: IMediaInfoHandler
    ) {
        super(container, titlekey, gestureHandler, handler);
        An.onInputEnterKey_(this._searchbox, () => {
            this._toolbarAction(BUT.Filter);
        });
    }

    protected createtoolbar_(container: HTMLElement, title: string): Toolbar {
        const d = new Toolbar(container, BUT.infos_(
            BUT.PrevPage,
            BUT.NextPage,
            BUT.Cancel,
            BUT.Filterbar,
        ));
        d.onTooltips_(toasters$.onTooltipsKey_);
        d.titleText_(title);
        return d;
    }

    protected createsearchbar_(container: HTMLElement): Toolbar {
        const ret = new Toolbar(container, [
            INPUT.info_(INPUT.FilterBox),
            BUT.info_(BUT.ClearSearchText),
            BUT.info_(BUT.Filter),
            BUT.info_(BUT.Toolbar),
        ]);
        ret.onTooltips_(toasters$.onTooltipsKey_);
        ret.hide_();
        return ret;
    }

    protected createcontent_(container: HTMLElement): HTMLElement {
        return new DomBuilderEx(container).tr_().td1_(CSS.AnGalleryContent).cursor_();
    }

    setFilename_(filename: string): this {
        this._filename = filename;
        return this;
    }

    onView_(callback: ViewMediaCallback | null): this {
        this._viewCallback = callback;
        return this;
    }

    protected _onSelectionChange(_selected: number): void {
    }

    above_(elm: HTMLElement, delta: number = DEF.zindexAbove10): this {
        this.config_().zindex(An.zindexOf_(elm, delta, DEF.zindexPrompt + delta));
        return this;
    }

    zindex_(zindex: number): this {
        this.config_().zindex(zindex);
        return this;
    }

    protected sort_(): void {
        if (this._filtered == null || this._layout == null) { return; }
        const sorted = Array.from(this._filtered);
        sorted.sort(Imagepicker.sortFunctions[this._sortby][this._sortdir]);
        this._sorted = sorted;
        this._selected = null;
        this._offset = 0;
        this._count = Math.min(this._sorted.length, this._layout.rows * this._layout.cols);
        if (this._selected != null) {
            this._onSelectionChange(this._selected);
        }
    }

    protected refreshWithSpinner_(): void {
        const spinner = new Spinner(this._container);
        spinner.show_(() => {
            Timer.sleep0_(() => {
                this.refresh_(spinner);
            });
        });
    }

    protected refresh_(spinner: Spinner): void {
        let nmissing = 0;
        const infos = new Array<MediaInfo | null>();
        if (this._sorted != null) {
            for (let i = 0; i < this._count; ++i) {
                const info = this._sorted[this._offset + i];
                if (info.tnInfo$ == null) {
                    ++nmissing;
                    infos.push(info);
                } else {
                    infos.push(null);
                }
            }
        }
        if (nmissing > 0) {
            
            this._refresh1(spinner, infos);
        } else {
            this.refreshnow_();
            if (spinner != null) {
                spinner.hide_();
            }
        }
    }

    private _refresh1(spinner: Spinner, infos: Array<MediaInfo | null>): void {
        this._handler.thumbnails_(DEF.thumbnailSizeMicro, DEF.jpegQualityThumbnail, infos, ret => {
            if (toasters$.warn_(ret[Key.errors])) {
                
                return;
            }
            const tns = ret[Key.result] as Array<JSONObject>;
            for (let i = 0; i < this._count; ++i) {
                const tinfo = tns[i];
                const info = this._sorted[this._offset + i];
                info.setTnInfo_(tinfo);
            }
            this.refreshnow_();
            if (spinner != null) {
                spinner.hide_();
            }
        });
    }

    protected shownow_(spinner: Spinner): void {
        An.showHidden_(this._dialog);
        this._relayout();
        this.filter_();
        this.sort_();
        let selected = null;
        if (!An.isempty_(this._filename)) {
            for (let index = 0, len = this._sorted.length; index < len; ++index) {
                const info = this._sorted[index];
                const name = info.title$;
                if (this._filename == name) {
                    this._selected = index;
                    selected = info;
                }
            }
        }
        this.refresh_(spinner);
        An.setVisible_(this._dialog);
        if (selected != null) {
            this._briefInfo(selected);
            this.viewMedia_(selected);
        }
    }

    protected _toolbarAction(action: string): void {
        switch (action) {
            case BUT.Filterbar:
                this._toolbar.hide_();
                this._searchbar.show_();
                this._searchbox.focus();
                break;
            case BUT.Toolbar:
                this._searchbar.hide_();
                this._toolbar.show_();
                break;
            case BUT.Filter:
                this._search();
                break;
            case BUT.ClearSearchText:
                this._searchbox.value = "";
                this._search();
                break;
            case BUT.Cancel:
                this.cancel_();
                break;
            case BUT.NextPage:
                this._actionNextPage();
                break;
            case BUT.PrevPage:
                this._actionPrevPage();
                break;
            default:
                
        }
    }

    private _actionPrevPage(): void {
        if (this._offset == 0) {
            toasters$.warnKey_(RS.NoMoreItems);
            return;
        }
        if (this._layout == null) { return; }
        const layout = this._layout;
        const page = layout.rows * layout.cols;
        let offset = this._offset - page;
        if (offset < 0) {
            offset = 0;
        }
        const length = this._sorted.length;
        this._offset = offset;
        this._count = Math.min(length - offset, page);
        this.refreshWithSpinner_();
    }

    private _actionNextPage(): void {
        const length = this._sorted.length;
        const offset = this._offset + this._count;
        if (offset >= length) {
            toasters$.warnKey_(RS.NoMoreItems);
            return;
        }
        const layout = this._layout;
        if (layout == null) { return; }
        this._offset = offset;
        this._count = Math.min(length - offset, layout.rows * layout.cols);
        this.refreshWithSpinner_();
    }

    protected filter_(): void {
        let searchtext = this._searchbox.value;
        const keys = [MediaInfo.Id, MediaInfo.Title, MediaInfo.Description];
        let filtered = new Array<MediaInfo>();
        if (searchtext != null && searchtext.length > 0) {
            searchtext = searchtext.toLowerCase();
            for (const info of this._infos) {
                for (const key of keys) {
                    const value = info.tostring_(key, null);
                    if (value != null && value.toLowerCase().indexOf(searchtext) >= 0) {
                        filtered.push(info);
                        break;
                    }
                }
            }
            toasters$.info_(MSG.format1_(RS.found_items, `${filtered.length}`), { attop: false });
        } else {
            filtered = Array.from(this._infos);
        }
        this._filtered = filtered;
    }

    protected refreshnow_(): void {
        const layout = this._layout;
        if (layout == null) { return; }
        const offset = this._offset;
        const count = this._count;
        const sorted = this._sorted;
        const b = new DomBuilderEx(this._content).empty_();
        b.table_({ "style": "margin:auto" }).push_();
        for (let r = 0; r < layout.rows; ++r) {
            b.peek_().tr_().push_();
            for (let c = 0; c < layout.cols; ++c) {
                const index = offset + r * layout.cols + c;
                const cell = b.peek_().td1_(CSS.AnGalleryCell).cursor_();
                if (index >= offset + count) {
                    continue;
                }
                const info = sorted[index];
                if (this._selected != null && this._selected == index) {
                    cell.classList.add(CSS.AnSelected);
                }
                cell.setAttribute(ATTR.AnInfo, index.toString());
                let dataurl = null;
                let error = null;
                const tn = MediaInfo.of_(info.tnInfo$);
                if (tn != null) {
                    dataurl = tn.dataUrl$;
                    error = tn.error$;
                }
                if (dataurl == null || error != null) {
                    cell.setAttribute(ATTR.xTooltips, MSG.string_(RS.ERROR));
                    b.span_().text_(MSG.string_(RS.ERROR));
                    
                } else {
                    b.img_(dataurl, {
                        "style": `max-width:${layout.cellWidth}px; max-height:${layout.cellHeight}px`,
                    });
                }
            }
            b.pop_();
        }
        An.enableButton_(this._toolbar.button_(BUT.PrevPage), offset > 0);
        An.enableButton_(this._toolbar.button_(BUT.NextPage), offset + count < sorted.length);
    }

    protected viewMedia_(info: MediaInfo): void {
        if (info == null) {
            toasters$.okKey_(RS.NoImageFound, { attop: true });
            return;
        }
        if (this._gestureHandler != null) {
            this._gestureHandler.pause_();
        }
        this._viewCallback?.(this._dialog, info, (ok: boolean) => {
            if (this._gestureHandler != null) {
                this._gestureHandler.resume_();
            }
            if (ok) {
                super.ok_();
            }
        });
    }

    protected _handleGesture(event: string, _data: JSONObject): boolean {
        Timer.sleep1_(() => {
            if (event == GestureEvent.leftInward || event == GestureEvent.rightOutward) {
                this._actionPrevPage();
            } else if (event == GestureEvent.leftOutward || event == GestureEvent.rightInward) {
                this._actionNextPage();
            }
        });
        return true;
    }
}

const suffixSorter = (a: string, b: string) => {
    const alen = a.length;
    const blen = b.length;
    const lca = a.toLowerCase();
    const lcb = b.toLowerCase();
    const len = Math.min(alen, blen);
    for (let index = 0; index < len; ++index) {
        const ca = lca.charCodeAt(index);
        const cb = lcb.charCodeAt(index);
        if (ca > cb) return 1;
        if (ca < cb) return -1;
        const uca = a.charCodeAt(index);
        const ucb = b.charCodeAt(index);
        if (uca > ucb) return 1;
        if (uca < ucb) return -1;
    }
    return alen > blen ? 1 : alen < blen ? -1 : 0;
};

//////////////////////////////////////////////////////////////////////////

class InputBackupFileDelegate extends FilepickerSuffixesDelegate {
    static singleton$: InputBackupFileDelegate = new InputBackupFileDelegate();
    constructor() {
        super([
            [Suffix.IBACKUP$, RS.Tooltips_RestoreDataFromIncrementalBackup],
            [Suffix.BACKUP$, RS.Tooltips_RestoreDataFromFullBackup],
            [Suffix.ZIP$, RS.Tooltips_RestoreData],
        ]);
    }
}

class FilepickerHandlerAdapter implements IFilepickerHandler {
    protected _notfound(cpath: string, callback: JSONCallback) {
        callback(json1_(Key.errors, MSG.string1_(RS.FileNotFound_, cpath)));
    }
    protected _notsupported(callback: JSONCallback) {
        callback(json1_(Key.errors, MSG.string_(RS.AssertUnsupportedOperation)));
    }
    protected _notdirectory(cpath: string, callback: JSONCallback) {
        callback(json1_(Key.errors, MSG.string1_(RS.NotADirectory_, cpath)));
    }
    fileInfo_(_path: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    listDir_(_path: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    mkDirs_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    delete_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    deleteAll_(_srcpath: string, _rpaths: string[], callback: JSONCallback): void {
        this._notsupported(callback);
    }
    deleteInfo_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    rename_(_fromcpath: string, _newname: string, _fixxrefs: boolean, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    copy_(
        _cut: boolean,
        _preservetimestamp: boolean,
        _fixxrefs: boolean,
        _dst: string,
        _src: string,
        _rpaths: string[] | null,
        callback: JSONCallback): void {
        this._notsupported(callback);
    }
    copyInfo_(_cut: boolean, _dst: string, _src: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    deleteDirSubtree_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    localImageInfos_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    localImageThumbnails_(_size: Int, _quality: Int, _infos: JSONObjectX[], callback: JSONCallback): void {
        this._notsupported(callback);
    }
    deleteEmptyDirs_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    listRecursive_(_params: JSONObject, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    fileInfos_(_dir: string, _rpaths: string[], callback: JSONCallback): void {
        this._notsupported(callback);
    }
    dirInfo_(_cpath: string, callback: JSONCallback): void {
        this._notsupported(callback);
    }
    shred_(_dir: string, _rpaths: string[], callback: JSONCallback): void {
        this._notsupported(callback);
    }
    protected _dirinfo(dirinfo: FileInfo, callback: JSONCallback) {
        const fileinfos = dirinfo.files$;
        if (fileinfos == null) return;
        let files1 = 0;
        let dirs1 = 0;
        let size1 = 0;
        let files = 0;
        let dirs = 0;
        let size = 0;
        const count = (dir: FileInfo) => {
            let infos = dir.files$;
            if (infos == null) return;
            for (const value of Object.values(infos)) {
                const info = FileInfo.of_(value);
                if (info == null) continue;
                const isdir = info.isdir$;
                if (isdir == true) {
                    ++dirs;
                    count(info);
                } else if (isdir == false) {
                    ++files;
                    size += info.size$ ?? 0;
                }
            }
        };
        for (const value of Object.values(fileinfos)) {
            const fileinfo = FileInfo.of_(value);
            if (fileinfo == null) continue;
            if (fileinfo.isdir$) {
                ++dirs1;
                count(fileinfo);
            } else {
                ++files1;
                size1 += fileinfo.size$;
            }
        }
        callback(json1_(Key.result, [
            files + files1,
            dirs + dirs1,
            size + size1,
            files1,
            dirs1,
            size1,
        ]));
    }
}

class RestoreDataFilepickerHandler extends FilepickerHandlerAdapter {
    constructor(private fileinfos: StringMap<any>) {
        super();
    }
    fileInfo_(path: string, callback: JSONCallback): void {
        const segments = path.split(FS);
        let info = this.fileinfos;
        for (const segment of segments) {
            if (segment.length == 0) continue;
            info = info[FileInfoKey._files]?.[segment];
            if (info == null) break;
        }
        callback(smap1_(Key.fileinfo, FileInfo.of_(info) ?? FileInfo.NOT_EXISTS));
    }
    listDir_(path: string, callback: JSONCallback): void {
        const dirpath = Array<StringMap<any>>();
        let info = this.fileinfos;
        const segments = path.split(FS);
        for (const segment of segments) {
            if (segment.length == 0) continue;
            info = info[FileInfoKey._files]?.[segment];
            if (info == null) {
                callback(smap1_(Key.errors, MSG.string1_(RS.DirectoryNotExists_, path)));
                return;
            };
            dirpath.push(info);
        }
        callback(smap_<any>(
            [Key.dirpath, dirpath],
            [Key.dirtree, Object.values(info[FileInfoKey._files] ?? {})],
            [Key.path, path],
            [Key.filename, ""],
        ));
    }
    dirInfo_(cpath: string, callback: JSONCallback): void {
        let dir = this.fileinfos;
        const segments = cpath.split(FS);
        for (const segment of segments) {
            if (segment.length == 0) continue;
            dir = dir[FileInfoKey._files]?.[segment];
            if (dir == null) {
                return callback(smap1_(Key.errors, MSG.string1_(RS.DirectoryNotExists_, cpath)));
            };
        }
        if (dir == null) return callback(json1_(Key.errors, MSG.string1_(RS.FileNotFound_, cpath)));
        const dirinfo = FileInfo.of_(dir);
        if (dirinfo?.isdir$ != true) return callback(json1_(Key.errors, MSG.string1_(RS.NotADirectory_, cpath)));
        this._dirinfo(dirinfo, callback);
    }
}

class _SystemActionsHelper {
    static backupRestoreResult(ret: JSONObject) {
        if (toasters$.warn_(ret, { hold: true })) return;
        const warns: Array<String> = ret[Key.warns] ?? [];
        if (warns.length > 0) toasters$.warn_(warns, { hold: true });
        toasters$.info_(ret[Key.result], { attop: true, hold: true });
    }

    static showExtensionTooltips_(exttooltips: Map<string, stringX>, filename: string): void {
        const suffix = Basepath.suffix_(filename);
        const tooltipskey = exttooltips.get(suffix) ?? null;
        if (tooltipskey !== null) toasters$.infoKey_(tooltipskey);
    }

    static actionManageBackupKeys_(dateformat: string): void {
        host$.getBackupKeyAliases_((ret) => {
            if (toasters$.warn_(ret)) return;
            new PromptBackupKeyManager(accessories$, dateformat, ret[Key.result])
                .titleKey_(RS.BackupKeyManagerTitle)
                .zindex_(DEF.zindexPrompt)
                .show_();
        });
    }

    static promptInputBackupFile(path: string, dateformat: string, zindex: Int): Filepicker {
        const basepath = new Basepath(path);
        return Filepicker.withTitleKey_(
            accessories$,
            RS.Restore,
            FilepickerKind.EXISTING_FILE,
            null,
            PATH._Internal_,
            (basepath.dir$ ?? PATH._Internal_),
            basepath.filename$,
            fileinfoUt$)
            .zindex_(zindex)
            .dateFormat_(dateformat)
            .onHelp_((_toaster, b) => {
                _SystemActionsHelper._help(b, RS.Help_BackupFilepicker);
            })
            .setDelegate_(InputBackupFileDelegate.singleton$);
    }

    static promptInputKeyFile(path: string, dateformat: string, zindex: Int): Filepicker {
        const basepath = new Basepath(path);
        const d = Filepicker.withTitleKey_(
            document.body,
            RS.KeyFile,
            FilepickerKind.EXISTING_FILE,
            null,
            PATH._Internal_,
            (basepath.dir$ ?? PATH._Internal_),
            basepath.filename$,
            fileinfoUt$);
        d.zindex_(zindex)
            .dateFormat_(dateformat)
            .setDelegate_(ImportKeyDelegate.singleton$)
            .onHelp_((_toaster, b) => {
                _SystemActionsHelper._help(b, RS.BackupKeyImportFilepickerHelp);
            })
            .onValidate_((path, fileinfo, mode, okcallback) => {
                if (fileinfo.isdir$) {
                    okcallback(true);
                    return;
                };
                d.defaultValidator_(path, fileinfo, mode, okcallback);
            });
        return d;
    }

    static promptOutputKeyFile(opath: string, dateformat: string, zindex: Int): Filepicker {
        const basepath = new Basepath(opath);
        const d = Filepicker.withTitleKey_(
            document.body,
            RS.KeyFile,
            FilepickerKind.WRITE_FILE,
            null,
            PATH._Internal_,
            (basepath.dir$ ?? PATH._Internal_),
            basepath.filename$,
            fileinfoUt$);
        d.zindex_(zindex)
            .dateFormat_(dateformat)
            .setDelegate_(ExportKeyDelegate.singleton$)
            .onHelp_((_toaster, b) => {
                _SystemActionsHelper._help(b, RS.BackupKeyExportFilepickerHelp);
            })
            .onValidate_((path, fileinfo, mode, okcallback) => {
                if (fileinfo.isdir$) {
                    okcallback(true);
                    return;
                };
                d.defaultValidator_(path, fileinfo, mode, okcallback);
            });
        return d;
    }

    static promptOutputBackupFile(path: string, dateformat: string, zindex: Int, delegate: FilepickerDelegate = OutputBackupFileDelegate.singleton$): Filepicker {
        const basepath = new Basepath(path);
        return Filepicker.withTitleKey_(
            accessories$,
            RS.Backup,
            FilepickerKind.ANY_FILE,
            null,
            PATH._Internal_,
            (basepath.dir$ ?? PATH._Internal_),
            basepath.filename$,
            fileinfoUt$)
            .zindex_(zindex)
            .dateFormat_(dateformat)
            .onHelp_((_toaster, b) => {
                _SystemActionsHelper._help(b, RS.Help_BackupFilepicker);
            })
            .setDelegate_(delegate)
            ;
    }

    static promptDir_(titlekey: StringId, path: string, dateformat: string, zindex: Int): Filepicker {
        return Filepicker.withTitleKey_(
            accessories$,
            titlekey,
            FilepickerKind.EXISTING_DIR,
            "",
            "",
            path,
            "",
            fileinfoUt$
        )
            .zindex_(zindex)
            .dateFormat_(dateformat)
            .setDelegate_(FilepickerDirDelegate.singleton$);
    }

    private static _help(b: DomBuilderEx, msgid: string): void {
        const a = MSG.stringArray_(msgid);
        b.push_().div_({
            "class": CSS.AnViewport,
            "style": "white-space:normal;font-size:small"
        });
        const len = a.length;
        if (len == 0) {
            return;
        }
        b.text_(a[0]);
        b.append_("br");
        for (let i = 1; i + 1 < len;) {
            b.b_().text_(a[i++]).up_().text_("\u00a0").text_(a[i++]).append_("br");
        }
        b.pop_();
    }
}

abstract class IPC {
    static readonly hello = "XxXBM";
    static readonly quit = "XxXp6";
    static readonly CMD = "XxXle";
    static readonly FROM_RENDERER_INVOKE = "XxXGt";
    static readonly result = "XxX2j";
    static readonly SERIAL = "XxX5k";
    static readonly FROM_RENDERER = "XxXgb";
    static readonly progress = "XxXI2";
    static readonly HOST = "XxXZl";
    static readonly test = "XxXr3";
    static readonly FROM_MAIN = "XxX2L";
    static readonly hi = "XxXY5";
    static readonly ARGS = "XxXSr";
    static readonly showDeveloperTools = "XxXUh";
    static readonly showPdf = "XxXN2";
    static readonly screenshot = "XxXhm";
    static readonly jof = "XxXMy";
}

/// Shared code for Host.
class HostUtil {
    static getXrefs_(idoc: Document | null, docuri: UriX, callback: JSONCallback) {
        const ret = json_();
        if (idoc == null || docuri == null) {
            callback(ret);
            return;
        }
        const links = new StringMap<JSONObject>();
        const addlink = (href: stringXX, kind: Int) => {
            if (href === null || href === undefined || href.length == 0) return;
            const cpath = An.cpathOfHref2_(docuri, href);
            if (cpath != null) {
                let info = links[cpath];
                if (info == null) {
                    info = json_();
                    links[cpath] = info;
                }
                info[href] = (info[href] ?? 0) | kind;
            }
        };
        JsUtil.elementWalker_(idoc.documentElement, (e) => {
            const href = e.getAttribute("href");
            const src = e.getAttribute("src");
            if (href == null && src == null) return;
            let kind = XrefKind.NONE;
            addlink(href, kind | XrefKind.HREF);
            addlink(src, kind | XrefKind.SRC);
        });
        ret[XrefKey.LINKS] = links;
        callback(ret);
    }

}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

abstract class _JOF {
    ///# NOTE: This should be in sync with AnnocloudServlet._JOF.
    static readonly takeScreenshot = "/a/XxXA2";
    static readonly actionBackupData = "/a/XxX7B";
    static readonly actionBackupKey = "/a/XxXfD";
    static readonly actionRestoreData = "/a/XxXTL";
    static readonly readBackupFiletree = "/a/XxX2e";
    static readonly getBackupFileInfo = "/a/XxXOD";
    static readonly getBackupKeyAliases = "/a/XxXSI";
    static readonly deleteBackupKey = "/a/XxXgA";
    static readonly importBackupKey = "/a/XxXNz";
    static readonly exportBackupKey = "/a/XxXTa";
    static readonly actionCleanHome = "/a/XxX0k";
    static readonly actionBackupVerify = "/a/XxXfU";
    static readonly actionBackupForward = "/a/XxX7H";
    static readonly actionBackupConversion = "/a/XxXJQ";
    static readonly actionQuit = "/a/XxXx1";
    static readonly actionFactoryReset = "/a/XxXSa";
    static readonly actionPrint = "/a/XxXCW";
    static readonly actionResetUserSettings = "/a/XxXWf";
    static readonly actionShare = "/a/XxXdU";
    static readonly actionView = "/a/XxXkW";
    static readonly audioInfos = "/a/XxXFQ";
    static readonly audioPause = "/a/XxXOA";
    static readonly audioPlay = "/a/XxX6s";
    static readonly audioSeek = "/a/XxX30";
    static readonly historyFilepicker = "/a/XxXvt";
    static readonly listZip = "/a/XxXCs";
    static readonly pdfPoster = "/a/XxXy7";
    static readonly cleanupTrash = "/a/XxXcz";
    static readonly clearEvents = "/a/XxXY7";
    static readonly clearFocus = "/a/XxX2A";
    static readonly copyToClipboard = "/a/XxXwW";
    static readonly createAudioPlayer = "/a/XxXvv";
    static readonly createFromTemplate = "/a/XxXmh";
    static readonly destroyAudioPlayer = "/a/XxXkJ";
    static readonly exportEvents = "/a/XxXgy";
    static readonly exportToPhotoLibrary = "/a/XxXxI";
    static readonly exportToPhotoLibraryInfos = "/a/XxXuF";
    static readonly filepicker = "/a/XxX7s";
    static readonly findBlog = "/a/XxXs9";
    static readonly listBlogs = "/a/XxXo5";
    static readonly findFiles = "/a/XxXah";
    static readonly focus = "/a/XxXIx";
    static readonly formatCSS = "/a/XxXFS";
    static readonly actionFsck = "/a/XxXwv";
    static readonly generateBarcode = "/a/XxXPh";
    static readonly generateGallery = "/a/XxXAY";
    static readonly gestureEnable = "/a/XxXmT";
    static readonly getAudioStatus = "/a/XxXR6";
    static readonly getDeviceSize = "/a/XxXpk";
    static readonly getEvents = "/a/XxX61";
    static readonly getPendingAlarmCount = "/a/XxXqX";
    static readonly getSessionPreferences = "/a/XxXfA";
    static readonly getSettings = "/a/XxXo2";
    static readonly getTemplatesInfo = "/a/XxXiF";
    static readonly globalSearch = "/a/XxXa4";
    static readonly globalSearchResult = "/a/XxXII";
    static readonly heartbeat = "/a/XxXyI";
    static readonly hideCaret = "/a/XxXyN";
    static readonly hideKeyboard = "/a/XxXwH";
    static readonly imageConversion = "/a/XxXUM";
    static readonly importImageFromPhotoLibrary = "/a/XxXaN";
    static readonly importVideoFromPhotoLibrary = "/a/XxX56";
    static readonly isKeyboardShown = "/a/XxX8J";
    static readonly linkVerifier = "/a/XxX6J";
    static readonly localImageInfo = "/a/XxXLW";
    static readonly localImageThumbnail = "/a/XxXmw";
    static readonly onBoot = "/a/XxXVq";
    static readonly onDocumentLoaded = "/a/XxXtN";
    static readonly onDocumentUnload = "/a/XxXGW";
    static readonly onIFrameLoaded = "/a/XxXDW";
    static readonly onIFrameUnload = "/a/XxXnw";
    static readonly onWindowSizeChanged = "/a/XxXcF";
    static readonly pasteFromClipboard = "/a/XxXcx";
    static readonly photoLibraryInfos = "/a/XxXUe";
    static readonly photoLibraryThumbnails = "/a/XxXVm";
    static readonly playVideo = "/a/XxXQC";
    static readonly pollAudioPlayer = "/a/XxXgi";
    static readonly postEvent = "/a/XxX43";
    static readonly previewImage = "/a/XxXGL";
    static readonly readCSS = "/a/XxXgE";
    static readonly recents = "/a/XxXbz";
    static readonly rebuildXrefs = "/a/XxXrxr";
    static readonly requestFixBrokenLinks = "/a/XxXrfb";
    static readonly confirmFixBrokenLinks = "/a/XxXcfb";
    static readonly getXrefs = "/a/XxXgxr";
    static readonly recentsPut = "/a/XxXrz";
    static readonly recordVideo = "/a/XxXVZ";
    static readonly releaseAudioPlayer = "/a/XxXuT";
    static readonly removeEvents = "/a/XxX4z";
    static readonly requestAudioRecordingPermission = "/a/XxXJe";
    static readonly requestVideoRecordingPermission = "/a/XxXYU";
    static readonly sanitize = "/a/XxXsS";
    static readonly saveBase64Image = "/a/XxX9P";
    static readonly saveCSS = "/a/XxXNS";
    static readonly saveHtml = "/a/XxXVa";
    static readonly saveRecovery = "/a/XxX2S";
    static readonly scanBarcode = "/a/XxX9v";
    static readonly showKeyboard = "/a/XxXrI";
    static readonly sidepanelChanged = "/a/XxXkP";
    static readonly startAudioRecording = "/a/XxXSC";
    static readonly stopAudioRecording = "/a/XxXON";
    static readonly takePhoto = "/a/XxXts";
    static readonly takePhotoCancelled = "/a/XxXEI";
    static readonly toggleNobackup = "/a/XxXWu";
    static readonly undead = "/a/XxXbf";
    static readonly updateSessionPreferences = "/a/XxX03";
    static readonly updateUISettings = "/a/XxXsu";
    static readonly videoInfos = "/a/XxXFi";
    static readonly videoPoster = "/a/XxXvpo";
    static readonly viewPhotoLibraryThumbnail = "/a/XxX4K";
    static readonly writeImage = "/a/XxXOE";
    static readonly unzip = "/a/XxXIj";
    static readonly zip = "/a/XxX8F";
    ///# NOTE: This should be in sync with AnnocloudServlet._XOF.
    static readonly testIsEncrypted = "/a/testIsEncrypted";
    static readonly desktopChangeLogin = "/a/desktopChangeLogin";
}

class Host {
    static readonly DPI: number = 160;

    private readonly _ipc = (window as any)[IPC.HOST] as IpcRenderer;
    private _serial = new Serial();
    private _callbacks: Map<Long, JSONCallback> = map_();
    private _clipboardText: stringX = null;

    constructor() {
        this._ipc.
            XxXior
            (IPC.FROM_MAIN, (_event, ...args) => {
                if (args.length == 0) { return; }
                switch (args[0]) {
                    case IPC.screenshot: {
                        
                        Host.handleScreenshotResult_(args);
                        break;
                    }
                    case IPC.jof: {
                        
                        this.ajaxResult_(args);
                        break;
                    }
                    case IPC.quit: {
                        
                        this.ajax_(_JOF.actionQuit, 0, null, () => {
                            mainPanel$.onPauseCallback(null);
                            this.ipcsend_(IPC.quit);
                        });
                        break;
                    }
                }
            });
    }

    static handleScreenshotResult_(args: string[]): void {
        let hasrsb = true;
        try {
            function failed() {
                toasters$.warn_(MSG.actionFailed_(RS.ActionScreenshotTitle));
            }
            
            if (args.length < 6)
                return failed();
            const dataurl = args[2];
            const width = An.parseInt_(args[3], 0);
            const height = An.parseInt_(args[4], 0);
            hasrsb = (args[5] == "true");
            if (width == 0 || height == 0)
                return failed();
            const cpath = Basepath.changeSuffix_(args[1], Suffix.PNG$);
            const basedir = Basepath.dir_(cpath) ?? "";
            _Util.promptOutputImage0_((() => cpath), basedir, null, width, height, DEF.zindexPrompt,
                dataurl, MediaUtil.optionalDimension_, (outputinfo) => {
                    host$.writeImage_(dataurl, outputinfo, null, ret => {
                        if (toasters$.warn_(ret)) return;
                        toasters$.ok_(MSG.actionOK_(RS.ActionScreenshotTitle), { attop: true });
                    });
                }, (d) => {
                    d.show_();
                });
        } finally {
            sidePanel$.sidebarAnimate(_DEF.SidebarTop);
            if (hasrsb) {
                const rsb = native$.iGetElementById_(ID.xRightSidebar);
                if (rsb != null) {
                    rsb.classList.remove(CSS.xHidetemp);
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////

    ipcsend_(channel: string, ...args: any[]): void {
        this._ipc.
            XxXisd
            (channel, ...args);
    }

    ajax_(query: string, kind: number, data: stringX, callback: JSONCallback | null): void {
        const url = `${Conf.schemeHost$}${query}?kind=${kind}`;
        const serial = this._serial.get_();
        this._callbacks.set(serial, callback ?? An.noop_);
        this.ipcsend_(IPC.FROM_RENDERER, IPC.jof, url, data, serial);
    }
    ajaxResult_(args: any[]) {
        if (args.length > 2) {
            const serial = args[1] as Long;
            const result = args[2] as JSONObject;
            const callback = this._callbacks.get(serial);
            Timer.sleep0_(() => {
                try {
                    callback?.(result);
                } catch (e: any) {
                }
            });
        }
    }

    ajaxWithSpinner_(query: string, kind: number, data: stringX, callback: JSONCallback) {
        spinner$.show_(() => {
            this.ajax_(query, kind, data, (ret) => {
                spinner$.hide_();
                callback(ret);
            });
        });
    }

    filepicker_ = (jof: string, cmd: Int, params: JSONObject, callback: JSONCallback): void => {
        this.ajax_(jof, cmd, JSON.stringify(params), callback);
    };

    imageInfo_ = (jof: string, params: any[], callback: JSONCallback): void => {
        this.ajax_(jof, 0, JSON.stringify(params), callback);
    };

    recents_ = (cmd: Int, callback: JSONCallback): void => {
        this.ajax_(_JOF.recents, cmd, null, callback);
    };

    showDeveloperTools_ = () => {
        const ipc = (window as any)[IPC.HOST] as IpcRenderer;
        if (ipc == null) return;
        this.ipcsend_(IPC.FROM_RENDERER, IPC.showDeveloperTools);
    };

    showPdf_ = (uri: Uri, e: Event | null = null): boolean => {
        const ipc = (window as any)[IPC.HOST] as IpcRenderer;
        if (ipc != null) {
            if (e != null) JsUtil.stopevent_(e);
            this.ipcsend_(IPC.FROM_RENDERER, IPC.showPdf, uri.toAbsolute_().href$, window.outerWidth, window.outerHeight);
            return true;
        }
        return false;
    };

    ////////////////////////////////////////////////////////////////////////

    getDeviceSize_(): Point<number> {
        const ret = new Point(window.innerWidth, window.innerHeight);
        
        return ret;
    }

    getDPI_(): number {
        return Host.DPI;
    }

    recentsBack_(callback: JSONCallback): void {
        this.ajax_(_JOF.recents, RecentsCmd.BACK, "", callback);
    }

    recentsPeek_(callback: JSONCallback): void {
        this.ajax_(_JOF.recents, RecentsCmd.PEEK, "", callback);
    }

    recentsForward_(callback: JSONCallback): void {
        this.ajax_(_JOF.recents, RecentsCmd.FORWARD, "", callback);
    }

    recentsPut_(navigation: number, path: string, state: JSONObjectX, callback: JSONCallback): void {
        this.ajax_(_JOF.recentsPut, 0, JSON.stringify([navigation, path, state]), callback);
    }

    login_(_testing: boolean, callback: JSONCallback): void {
        Timer.sleep0_(() => {
            callback({});
        });
    }

    /// @param callback(ok)
    logout_(_skipreload: boolean = false, _callback: JSONCallback | null = null/* for testing only. */): void {
        native$.reloadHome_();
    }

    /**
    * @param path The context relative file path of the new page, eg. /Home/test.html.
    * @param template The file content.
    * @param onerror(msg) Callback on error.
    */
    addPage_(path: stringX, template: string, callback: JSONCallback): void {
        if (path == null) {
            callback(smap1_(Key.errors, [MSG.string_(RS.InvalidPath), path]));
            return;
        }
        if (path.length > 0 && path[0] != FS) {
            path = FS + path;
        }
        const url = _JOF.createFromTemplate;
        const data = stringify_(
            [Key.template, template],
            [Key.path, path],
        );
        this.ajax_(url, 0, data, callback);
    }

    /// Simulating system clipboard.
    copyToClipboard_(text: string, callback: JSONCallback | null = null): void {
        this._clipboardText = text;
        callback?.({});
    }

    pasteFromClipboard_(callback: JSONCallback): void {
        if (this._clipboardText != null) {
            callback(smap1_(Key.result, this._clipboardText));
        } else {
            callback(An.jsonError_(RS.ClipboardIsEmptyOrInvalid));
        }
    }

    /**
    * Sanitize actions:
    *   Key.tag: String,
    *   Key.attrs: String,
    *
    *
    *
    *
    *
    *
    *
    */

    /**
    * Sanitize actions:
    *   Key.tag: String,
    *   Key.attrs: String,
    */
    sanitizeTagAttrs_(params: JSONObject, callback: JSONCallback): void {
        this.ajax_(_JOF.sanitize, 0, JSON.stringify(params), callback);
    }

    getDocInfo_(callback: JSONCallback): void {
        const path = native$.getIFrameContextPath_();
        this.ajax_(_JOF.filepicker, FilepickerCmd.FILEINFO, stringify1_(Key.path, path), callback);
    }

    /**
    * @return { Key.result: {settings}, Key.fileinfo: {fileinfo}}
    */
    getSettings_(docpath: stringX, callback: JSONCallback): void {
        this.ajax_(_JOF.getSettings, 0, docpath, callback);
    }

    getTemplatesInfo_(callback: JSONCallback): void {
        this.ajax_(_JOF.getTemplatesInfo, 0, null, callback);
    }

    updateUISettings_(update: UISettings, callback: JSONCallback): void {
        this.ajax_(_JOF.updateUISettings, 0, update.toJSONString_(), ret => {
            callback(ret);
        });
    }

    updateSessionPreferences_(update: JSONObject, callback: JSONCallback): void {
        this.ajax_(_JOF.updateSessionPreferences, 0, JSON.stringify(update), callback);
    }

    getSessionPreferences_(callback: JSONCallback): void {
        this.ajax_(_JOF.getSessionPreferences, 0, null, callback);
    }

    /**
    * @param cpath Context relative media file path.
    * @return {Key.result: { image info with dimension information}, Key.errors: error }.
    */
    localImageInfo_(cpath: string, withtn: boolean, callback: JSONCallback): void {
        this.ajax_(_JOF.localImageInfo, 0, JSON.stringify([cpath, withtn]), callback);
    }

    /**
    * Import the media to a temporary local file if neccessary which may be deleted on clearCaches.
    * @return { Key.result: dataurl, errors: Object }
    */
    viewPhotoLibraryThumbnail_(size: number, info: MediaInfo, callback: JSONCallback): void {
        this.ajax_(_JOF.viewPhotoLibraryThumbnail, size, JSON.stringify(info.json$), callback);
    }

    previewImage_(
        dataurl: string,
        width: Int,
        height: Int,
        rotation: number,
        effect: number,
        adjust: number,
        quality: number,
        callback: JSONCallback): void {
        this.ajax_(
            _JOF.previewImage,
            0,
            JSON.stringify([
                dataurl,
                width,
                height,
                rotation,
                effect,
                adjust,
                quality,
            ]),
            callback);
    }

    localImageThumbnail_(cpath: string, tnsize: number, quality: number, crop: CropInfo | null, callback: JSONCallback): void {
        this.ajax_(
            _JOF.localImageThumbnail,
            0,
            JSON.stringify([
                cpath,
                tnsize,
                quality,
                crop?.toJSONArray() ?? null,
            ]),
            callback);
    }

    /**
    * Import the media to a permanent local file, eg. to /Home/Images/Import/ for images, if neccessary.
    * @param outpath An absolute context path.
    * @param width The output width.
    * @parma height The output height.
    * @param rotation 0, 90, 180 or 270.
    * @param colorspace ColorSpace values.
    * @param quality For lossy compressions, eg. jpeg, 0..100.
    * @param tnwidth Optional thumbnail width, -1 to skip generating thumbnail.
    * @param tnheight Optional thumbnail height, -1 to skip generating thumbnail.
    * @param tnquality For lossy compressions, eg. jpeg, 0..100.
    * @return  ret{
    *   Key.result: The cpath of the imported image, relative to context root with leading slash,
    *   Key.imageinfo: { The imageinfo of the imported image }
    *   Key.tnpath: The cpath of the thumbnail file with leading / if any, may be same as Key.result.
    * }.
    */

    /// @since 2.8.3
    actionShare_(cpaths: string[]): void {
        this.ajax_(_JOF.actionShare, 0, JSON.stringify([cpaths]), ret => {
            toasters$.warn_(ret);
        });
    }

    /**
    * @parm src A context relative URL, eg. Home/index.html or /Home/index.html.
    * @param content The serialized document content.
    * @param callback ({Key.errors: errors, Key.result: path}).
    */
    saveHtml_(cpath: string, content: string, callback: JSONCallback): void {
        if (cpath == null) {
            return;
        }
        if (cpath.length > 0 && cpath[0] != FS) {
            cpath = FS + cpath;
        }
        const docuri = native$.getIFrameUri_();
        HostUtil.getXrefs_(native$.getIFrameDocument_(), docuri, (xrefs) => {
            this.ajax_(_JOF.saveHtml, 0, JSON.stringify([cpath, content, xrefs]), callback);
        });
    }

    unzip_(zipfile: string, dstdirpath: string, srcpath: string, callback: JSONCallback) {
        this.ajaxWithSpinner_(_JOF.unzip, 0, JSON.stringify([zipfile, dstdirpath, srcpath]), callback);
    }

    zip_(zippath: string, srcdirpath: string, callback: JSONCallback) {
        this.ajaxWithSpinner_(_JOF.zip, 0, JSON.stringify([zippath, srcdirpath]), callback);
    }

    saveBase64Image_(cpath: string, dataurl: string, callback: JSONCallback): void {
        const json = stringify_(
            [Key.path, cpath],
            [Key.data, dataurl],
        );
        this.ajax_(_JOF.saveBase64Image, 0, json, callback);
    }

    /**
    * @parma callback({Key.errors: errors})
    */
    writeImage_(fromcpath: string, outputinfo: ImageOutputInfo, crop: CropInfo | null, callback: JSONCallback): void {
        this.ajax_(
            _JOF.writeImage,
            0,
            JSON.stringify([
                fromcpath,
                outputinfo.cpath,
                outputinfo.width,
                outputinfo.height,
                outputinfo.rotation,
                outputinfo.effect,
                outputinfo.adjust,
                outputinfo.quality,
                crop?.toJSONArray() ?? null
            ]),
            callback);
    }

    hideCaret_(_tab: string, callback: JSONCallback): void {
        callback({});
    }

    /**
    * @param linkinfos Object as return by native$.getIFrameLinks(). { baseurl: string, links: [{link: null}...]}.
    * @param callback({errors:[], result:{link: status, ...}})
    */
    linkInfos_(links: JSONObject, callback: JSONCallback): void {
        this.ajax_(_JOF.linkVerifier, LinkVerifierCmd.LINKINFOS, JSON.stringify(links), callback);
    }

    /**
    * @param baseuri IFrame uri
    * @param link link uri.
    * @param callback({errors:[], Key.linkinfo: status})
    */
    linkInfo_(baseuri: string, link: string, callback: JSONCallback): void {
        this.ajax_(
            _JOF.linkVerifier,
            LinkVerifierCmd.LINKINFO,
            stringify_(
                [Key.baseurl, baseuri],
                [Key.path, link],
            ),
            callback);
    }

    /**
    * @parma fromdir Context relative path, with leading /, to start search from.
    */
    findFiles_(fromdir: string, searchtext: string, callback: JSONCallback): void {
        this.ajax_(
            _JOF.findFiles,
            0,
            stringify_(
                [Key.path, fromdir],
                [Key.text, searchtext],
            ),
            callback);
    }

    globalSearch_(
        filterignorecase: boolean, filefilter: string, searchignorecase: boolean, searchtext: string, isregex: boolean, callback: JSONCallback): void {
        this.ajax_(
            _JOF.globalSearch,
            0,
            stringify_(
                [Key.filterIgnorecase, filterignorecase],
                [Key.filter, filefilter],
                [Key.searchIgnorecase, searchignorecase],
                [Key.text, searchtext],
                [Key.isregex, isregex],
            ),
            callback);
    }

    globalSearchResult_(id: number, isregex: boolean, callback: JSONCallback): void {
        this.ajax_(
            _JOF.globalSearchResult,
            0,
            stringify_(
                [Key.id, id],
                [Key.isregex, isregex],
            ),
            callback);
    }

    ////////////////////////////////////////////////////////////////////////

    getAudioStatus_(callback: JSONCallback): void {
        const player = _AudioPlayerDialog.singleton$;
        if (player == null) {
            callback({});
            return;
        }
        player.getAudioStatus_(callback);
    }

    /// @maxms 0 for unlimited.
    /// @maxbytes 0 for unlimited.
    startAudioRecording_(_filepath: string, _maxms: number, _maxbytes: number, _quality: number, callback: JSONCallback): void {
        callback(smap1_(Key.errors, MSG.string_(RS.DesktopOperationRecordAudioNotAvailable)));
    }

    stopAudioRecording_(callback: JSONCallback): void {
        callback(smap1_(Key.errors, MSG.string_(RS.DesktopOperationRecordAudioNotAvailable)));
    }

    requestAudioRecordingPermission_(callback: JSONCallback): void {
        callback(smap1_(Key.errors, MSG.string_(RS.DesktopOperationRecordAudioNotAvailable)));
    }

    audioInfos_(requests: JSONObject[], callback: JSONCallback): void {
        if (requests.length == 0) {
            callback({});
            return;
        }
        this.ajax_(_JOF.audioInfos, 0, JSON.stringify(requests), callback);
    }

    videoInfos_(requests: JSONObject[], callback: JSONCallback): void {
        if (requests.length == 0) {
            callback({});
            return;
        }
        this.ajax_(_JOF.videoInfos, 0, JSON.stringify(requests), callback);
    }

    takePhoto_(isprivate: boolean, testing: boolean): void {
        this.ajax_(_JOF.takePhoto, 0, JSON.stringify([isprivate, testing]), ret => {
            native$.onCallback_(AjaxAction.takePhotoResult, JSON.stringify(ret));
        });
    }

    takePhotoCancelled_(imageinfo: MediaInfo, callback: JSONCallback): void {
        this.ajax_(_JOF.takePhotoCancelled, 0, JSON.stringify(imageinfo.json$), callback);
    }

    takeScreenshot_(cpath: string, top: Int, winheight: Int, hasrsb: boolean): void {
        const ipc = (window as any)[IPC.HOST] as IpcRenderer;
        if (ipc == null) return;
        this.ipcsend_(IPC.FROM_RENDERER, IPC.screenshot, cpath, top, winheight, hasrsb ? "true" : "false");
    }

    toggleNobackup_(cpath: string, callback: JSONCallback): void {
        this.ajax_(_JOF.toggleNobackup, 0, cpath, callback);
    }

    actionQuit_(): void {
        DialogUt.confirmSmall_(document.body, MSG.string_(RS.ActionQuitTooltips), DEF.zindexPrompt, (yes) => {
            if (!yes) {
                toasters$.warn_(MSG.actionCancelled_(RS.ActionQuitTitle));
                return;
            }
            const ipc = (window as any)[IPC.HOST] as IpcRenderer;
            if (ipc == null) return;
            this.ipcsend_(IPC.FROM_RENDERER, IPC.quit);
        });
    }

    ////////////////////////////////////////////////////////////////////////

    /**
    * @param includeExpired True to include alarms that is expired.
    * @return {Key.result: {name: alarm}, Key.errors: errors}
    */
    getEvents_(refresh: boolean, excludeExpired: boolean, callback: JSONCallback): void {
        this.ajax_(
            _JOF.getEvents,
            0,
            stringify_(
                [Key.filterIgnorecase, refresh],
                [Key.filter, excludeExpired],
            ),
            callback);
    }

    postEvent_(alarm: JSONObject, callback: JSONCallback): void {
        this.ajax_(_JOF.postEvent, 0, JSON.stringify(alarm), callback);
    }

    removeEvents_(ids: string[], callback: JSONCallback): void {
        this.ajax_(_JOF.removeEvents, 0, JSON.stringify(ids), callback);
    }

    clearEvents_(callback: JSONCallback): void {
        this.ajax_(_JOF.clearEvents, 0, null, callback);
    }

    getPendingAlarmCount_(callback: JSONCallback): void {
        this.ajax_(_JOF.getPendingAlarmCount, 0, null, callback);
    }

    exportEvents_(cpath: string, callback: JSONCallback): void {
        this.ajax_(_JOF.exportEvents, 0, JSON.stringify([cpath]), callback);
    }

    ////////////////////////////////////////////////////////////////////////

    isKeyboardShown_(callback: BoolCallback): void {
        callback(true);
    }

    hideKeyboard0_(): void { }

    hideKeyboard_(callback: Fun00X = null): void {
        callback?.();
    }

    showKeyboard_(_variant: stringX = null, callback: Fun00X = null): void {
        callback?.();
    }

    toggleKeyboard_(callback: Fun00X = null): void {
        callback?.();
    }

    sidepanelChanged_(_info: JSONObject): void { }

    gestureEnable_(_event: string, _enable: boolean): void { }

    onDocumentLoaded_(): void {
        Timer.sleep0_(() => {
            
            this.ajax_(
                _JOF.onDocumentLoaded,
                0,
                JSON.stringify(Array.from(native$.cssProperties_().keys())),
                () => { });
        });
    }

    autoCleanupTrash_(callback: Fun10<boolean>): void {
        this.getSessionPreferences_(ret => {
            const result = ret[Key.result];
            if (result == null) return;
            const last = result[SessionPreferencesKey.trashAutoCleanupTimestamp];
            const now = An.ms_();
            if (last == null) {
                this.updateSessionPreferences_(smap1_(
                    SessionPreferencesKey.trashAutoCleanupTimestamp, now
                ), () => callback(false));
                return;
            }
            if (now - last <= DEF.trashAutoCleanupInterval) {
                callback(false);
                return;
            }
            _Util.confirmKeySmall_(RS.TrashConfirmAutoCleanup, DEF.zindexPrompt, (yes) => {
                if (!yes) {
                    callback(false);
                    return;
                }
                this.cleanupTrash_("", (ret) => {
                    this.updateSessionPreferences_(smap1_(
                        SessionPreferencesKey.trashAutoCleanupTimestamp, now
                    ), () => {
                        mainPanel$.addIFrameReadyOneshotCallback0(() => {
                            toasters$.info_(ret[Key.result], { attop: true });
                        });
                        callback(true);
                    });
                });
            });
        });
    }

    onDocumentUnload_(): void {
        //// Use by Android code only.
        
    }

    onBoot_(): void {
        
    }

    onIFrameLoad_(_uri: UriX): void {
        
    }

    onIFrameUnload_(_uri: UriX): void {
        
    }

    clearFocus_(): void { }

    ////////////////////////////////////////////////////////////////////////

    actionPrint_(cpath: string, _state: JSONObjectX, callback: JSONCallback): void {
        this.ajax_(_JOF.actionPrint, 0, cpath, callback);
    }

    backupRestore_ = (jof: string, params: any[], callback: JSONCallback): void => {
        this.ajaxWithSpinner_(jof, 0, JSON.stringify(params), (ret) => {
            callback(ret);
        });
    };

    readBackupFiletree_ = (backupfile: string, callback: JSONCallback): void => {
        this.ajax_(_JOF.readBackupFiletree, 0, JSON.stringify([backupfile]), callback);
    };

    getBackupKeyAliases_(callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.getBackupKeyAliases, 0, "", callback);
    }

    getBackupFileInfo_(cpath: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.getBackupFileInfo, 0, JSON.stringify([cpath]), callback);
    }

    deleteBackupKey_(alias: string, callback: JSONCallback): void {
        this.ajax_(_JOF.deleteBackupKey, 0, alias, callback);
    }

    importBackupKey_(alias: string, cpath: string, callback: JSONCallback): void {
        this.ajax_(_JOF.importBackupKey, 0, JSON.stringify([alias, cpath]), callback);
    }

    exportBackupKey_(alias: string, cpath: string, callback: JSONCallback): void {
        this.ajax_(_JOF.exportBackupKey, 0, JSON.stringify([alias, cpath]), callback);
    }

    actionBackup_(dateformat: string, backupfilepath: string, srcdir: string, callback: Fun00): void {
        host$.getBackupKeyAliases_((ret) => {
            if (toasters$.warn_(ret)) return;
            new PromptBackup(accessories$, dateformat, backupfilepath, srcdir, ret[Key.result], callback).show_();
        });
    }

    actionRestore_(dateformat: string, backupfile: string, dstdirpath: string, callback: JSONCallback | null = null): void {
        new PromptRestore(accessories$, dateformat, backupfile, dstdirpath, callback).show_();
    }

    actionBackupVerify_(backupfile: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.actionBackupVerify, 0, JSON.stringify([backupfile]), callback);
    }

    actionBackupForward_(backupfile: string, aliases: string[], callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.actionBackupForward, 0, JSON.stringify([backupfile, aliases]), callback);
    }

    actionFsck_(cpath: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.actionFsck, 0, JSON.stringify([cpath]), callback);
    }

    actionRebuildXrefs_(cpath: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.rebuildXrefs, 0, JSON.stringify([cpath]), callback);
    }

    requestFixBrokenLinks_(cpath: string, fromdir: stringX, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.requestFixBrokenLinks, 0, JSON.stringify([cpath, fromdir]), callback);
    }

    confirmFixBrokenLinks_(cpath: string, tofix: JSONObject, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.confirmFixBrokenLinks, 0, JSON.stringify([cpath, tofix]), callback);
    }

    getXrefs_(cpath: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.getXrefs, 0, JSON.stringify([cpath]), callback);
    }

    actionBackupConversion_(dstpath: string, srcpath: string, aliases: string[], cut: boolean, callback: JSONCallback) {
        this.ajaxWithSpinner_(_JOF.actionBackupConversion, 0, JSON.stringify([dstpath, srcpath, aliases, cut]), callback);
    }

    actionResetUserSettings_(_skipreload: boolean = false /* for testing only. */): void {
        DialogUt.confirmSmall_(document.body, MSG.string_(RS.ResetUserSettingsTooltips), DEF.zindexPrompt, (yes) => {
            if (!yes) {
                toasters$.warn_(MSG.actionCancelled_(RS.ResetUserSettingsTitle));
                return;
            }
            this.ajax_(_JOF.actionResetUserSettings, 0, "", (ret) => {
                toasters$.warnErrorsOrOK_(ret, MSG.actionOK_(RS.ResetUserSettingsTitle));
                    native$.reloadHome_();
            });
        });
    }

    actionCleanHome_(_skipreload: boolean = false /* for testing only */): void {
        DialogUt.promptOK_(accessories$, RS.ActionCleanHomeTitle, MSG.string_(RS.ActionCleanHomeTooltips), (yes) => {
            if (!yes) {
                toasters$.warn_(MSG.actionCancelled_(RS.ActionCleanHomeTitle));
                return;
            }
            host$.ajaxWithSpinner_(_JOF.actionCleanHome, 0, "", (ret) => {
                toasters$.warnErrorsOrOK_(ret, MSG.actionOK_(RS.ActionCleanHomeTitle));
                    native$.reloadHome_();
            });
        }).zindex_(DEF.zindexPrompt).smallWidth_().showWarning_();
    }

    actionFactoryReset_(_skipreload: boolean = false /* for testing only */): void {
        DialogUt.promptOK_(accessories$, RS.FactoryResetTitle, MSG.string_(RS.FactoryResetTooltips), (yes) => {
            if (!yes) {
                toasters$.warn_(MSG.actionCancelled_(RS.FactoryResetTitle));
                return;
            }
            DialogUt.promptOK_(accessories$, RS.Confirm, MSG.confirmProceed_(RS.FactoryResetTooltips), (yes) => {
                if (!yes) {
                    toasters$.warn_(MSG.actionCancelled_(RS.FactoryResetTitle));
                    return;
                }
                host$.ajaxWithSpinner_(_JOF.actionFactoryReset, 0, "", (ret) => {
                    toasters$.warnErrorsOrOK_(ret, MSG.actionOK_(RS.FactoryResetTitle));
                        native$.reloadHome_();
                });
            }).zindex_(DEF.zindexPrompt).showError_();
        }).zindex_(DEF.zindexPrompt).smallWidth_().showWarning_();
    }

    ////////////////////////////////////////////////////////////////////////

    heartbeat_(): void {
    }

    /// @param The cpath of the document to be saved.
    saveRecovery_(src: string, callback: JSONCallback): void {
        Assert.assertion_(src != null);
        if (src.length > 0 && src[0] != FS) {
            src = FS + src;
        }
        if (!PathUtil.isDocumentsSubtree(src)) {
            callback({});
            return;
        }
        const content = native$.serializeIFrameDocument_();
        this.ajax_(_JOF.saveRecovery, 0, JSON.stringify([src, content]), ret => {
            callback(ret);
        });
    }

    scanQRCode_(_cpath: string, _id: string, /* _exporting: boolean, */ callback: JSONCallback): void {
        callback({});
    }

    ////////////////////////////////////////////////////////////////////////

    playVideo_(cpath: string, _requestinfo: boolean, seek: numberX, callback: JSONCallback): void {
        const href = An.uriFrom_(null, cpath.split(FS))?.encoded$;
        if (href != null) {
            const d = new FullscreenVideoPlayer(accessories$, href, seek ?? 0)
                .on_("click", () => {
                    callback?.(jsonOf_(Key.time, d.currentTime_()));
                    d.destroy_();
                });
            d.show_();
        }
    }

    videoPoster_(cpath: string, time: Double, w: Int, h: Int, quality: Int, callback: JSONCallback): void {
        this.ajax_(_JOF.videoPoster, 0, JSON.stringify([cpath, time, w, h, quality]), callback);
    }

    importVideoFromPhotoLibrary_(_topath: string, _mediainfo: JSONObject, callback: JSONCallback): void {
        callback({});
    }

    exportToPhotoLibraryInfos_(srcdir: string, callback: JSONCallback): void {
        this.ajax_(_JOF.exportToPhotoLibraryInfos, 0, JSON.stringify([srcdir]), callback);
    }

    requestVideoRecordingPermission_(callback: JSONCallback): void {
        callback(smap1_(Key.errors, MSG.string_(RS.DesktopOperationRecordVideoNotAvailable)));
    }

    recordVideo_(_cpath: string, _duration: number, _quality: string, _poster: number, /* _exporting: boolean, */ _testing: boolean): void {
    }

    focus_(): void { }

    ////////////////////////////////////////////////////////////////////////

    iosPickFromPhotoLibrary_(_images: boolean, _movies: boolean, callback: JSONCallback): void {
        callback(smap1_(
            Key.errors, MSG.string_(RS.AssertUnsupportedOperation)
        ));
    }

    iosPickFromPhotoLibraryCancelled_(_path: string): void {
    }

    iosSavePhoto_(): void {
    }

    onWindowSizeChanged_(width: number, height: number): void {
        this.ajax_(_JOF.onWindowSizeChanged, 0, JSON.stringify([width, height]), null);
    }

    scanBarcode_(cpath: string, id: string, crop: CropInfo, /* _exporting: boolean, */ callback: JSONCallback): void {
        this.ajax_(_JOF.scanBarcode, 0, JSON.stringify([cpath, id, crop.toJSONArray()]), callback);
    }

    undead_(): void {
        this.ajax_(_JOF.undead, 0, null, null);
    }

    actionView_(cpath: string): void {
        this.ajax_(_JOF.actionView, 0, JSON.stringify([cpath]), ret => {
            toasters$.warn_((ret));
        });
    }

    /// @return {Key.data, dataurl, Key.errors: errors }
    generateBarcode_(type: string, scale: number, text: string, callback: JSONCallback): void {
        this.ajax_(_JOF.generateBarcode, 0, JSON.stringify([type, scale, text]), callback);
    }

    generateGallery_(
        path: string,
        template: string,
        options: GalleryOptions,
        dir: string,
        rpaths: string[],
        callback: JSONCallback
    ): void {
        const path1 = this._checkDestinationPath(path, callback);
        if (path1 != null) {
            this.ajaxWithSpinner_(_JOF.generateGallery, 0, JSON.stringify([
                path1,
                template,
                options.options$.toJSONArray_(),
                dir,
                rpaths]), callback);
        }
    }

    readCSS_(cpath: string, callback: JSONCallback): void {
        this.ajax_(_JOF.readCSS, 0, JSON.stringify([cpath]), callback);
    }

    saveCSS_(cpath: string, content: string, infos: JSONObjectX, callback: JSONCallback): void {
        this.ajax_(_JOF.saveCSS, 0, JSON.stringify([cpath, content, infos]), callback);
    }

    formatCSS_(content: string, callback: JSONCallback): void {
        this.ajax_(_JOF.formatCSS, 0, JSON.stringify([content]), callback);
    }

    cleanupTrash_(cpath: string, callback: JSONCallback): void {
        this.ajaxWithSpinner_(_JOF.cleanupTrash, 0, JSON.stringify([cpath]), callback);
    }

    private _checkDestinationPath(path: string, callback: JSONCallback): stringX {
        if (path == null) {
            callback(this._errors(MSG.string_(RS.DestinationNotValid)));
            return null;
        }
        if (path.length > 0 && path[0] != FS) {
            path = FS + path;
        }
        return path;
    }

    /// @param month 1..12
    /// @param day 1..31
    findBlog_(year: Int, month: Int, day: Int, next: boolean, callback: JSONCallback) {
        this.ajax_(_JOF.findBlog, 0, JSON.stringify([year, month, day, next]), callback);
    }

    listBlogs_(year: Int, month: Int, callback: JSONCallback) {
        this.ajax_(_JOF.listBlogs, 0, JSON.stringify([year, month]), callback);
    }

    imageConversion_(dirpath: string, rpaths: string[], info: ImageOutputInfo, cut: boolean, callback: JSONCallback) {
        this.ajaxWithSpinner_(_JOF.imageConversion, 0, JSON.stringify([
            dirpath, rpaths, info.cpath, info.width, info.height, info.rotation, info.effect, info.adjust, info.quality, cut,]), callback);
    }

    listZip_(cpath: string, callback: JSONCallback) {
        this.ajax_(_JOF.listZip, 0, JSON.stringify([cpath]), callback);
    }

    pdfPoster_(cpath: string, page: Int, callback: JSONCallback) {
        this.ajax_(_JOF.pdfPoster, 0, JSON.stringify([cpath, page]), callback);
    }

    ////////////////////////////////////////////////////////////////////////

    private _errors(msg: any): JSONObject {
        return smap1_(Key.errors, msg);
    }
}

////////////////////////////////////////////////////////////////////////

class FilepickerHandlerBase implements IFilepickerHandler {
    //// _host is required in Android code.

    constructor(protected cmd$: string) { }

    protected _action(cmd: Int, path: string, callback: JSONCallback) {
        host$.ajax_(this.cmd$, cmd, stringify1_(Key.path, path), callback);
    }

    /// @return {Key.fileinfo: {}}.
    fileInfo_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.FILEINFO, path, callback);
    }

    listDir_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.LISTDIR, path, callback);
    }

    mkDirs_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.MKDIRS, path, callback);
    }

    delete_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.DELETE, path, callback);
    }

    shred_(dir: string, rpaths: string[], callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.SHRED, stringify_(
            [Key.path, dir],
            [Key.rpaths, rpaths],
        ), callback);
    }

    rename_(from: string, to: string, fixxrefs: boolean, callback: JSONCallback): void {
        host$.ajax_(this.cmd$, FilepickerCmd.RENAME, stringify_(
            [Key.path, from],
            [Key.filename, to],
            [Key.xrefs, fixxrefs],
        ), callback);
    }

    copy_(
        cut: boolean,
        preservetimestamp: boolean,
        fixxrefs: boolean,
        dst: string,
        src: string,
        rpaths: string[] | null,
        callback: JSONCallback
    ): void {
        const params = json_(
            [Key.cut, cut],
            [Key.timestamp, preservetimestamp],
            [Key.xrefs, fixxrefs],
            [Key.dst, dst],
            [Key.src, src],
        );
        if (rpaths != null) {
            params[Key.rpaths] = rpaths;
        }
        host$.ajax_(this.cmd$, FilepickerCmd.COPY, JSON.stringify(params), callback);
    }

    copyInfo_(cut: boolean, dst: string, src: string, callback: JSONCallback): void {
        const params = json_(
            [Key.cut, cut],
            [Key.dst, dst],
            [Key.src, src],
        );
        host$.ajax_(this.cmd$, FilepickerCmd.COPY_INFO, JSON.stringify(params), callback);
    }

    deleteDirSubtree_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.DELETE_DIRSUBTREE, path, callback);
    }

    deleteAll_(dir: string, rpaths: string[], callback: JSONCallback): void {
        const params = json_(
            [Key.src, dir],
            [Key.rpaths, rpaths],
        );
        host$.ajax_(this.cmd$, FilepickerCmd.DELETE_ALL, JSON.stringify(params), callback);
    }

    deleteInfo_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.DELETE_INFO, path, callback);
    }

    deleteEmptyDirs_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.DELETE_EMPTY_DIRS, path, callback);
    }

    localImageInfos_(path: string, callback: JSONCallback): void {
        this._action(FilepickerCmd.LOCAL_IMAGE_INFOS, path, callback);
    }

    localImageThumbnails_(size: Int, quality: Int, infos: Array<Map<string, any>>, callback: JSONCallback): void {
        const params = json_(
            [Key.size, size],
            [Key.quality, quality],
            [Key.infos, infos],
        );
        host$.ajax_(this.cmd$, FilepickerCmd.LOCAL_IMAGE_THUMBNAILS, JSON.stringify(params), callback);
    }

    listRecursive_(params: JSONObject, callback: JSONCallback): void {
        host$.ajax_(this.cmd$, FilepickerCmd.LIST_RECURSIVE, JSON.stringify(params), callback);
    }

    fileInfos_(dir: string, rpaths: string[], callback: JSONCallback): void {
        const params = json_(
            [Key.src, dir],
            [Key.rpaths, rpaths],
        );
        host$.ajax_(this.cmd$, FilepickerCmd.FILEINFOS, JSON.stringify(params), callback);
    }

    dirInfo_(cpath: string, callback: JSONCallback): void {
        const params = json_(
            [Key.path, cpath],
        );
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.DIRINFO, JSON.stringify(params), callback);
    }

}

class FilepickerHandler extends FilepickerHandlerBase {
    constructor() {
        super(_JOF.filepicker);
    }
}

class HistoryFilepickerHandler extends FilepickerHandlerBase {
    //// _host is required in Android code.

    constructor() {
        super(_JOF.historyFilepicker);
    }

    listRecursive_(params: JSONObject, callback: JSONCallback): void {
        host$.ajax_(this.cmd$, FilepickerCmd.LIST_RECURSIVE, JSON.stringify(params), callback);
    }

    deleteDirSubtree_(params: string, callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.DELETE_DIRSUBTREE, params, callback);
    }

    delete_(params: string, callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.DELETE, params, callback);
    }

    rename_(params: string, _notused: string, _fixxrefs: boolean, callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.RENAME, params, callback);
    }

    dirInfo_(cpath: string, callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.DIRINFO, stringify1_(Key.path, cpath), callback);
    }

    shred_(dir: string, rpaths: string[], callback: JSONCallback): void {
        host$.ajaxWithSpinner_(this.cmd$, FilepickerCmd.SHRED, stringify_(
            [Key.path, dir],
            [Key.rpaths, rpaths],
        ), callback);
    }
}

class RecentsHandler implements IRecentsHandler {
    constructor() { }

    info_(callback: JSONCallback): void {
        host$.ajax_(_JOF.recents, RecentsCmd.INFO, "", callback);
    }

    sorted_(callback: JSONCallback): void {
        host$.ajax_(_JOF.recents, RecentsCmd.SORTED, "", callback);
    }

    clean_(callback: JSONCallback): void {
        host$.ajax_(_JOF.recents, RecentsCmd.CLEAN, "", callback);
    }

    clear_(callback: JSONCallback): void {
        host$.ajax_(_JOF.recents, RecentsCmd.CLEAR, "", callback);
    }
}

const host$ = new Host();

////////////////////////////////////////////////////////////////////////

class ZipFilepickerHandler extends FilepickerHandlerAdapter {
    constructor(private _root: JSONObject) {
        super();
    }
    private _get(cpath: string): JSONObjectX {
        if (cpath.length == 0) return this._root;
        let info = this._root;
        for (const s of cpath.split(FS)) {
            if (s.length == 0) continue;
            info = info[FileInfoKey._files]?.[s];
            if (info == null) return null;
        }
        return info;
    }
    private _dirpathandtree(dir: string): [Array<JSONObject>, Array<JSONObject>] | null {
        let info = this._root;
        const dirpath = Array<JSONObject>();
        for (const s of dir.split(FS)) {
            if (s.length == 0) continue;
            info = info[FileInfoKey._files]?.[s];
            if (info == null || info[FileInfoKey._isdir] != true) return null;
            dirpath.push(info);
        }
        const files = info[FileInfoKey._files] as JSONObject;
        if (files == null) return null;
        const dirtree = Object.values(files);
        return [dirpath, dirtree];
    }
    fileInfo_(cpath: string, callback: JSONCallback): void {
        const info = this._get(cpath);
        if (info == null) return this._notfound(cpath, callback);
        callback(json1_(Key.fileinfo, info));
    }
    listDir_(cpath: string, callback: JSONCallback): void {
        const ret = this._dirpathandtree(cpath);
        if (ret == null) return this._notfound(cpath, callback);
        callback(json_(
            [Key.filename, ""],
            [Key.path, cpath],
            [Key.dirpath, ret[0]],
            [Key.dirtree, ret[1]],
        ));
    }
    dirInfo_(cpath: string, callback: JSONCallback): void {
        const dir = this._get(cpath);
        if (dir == null) return this._notfound(cpath, callback);
        const dirinfo = FileInfo.of_(dir);
        if (dirinfo?.isdir$ != true) return this._notdirectory(cpath, callback);
        this._dirinfo(dirinfo, callback);
    }
}

///////////////////////////////////////////////////////////////////////

class _DEF {
    static readonly HistorySize: number = 8;
    static readonly OutlineTextLen: number = 128;
    static readonly SidebarTop: number = 5;
    static readonly SidebarActive: number = 5;
    static readonly SidepanelPaddingRight: number = 5;
    static readonly AudioplayerWidth: number = 320;
    static readonly AudioplayerHeight: number = 240;
    static readonly SlideshowBGColor = "#ccc";
}

////////////////////////////////////////////////////////////////////////

class _UICache {
    private _iframe: HTMLIFrameElement | null = null;
    private _buttonSize: numberX = null;
    private _rem: numberX = null;
    private _toolbarHeight: numberX = null;
    private _sidebarHeight: numberX = null;
    private _dpi: numberX = null;
    private _tabStyles: Map<string, Map<string, string>> | null = null;
    private _tabBottoms: Map<string, number> | null = null;
    private _hasClientCss: booleanX = null;

    getIFrame_(): HTMLIFrameElement {
        if (this._iframe == null) {
            this._iframe = document.getElementById(ID.contentIFrame) as HTMLIFrameElement;
        }
        return this._iframe;
    }

    dpi_(): number {
        if (this._dpi == null) {
            this._dpi = host$.getDPI_();
        }
        return this._dpi;
    }

    buttonSize_(): number {
        if (this._buttonSize == null) {
            this._buttonSize = settings$.current_().buttonSize$;
            
        }
        return this._buttonSize;
    }

    symbolFontSize_(): number {
        return Math.floor(this.buttonSize_() * DEF.symbolFontSizeRatio);
    }

    toolbarFontSize_(): number {
        return Math.floor(this.buttonSize_() * DEF.toolbarFontSizeRatio);
    }

    rem_(): number {
        if (this._rem == null) {
            const div = new DomBuilderEx(accessories$).div_({ "style": "width:1rem" }).cursor_();
            this._rem = div.offsetWidth;
            div.remove();
        }
        return this._rem;
    }

    /// #toolbar.outerHeight, ie. including the border.
    toolbarHeight_(): number {
        if (this._toolbarHeight == null) {
            this._toolbarHeight = settings$.current_().buttonSize$ + 1;
            
        }
        return this._toolbarHeight;
    }

    sidebarHeight_(): number {
        if (this._sidebarHeight == null) {
            /// Apparently, bounding rectangle use the dimension after transform.
            this._sidebarHeight = Math.round(document
                .getElementById(ID.sidebar)!
                .getBoundingClientRect()
                .width);
        }
        return this._sidebarHeight;
    }

    iwinWidth_(): number {
        return window.innerWidth;
    }

    iwinHeight_(): number {
        return window.innerHeight - this.toolbarHeight_();
    }

    iwinMax_(): number {
        const w = this.iwinWidth_();
        const h = this.iwinHeight_();
        return h > w ? h : w;
    }

    iwinPadding_(): number {
        return this.iwinMax_() * 3 / 4;
    }

    getSidebarTabStyle_(tabid: string, property: string): stringX {
        const styles = this._gettabstyles(tabid);
        return styles == null ? null : styles.get(property) ?? null;
    }

    exploreBottom_(): number {
        return this._gettabbottoms().get(ID.sidebarExplore)!;
    }

    templatesBottom_(): number {
        return this._gettabbottoms().get(ID.sidebarTemplates)!;
    }

    documentBottom_(): number {
        return this._gettabbottoms().get(ID.sidebarDocument)!;
    }

    resizeBottom_(): numberX {
        return this._gettabbottoms().get(ID.sidebarResize)! ?? null;
    }

    hasClientCss_(): boolean {
        if (this._hasClientCss == null) {
            this._hasClientCss = this._hascss(PATH._assetsClientCss);
        }
        return this._hasClientCss;
    }

    addClientCss_(): void {
        this._addcss(PATH._assetsClientCss);
        this._hasClientCss = true;
    }

    onIFrameLoad_(): void {
        this._reset();
    }

    onIFrameUnload_(): void {
        this._reset();
    }

    onResize_(): void {
        this._reset();
    }

    private _reset(): void {
        this._iframe = null;
        this._buttonSize = null;
        this._toolbarHeight = null;
        this._sidebarHeight = null;
        this._tabStyles = null;
        this._tabBottoms = null;
        this._hasClientCss = null;
    }

    private _hascss(csspath: string): boolean {
        const idoc = native$.getIFrameDocument_();
        const baseuri = native$.getIFrameUri_();
        if (idoc == null || baseuri == null) { return false; }
        const stylesheets = idoc.styleSheets;
        const len = stylesheets.length;
        for (let i = 0; i < len; ++i) {
            const stylesheet = stylesheets[i];
            const href = stylesheet.href;
            const type = stylesheet.type;
            if (type != null && href != null && "text/css" == type) {
                const cpath = An.cpathOfHref2_(baseuri, href);
                if (cpath == csspath) {
                    return true;
                }
            }
        }
        return false;
    }

    private _addcss(csspath: string): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        const head = idoc.head;
        const head1 = head.firstChild;
        const b = new DomBuilderEx(head);
        b.insertBefore_(head1, "link", { "rel": "stylesheet", "type": "text/css", "href": FS + csspath });
    }

    private _inittabstyles(): void {
        const ret = new Map<string, Map<string, string>>();
        for (const [id, tab] of sidePanel$.sidebarTabs$) {
            const css = An.getComputedStyle_(tab);
            const styles = new Map<string, string>();
            if (css != null) {
                styles.set(PK.BackgroundColor, css.backgroundColor);
            }
            ret.set(id, styles);
        }
        this._tabStyles = ret;
    }

    private _inittabbottoms(): void {
        const ret = new Map<string, number>();
        for (const [id, tab] of sidePanel$.sidebarTabs$) {
            ret.set(id, Math.round(tab.getBoundingClientRect().bottom));
        }
        const resizebar = document.getElementById(ID.sidebarResize);
        if (resizebar != null) {
            ret.set(ID.sidebarResize, Math.round(resizebar.getBoundingClientRect().bottom));
        }
        this._tabBottoms = ret;
    }

    private _gettabstyles(tabid: string): Map<string, string> | null {
        if (this._tabStyles == null) {
            this._inittabstyles();
        }
        return this._tabStyles?.get(tabid) ?? null;
    }

    private _gettabbottoms(): Map<string, number> {
        if (this._tabBottoms == null) {
            this._inittabbottoms();
        }
        return this._tabBottoms!;
    }
}

class _DocInfo {
    private _fileinfo: FileInfo;
    private _href: stringX = null;
    private _uri: UriX = null;
    private _isHtml: boolean = false;
    private _hasNext: boolean = false;
    private _hasPrev: boolean = false;
    private _next: stringX = null;
    private _prev: stringX = null;
    private _version: numberX = null;
    private _recalc: boolean = false;

    constructor(fileinfo: JSONObject, uri: Uri) {
        this._fileinfo = FileInfo.of_(fileinfo) ?? FileInfo.NOT_EXISTS;
        if (uri == null) {
            this._href = native$.getIFrameHref_();
            if (this._href != null) {
                this._uri = An.parseUriSafe_(this._href, null);
            }
        } else {
            this._uri = uri;
            this._href = uri.href$;
        }
        this._isHtml = (Basepath.lcSuffixOfFilename_(this._fileinfo.name$) == Suffix.HTML$);
    }

    get href$(): stringX {
        return this._href;
    }

    get uri$(): UriX {
        return this._uri;
    }

    get isHtml$(): boolean {
        return this._isHtml;
    }

    get hasInfo$(): boolean {
        return this._fileinfo != null;
    }

    get fileInfo$(): FileInfo {
        return this._fileinfo;
    }

    next_(): stringX {
        if (this._isHtml && this._hasNext == null) {
            const head = native$.getIFrameHead_();
            if (head != null) {
                const elm = native$.iQuery("link[rel='next']", head);
                this._hasNext = (elm != null);
                this._next = (elm != null) ? elm.getAttribute("href") : null;
            } else {
                this._hasNext = false;
                this._next = null;
            }
        }
        return this._next;
    }

    prev_(): stringX {
        if (this._isHtml && this._hasPrev == null) {
            const head = native$.getIFrameHead_();
            if (head != null) {
                const elm = native$.iQuery("link[rel='prev']", head);
                this._hasPrev = (elm != null);
                this._prev = elm != null ? elm.getAttribute("href") : null;
            } else {
                this._hasPrev = false;
                this._prev = null;
            }
        }
        return this._prev;
    }

    resetPrev_(): void {
        this._hasPrev = false;
        this._prev = null;
    }

    resetNext_(): void {
        this._hasNext = false;
        this._next = null;
    }

    get version$(): number {
        if (this._version == null) {
            this._version = native$.iGetMetaVersion_();
        }
        return this._version;
    }

    ///@return @nullable
    getRecalc_(): boolean {
        return this._recalc;
    }

    setRecalc_(b: boolean): void {
        this._recalc = b;
    }

    toString(): string {
        return this._fileinfo == null ? "null" : this._fileinfo.toString();
    }
}

class _Cache {
    static readonly TIMEOUT = 30 * 60 * 1000;
    static readonly HOMECOUNT = 25;
    static _audioContext: AudioContext | null = null;
    private _ui: _UICache = new _UICache();
    private _lastHomeAction = DateTime.now_().millisecondsSinceEpoch$;
    private _homeCount = 0;

    get audioContext$(): AudioContext {
        if (_Cache._audioContext == null) {
            _Cache._audioContext = new AudioContext();
        }
        return _Cache._audioContext;
    }

    onIFrameUnload_(): void {
        this.ui$.onIFrameUnload_();
    }

    onIFrameLoad_(_uri: UriX): void {
        this.ui$.onIFrameLoad_();
    }

    onResize_(): void {
        this.ui$.onResize_();
    }

    get ui$(): _UICache {
        return this._ui;
    }

    onHomeAction_(): boolean {
        const now = DateTime.now_().millisecondsSinceEpoch$;
        const elapsed = now - this._lastHomeAction;
        ++this._homeCount;
        const reload = (elapsed > _Cache.TIMEOUT || this._homeCount > _Cache.HOMECOUNT);
        if (reload) {
            this._lastHomeAction = now;
            this._homeCount = 0;
            return true;
        }
        return false;
    }
}

////////////////////////////////////////////////////////////////////////

class _WindowResizer {
    private _subscription: StreamSubscription | null;
    private _isResizing: boolean = false;
    private _resizeTimer: Timer | null = null;
    private _width: numberX = null;
    private _height: numberX = null;

    constructor(window: Window) {
        this._subscription = An.subscriptEvent_(window, "resize", () => this.onresize_());
    }

    destroy_(): void {
        this._resizeTimer?.cancel_();
        this._resizeTimer = null;
        this._subscription?.cancel_();
        this._subscription = null;
    }

    onresize_(): void {
        this._resizeTimer?.cancel_();
        this._resizeTimer = new Timer(250, () => this.resizenow_());
    }

    private resizenow_(): void {
        if (this._isResizing) {
            this._resizeTimer?.cancel_();
            this._resizeTimer = new Timer(250, () => this.resizenow_());
            return;
        }
        const width = window.innerWidth;
        const height = window.innerHeight;
        const changed = (width != this._width || height != this._height);
        if (!changed) {
            return;
        }
        this._isResizing = true;
        this._width = width;
        this._height = height;
        
        if (history$ != null) {
            history$.startGroup_(RS.HistoryIgnore, "");
        }
        searchSpotlight$.hide_();
        _Util.hideContextmenus_();
        cache$.onResize_();
        _WindowResizer._resizeIFrame();
        sidePanel$.onWindowSizeChanged_( /*, _cache.ui.deviceSize() */);
        mainPanel$.onWindowSizeChanged();
        host$.onWindowSizeChanged_(width, height);
        native$.iRevealSelection_(null);
        sidePanel$.sidepanelWidthInit_();
        toasters$.onResize_();
        if (history$ != null) {
            history$.endGroup_();
        }
        this._isResizing = false;
        if (this._resizeTimer != null) {
            this._resizeTimer.cancel_();
        }
        this._resizeTimer = new Timer(500, () => this.resizenow_());
    }

    static _resizeIFrame(): void {
        _Hacks.fixBody();
        //// IFrame dimension now use vw and vh and determined in CSS.
    }
}

////////////////////////////////////////////////////////////////////////

abstract class LifecycleManager {
    static fireOnBoot(): void {
        host$.onBoot_();
    }

    static fireOnDocumentLoaded(): void {
        host$.onDocumentLoaded_();
    }

    static fireOnDocumentUnload(): void {
        
        host$.onDocumentUnload_();
    }

    static fireOnDocumentError(_e: ErrorEvent): void {
        
    }

    static fireOnIFrameLoad(uri: UriX): void {
        
        cache$.onIFrameLoad_(uri);
        mainPanel$.onIFrameLoad(uri);
        host$.onIFrameLoad_(uri);
        const splash = document.getElementById(ID.splash);
        if (splash != null) {
            splash.remove();
        }
    }

    static fireOnIFrameUnload(uri: UriX): void {
        
        host$.onIFrameUnload_(uri);
        mainPanel$.onIFrameUnload(uri);
        native$.onIFrameUnload_();
    }

    static fireOnIFrameError(_msg: string): void {
        const notexists = (docInfo$ != null && docInfo$.fileInfo$.notexists$);
        const href = (docInfo$ != null ? docInfo$.href$ : "");
        
        native$.onIFrameUnload_();
        toasters$.error_([
            (notexists
                ? MSG.string_(RS.DocumentNotFound)
                : MSG.string_(RS.ErrorLoadingDocument)),
            href
        ]);
    }
}

////////////////////////////////////////////////////////////////////////

class _GestureHandler implements IGestureHandler {
    static NOOP(_event: string, _data: any) { }
    _listeners = new Map<string, Array<IGestureListener | null>>();

    constructor() { }

    pause_(): void {
        
        this.push_(GestureEvent.leftInward, An.predicate1_);
        this.push_(GestureEvent.leftOutward, An.predicate1_);
        this.push_(GestureEvent.rightInward, An.predicate1_);
        this.push_(GestureEvent.rightOutward, An.predicate1_);
        this.push_(GestureEvent.pinchZoom, An.predicate1_);
    }

    resume_(): void {
        
        this.pop_(GestureEvent.leftInward);
        this.pop_(GestureEvent.leftOutward);
        this.pop_(GestureEvent.rightInward);
        this.pop_(GestureEvent.rightOutward);
        this.pop_(GestureEvent.pinchZoom);
    }

    push_(event: string, listener: IGestureListener | null): void {
        let a = this._listeners.get(event);
        if (a === undefined) {
            a = [];
            this._listeners.set(event, a);
        }
        a.push(listener);
        host$.gestureEnable_(event, listener != null);
        
    }

    pop_(event: string): void {
        const a = this._listeners.get(event);
        if (a === undefined || a.length == 0) {
            
            return;
        }
        a.pop();
        host$.gestureEnable_(event, a.length != 0 && ArrayUt.last_(a) != null);
        
    }

    handle_(e: JSONObject): void {
        const event = e[GestureKey.event];
        if (event == null) {
            return;
        }
        const a = this._listeners.get(event);
        if (a == null || a.length == 0) {
            return;
        }
        const clone = Array.from(a).reverse();
        for (const listener of clone) {
            if (listener?.(event, e) == true) {
                break;
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _BootInfo {
    static readonly RELOAD_COUNT: number = 10;
    reloadCounter = _BootInfo.RELOAD_COUNT;
    bootTimer = new StepTimer("# boot: ");
    docInfo: JSONObjectX = null;
}

class CSSTokenType {
    static readonly Ident = 0;
    static readonly AtKeyword = 1;
    static readonly String = 2;
    static readonly BadString = 3;
    static readonly UnquotedString = 4;
    static readonly Hash = 5;
    static readonly Num = 6;
    static readonly Percentage = 7;
    static readonly Dimension = 8;
    static readonly UnicodeRange = 9;
    static readonly CDO = 10;
    static readonly CDC = 11;
    static readonly Colon = 12;
    static readonly SemiColon = 13;
    static readonly CurlyL = 14;
    static readonly CurlyR = 15;
    static readonly ParenthesisL = 16;
    static readonly ParenthesisR = 17;
    static readonly BracketL = 18;
    static readonly BracketR = 19;
    static readonly Whitespace = 20;
    static readonly Includes = 21;
    static readonly Dashmatch = 22;
    static readonly SubstringOperator = 23;
    static readonly PrefixOperator = 24;
    static readonly SuffixOperator = 25;
    static readonly Delim = 26;
    static readonly EMS = 27;
    static readonly EXS = 28;
    static readonly Length = 29;
    static readonly Angle = 30;
    static readonly Time = 31;
    static readonly Freq = 32;
    static readonly Exclamation = 33;
    static readonly Resolution = 34;
    static readonly Comma = 35;
    static readonly Charset = 36;
    static readonly EscapedJavaScript = 37;
    static readonly BadEscapedJavaScript = 38;
    static readonly Comment = 39;
    static readonly SingleLineComment = 40;
    static readonly EOF = 41;
    static readonly CustomToken = 42;
    static readonly names$ = [
        "Ident",
        "AtKeyword",
        "String",
        "BadString",
        "UnquotedString",
        "Hash",
        "Num",
        "Percentage",
        "Dimension",
        "UnicodeRange",
        "CDO",
        "CDC",
        "Colon",
        "SemiColon",
        "CurlyL",
        "CurlyR",
        "ParenthesisL",
        "ParenthesisR",
        "BracketL",
        "BracketR",
        "Whitespace",
        "Includes",
        "Dashmatch",
        "SubstringOperator",
        "PrefixOperator",
        "SuffixOperator",
        "Delim",
        "EMS",
        "EXS",
        "Length",
        "Angle",
        "Time",
        "Freq",
        "Exclamation",
        "Resolution",
        "Comma",
        "Charset",
        "EscapedJavaScript",
        "BadEscapedJavaScript",
        "Comment",
        "SingleLineComment",
        "EOF",
        "CustomToken",
    ];
}

abstract class CSSToken {
    abstract get type(): Int;
    abstract get offset(): Int;
    abstract get len(): Int;
    static end_(token: CSSToken): Int {
        return token.offset + token.len;
    }
    static text_(input: string, token: CSSToken): string {
        return input.substr(token.offset, token.len);
    }
}

class CSSType {
    static readonly Undefined = 0;
    static readonly Identifier = 1;
    static readonly Stylesheet = 2;
    static readonly Ruleset = 3;
    static readonly Selector = 4;
    static readonly SimpleSelector = 5;
    static readonly SelectorInterpolation = 6;
    static readonly SelectorCombinator = 7;
    static readonly SelectorCombinatorParent = 8;
    static readonly SelectorCombinatorSibling = 9;
    static readonly SelectorCombinatorAllSiblings = 10;
    static readonly SelectorCombinatorShadowPiercingDescendant = 11;
    static readonly Page = 12;
    static readonly PageBoxMarginBox = 13;
    static readonly ClassSelector = 14;
    static readonly IdentifierSelector = 15;
    static readonly ElementNameSelector = 16;
    static readonly PseudoSelector = 17;
    static readonly AttributeSelector = 18;
    static readonly Declaration = 19;
    static readonly Declarations = 20;
    static readonly Property = 21;
    static readonly Expression = 22;
    static readonly BinaryExpression = 23;
    static readonly Term = 24;
    static readonly Operator = 25;
    static readonly Value = 26;
    static readonly StringLiteral = 27;
    static readonly URILiteral = 28;
    static readonly EscapedValue = 29;
    static readonly Function = 30;
    static readonly NumericValue = 31;
    static readonly HexColorValue = 32;
    static readonly MixinDeclaration = 33;
    static readonly MixinReference = 34;
    static readonly VariableName = 35;
    static readonly VariableDeclaration = 36;
    static readonly Prio = 37;
    static readonly Interpolation = 38;
    static readonly NestedProperties = 39;
    static readonly ExtendsReference = 40;
    static readonly SelectorPlaceholder = 41;
    static readonly Debug = 42;
    static readonly If = 43;
    static readonly Else = 44;
    static readonly For = 45;
    static readonly Each = 46;
    static readonly While = 47;
    static readonly MixinContent = 48;
    static readonly Media = 49;
    static readonly Keyframe = 50;
    static readonly FontFace = 51;
    static readonly Import = 52;
    static readonly Namespace = 53;
    static readonly Invocation = 54;
    static readonly FunctionDeclaration = 55;
    static readonly ReturnStatement = 56;
    static readonly MediaQuery = 57;
    static readonly FunctionParameter = 58;
    static readonly FunctionArgument = 59;
    static readonly KeyframeSelector = 60;
    static readonly ViewPort = 61;
    static readonly Document = 62;
    static readonly AtApplyRule = 63;
    static readonly CustomPropertyDeclaration = 64;
    static readonly CustomPropertySet = 65;
    static readonly ListEntry = 66;
    static readonly Supports = 67;
    static readonly SupportsCondition = 68;
    static readonly NamespacePrefix = 69;
    static readonly GridLine = 70;
    static readonly Plugin = 71;
    static readonly UnknownAtRule = 72;
    static readonly names$ = [
        "Undefined",
        "Identifier",
        "Stylesheet",
        "Ruleset",
        "Selector",
        "SimpleSelector",
        "SelectorInterpolation",
        "SelectorCombinator",
        "SelectorCombinatorParent",
        "SelectorCombinatorSibling",
        "SelectorCombinatorAllSiblings",
        "SelectorCombinatorShadowPiercingDescendant",
        "Page",
        "PageBoxMarginBox",
        "ClassSelector",
        "IdentifierSelector",
        "ElementNameSelector",
        "PseudoSelector",
        "AttributeSelector",
        "Declaration",
        "Declarations",
        "Property",
        "Expression",
        "BinaryExpression",
        "Term",
        "Operator",
        "Value",
        "StringLiteral",
        "URILiteral",
        "EscapedValue",
        "Function",
        "NumericValue",
        "HexColorValue",
        "MixinDeclaration",
        "MixinReference",
        "VariableName",
        "VariableDeclaration",
        "Prio",
        "Interpolation",
        "NestedProperties",
        "ExtendsReference",
        "SelectorPlaceholder",
        "Debug",
        "If",
        "Else",
        "For",
        "Each",
        "While",
        "MixinContent",
        "Media",
        "Keyframe",
        "FontFace",
        "Import",
        "Namespace",
        "Invocation",
        "FunctionDeclaration",
        "ReturnStatement",
        "MediaQuery",
        "FunctionParameter",
        "FunctionArgument",
        "KeyframeSelector",
        "ViewPort",
        "Document",
        "AtApplyRule",
        "CustomPropertyDeclaration",
        "CustomPropertySet",
        "ListEntry",
        "Supports",
        "SupportsCondition",
        "NamespacePrefix",
        "GridLine",
        "Plugin",
        "UnknownAtRule",
    ];
}

abstract class CSSNode {
    abstract get type(): Int;
    abstract get offset(): Int;
    abstract get length(): Int;
    abstract get end(): Int;
    abstract get parent(): CSSNode | null | undefined;
    abstract get children(): CSSNode[] | null | undefined;
    static text_(value: string, node: CSSNode): string {
        return value.substr(node.offset, node.length);
    }
}

abstract class CSSError {
    abstract get node(): CSSNode;
    abstract get rule(): CSSNode;
    abstract get level(): Int;
    abstract get message(): string;
    abstract get offset(): Int;
    abstract get length(): Int;
}

class LineMap {
    private _offsets = [0];
    constructor(private _input: string) {
        let start = 0;
        while (true) {
            const offset = this._input.indexOf("\n", start);
            if (offset < 0) return;
            start = offset + 1;
            this._offsets.push(start);
        }
    }

    lineCol(offset: Int): string {
        let index = this._search(offset);
        if (index < 0) index = -index - 2;
        const line = index + 1;
        const col = (offset - this._offsets[index]) + 1;
        return `${line}:${col}`;
    }

    private _search(x: Int): Int {
        let start = 0;
        let end = this._offsets.length - 1;
        while (start <= end) {
            const mid = (start + end) >>> 1;
            const m = this._offsets[mid];
            if (m < x) start = mid + 1;
            else if (m > x) end = mid - 1;
            else return mid;
        }
        return -(start + 1);
    }
}

class CSSParser {

    static readonly _NODETYPE = "XxXo5";
    static readonly _DECL = "XxX8t";
    static readonly _ISSUES = "XxXjr";
    static readonly _HASISSUE = "XxXJB";
    static readonly _SCAN = "XxXZU";
    static readonly _RULESET = "XxXsZ";
    static readonly _EXPR = "XxX9M";
    static readonly _FORMAT = "XxX4G";
    static readonly _DECLS = "XxXj7";
    static readonly _PARSER = "XxX8x";

    readonly cssparser$ = (window as any).
        XxXPo
        ;

    scanStylesheet_(text: string): CSSToken[] {
        const ret = new Array<CSSToken>();
        const scanner = this.cssparser$[CSSParser._SCAN](text, false) as any;
        while (true) {
            const token = scanner.scan() as CSSToken;
            ret.push(token);
            if (token.type == CSSTokenType.EOF) break;
        }
        return ret;
    }
    parseStylesheet_(text: string): CSSNode {
        return this.cssparser$[CSSParser._PARSER](text) as CSSNode;
    }
    parseRuleset_(text: string): CSSNode {
        return this.cssparser$[CSSParser._RULESET](text) as CSSNode;
    }
    parseDecls_(text: string): CSSNode {
        return this.cssparser$[CSSParser._DECLS](text) as CSSNode;
    }
    parseDecl_(text: string): CSSNode {
        return this.cssparser$[CSSParser._DECL](text) as CSSNode;
    }
    parseExpr_(text: string): CSSNode {
        return this.cssparser$[CSSParser._EXPR](text) as CSSNode;
    }
    hasError_(node: any): boolean {
        return this.cssparser$[CSSParser._HASISSUE](node);
    }
    errors_(node: any): ArrayXX<CSSError> {
        return this.cssparser$[CSSParser._ISSUES](node);
    }
    parseGradient_(value: string): Gradient | null {
        if (value.length == 0) return null;
        const node = this.parseExpr_(value);
        
        if (this.hasError_(node)) return null;
        const f = CSSParser.decodeFunc_(node);
        if (f == null) return null;
        const name = CSSNode.text_(value, f[0]);
        if (!An.isGradient_(name + "(")) return null;
        const args = f[1];
        let position = "";
        if (args.length > 0) {
            const term = CSSParser.firstDescendant_(args[0], CSSType.Term);
            if (term == null) return null;
            const text = CSSNode.text_(value, term);
            if (!text.startsWith("#") && !text.startsWith("rgb(") && !text.startsWith("rgba(")) {
                position = text;
                args.shift();
            }
        }
        const colorstops = CSSParser.decodeColorStops_(value, args);
        if (colorstops == null) return null;
        return new Gradient(name, position, colorstops);
    }
    findColor_(value: string): CSSNode | null {
        if (value.length == 0) return null;
        const node = this.parseExpr_(value);
        
        if (this.hasError_(node)) return null;
        return CSSParser.findTerm_(node, (n) => {
            const text = CSSNode.text_(value, n);
            return text.startsWith("rgb(") || text.startsWith("rgba(") || text.startsWith("#");
        });
    }
    private _sanitizeDeclaration(ret: SStringMap, input1: string, baseuri: BaseUriX, decl: CSSNode, onerror: Fun20<string, Int>): boolean {
        const children = decl.children;
        if (!children || children.length < 2) return false;
        const name = children[0];
        const value = children[1];
        if (name.type != CSSType.Property) return false;
        const prio = children.length > 2 ? " " + CSSNode.text_(input1, children[2]) : "";
        const key = CSSNode.text_(input1, name);
        ret[key] = CSSSanitizer.sanitizeValue_(input1, baseuri, value, onerror) + prio;
        return true;
    }
    sanitizeStyle_(input: string, baseuri: BaseUriX, callback: JSONCallback) {
        if (input.length == 0) {
            callback(smap_());
            return;
        }
        const input1 = "{" + input + "}";
        const node = this.parseDecls_(input1);
        
        const errors = sarray_();
        const parseerrors = this.errors_(node);
        const linemap = new LineMap(input);
        if (parseerrors && parseerrors.length > 0) {
            for (const e of parseerrors) {
                errors.push(`@${linemap.lineCol(e.offset - 1)}: ${e.message}`);
            }
        }
        const ret = smap_<string>();
        if (node != null && node.children) {
            for (const decl of node.children) {
                if (decl.type == CSSType.Declaration) {
                    if (!this._sanitizeDeclaration(ret, input1, baseuri, decl, (e, offset) => {
                        errors.push(`@${linemap.lineCol(offset - 1)}: ${e} `);
                    })) {
                        callback(smap1_(Key.errors, `@${linemap.lineCol(decl.offset - 1)}: ` + MSG.string_(RS.ErrorParsingStyle)));
                        return;
                    }
                }
            }
        }
        if (errors.length > 0) {
            callback(json_(
                [Key.errors, errors],
                [Key.style, ret],
            ));
            return;
        }
        callback(json1_(Key.style, ret));
    }
    sanitizeRuleset_(input: string, baseuri: BaseUriX, callback: JSONCallback) {
        const node = this.parseRuleset_(input);
        
        const errors = sarray_();
        const parseerrors = this.errors_(node);
        const linemap = new LineMap(input);
        if (parseerrors && parseerrors.length > 0) {
            for (const e of parseerrors) {
                errors.push(`@${linemap.lineCol(e.offset)}: ${e.message}`);
            }
        }
        const decls = CSSParser.findChild_(node, CSSType.Declarations);
        const styles = smap_<string>();
        if (decls != null && decls.children) {
            for (const decl of decls.children) {
                if (decl.type == CSSType.Declaration) {
                    if (!this._sanitizeDeclaration(styles, input, baseuri, decl, (e, offset) => {
                        errors.push(`@${linemap.lineCol(offset)}: ${e}`);
                    })) {
                        callback(smap1_(Key.errors, ` @${linemap.lineCol(decl.offset)}` + MSG.string_(RS.ErrorParsingStyle)));
                        return;
                    }
                }
            }
        }
        const formatted = CSSSanitizer.sanitizeRuleset_(input, baseuri, node, (e, offset) => {
            errors.push(`@${linemap.lineCol(offset)}: ${e}`);
        });
        if (errors.length > 0) {
            callback(json_(
                [Key.errors, errors],
                [Key.cssrule, formatted],
                [Key.style, styles],
            ));
            return;
        }
        callback(json_(
            [Key.cssrule, formatted],
            [Key.style, styles],
        ));
    }

    static findTerm_(node: CSSNode, predicate: Fun11<CSSNode, boolean>): CSSNode | null {
        if (node.type == CSSType.Term && predicate(node)) return node;
        if (node.children) {
            for (const c of node.children) {
                const ret = this.findTerm_(c, predicate);
                if (ret != null) return ret;
            }
        }
        return null;
    }
    static count_(nodes: CSSNode[], type: Int): Int {
        let ret = 0;
        for (const node of nodes) {
            if (node.type == type) ++ret;
        }
        return ret;
    }
    static childAt_(node: CSSNode | null, n: Int = 0): CSSNode | null {
        return node != null && node.children && node.children.length > n ? node.children[n] : null;
    }
    static textAt_(value: string, node: CSSNode | null, n: Int = 0, def: string = ""): string {
        const c = this.childAt_(node, n);
        return c == null ? def : CSSNode.text_(value, c);
    }
    static find_(node: CSSNode | null, type: Int): CSSNode | null {
        if (node == null) return null;
        if (node.type == type) return node;
        return this.findChild_(node, type);
    }
    static findChild_(node: CSSNode | null, type: Int): CSSNode | null {
        if (node == null || !node.children) return null;
        for (const c of node.children) {
            if (c.type == type) return c;
        }
        return null;
    }
    static firstDescendant_(node: CSSNode | null, type: Int): CSSNode | null {
        if (node == null) return null;
        if (node.type == type) return node;
        return this.firstDescendant_(this.childAt_(node), type);
    }
    static decodeFunc_(node: CSSNode): [name: CSSNode, args: CSSNode[]] | null {
        const f = this.firstDescendant_(node, CSSType.Function);
        const name = this.childAt_(f, 0);
        if (name == null) return null;
        const args = new Array<CSSNode>();
        const c = this.childAt_(f, 1);
        if (c != null && c.children) {
            for (const cc of c.children) {
                if (cc.type != CSSType.FunctionArgument) return null;
                args.push(cc);
            }
        }
        return [name, args];
    }
    static decodeColorStops_(value: string, nodes: CSSNode[]): ColorStops | null {
        const ret = new Array<ColorStop>();
        for (const node of nodes) {
            const c = this.childAt_(node);
            if (c == null || c.type != CSSType.Expression || !c.children || c.children.length < 1) return null;
            const color = CSSNode.text_(value, c.children[0]);
            const position = this.textAt_(value, c, 1, "");
            ret.push(new ColorStop(color, position));
        }
        return ret;
    }
    static hasSingleRuleset_(node: CSSNode): boolean {
        const ruleset = this.firstDescendant_(node, CSSType.Ruleset);
        if (ruleset == null || !ruleset.parent || !ruleset.parent.children) return false;
        return this.count_(ruleset.parent.children, CSSType.Ruleset) == 1;
    }
}

class CSSSanitizer {
    private static regexUri = RegExp("^url\\(\\s*(.*?)\\s*\\)$");
    private buf$ = sarray_();
    private indent$ = "";
    private tab$ = "  ";

    constructor(
        private readonly input$: string,
        private readonly baseuri$: BaseUriX,
        private readonly onError$: Fun20<string, Int>,
    ) { }

    private _onUri(value: string, offset: Int): string {
        const m = CSSUtil.firstCSSUrl_(value);
        if (m == null) return value;
        const uri = An.parseUriSafe_(m[1], this.baseuri$);
        if (uri == null) {
            this.onError$(MSG.string1_(RS.InvalidURL_, m[1]), offset);
            return value;
        }
        Sanitizers.sanitizeFilepath_(uri.pathSegments$, (e) => this.onError$(e, offset));
        const quot = m[2] ?? "";
        return `url(${quot}${UriUt.stripSchemeHost(m[1])}${quot})`;
    };

    private node_(node: CSSNode): this {
        this.buf$.push(CSSNode.text_(this.input$, node));
        return this;
    }
    private text_(s: string): this {
        this.buf$.push(s);
        return this;
    }
    private substring_(start: Int, end: Int): this {
        const s = this.input$.substring(start, end).trim();
        if (s.length > 0) this.buf$.push(s);
        return this;
    }
    private lb_(s: string = ""): this {
        this.buf$.push(`\n${this.indent$}${s}`);
        return this;
    }
    private indent_(): this {
        this.indent$ += this.tab$;
        return this;
    }
    private undent_(): this {
        this.indent$ = this.indent$.substring(0, this.indent$.length - this.tab$.length);
        return this;
    }
    private chd_(node: CSSNode, joining: Fun10X<CSSNode> = null): this {
        if (node.children) {
            const last = node.children.length - 1;
            node.children.forEach((c, index) => {
                this._fmt(c);
                if (index != last) joining?.(c);
            });
        }
        return this;
    }
    private func_(node: CSSNode): Int {
        if (node.children && node.children.length > 0) {
            this.node_(node.children[0]);
            this.text_("(");
            if (node.children.length > 1) {
                const args = node.children[1];
                this.args_(args, args.offset);
            }
            this.text_(")");
        }
        return node.end;
    }
    private args_(args: CSSNode, start: Int) {
        if (args.children) {
            const end = args.children.length - 1;
            args.children.forEach((c, index) => {
                start = this.expr1_(c, c.offset);
                if (start < c.end) {
                    this.substring_(start, c.end);
                }
                if (index != end) {
                    this.text_(", ");
                }
            });
        }
    }
    private expr_(node: CSSNode, start: Int): Int {
        if (node.children) {
            const end = node.children.length - 1;
            for (let index = 0; index <= end; ++index) {
                const c = node.children[index];
                start = this.expr1_(c, start);
                if (index < end) {
                    if (start < c.end) {
                        this.substring_(start, c.end);
                    }
                    start = node.children[index + 1].offset;
                    this.substring_(c.end, start);
                    this.text_(" ");
                }
            }
        }
        return start;
    }
    private expr1_(node: CSSNode, start: Int): Int {
        if (node.type == CSSType.Function) {
            this.substring_(start, node.offset);
            return this.func_(node);
        } else if (node.type == CSSType.URILiteral) {
            this.substring_(start, node.offset);
            let value = CSSNode.text_(this.input$, node);
            const m = CSSSanitizer.regexUri.exec(value);
            if (m != null) value = "url(" + m[1] + ")";
            value = this._onUri(value, node.offset);
            this.text_(value);
            return node.end;
        } else if (node.type == CSSType.Expression) {
            return this.expr_(node, start);
        } else if (node.children) {
            for (const c of node.children) {
                start = this.expr1_(c, start);
            }
        }
        return start;
    }
    private _fmt(node: CSSNode) {
        switch (node.type) {
            case CSSType.AtApplyRule:
                this.text_("@apply ");
                break;
            case CSSType.Declaration:
                this.chd_(node).text_(";");
                break;
            case CSSType.Declarations:
                this.text_("{").indent_().lb_().chd_(node, () => this.lb_()).undent_().lb_("}").lb_();
                break;
            case CSSType.Identifier:
                this.node_(node);
                break;
            case CSSType.Prio:
                this.text_(" !important");
                break;
            case CSSType.Property:
                this.node_(node).text_(": ");
                break;
            case CSSType.Selector:
                this.chd_(node, () => this.text_(",").lb_()).text_(" ");
                break;
            case CSSType.SimpleSelector:
                this.node_(node);
                break;
            case CSSType.SelectorCombinatorParent:
                this.text_(" > ");
                break;
            case CSSType.SelectorCombinatorSibling:
                this.text_(" + ");
                break;
            case CSSType.SelectorCombinatorAllSiblings:
                this.text_(" ~ ");
                break;
            case CSSType.SelectorCombinatorShadowPiercingDescendant:
                this.text_(" >>> ");
                break;
            case CSSType.SimpleSelector:
                this.node_(node);
                break;
            case CSSType.Undefined:
            case CSSType.Stylesheet:
            case CSSType.Ruleset:
                this.chd_(node);
                break;
            case CSSType.Expression: {
                const start = this.expr_(node, node.offset);
                if (start < node.end) {
                    this.substring_(start, node.end);
                }
                break;
            }
            case CSSType.Page:
            case CSSType.PageBoxMarginBox:
            case CSSType.ClassSelector:
            case CSSType.IdentifierSelector:
            case CSSType.ElementNameSelector:
            case CSSType.SelectorCombinator:
            case CSSType.SelectorInterpolation:
            case CSSType.PseudoSelector:
            case CSSType.AttributeSelector:
            case CSSType.BinaryExpression:
            case CSSType.Term:
            case CSSType.Operator:
            case CSSType.Value:
            case CSSType.StringLiteral:
            case CSSType.URILiteral:
            case CSSType.EscapedValue:
            case CSSType.Function:
            case CSSType.NumericValue:
            case CSSType.HexColorValue:
            case CSSType.MixinDeclaration:
            case CSSType.MixinReference:
            case CSSType.VariableName:
            case CSSType.VariableDeclaration:
            case CSSType.Interpolation:
            case CSSType.NestedProperties:
            case CSSType.ExtendsReference:
            case CSSType.SelectorPlaceholder:
            case CSSType.Debug:
            case CSSType.If:
            case CSSType.Else:
            case CSSType.For:
            case CSSType.Each:
            case CSSType.While:
            case CSSType.MixinContent:
            case CSSType.Media:
            case CSSType.Keyframe:
            case CSSType.FontFace:
            case CSSType.Import:
            case CSSType.Namespace:
            case CSSType.Invocation:
            case CSSType.FunctionDeclaration:
            case CSSType.ReturnStatement:
            case CSSType.MediaQuery:
            case CSSType.FunctionParameter:
            case CSSType.FunctionArgument:
            case CSSType.KeyframeSelector:
            case CSSType.ViewPort:
            case CSSType.Document:
            case CSSType.CustomPropertyDeclaration:
            case CSSType.CustomPropertySet:
            case CSSType.ListEntry:
            case CSSType.Supports:
            case CSSType.SupportsCondition:
            case CSSType.NamespacePrefix:
            case CSSType.GridLine:
            case CSSType.Plugin:
            case CSSType.UnknownAtRule:
            default:
                this.onError$(MSG.string_(RS.InvalidCSSStyle_) + CSSNode.text_(this.input$, node), node.offset);
                break;
        }
    }
    private _sanitize(node: CSSNode): string {
        this._fmt(node);
        return this.buf$.join("");
    }
    static sanitizeValue_(input: string, baseuri: BaseUriX, node: CSSNode, onerror: Fun20<string, Int>): string {
        return new CSSSanitizer(input, baseuri, onerror)._sanitize(node);
    }
    static sanitizeRuleset_(input: string, baseuri: BaseUriX, node: CSSNode, onerror: Fun20<string, Int>): string {
        return new CSSSanitizer(input, baseuri, onerror)._sanitize(node);
    }
}

class FormatOptions {
    static DEFAULT$ = new FormatOptions();
    constructor(
        readonly tab$: string = "  ",
    ) { }
    static getPreference(callback: Fun10<FormatOptions>) {
        host$.getSessionPreferences_((ret) => {
            let options = FormatOptions.DEFAULT$;
            const prefs = ret[Key.result];
            if (prefs) {
                const tab = prefs[SessionPreferencesKey.indentTab] as string;
                if (tab != null) options = new FormatOptions(tab);
            }
            callback(options);
        });
    }
}

abstract class FormatBuf {
    constructor(
        private readonly input$: string,
        private readonly tokens$: CSSToken[],
        private readonly options$: FormatOptions = FormatOptions.DEFAULT$,
    ) { }
    private buf$ = sarray_();
    private indent$ = "";
    private tab$ = this.options$.tab$;
    private lb = TextUt.lineSep$;
    protected length$ = this.input$.length;
    emit_(t: CSSToken): this {
        if (t.type == CSSTokenType.Whitespace) this._ws(t);
        else if (t.type == CSSTokenType.Comment) this.space_()._emit(t);
        else this._emit(t);
        return this;
    }
    emit0_(t: CSSToken): this {
        if (t.type == CSSTokenType.Whitespace) return this;
        if (t.type == CSSTokenType.Comment) this.space_()._emit(t);
        else this._emit(t);
        return this;
    }
    emitx_(t: CSSToken | null | undefined): this {
        if (t !== null && t !== undefined) this.emit_(t);
        return this;
    }
    emita_(tokens: CSSToken[]): this {
        for (const t of tokens) this.emit_(t);
        return this;
    }
    emit1_(): this {
        return this.emitx_(this.tokens$.shift());
    }
    emitss_(): this {
        return this.emita_(this._getssOf(this.tokens$));
    }
    emitssBeforeLinebreak_(): this {
        return this.emita_(this.get_((t) => (
            t.type == CSSTokenType.Whitespace && !CSSToken.text_(this.input$, t).includes(this.lb)
            || t.type == CSSTokenType.Comment
        )));
    }
    emitWhile_(predicate: Fun11<CSSToken, boolean>): this {
        return this.emita_(this._get(this.tokens$, predicate));
    }
    emitUntilOffset_(offset: Int): this {
        return this.emitWhile_((t) => t.offset < offset);
    }
    emitUntilType_(type: Int): this {
        return this.emita_(this._get(this.tokens$, (t) => t.type != type));
    }
    emitSpace0_(end: Int): this {
        const tokens = this._get(this.tokens$, (t) => t.offset < end);
        while (true) {
            this.emitss0Of_(tokens);
            if (tokens.length > 0) this.emit1Of_(tokens);
            if (tokens.length == 0) break;
        }
        return this;
    }
    emitss0Of_(tokens: CSSToken[]): this {
        const a = this._getssOf(tokens);
        if (a.find((t) => t.type != CSSTokenType.Whitespace) === undefined) return this;
        return this.emita_(a);
    }
    emitssOf_(tokens: CSSToken[]): this {
        return this.emita_(this._getssOf(tokens));
    }
    emit1Of_(tokens: CSSToken[]): this {
        return this.emitx_(tokens.shift());
    }
    emitwOf_(tokens: CSSToken[], predicate: Fun11<CSSToken, boolean>) {
        return this.emita_(this._get(tokens, predicate));
    }
    emitUntilTypeOf_(tokens: CSSToken[], type: Int) {
        return this.emita_(this._get(tokens, (t) => t.type != type));
    }
    emitSpace0Space1Of_(tokens: CSSToken[]): this {
        return this.emitssOf_(tokens).space0_().emita_(tokens).space1_();
    }
    node_(node: CSSNode): this {
        return this.emitUntilOffset_(node.end);
    }
    space_(): this {
        if (!this._wasWs()) this._push(" ");
        return this;
    }
    space0_(): this {
        return this._trimRight();
    }
    space1_(): this {
        this._trimRight();
        this._push(" ");
        return this;
    }
    lb_(): this {
        while (true) {
            if (!this._wasEmptyLine()) break;
            this.buf$.pop();
        }
        this._push(`${this.lb}${this.indent$}`);
        return this;
    }
    indent_(): this {
        this.indent$ += this.tab$;
        return this;
    }
    undent_(): this {
        this.indent$ = this.indent$.substring(0, this.indent$.length - this.tab$.length);
        return this;
    }
    join_(sep: string): string {
        return this.buf$.join(sep);
    }
    get_(predicate: Fun11<CSSToken, boolean>): CSSToken[] {
        return this._get(this.tokens$, predicate);
    }
    getTillOffset_(end: Int): CSSToken[] {
        return this._get(this.tokens$, (t) => t.offset < end);
    }
    private _get(tokens: CSSToken[], predicate: Fun11<CSSToken, boolean>): CSSToken[] {
        const index = tokens.findIndex((t) => !predicate(t));
        return tokens.splice(0, index >= 0 ? index : tokens.length);
    }
    private _getssOf(tokens: CSSToken[]): CSSToken[] {
        return this._get(tokens, (t) => t.type == CSSTokenType.Whitespace || t.type == CSSTokenType.Comment);
    }
    private _emit(t: CSSToken): this {
        this._push(CSSToken.text_(this.input$, t));
        return this;
    }
    private _push(s: string) {
        this.buf$.push(s);
    }
    private _ws(t: CSSToken) {
        const text = CSSToken.text_(this.input$, t);
        if (text.includes(this.lb)) this.lb_();
        else this.space_();
    }
    private _trimRight(): this {
        while (true) {
            const last = ArrayUt.last_(this.buf$);
            if (last !== undefined) {
                const s = last.trimRight();
                if (s.length == 0) {
                    this.buf$.pop();
                    continue;
                }
                if (s.length != last.length) this.buf$[this.buf$.length - 1] = s;
                break;
            }
        }
        return this;
    }
    private _wasWs(): boolean {
        const last = ArrayUt.last_(this.buf$);
        return last === undefined || RX.EndsWithWhitespaces.test(last);
    }
    private _wasEmptyLine(): boolean {
        const last = ArrayUt.last_(this.buf$);
        return last !== undefined && RX.IsWhitespaces.test(last);
    }
}

class CSSFormatter extends FormatBuf {
    constructor(input: string, tokens: CSSToken[], options: FormatOptions = FormatOptions.DEFAULT$) {
        super(input, tokens, options);
    }
    static formatStylesheet_(input: string, options: FormatOptions): string {
        const tokens = cssParser$.scanStylesheet_(input);
        const node = cssParser$.parseStylesheet_(input);
        return new CSSFormatter(input, tokens, options)._format(node);
    }
    private _format(node: CSSNode): string {
        this.fmt_(node);
        return this.join_("");
    }
    private fmt_(node: CSSNode) {
        this.emitss_();
        switch (node.type) {
            case CSSType.Stylesheet:
                this.chd_(node).emita_(this.getTillOffset_(this.length$));
                break;
            case CSSType.CustomPropertyDeclaration:
            case CSSType.Declaration:
                this.chd_(node, (tokens) => this.emitSpace0Space1Of_(tokens));
                break;
            case CSSType.Declarations:
                this.emitUntilType_(CSSTokenType.CurlyL).emit1_().emitssBeforeLinebreak_().indent_().lb_().chd_(node,
                    (tokens) => this.emitssOf_(tokens).space0_().emita_(tokens).emitssBeforeLinebreak_().lb_(),
                    (tokens) => {
                        this.emitssOf_(tokens).space0_().emitUntilTypeOf_(tokens, CSSTokenType.CurlyR)
                            .undent_().lb_().emita_(tokens).emitssBeforeLinebreak_().lb_();
                    });
                break;
            case CSSType.Ruleset:
                if (node.children) {
                    if (node.children.length == 2) {
                        this.chd_(node.children[0],
                            (tokens) => this.space0_().emita_(tokens).emitssBeforeLinebreak_().lb_(),
                            (tokens) => this.emitSpace0Space1Of_(tokens));
                        this.fmt_(node.children[1]);
                        break;
                    }
                }
                this.node_(node);
                break;
            case CSSType.Selector:
                this.chd_(node, (tokens) => this.emitssOf_(tokens).space1_().emita_(tokens));
                break;
            case CSSType.SelectorCombinatorParent:
            case CSSType.SelectorCombinatorSibling:
            case CSSType.SelectorCombinatorAllSiblings:
            case CSSType.SelectorCombinatorShadowPiercingDescendant:
                this.space_().node_(node).space_();
                break;
            case CSSType.Expression: {
                const start = this.expr_(node, node.offset);
                if (start < node.end) {
                    this.emitWhile_((t) => t.offset < node.end);
                }
                break;
            }
            case CSSType.Media: {
                const end = (node.children && node.children.length > 0 ? node.children[0].offset : node.end);
                this.emitWhile_((t) => t.offset < end).space_();
                if (node.children) {
                    const children = node.children;
                    const len = children.length;
                    if (len > 1) {
                        this.chd_(children[0],
                            (tokens) => this.emitSpace0Space1Of_(tokens),
                            (tokens) => this.emitSpace0Space1Of_(tokens));
                    }
                    for (let index = 1; index < len; ++index) {
                        this.fmt_(children[index]);
                    }
                    break;
                }
                this.chd_(node);
                break;
            }
            case CSSType.Keyframe:
            case CSSType.Page:
            case CSSType.PageBoxMarginBox:
            case CSSType.FontFace:
            case CSSType.Import:
            case CSSType.Namespace:
            case CSSType.KeyframeSelector:
            case CSSType.UnknownAtRule: {
                const decls = this.while_(node, (c) => c.type != CSSType.Declarations);
                if (decls != null) this.space_().fmt_(decls);
                break;
            }
            case CSSType.SimpleSelector:
            case CSSType.Undefined:
                this.chd_(node);
                break;
            case CSSType.AtApplyRule:
            case CSSType.Identifier:
            case CSSType.Prio:
            case CSSType.Property:
            case CSSType.MediaQuery:
            case CSSType.SimpleSelector:
            case CSSType.ClassSelector:
            case CSSType.IdentifierSelector:
            case CSSType.ElementNameSelector:
            case CSSType.SelectorCombinator:
            case CSSType.SelectorInterpolation:
            case CSSType.PseudoSelector:
            case CSSType.AttributeSelector:
            case CSSType.VariableName:
            case CSSType.MixinDeclaration:
            case CSSType.MixinReference:
            case CSSType.VariableDeclaration:
            case CSSType.Interpolation:
            case CSSType.NestedProperties:
            case CSSType.ExtendsReference:
            case CSSType.SelectorPlaceholder:
            case CSSType.Debug:
            case CSSType.If:
            case CSSType.Else:
            case CSSType.For:
            case CSSType.Each:
            case CSSType.While:
            case CSSType.MixinContent:
            case CSSType.Invocation:
            case CSSType.FunctionDeclaration:
            case CSSType.ReturnStatement:
            case CSSType.ViewPort:
            case CSSType.Document:
            case CSSType.CustomPropertySet:
            case CSSType.ListEntry:
            case CSSType.Supports:
            case CSSType.SupportsCondition:
            case CSSType.NamespacePrefix:
            case CSSType.GridLine:
            case CSSType.Plugin:
                this.node_(node);
                break;
            default:
                
                this.node_(node);
                break;
        }
    }
    private chd_(
        node: CSSNode,
        joining: Fun10X<CSSToken[]> = null,
        ending: Fun10X<CSSToken[]> = null,
    ): this {
        if (node.children) {
            const children = node.children;
            const last = children.length - 1;
            children.forEach((c, index) => {
                this.fmt_(c);
                if (index < last) {
                    const end = children[index + 1].offset;
                    const tokens = this.getTillOffset_(end);
                    if (joining != null) joining(tokens);
                    else this.emita_(tokens);
                }
            });
        }
        const tokens = this.getTillOffset_(node.end);
        if (ending != null) ending(tokens);
        else this.emita_(tokens);
        return this;
    }
    private while_(node: CSSNode, predicate: Fun11<CSSNode, boolean>): CSSNode | null {
        const children = node.children;
        if (!children) return null;
        for (const child of children) {
            if (!predicate(child)) {
                this.emitWhile_((t) => t.offset < child.offset);
                return child;
            }
        }
        this.emitWhile_((t) => t.offset < node.end);
        return null;
    }
    private func_(node: CSSNode): Int {
        if (node.children && node.children.length > 0) {
            this.node_(node.children[0]);
            if (node.children.length > 1) {
                const args = node.children[1];
                this.emitSpace0_(args.offset);
                this.args_(args, args.offset);
            }
            this.emitSpace0_(node.end);
        }
        return node.end;
    }
    private args_(args: CSSNode, start: Int) {
        if (args.children) {
            const children = args.children;
            const end = children.length - 1;
            children.forEach((c, index) => {
                start = this.expr1_(c, c.offset);
                if (start < c.end) {
                    this.emitWhile_((t) => t.offset < c.end);
                }
                if (index != end) {
                    const next = children[index + 1];
                    this.emitSpace0Space1Of_(this.get_((t) => t.offset < next.offset));
                }
            });
        }
    }
    private expr_(node: CSSNode, start: Int): Int {
        if (node.children) {
            const end = node.children.length - 1;
            for (let index = 0; index <= end; ++index) {
                const c = node.children[index];
                start = this.expr1_(c, start);
                if (index < end) {
                    if (start < c.end) {
                        this.emitWhile_((t) => t.offset < c.end);
                    }
                    this.emitss_().space1_();
                }
            }
        }
        return start;
    }
    private expr1_(node: CSSNode, start: Int): Int {
        if (node.type == CSSType.Function) {
            return this.func_(node);
        } else if (node.type == CSSType.URILiteral) {
            this.node_(node);
            return node.end;
        } else if (node.type == CSSType.Expression) {
            return this.expr_(node, start);
        } else if (node.children) {
            for (const c of node.children) {
                start = this.expr1_(c, start);
            }
        }
        return start;
    }
}

////////////////////////////////////////////////////////////////////////

const gestureHandler$ = new _GestureHandler();
const cssParser$ = new CSSParser();
const fileinfoUt$ = new FileInfoUtil(new FilepickerHandler());
const historyFileinfoUt$ = new FileInfoUtil(new HistoryFilepickerHandler());
let iframe$!: HTMLIFrameElement;
let accessories$!: HTMLElement;
let settings$!: Settings;
let cache$!: _Cache;
let spinner$!: Spinner;
let bootInfo$!: _BootInfo | null;
let bootPreferences$ = json_();
let docInfo$: _DocInfo | null = null;

////////////////////////////////////////////////////////////////////////

class _Main {
    static _windowResizer: _WindowResizer | null = null;

    run_(): void {
        accessories$ = document.getElementById(ID.accessories) as HTMLElement;
        spinner$ = new Spinner(accessories$);
        const ret = Assert.notNull_(native$.getSettings_());
        settings$ = new Settings(ret?.[Key.result] ?? json_());
        cache$ = new _Cache();
        this._updatemimesupport(ret?.[Key.supportwebp]);
        bootPreferences$ = ret?.[Key.status] ?? json_();
        bootInfo$ = new _BootInfo();
        bootInfo$.bootTimer.debug_("start");
        bootInfo$.bootTimer.debug_("init");
        bootInfo$.docInfo = (ret?.[Key.fileinfo] as JSONObject);
        native$.onBoot_(settings$);
        window.addEventListener("unload", () => {
            LifecycleManager.fireOnDocumentUnload();
        });
        window.addEventListener("error", (e) => {
            LifecycleManager.fireOnDocumentError(e as ErrorEvent);
        });

        const sinkhole_ = (e: Event) => {
            e.stopImmediatePropagation();
            An.stopevent_(e);
        };

        window.addEventListener("doubleclick", sinkhole_);
        window.addEventListener("contextmenu", sinkhole_);
        window.addEventListener("dragstart", sinkhole_);
        window.addEventListener("drag", sinkhole_);
        window.addEventListener("drop", sinkhole_);
        An.onKeypress_(window, (e: KeyboardEvent) => {
            if (!e.ctrlKey) return;
            switch (e.key) {
                case "f": case "F": {
                    mainPanel$?._mainToolbar?.toggleSearchbar_(e);
                    break;
                }
                case "i": case "I": {
                    if (e.shiftKey) {
                        An.stopevent_(e);
                        host$.showDeveloperTools_();
                    }
                    break;
                }
                case "w": case "W": case "r": case "R": {
                    
                    e.stopImmediatePropagation();
                    An.stopevent_(e);
                    break;
                }
            }
        });
        An.onPointerEnd_(window, e => {
            if (host$ != null) {
                const target = DomUt.asHTMLElement_(e.target);
                if (target != null) {
                    const name = target.nodeName;
                    
                    if (name == "HTML") {
                        host$.hideKeyboard0_();
                        host$.undead_();
                        return;
                    }
                }
                host$.heartbeat_();
            }
        });
        LifecycleManager.fireOnBoot();
        let src = settings$.getUrl_(
            Conf.publicHomePath$
        );
        const uri = An.parseUriSafe_(window.location.href, null);
        Assert.assertion_(uri != null);
        const params = uri!.searchParams$;
        let path = params.get(Param.path);
        if (path != null) {
            const fragment = params.get(Param.fragment);
            if (!path.startsWith(FS)) {
                path = FS + path;
            }
            const segments = path.split(FS);
            const queries = new Map<string, string>();
            if (fragment != null && fragment.length > 0) {
                queries.set(Param.fragment, fragment);
            }
            for (const param of [Param.session, Param.t, Param.poster]) {
                const value = params.get(param);
                if (value != null) {
                    queries.set(param, value);
                }
            }
            const ishtml = ArrayUt.last_(segments)?.toLowerCase().endsWith(".html") ?? false;
            const view = params.get(Param.view);
            if (!ishtml && view != null) {
                queries.set(Param.view, view);
            }
            const u = An.uriFromSafe_(null, segments, queries);
            if (u != null) {
                src = u.encoded$;
            }
            if (bootInfo$ != null) {
                bootInfo$.docInfo = null;
            }
        }
        
        iframe$ = document.getElementById(ID.contentIFrame) as HTMLIFrameElement;
        iframe$.addEventListener("error", e => {
            
            const err = (e as ErrorEvent);
            LifecycleManager.fireOnIFrameError(`${err}: ${err == null ? "null" : err.filename}: ${err == null ? "null" : err.error}`);
        });
        iframe$.addEventListener("doubleclick", sinkhole_);
        iframe$.addEventListener("contextmenu", sinkhole_);
        iframe$.addEventListener("load", () => {
            _Main._onIFrameLoad();
        });
        iframe$.src = src;
    }

    private _updatemimesupport(extra: booleanX) {
        MimeUtil.configExtraDesktopImageFormats_(Conf.isMobile$ || (extra ?? Conf.isMobile$));
        FilepickerWriteImageDelegate.singleton$ = new FilepickerWriteImageDelegate();
        FilepickerReadImageDelegate.singleton$ = new FilepickerReadImageDelegate();
        FilepickerLinkDelegate.singleton$ = new FilepickerLinkDelegate();
        ImportKeyDelegate.singleton$ = new ImportKeyDelegate();
        FilepickerRestoreDataDelegate.singleton$ = new FilepickerRestoreDataDelegate();
    }

    static _hack(y: number, target: EventTarget): boolean {
        if (y <= cache$.ui$.buttonSize_()) {
            const n = DomUt.asHTMLElement_(target);
            if (n != null && n.nodeName == "HTML") return true;
        }
        return false;
    }

    static _onIFrameLoad(): void {
        const timer = (bootInfo$ != null ? bootInfo$.bootTimer : new StepTimer("# iframe.load: "));
        timer.debug_("_onIFrameLoad: start");
        const uri = _Main._validateIFrame(timer);
        if (uri == null) {
            //// Redirected or error, abort loading.
            return;
        }
        native$.onIFrameLoad_(() => {
            native$.iAddEventListener_(null, "error", (e) => {
                
                LifecycleManager.fireOnIFrameError(`${e}`);
            }, true);
            native$.iAddEventListener_(null, "unload", () => {
                
                LifecycleManager.fireOnIFrameUnload(docInfo$ == null ? null : docInfo$.uri$);
                _Main.resetIFrame_();
            }, true);
            if (bootInfo$ != null && bootInfo$.docInfo != null) {
                //// Booting
                _Main._onIFrameBoot(bootInfo$.docInfo, uri);
            } else if (bootInfo$ != null) {
                //// Booting but redirected, get docInfo again.
                timer.debug_("# getDocInfo");
                host$.getDocInfo_(ret => {
                    _Main._onIFrameBoot(ret[Key.fileinfo] as JSONObject, uri);
                });
            } else {
                _Main.resetIFrame_();
                host$.getDocInfo_(ret => {
                    docInfo$ = new _DocInfo(ret[Key.fileinfo] as JSONObject, uri);
                    timer.debug_(`getDocInfo(): ${docInfo$}`);
                    LifecycleManager.fireOnIFrameLoad(docInfo$?.uri$ ?? null);
                    timer.debug_("done");
                });
            }
        });
    }

    static _onIFrameBoot(fileinfo: JSONObject, uri: Uri): void {
        //// Give way to other tasks that may have more visual effects.
        Timer.sleep0_(() => {
            //// Booting
            const timer = bootInfo$!.bootTimer;
            timer.debug_(`# _onIFrameBoot: docInfo: ${JSON.stringify(fileinfo)}`);
            _WindowResizer._resizeIFrame();
            timer.debug_("resize");
            docInfo$ = new _DocInfo(fileinfo, uri);
            if (Conf.useSweep$) {
                gestureHandler$.push_(GestureEvent.leftInward, _SidePanel._handleGesture);
            }
            
            LifecycleManager.fireOnIFrameLoad(docInfo$.uri$);
            LifecycleManager.fireOnDocumentLoaded();
            timer.debug_("done");
            bootInfo$ = null;
        });
    }

    /**
         * Check that iframe is being loaded with valid content.
         * Redirect to an error page on error or a viewer page on non-html media content.
         * @return null on error, otherwise the iframe Uri.
         */
    static _validateIFrame(timer: StepTimer): UriX {
        try {
            return _Main._validateIFrame1(timer);
        } catch (e) {
            
        }
        _Main._error500(null, RS.ErrorLoadingDocument);
        return null;
    }

    private static _validateIFrame1(timer: StepTimer): UriX {
        const href = native$.getIFrameHref_();
        if (href == null) {
            throw "";
        }
        timer.debug_(`href=${href}`);
        if (!href.startsWith(`${Conf.scheme$}:`)) {
            if (bootInfo$ != null && href.startsWith("about:")) {
                return null;
            }
            throw "";
        }
        const uri = An.parseUriSafe_(href, null);
        if (uri == null) {
            _Main._error500(uri, RS.InvalidURL);
            return null;
        }
        const segments = uri.pathSegments$;
        if (_Main._isrootpage(segments)) {
            _Main._error500(uri, RS.InvalidURL);
            return null;
        }
        const queries = uri.searchParams$;
        const view = queries.has(Param.view);
        const lcsuffix = UriUt.lcSuffixOfSegments_(segments);
        const isviewable = MimeUtil.isViewerLcSuffix_(lcsuffix);
        if (view) {
            if (lcsuffix == Suffix.HTML$) {
                const q = Uri.asMap_(queries);
                q.delete(Param.view);
                const u = An.uriFromSafe_(null, segments, q, uri.hash$);
                _Main._redirect(u);
                return null;
            }
            if (!isviewable) {
                _Main._error500(uri, RS.UnsupportedFileType_, lcsuffix);
                return null;
            }
            return uri;
        }
        if (lcsuffix == Suffix.PDF$) {
            return uri;
        }
        if (isviewable) {
            const q = Uri.asMap_(queries);
            q.set(Param.view, "");
            _Main._redirect(An.uriFromSafe_(null, segments, q, uri.hash$));
            return null;
        }
        if (lcsuffix == Suffix.HTML$) {
            const idoc = native$.getIFrameDocument_();
            const nodelist = native$.iQueryAll_(INVALID_TAGS.join(", "), idoc);
            if (nodelist.length > 0) {
                _Main._error500(uri, RS.UnsupportedTag);
                return null;
            }
            return uri;
        }
        _Main._error500(uri, RS.ExpectingHtml);
        return null;
    }

    private static _error500(uri: UriX, msgkey: string, arg: string = ""): void {
        const msg = MSG.string_(msgkey) + arg;
        
        const path = uri?.pathSegments$.join(FS) ?? null;
        if (path == Conf.errorPath$) { return; }
        if (bootInfo$ != null) {
            //// Redirecting, invalidate docInfo.
            bootInfo$.docInfo = null;
        }
        _Main._error(settings$.getUrl_(
            Conf.errorPath$
            + native$.asPathQuery_(uri)
            + "&msg=" + encodeURIComponent(msg)));
    }

    /**
         * Redirect to an error page.
         * Note that MainPanel.onIFrameLoad() is not yet called, so MainPanel should still
         * in reset state.
         */
    private static _error(uri: string): void {
        if (mainPanel$ != null) {
            //// Reset MainPanel state on error.  In particular it need to clear the oneshot callbacks,
            //// which are no longer valid for the new page.
            mainPanel$.onIFrameError();
        }
        native$.onIFrameUnload_();
        iframe$.src = uri;
    }

    /**
         * Redirect to a viewer page.
         * Note that MainPanel.onIFrameLoad() is not yet called, so MainPanel should still
         * in reset state.
         */
    static _redirect(uri: UriX): void {
        if (uri == null) {
            this._error500(uri, RS.InvalidURL);
            return;
        }
        
        native$.onIFrameUnload_();
        iframe$.src = uri.href$;
    }

    static resetIFrame_(): void {
        cache$.onIFrameUnload_();
        docInfo$ = null;
    }

    static _isrootpage(segments: string[]): boolean {
        const a = sarray_();
        for (const s of segments) {
            if (s.length > 0) {
                a.push(s);
            }
        }
        switch (a.length) {
            case 0:
                return true;
            default:
                return _Main._isrootpath(a[0]);
        }
    }

    static _isrootpath(path: string): boolean {
        return path.length == 0 || path.toLowerCase() == "index.html";
    }

    static _onResizeWindow(): stringX {
        if (_Main._windowResizer != null) {
            
            _Main._windowResizer.onresize_();
        }
        return null;
    }

    static _onGestureEvent(json: stringX): stringX {
        const result = An.parseJSONObjectOrNull_(json);
        if (result != null) {
            gestureHandler$.handle_(result);
        }
        return null;
    }
}

new _Main().run_();

////////////////////////////////////////////////////////////////////////

interface PromptInsertImgResult {
    src: Uri;
    caption: string;
    attrs: StringMap<string>;
    link: UriX;
}
type PromptInsertImgCallback = (result: PromptInsertImgResult | null) => void;

////////////////////////////////////////////////////////////////////////

class _SymbolPreferences implements IPromptSymbolHandler {
    static _singleton: _SymbolPreferences | null = null;
    _category: string = DEF.FontAwesome;

    _recents: JSONObject[] = [];

    static get_(callback: (session: _SymbolPreferences) => void): void {
        if (_SymbolPreferences._singleton != null) {
            callback(_SymbolPreferences._singleton);
            return;
        }
        host$.getSessionPreferences_(result => {
            const session = new _SymbolPreferences(result);
            _SymbolPreferences._singleton = session;
            callback(session);
        });
    }

    constructor(result: JSONObject) {
        const prefs = result[Key.result];
        if (prefs != null) {
            const category = prefs[SessionPreferencesKey.symbolFamily];
            if (category != null) {
                this._category = category;
            }
            const recents = prefs[SessionPreferencesKey.symbolRecents];
            if (recents != null) {
                this._recents = recents;
            }
        }
    }

    get category$(): string {
        return this._category;
    }

    get recents$(): JSONObject[] {
        return this._recents;
    }

    settings(): Settings {
        return settings$;
    }

    getGestureHandler(): IGestureHandler {
        return gestureHandler$;
    }

    updateSymbolCategory(category: stringX, callback: Fun00): void {
        if (category == null || category == this._category) {
            callback();
            return;
        }
        this._category = category;
        host$.updateSessionPreferences_(
            smap1_(SessionPreferencesKey.symbolFamily, category),
            (ret) => {
                toasters$.warn_(ret);
                callback();
            });
    }

    updateRecentsSymbol(family: string, name: string, text: string): void {
        const match = (index: number) => {
            const recent = this._recents[index];
            return SymbolInfo.family_(recent) == family && SymbolInfo.text_(recent) == text;
        };

        let last = this._recents.length - 1;
        if (last >= 0 && match(last)) {
            return;
        }
        this._recents.push(SymbolInfo.create_(family, name, text));
        while (--last >= 0) {
            if (match(last)) {
                this._recents.splice(last, 1);
                break;
            }
        }
        const extra = this._recents.length - DEF.recentSymbolCount;
        if (extra > 0) {
            this._recents.splice(0, extra);
        }
        host$.updateSessionPreferences_(
            smap1_(SessionPreferencesKey.symbolRecents, this._recents),
            (ret) => {
                toasters$.warn_(ret);
            });
    }

    showSpinner(_show: boolean): void {
    }
}

class _JsUtil {

    static toastElement_(elm: HTMLElement, attop: boolean = false, maxwidth: number = DEF.maxToastLen): void {
        if (elm != null) {
            toasters$.info_(this.elementInfo_(elm, maxwidth), { attop: attop });
        }
    }

    static toastNode_(node: Node, attop: boolean = false, maxwidth: number = DEF.maxToastLen): void {
        if (node != null) {
            toasters$.info_(this.nodeInfo_(node, maxwidth), { attop: attop });
        }
    }

    static elementInfo_(elm: HTMLElement, maxwidth: number = DEF.maxToastLen): string {
        const name = elm.nodeName;
        if (An.isBodyElement_(name)) {
            return "<" + name + ">";
        } else {
            if (maxwidth == null) {
                maxwidth = DEF.maxToastLen;
            }
            return An.truncate_("<" + name + native$.getNodeInfo_(elm) + "...>", maxwidth);
        }
    }

    static nodeInfo_(node: Node, maxwidth: number = DEF.maxToastLen): string {
        const type = node.nodeType;
        if (type == Node.ELEMENT_NODE) {
            return this.elementInfo_(node as HTMLElement, maxwidth);
        } else {
            return An.truncate_(node.nodeName, maxwidth);
        }
    }

    /**
       * Wrap the given selection in the given node with the given tag.
       * @param startnode :Node A TEXT_NODE or ELEMENT_NODE.
       * @param start :Integer Start offset.
       * @param endnode :Node A TEXT_NODE or ELEMENT_NODE.
       * @param end :Integer End offset.
       */
    static wrapSelection_(
        tag: string,
        attrs: StringMap<stringX>,
        startnode: NodeX,
        start: number,
        endnode: NodeX,
        end: number
    ): HTMLElementX {
        if (startnode == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        if (endnode == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        let startparent: NodeX = startnode;
        let endparent: NodeX = endnode;
        if (endnode.nodeType == Node.TEXT_NODE) {
            endparent = endnode.parentElement;
            end = _JsUtil._adjustTextOffset(endnode, end);
            endnode = (endnode as Text).splitText(end);
        } else if (endnode.nodeType == Node.ELEMENT_NODE) {
            endnode = endparent.childNodes[end];
        } else {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        if (startnode.nodeType == Node.TEXT_NODE) {
            startparent = startnode.parentNode;
            start = _JsUtil._adjustTextOffset(startnode, start);
            startnode = (startnode as Text).splitText(start);
        } else if (startnode.nodeType == Node.ELEMENT_NODE) {
            startnode = startparent.childNodes[start];
        } else {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        if (startparent != endparent) {
            toasters$.warnKey_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
            return null;
        }
        if (startparent == null || startparent.nodeType != Node.ELEMENT_NODE) {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        if (startnode != null && startnode.nodeType == Node.ELEMENT_NODE && An.isBodyElement_(startnode.nodeName) ||
            endnode != null && endnode.nodeType == Node.ELEMENT_NODE && An.isBodyElement_(endnode.nodeName)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        const b = new DomBuilderEx(startparent as HTMLElement);
        const newnode = b.childBefore_(startnode, tag, attrs).cursor_();
        while (startnode != null && startnode != endnode) {
            const next: NodeX = startnode.nextSibling;
            startparent.removeChild(startnode);
            newnode.appendChild(startnode);
            startnode = next;
        }
        return newnode;
    }

    private static _adjustTextOffset(_node: Node, offset: number): number {
        return offset;
    }

    /// Get background-image value from style attribute.
    /// @callback(url) return null if style attribute do not contains background-image property.
    static getBgImgFromStyleAttribute_(target: HTMLElement, baseuri: BaseUriX, callback: StringXCallback): void {
        const style = target.getAttribute("style");
        if (style === null || style.length == 0) {
            callback(null);
            return;
        }
        cssParser$.sanitizeStyle_(style, baseuri, (ret) => {
            if (toasters$.warn_(ret)) {
                callback(null);
            } else {
                const styles = (ret[Key.style] as SStringMap);
                callback(styles[PK.BackgroundImage] ?? null);
            }
        });
    }

    static setStyleUrlValue_(target: HTMLElement, name: string, value: string, callback: Fun00X = null): void {
        native$.replaceStyle_(target, name, value);
        callback?.();
    }

    static nodeStyles_(node: HTMLElement, keys: string[]): Map<string, string> {
        const ret = new Map<string, string>();
        const nodestyle = node.style;
        for (const key of keys) {
            ret.set(key, nodestyle.getPropertyValue(key));
        }
        return ret;
    }
}

class Role {
    static addRole(elm: HTMLElement, role: string) {
        elm.setAttribute(ATTR.xRole, Array.from(
            new Set((elm.getAttribute(ATTR.xRole) ?? "").split(RX.Spaces)).add(role)
        ).filter((s) => s.length > 0).join(" "));
    }
    static hasRole(elm: HTMLElement, role: string) {
        return new Set((elm.getAttribute(ATTR.xRole) ?? "").split(RX.Spaces)).has(role);
    }
}

class CSSUtil {
    static hasValue_(value: string): boolean {
        const lc = value.toLowerCase();
        return (lc.length > 0 && lc != "none" && lc != "auto" && lc != "inherit");
    }
    static alphanum(c: Int): boolean {
        const cat = Unicode$.unicodeCat_(c);
        return cat >= Unicode$.Cat.Ll && cat <= Unicode$.Cat.Lu || cat == Unicode$.Cat.Nd;
    }

    static nonascii(c: Int): boolean {
        return c >= 0xa0 && c <= 0x10ffff && this.alphanum(c);
    }

    static nmstart(c: Int): boolean {
        return c >= 0x61 && c <= 0x7a || c >= 0x41 && c <= 0x5a || c == 0x5f || /* c == 0x5c || */ this.nonascii(c);
    }

    static nmchar(c: Int): boolean {
        return this.nmstart(c) || c >= 0x30 && c <= 0x39 || c == 0x2d;
    }

    static validateClassesOf(classes: stringX): string[] | null {
        if (classes == null) return null;
        const a = classes.split(RX.Spaces).filter(s => s.length > 0);
        for (let c of a) {
            if (!this.validateClass(c)) return null;
        }
        return a;
    }

    static validateClasses(classes: string[]): boolean {
        for (let c of classes) {
            if (!this.validateClass(c)) return false;
        }
        return true;
    }

    /// NOTE: This do not check for proper escape and excluded non-alphanumeric unicode characters.
    static validateClass(c: string): boolean {
        return Ut.codepoints_(c).every((c, index) => c !== undefined && (index == 0 ? this.nmstart(c) : this.nmchar(c)));
    }

    static ignoreInherit(value: stringXX): string {
        return (value === null || value === undefined || value == "inherit") ? "" : value;
    }

    static ignoreInheritNone(value: stringXX): string {
        return (value === null || value === undefined || value == "inherit"
            || value == "none" || value == "unset" || value == "auto") ? "" : value;
    }

    /**
     * Parse style properties in editing format.
     * @return style in CSS format, null on errors.
     */
    static editingToCSSStyle_(errors: string[], style: string, baseurl: BaseUriX): stringX {
        if (style == null) { return null; }
        let ret = new StringBuffer();
        if (style.length > 0) {
            try {
                let lines = style.split(RX.Linebreaks);
                for (let line of lines) {
                    line = line.trim();
                    if (line.length == 0) {
                        continue;
                    }
                    let index = line.indexOf(" ");
                    let name = line;
                    let value = "";
                    if (index >= 0) {
                        name = line.substring(0, index).trim();
                        value = CSSUtil.unhumanCSSValue_(errors, line.substring(index + 1).trim(), baseurl) ?? "";
                    }
                    ret.write_(name);
                    ret.write_(":");
                    ret.write_(value);
                    ret.write_("; ");
                }
            } catch (e) {
                errors.push(MSG.string1_(RS.InvalidValue_, style));
                return null;
            }
        }
        return (errors.length > 0) ? null : ret.toString();
    }

    static editingToCSSRule_(errors: string[], cssrule: string, baseurl: BaseUriX): stringX {
        let p = CSSUtil.splitCSSRule_(cssrule);
        if (p == null) {
            errors.push(MSG.string1_(RS.InvalidCSSRule_, cssrule));
            return null;
        }
        let styles = CSSUtil.editingToCSSStyle_(errors, p[1], baseurl);
        if (styles == null || errors.length > 0) {
            return null;
        }
        return `${p[0]} { ${styles} }`;
    }

    static joinStyles_(styles: Map<string, string>): string {
        return this.joinStyles1_(Array.from(styles.entries()));
    }

    static joinStyles1_(entries: Array<[key: string, value: string]>) {
        let b = new StringBuffer();
        for (let [key, style] of entries) {
            let value = An._stylevalue(style);
            if (value == null) {
                continue;
            }
            b.write_(key);
            b.write_(": ");
            b.write_(value);
            b.write_("; ");
        }
        return b.toString();
    }

    static joinStylesPreservingEmptyValues_(styles: Map<string, string>): string {
        let b = new StringBuffer();
        for (let [key, style] of [...styles]) {
            let value = An._stylevalue(style);
            if (value == null) {
                value = "";
            }
            b.write_(key);
            b.write_(": ");
            b.write_(value);
            b.write_("; ");
        }
        return b.toString();
    }

    static joinStylesRemovingEmptyValues_(styles: Map<string, string>): string {
        let b = new StringBuffer();
        for (let [key, style] of [...styles]) {
            let value = An._stylevalue(style);
            if (value == null || value.trim().length == 0) {
                continue;
            }
            b.write_(key);
            b.write_(": ");
            b.write_(value);
            b.write_("; ");
        }
        return b.toString();
    }

    static joinStyleList_(styles: Array<[name: string, value: string]>): string {
        let b = new StringBuffer();
        for (let namevalue of styles) {
            let value = An._stylevalue(namevalue[1]);
            if (value == null) {
                continue;
            }
            let key = namevalue[0];
            b.write_(key);
            b.write_(": ");
            b.write_(value);
            b.write_("; ");
        }
        return b.toString();
    }

    static joinlnStyleList_(styles: Array<[key: string, value: string]>, indent: string = "  ") {
        let b = new StringBuffer();
        for (let [key, style] of styles) {
            let value = An._stylevalue(style);
            if (value == null || value.length == 0) {
                continue;
            }
            b.write_(indent);
            b.write_(key);
            b.write_(": ");
            b.write_(value);
            b.write_(";\n");
        }
        return b.toString();
    }

    /// @return true if value is a valid CSS length value.
    static validateOptionalCSSLength_(value: string): boolean {
        if (value.length == 0) {
            return true;
        }
        for (let s of CSSLengths) {
            if (!value.endsWith(s)) {
                continue;
            }
            let num = value.substring(0, value.length - s.length);
            return An.parseDouble_(num, null) != null;
        }
        return false;
    }

    /// @return true if value is a valid CSS length value.
    static cssLengthUnit_(value: string): [value: number, unit: string] | null {
        if (value.length == 0 || value == "auto") { return null; }
        for (let s of CSSLengths) {
            if (!value.endsWith(s)) { continue; }
            let num = value.substring(0, value.length - s.length);
            let v = An.parseDouble_(num, null);
            if (v == null) { return null; }
            return [v, s];
        }
        return null;
    }

    static splitCSSRule_(cssrule: string): Pair<string, string> | null {
        if (cssrule == null) return null;
        let left = cssrule.indexOf("{");
        let right = cssrule.lastIndexOf("}");
        if (left < 0 || right < 0) {
            return null;
        }
        return [
            cssrule.substring(0, left).trim(),
            cssrule.substring(left + 1, right).trim()
        ];
    }

    static splitStyle_<T>(ret: T, style: string, callback: Fun30<T, string, string>): T {
        const styles = style.split(RX.SemicolonSpace);
        for (const s of styles) {
            const m = RX.CSSValue.exec(s);
            if (m != null) {
                callback(ret, m[1], m[2]);
            }
        }
        return ret;
    }

    static escCSSValue_(key: string, value: string): string {
        if (key != "content") {
            return value;
        }
        let end = value.length;
        let isquoted = false;
        if (end > 2) {
            let c = value.codePointAt(0);
            isquoted = (c == 0x22 || c == 0x27) && c == value.codePointAt(end - 1);
        }
        let ret: StringBuffer | null = null;
        let start = 0;
        for (let i = 0; i < end; ++i) {
            let c = value.codePointAt(i);
            if (c === undefined) continue;
            if (c < 0x20 || c >= 0x7f && !An.isHuman_(c) || !isquoted && c == 0x22) {
                if (ret == null) {
                    ret = new StringBuffer();
                    if (!isquoted) {
                        ret.write_("\"");
                    }
                }
                if (start < i) {
                    ret.write_(value.substring(start, i));
                }
                ret.write_("\\" + c.toString(16).padStart(6, "0"));
                start = i + 1;
            }
        }
        if (ret == null) {
            return value;
        }
        if (start < end) {
            ret.write_(value.substring(start, end));
        }
        if (!isquoted) {
            ret.write_("\"");
        }
        return ret.toString();
    }

    static firstCSSUrlHostPort_(cssvalue: string): RegExpExecArray | null {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return null;
        let m = RX._CSSUrlHostPortQQ.exec(cssvalue);
        if (m == null) {
            m = RX._CSSUrlHostPortQ.exec(cssvalue);
            if (m == null) {
                m = RX._CSSUrlHostPort.exec(cssvalue);
            }
        }
        return m;
    }

    static firstCSSUrl_(cssvalue: string): RegExpExecArray | null {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return null;
        let m = RX._CSSUrlQQ.exec(cssvalue);
        if (m == null) {
            m = RX._CSSUrlQ.exec(cssvalue);
            if (m == null) {
                m = RX._CSSUrl.exec(cssvalue);
            }
        }
        return m;
    }

    static normalizeCSSValue_(value: string): string {
        if (An.isempty_(value)) return value;
        return value.replace(RX._QQ_G, "\"").replace(RX._Q_G, "'");
    }

    static hasCSSUrl_(cssvalue: string): boolean {
        return !An.isempty_(cssvalue) && cssvalue.includes("url(");
    }

    static cleanupCSSUrlHostPort_(style: string, baseurl: BaseUriX): string {
        if (!CSSUtil.hasCSSUrl_(style)) return style;
        style = this._cleanupCSSUrlHostPort(style, RX._CSSUrlHostPortQQ, baseurl);
        style = this._cleanupCSSUrlHostPort(style, RX._CSSUrlHostPortQ, baseurl);
        return this._cleanupCSSUrlHostPort(style, RX._CSSUrlHostPort, baseurl);
    }

    private static _cleanupCSSUrlHostPort(style: string, regex: RegExp, baseurl: BaseUriX): string {
        if (!CSSUtil.hasCSSUrl_(style)) return style;
        let m = regex.exec(style);
        if (m != null) {
            let value = m[1];
            let start = m.index;
            let end = start + m[0].length;
            let uu = An.parseUriSafe_(value, baseurl);
            if (uu != null) {
                let prefix = style.substring(0, start);
                let suffix = this._cleanupCSSUrlHostPort(style.substring(end), regex, baseurl);
                return `${prefix}${m[1]}${m[3]}${suffix}`;
            }
        }
        return style;
    }

    static humanCSSUrls_(cssvalue: string, baseurl: BaseUriX): string {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return cssvalue;
        cssvalue = this._humanCSSUrls(cssvalue, RX._CSSUrlQQ, baseurl);
        cssvalue = this._humanCSSUrls(cssvalue, RX._CSSUrlQ, baseurl);
        return this._humanCSSUrls(cssvalue, RX._CSSUrl, baseurl);
    }

    private static _humanCSSUrls(cssvalue: string, regex: RegExp, baseurl: BaseUriX): string {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return cssvalue;
        let m = regex.exec(cssvalue);
        if (m != null) {
            let value = m[1];
            let quote = m.length >= 3 ? m[2] : "";
            let start = m.index;
            let end = start + m[0].length;
            let uu = An.parseUriSafe_(value, baseurl);
            if (uu != null) {
                let prefix = cssvalue.substring(0, start);
                let suffix = this._humanCSSUrls(cssvalue.substring(end), regex, baseurl);
                return `${prefix}url(${quote}${HumanLink.fromUri_(uu).humanHref$}${quote})${suffix}`;
            }
        }
        return cssvalue;
    }

    /// @param url An encoded and valid URL.
    static toCSSUrl_(url: string): string {
        if (An.isempty_(url)) return url;
        return "url(" + replaceAll_(replaceAll_(url, ")", "%29"), "(", "%28") + ")";
    }

    static humanCSSUrl_(url: string): HumanLink {
        if (An.isempty_(url)) return HumanLink.Empty$;
        let m = CSSUtil.firstCSSUrl_(url);
        if (m != null) url = m[1];
        return HumanLink.fromHref_(url);
    }

    static unhumanCSSValue_(errors: string[], value: stringX, baseurl: BaseUriX): stringX {
        return value == null ? null : CSSUtil._unhumanCSSUrls(errors, CSSUtil.normalizeCSSValue_(value), baseurl);
    }

    private static _unhumanCSSUrls(errors: string[], cssvalue: string, baseurl: BaseUriX): string {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return cssvalue;
        let ret = this._unhumanCSSUrls1(errors, cssvalue, RX._CSSUrlQQ, baseurl) ?? cssvalue;
        ret = this._unhumanCSSUrls1(errors, ret, RX._CSSUrlQ, baseurl) ?? cssvalue;
        return this._unhumanCSSUrls1(errors, ret, RX._CSSUrl, baseurl) ?? cssvalue;
    }

    private static _unhumanCSSUrls1(errors: string[], cssvalue: string, regex: RegExp, baseurl: BaseUriX): stringX {
        if (!CSSUtil.hasCSSUrl_(cssvalue)) return cssvalue;
        let m = regex.exec(cssvalue);
        if (m != null) {
            let value = m[1];
            let quote = m.length >= 3 ? m[2] : "";
            let start = m.index;
            let end = start + m[0].length;
            let uu = An.parseUriSafe_(value, baseurl);
            if (uu == null) {
                errors.push(MSG.string1_(RS.InvalidURL_, value));
                return null;
            }
            let errs = sarray_();
            Sanitizers.sanitizeFilepath_(uu.pathSegments$, (e) => errs.push(e));
            if (errs.length > 0) {
                errs.forEach((err) => { errors.push(err); });
                return null;
            }
            let prefix = cssvalue.substring(0, start);
            let suffix = this._unhumanCSSUrls1(errors, cssvalue.substring(end), regex, baseurl);
            if (suffix == null) return null;
            return `${prefix}url(${quote}${uu.encoded$}${quote})${suffix}`;
        }
        return cssvalue;
    }
    static splitBgImg_(value: string): string[] {
        const value1 = value.trim();
        if (value1.length == 0) return ["", "", ""];
        const node = cssParser$.parseExpr_(value1);
        const children = node.children;
        if (!children) return ["", "", ""];
        let values: string[] = [];
        for (let index = 0; index < 3; ++index) {
            if (index >= children.length) {
                values.push("");
                continue;
            }
            const c = children[index];
            values.push(value1.substring(c.offset, (index == 2) ? value1.length : c.offset + c.length));
        }
        return values;
    }
    private static _splitfilter1(ret: SStringMap, value: string) {
        const m = RX.Funcall.exec(value);
        const [k, v] = (m != null ? [m[1], m[2]] : [value, "()"]);
        ret[k] = BackdropFilter.FILTERS$.includes(k) ? v : "";
    }
    static splitFilter_(value: string): SStringMap {
        const value1 = value.trim();
        let values = ssmap_();
        if (value1.length > 0) {
            const node = cssParser$.parseExpr_(value1);
            const children = node.children;
            if (!children) {
                this._splitfilter1(values, value1);
            } else {
                for (const c of children) {
                    const value = value1.substr(c.offset, c.length);
                    this._splitfilter1(values, value);
                }
            }
        }
        return values;
    }
    static updateFilter_(ovalue: string, name: string, value: string, toggle: boolean): string {
        if (name == MSG.string_(RS.None)) return "";
        const map = CSSUtil.splitFilter_(ovalue);
        if (value.length == 0 || toggle && Object.keys(map).includes(name)) delete map[name]; else map[name] = value;
        return Object.entries(map).map(([k, v]) => k + v).join(" ");
    }
    static lastFilter_(filter: string): [string, string] | undefined {
        return ArrayUt.last_(Object.entries(CSSUtil.splitFilter_(filter)));
    }
}

abstract class Callbacks {

    static filepickerDragstartHandler_ = (_dragger: Dragger, target: EventTarget): boolean => {
        const elm = DomUt.asHTMLElement_(target);
        return elm != null &&
            elm.nodeName == "TABLE" &&
            elm.classList.contains(CSS.AnFilepicker);
    };

    static copyToClipboard_ = (value: string) => {
        clipboard$.string_(value);
    };

    static pasteFromClipboard_ = (callback: JSONCallback): void => {
        const content = clipboard$.get_();
        if (content != null) {
            const value = native$.getClipboardText_(content);
            callback(smap1_(Key.result, value));
            return;
        }
        callback(An.jsonError_(RS.ClipboardIsEmptyOrInvalid));
    };

    static copyToSystemClipboard_ = (msgid: string, value: string, callback: Fun00) => {
        host$.copyToClipboard_(value, ret => {
            if (toasters$.warn_(ret)) return;
            if (msgid != null) {
                toasters$.info_([MSG.string_(msgid), An.truncate_(value, DEF.maxLongToastLen)], { attop: false });
            }
            callback();
        });
    };

    static onLinkFolderButton_ = (path: string, basedir: BasedirX, zindex: number, callback: Fun10<string>): void => {
        Callbacks.onFolderButton_(
            RS.Link,
            FilepickerLinkDelegate.singleton$,
            FilepickerKind.ANY_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onReadImageFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        Callbacks.onImageFolderButton_(
            FilepickerReadImageDelegate.singleton$,
            FilepickerKind.EXISTING_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onAnyImageFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        Callbacks.onImageFolderButton_(
            FilepickerReadImageDelegate.singleton$,
            FilepickerKind.ANY_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onWriteImageFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onImageFolderButton_(
            FilepickerWriteImageDelegate.singleton$,
            FilepickerKind.WRITE_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onMoveImageFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onImageFolderButton_(
            FilepickerWriteImageDelegate.singleton$,
            FilepickerKind.MOVE_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onImageFolderButton_ = (
        delegate: FilepickerDelegate,
        filepickerkind: FilepickerKind,
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onFolderButton_(
            RS.Image,
            delegate,
            filepickerkind,
            path,
            basedir,
            zindex,
            callback);
    };

    static onReadFilepathFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onFilepathFolderButton_(FilepickerKind.EXISTING_FILE, path, basedir, zindex, callback);
    };

    static onWriteFilepathFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onFilepathFolderButton_(FilepickerKind.WRITE_FILE, path, basedir, zindex, callback);
    };

    static onFilepathFolderButton_ = (
        filepickerkind: FilepickerKind,
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onFolderButton_(
            RS.Filepath,
            FilepickerLinkDelegate.singleton$,
            filepickerkind,
            path,
            basedir,
            zindex,
            callback);
    };

    static onAudioRecordFolderButton_ = (path: string, basedir: BasedirX, zindex: number, callback: Fun10<string>): void => {
        Callbacks.onFolderButton_(
            RS.Audio,
            FilepickerAudioRecordDelegate.singleton$,
            FilepickerKind.WRITE_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onVideoRecordingFolderButton_ = (path: string, basedir: BasedirX, zindex: number, callback: Fun10<string>): void => {
        Callbacks.onFolderButton_(
            RS.VideoRecordingTitle,
            FilepickerVideoRecordingDelegate.singleton$,
            FilepickerKind.WRITE_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onFolderButton_ = (
        titlekey: StringId,
        delegate: FilepickerDelegate,
        filepickerkind: FilepickerKind,
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        const ocpath = An.cpathOfFilepath2_(basedir, An.dataUrlScheme_(path) == null ? path : "");
        _Util.promptFilepathKey_(titlekey, filepickerkind, "", basedir, ocpath)
            .zindex_(zindex)
            .setDelegate_(delegate)
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                callback(cpath);
            })
            .show_();
    };

    static onBasenameFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        const suffix = Basepath.suffix_(path);
        const lcsuffix = suffix.toLowerCase();
        const ucsuffix = suffix.toUpperCase();
        const suffices = [suffix];
        if (lcsuffix != suffix) {
            suffices.push(lcsuffix);
        }
        if (ucsuffix != suffix) {
            suffices.push(ucsuffix);
        }
        _Util.promptFilepathKey_(RS.Filename, FilepickerKind.ANY, basedir, null, path)
            .zindex_(zindex)
            .setDelegate_(new FilepickerSuffixDelegate(suffices))
            .disableContextmenu_()
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                callback(cpath);
            })
            .show_();
    };

    static onFilenameButton_ = (
        ovalue: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        const ocpath = basedir + FS + ovalue;
        _Util.promptFilepathKey_(RS.Filename, FilepickerKind.ANY, basedir, null, ocpath)
            .zindex_(zindex)
            .setDelegate_(FilepickerLinkDelegate.singleton$)
            .onOK_((okcallback, cpath) => {
                okcallback(true);
                callback(cpath);
            })
            .show_();
    };

    static onHtmlFolderButton_ = (
        filepickerkind: FilepickerKind,
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        Callbacks.onFolderButton_(
            RS.Filepath,
            FilepickerHtmlDelegate.singleton$,
            filepickerkind,
            path,
            basedir,
            zindex,
            callback);
    };

    static onPngImageFolderButton_ = (
        filepickerkind: FilepickerKind,
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        Callbacks.onFolderButton_(
            RS.Image,
            FilepickerPngImageDelegate.singleton$,
            filepickerkind,
            path,
            basedir,
            zindex,
            callback);
    };

    static onAudioPlaybackFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>
    ): void => {
        Callbacks.onFolderButton_(
            RS.Audio,
            FilepickerAudioPlaybackDelegate.singleton$,
            FilepickerKind.EXISTING_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static onVideoPlaybackFolderButton_ = (
        path: string,
        basedir: BasedirX,
        zindex: number,
        callback: Fun10<string>,
    ): void => {
        Callbacks.onFolderButton_(
            RS.Video,
            FilepickerVideoPlaybackDelegate.singleton$,
            FilepickerKind.EXISTING_FILE,
            path,
            basedir,
            zindex,
            callback);
    };

    static getUriOfKind_ = (absolute: boolean, uri: Uri): Uri => {
        return absolute ? uri.toAbsolute_() : uri.toRelative_();
    };

    static getFilepathOfKind_ = (absolute: boolean, filepath: string, basedir: BasedirX): string => {
        if (An.dataUrlScheme_(filepath) != null) return filepath;
        const cpath = An.cpathOfFilepath2_(basedir, filepath) ?? filepath;
        if (absolute) return cpath;
        if (!filepath.startsWith(FS)) return filepath;
        return basedir == null ? filepath : An.rpath2_(basedir, cpath);
    };

    static showImageInfo_ = (cpath: string): void => {
        host$.localImageInfo_(cpath, true, (ret) => {
            if (toasters$.warn_(ret)) return;
            const info = MediaInfo.of_(ret[Key.result])!;
            toasters$.modal_((t, b) => new ImageInfoBuilder(t, b, settings$.dateFormat_(), settings$.timeFormat_(), info).build_());
        });
    };

    static onThumbnailButton_ = (frompath: string, baseuri: BaseUriX, dialog: IDialog, callback: Fun10<string>): void => {
        if (An.isempty_(frompath)) {
            dialog.warn_(MSG.string_(RS.PleaseSpecifyASourceImage));
            return;
        }
        const fromcpath = An.cpathOfFilepath2_(baseuri, frompath);
        if (fromcpath == null) {
            dialog.warn_(MSG.string_(RS.invalidFilepath_) + frompath);
            return;
        }
        host$.localImageInfo_(fromcpath, true, ret => {
            if (dialog.warn_(ret)) return;
            const imageinfo = MediaInfo.of_(ret[Key.result])!;
            const width = imageinfo.width$;
            const height = imageinfo.height$;
            const dim = MediaUtil.fit_(width, height, DEF.thumbnailSize, DEF.thumbnailSize);
            const bn = new Basepath(fromcpath);
            const tnpath = bn.sibling_(`${bn.stem$}-tn.jpg`).path$;
            const zindex = An.above_(dialog.element_());
            const dataurl = imageinfo.tnDataUrl$;
            if (dataurl == null) return;
            _Util.promptOutputImage_(
                tnpath,
                An.cdirOfUri_(baseuri),
                fromcpath,
                dim.x, dim.y,
                zindex,
                DEF.thumbnailSize,
                DEF.jpegQualityThumbnail,
                true,
                dataurl,
                MediaUtil.optionalDimension_,
                (info: ImageOutputInfo) => {
                    host$.writeImage_(fromcpath, info, null, ret => {
                        if (dialog.warn_(ret)) return;
                        const result = ret[Key.result];
                        callback(result ?? info.cpath);
                    });
                }).show_();
        });
    };

    private static onViewImageUrl_(host: HTMLElement, href: string, done: BoolCallback): ImageViewerDialog {
        
        const d = new ImageViewerDialog(accessories$, gestureHandler$, An.above_(host), href);
        d.titleKey_(RS.ImageViewerTitle);
        d.onCancel_(() => {
            done(false);
        });
        d.onOK_(() => {
            done(true);
        });
        return d;
    }

    static onViewLocalImage_ = (host: HTMLElement, mediainfo: MediaInfo, done: BoolCallback): void => {
        const u = An.parseUriSafe_(mediainfo.uri$, null)?.toAbsolute_();
        if (u == null) {
            toasters$.warn_([MSG.string_(RS.InvalidFilepath), mediainfo.uri$ ?? "null"]);
            return;
        }
        Callbacks.onViewImageUrl_(host, u.encoded$, done).show_();
    };

    static onPreviewImage_ = (
        host: HTMLElement,
        url: string,
        width: Int,
        height: Int,
        rotation: Int,
        effect: Int,
        adjust: Double,
        quality: Int,
    ): ImageViewerDialog => {
        const ret = new ImageViewerDialog(accessories$, gestureHandler$, An.above_(host),
            url, [], -1, width, height, rotation, effect, adjust, quality);
        ret.titleKey_(RS.ImageViewerTitle).showOnlyButtons([BUT.Cancel, BUT.RotateImage, BUT.Info]);
        return ret;
    };

    static promptColor_ = (buttonsize: number, zindex: number, color: stringX, defcolor: ColorValue): PromptColor => {
        return PromptColor.getSingleton_(accessories$, buttonsize)
            .setColor(color, defcolor)
            .zindex_(zindex);
    };

    static promptEditText_ = (ovalue: string, fontfamily: string, zindex: number, callback: (dialog: PromptEditText) => void): void => {
        _SymbolPreferences.get_((session) => {
            const d = new PromptEditText(
                accessories$, cache$.ui$.buttonSize_(), fontfamily, settings$.dateFormat_(), settings$.timeFormat_(), session, zindex);
            d.titleKey_(RS.EditText);
            d.value_(ovalue);
            callback(d);
        });
    };
}

class _Util {

    static readonly _XQUALITY = "#XvO";
    static readonly _XPREVIEW = "#X7K";
    static readonly _XTNSIZE = "#XS7";
    static readonly _XROTATION = "#XDY";
    static readonly _XCORRECTION = "#XUX";
    static readonly _XEFFECT = "#XXa";
    static readonly _XWXH = "#Xqd";
    static readonly _XCROP = "#XnP";
    static readonly _XTNWXH = "#XVs";
    static readonly _XFILEPATH = "#XuR";
    static readonly _XADJUST = "#X9U";

    /**
       * Create a content scroller on a smokescreen element.
       * Since smokescreen element is created on show,
       * this should be called in the SmokescreenCallback.
       */
    static createContentScroller_(elm: HTMLElement, endcallback: Fun00): Dragger | null {
        An.onPointerStart_(elm, e => {
            An.stopevent_(e);
            endcallback();
        });
        An.onPointerEnd_(elm, An.sinkhole_);
        An.onClick_(elm, An.sinkhole_);
        return null;
    }

    static actionScreenshot_(dir: stringX = null): void {
        sidePanel$.hideSidepanel1_(0, () => {
            const rightsidebar = native$.iGetElementById_(ID.xRightSidebar);
            let hasrsb = false;
            if (rightsidebar != null) {
                const classlist = rightsidebar.classList;
                if (!classlist.contains(CSS.xHidetemp)) {
                    classlist.add(CSS.xHidetemp);
                    hasrsb = true;
                }
            }
            Timer.sleep0_(() => {
                let outpath = With.notnull_(native$.getIFrameContextPath_(), (path) => {
                    if (dir == null) return Basepath.changeSuffix_(path, Suffix.PNG$);
                    return Basepath.joinRpath_(dir, Basepath.stem_(path) + Suffix.PNG$);
                }) ?? `${dir ?? PATH._HomeDrafts}/screenshot${An.simpleDateTimeString_()}.${Suffix.PNG$}`;
                host$.takeScreenshot_(outpath, cache$.ui$.toolbarHeight_(), window.innerHeight, hasrsb);
            });
        });
    }

    ////////////////////////////////////////////////////////////////////////

    static hideContextmenus_(): void {
        mainPanel$.hideMainContextmenu();
        mainPanel$.hideBrowsingContextmenu();
    }

    static findActionButtons_(buttons: Map<string, HTMLElement>, container: HTMLElement): void {
        for (const e of JsUtil.querySelectorAll_(container, `[${ATTR.AnAction}]`)) {
            const action = e.getAttribute(ATTR.AnAction);
            if (action != null && action.length > 0) {
                buttons.set(action, e);
            }
        }
    }

    static toggleIgnorecase_(button: HTMLElement): void {
        An.toggleOnOffButton_(button);
        _Util.toastOnOffButton_(MSG.string_(RS.Tooltips_IgnoreCase), An.isButtonOn_(button));
    }

    static toastOnOffButton_(msg: string, on: boolean): void {
        toasters$.info_(msg + ": " + ((true == on) ? MSG.string_(RS.On) : MSG.string_(RS.Off)), { attop: false });
    }

    /// Like browse(href) but check to make sure there is a view parameter for media target.
    static browse1_(uri: UriX): void {
        const u = (uri == null || uri.isRelative$) ? null : An.addViewParam_(uri, null);
        _Util.browse_(u, uri?.toString() ?? "null");
    }

    static browse_(uri: UriX, msg: string): void {
        if (uri == null) {
            toasters$.warn_(MSG.string1_(RS.InvalidURL_, msg));
            return;
        }
        native$.browse_(uri);
    }

    static _showCSSEditor(cpath: string, editable: boolean, edit: boolean): void {
        host$.readCSS_(cpath, ret => {
            if (toasters$.warn_(ret)) return;
            const content = ret[Key.result];
            const position = ret[Key.status] ?? null;
            const d = new CSSEditor(accessories$, gestureHandler$, cpath, editable, edit, content.trim(), position);
            d.zindex_(DEF.zindexPrompt);
            d.show_();
        });
    }

    /// @param cpath A context relative path with or without leading /.
    static browseFile_(
        cpath: string,
        state: JSONObjectX = null,
        edit: boolean = false,
        ignorecase: boolean = false,
        searchtext: stringX = null,
        isregex: boolean = false): void {
        cpath = Basepath.cleanFilepath_(cpath);
        if (cpath.length == 0 || cpath.lastIndexOf(FS) == 0) {
            toasters$.warn_(`${MSG.string_(RS.invalidFilepath_)}: ${cpath}`);
            return;
        }
        cpath = cpath.startsWith(FS) ? cpath : FS + cpath;
        const segments = cpath.split(FS);
        const lcsuffix = Basepath.lcSuffix_(cpath);
        let uri: UriX;
        if (Suffix.HTML$ == lcsuffix) {
            const params = new Map<string, string>();
            if (edit) {
                params.set(Param.edit, "");
            }
            if (searchtext != null) {
                params.set(Param.ignorecase, `${ignorecase}`);
                params.set(Param.searchtext, searchtext);
                params.set(Param.isregex, `${isregex}`);
            }
            if (state != null) {
                params.set(Param.session, JSON.stringify(state));
            }
            uri = An.uriFromSafe_(null, segments, params);
        } else if (lcsuffix == Suffix.PDF$) {
            uri = An.parseUriSafe_(cpath, null);
        } else if (MimeUtil.isViewerLcSuffix_(lcsuffix)) {
            const params = map1_(Param.view, "");
            if (state != null) {
                params.set(Param.session, JSON.stringify(state));
            }
            uri = An.uriFromSafe_(null, segments, params);
        } else {
            toasters$.warn_(MSG.string1_(RS.UnsupportedFileType_, lcsuffix));
            return;
        }
        _Util.browse_(uri, cpath);
    }

    //////////////////////////////////////////////////////////////////////

    static confirmSmall_(msg: TestResult, zindex: number, callback: BoolCallback): void {
        DialogUt.confirmSmall_(accessories$, msg, zindex, callback);
    }

    static confirmKeySmall_(msgid: string, zindex: number, callback: BoolCallback): void {
        DialogUt.confirmKeySmall_(accessories$, msgid, zindex, callback);
    }

    /**
       * If not existing, always call callback.
       * If editing, prompt user to save/discard/cancel. Call callback only on save or discard.
       */
    static onSaveOrDiscard_(callback: Fun00): void {
        if (state$.isEditing_()) {
            _Util.promptSave_(callback).show_();
        } else {
            callback();
        }
    }

    static promptSave_(callback: Fun00): PromptSave {
        const ret = new PromptSave(accessories$, RS.Confirm, MSG.string_(RS.ConfirmSaveOrDiscard));
        ret.onSave_(() => {
            mainPanel$.saveEdit(() => {
                toasters$.infoKey_(RS.DocumentSaved, { attop: true });
                callback();
            });
        });
        ret.onDiscard_(() => {
            mainPanel$.stopEdit(true, () => {
                toasters$.infoKey_(RS.DocumentChangesDiscarded, { attop: true });
                callback();
            });
        });
        return ret;
    }

    static promptWarning_(titlekey: StringId, msg: any): PromptWarning {
        return new PromptWarning(accessories$, titlekey, msg);
    }

    static getRotation_(value: string, def: Int): Int {
        return An.parseIntUnit_(value)?.[0] ?? def;
    }

    static promptInputImage_(
        titlekey: StringId,
        basedir: string,
        width: number,
        height: number,
        zindex: number,
        callback: PromptInputImageCallback
    ): PromptInputImage {
        return new PromptInputImage(accessories$, basedir, width, height, "0 deg")
            .titleKey_(titlekey)
            .zindex_(zindex)
            .onOK_((d, filepath, w, h, rotation, okcallback) => {
                Sanitizers.checkRequiredInputImage_(filepath, basedir, (result) => {
                    result.ifOK_(cpath => {
                        const uri = An.uriFromSafe_(An.uriFromSafe_(null, basedir + FS), filepath);
                        if (uri == null) return BotResult.failArrayKey_(RS.InvalidFilepath);
                        okcallback(true);
                        callback(cpath, uri, w, h, rotation);
                        return BotResult.ok_(true);
                    }).onFail_(msgs => {
                        okcallback(false);
                        d.warn_(msgs);
                    });
                });
            });
    }

    static setQualityVisibility_(d: ICompositeDialog, path: string): void {
        const lossy = (An.dataUrlScheme_(path) != null) ? true : MimeUtil.isLossyImageLcSuffix_(Basepath.lcSuffix_(path));
        d.setVisible_(_Util._XQUALITY, lossy);
    }

    static onEffectChanged_(d: ICompositeDialog, lasteffect: number, dataurl: stringX): number {
        const effect = EffectUtil.get_(d.getValue_(_Util._XEFFECT));
        if (effect != lasteffect) {
            switch (effect) {
                case Effect.GRAY2:
                case Effect.GRAY4:
                case Effect.GRAY8:
                case Effect.GRAY16:
                case Effect.GRAY256:
                    d.setVisible_(_Util._XADJUST, true);
                    d.setValue_(_Util._XADJUST, `${EffectUtil.getDefaultAdjust_(effect)}`);
                    let filepath = d.getValue_(_Util._XFILEPATH);
                    const lcsuffix = Basepath.lcSuffix_(filepath);
                    if (lcsuffix != Suffix.PNG$) {
                        const bn = new Basepath(filepath);
                        filepath = bn.changeSuffix_(Suffix.PNG$).path$;
                        d.setValue_(_Util._XFILEPATH, filepath);
                        d.setVisible_(_Util._XQUALITY, false);
                    }
                    break;
                default:
                    d.setVisible_(_Util._XADJUST, false);
            }
            _Util.updateThumbnail_(d, dataurl);
        }
        return effect;
    }

    static updateThumbnail_(d: ICompositeDialog, dataurl: stringX): void {
        if (dataurl == null || dataurl.length == 0) return;
        const effect = EffectUtil.get_(d.getValue_(_Util._XEFFECT));
        const rotation = _Util.getRotation_(d.getValue_(_Util._XROTATION), 0);
        const quality = An.parseInt_(d.getValue_(_Util._XQUALITY), DEF.jpegQuality);
        const errors = sarray_();
        const adjust = EffectUtil.getAdjust(effect, d.getValue_(_Util._XADJUST));
        if (d.warn_(errors)) return;
        host$.previewImage_(dataurl, DEF.previewPhotoSize, DEF.previewPhotoSize, rotation, effect, adjust, quality, ret => {
            if (toasters$.warn_(ret)) return;
            d.postUpdate(() => {
                d.setValue_(_Util._XPREVIEW, ret[Key.result]);
            });
        });
    }

    static styleEditor_(
        container: HTMLElement,
        declarations: string,
        cpath: string,
        baseuri: BaseUriX,
        zindex: number,
        warner: IWarner,
        callback: Fun10<SStringMap>
    ): StyleEditor {
        return new StyleEditor(container, cpath, declarations).zindex_(zindex).onOK_((style, okcallback) => {
            if (style.trim().length == 0) {
                okcallback(true);
                callback(ssmap_());
                return;
            }
            cssParser$.sanitizeStyle_(style, baseuri, (ret) => {
                if (warner.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                callback(ret[Key.style] as SStringMap);
            });
        });
    }

    static promptCanvasDimension_(
        msg: string,
        width: number,
        height: number,
        callback: (width: number, height: number, tnwidth: numberX, tnheight: numberX, bgcolor: ColorValue) => void
    ): CompositeDialog {
        const XTNHEIGHT = "#Xv4";
        const XTNWXH = "#X0n";
        const XTNWIDTH = "#XYV";
        const XWXH = "#Xlh";
        const XHEIGHT = "#XJt";
        const XWIDTH = "#XNc";
        const XBGCOLOR = "#XNI";
        const buttonsize = cache$.ui$.buttonSize_();
        const baseuri = native$.getIFrameUri_();
        return new CompositeDialog(accessories$, [
            new Input2FIeld(
                "",
                XWXH,
                ",",
                buttonsize,
                RS.Width,
                XWIDTH,
                `${width}`,
                "x",
                RS.Height,
                XHEIGHT,
                `${height}`,
                CSSLength.PX
            ),
            new Input2FIeld(
                "",
                XTNWXH,
                ",",
                buttonsize,
                RS.TnWidth,
                XTNWIDTH,
                "",
                "x",
                RS.TnHeight,
                XTNHEIGHT,
                "",
                CSSLength.PX,
            ),
            new ColorField(
                "",
                XBGCOLOR,
                "",
                buttonsize,
                RS.BGColor
            ),
        ])
            .titleKey_(RS.PromptCanvasTitle)
            .message_(msg)
            .zindex_(DEF.zindexPrompt)
            .onOK_((d, okcallback) => {
                const errors = sarray_();
                const w = An.onValidateOptionalPositiveInt_(errors, MSG.string_(RS.Width), d.getValue_(XWXH, 0));
                const h = An.onValidateOptionalPositiveInt_(errors, MSG.string_(RS.Height), d.getValue_(XWXH, 1));
                const tw = An.onValidateOptionalPositiveInt_(errors, MSG.string_(RS.TnWidth), d.getValue_(XTNWXH, 0));
                const th = An.onValidateOptionalPositiveInt_(errors, MSG.string_(RS.TnHeight), d.getValue_(XTNWXH, 1));
                const dim = MediaUtil.optionalDimension1_(w, h, width, height);
                if (dim.x * dim.y > DEF.maxOutputImageArea) {
                    errors.push(MSG.string1_(RS.OriginalSize, `: ${dim.x}x${dim.y}`));
                }
                if (tw != null && th != null && tw * th > DEF.maxOutputImageArea) {
                    errors.push(MSG.string1_(RS.OriginalSize, `: ${tw}x${th}`));
                }
                const done = (bgcolor: string) => {
                    let c = null;
                    if (bgcolor.length > 0) {
                        c = ColorUtil.getColorValue_(bgcolor);
                    }
                    callback(dim.x, dim.y, tw, th, c ?? ColorValue.X_WHITE);
                };
                const bgcolor = d.getValue_(XBGCOLOR).trim();
                if (bgcolor.length == 0) {
                    okcallback(true);
                    done("");
                    return;
                }
                cssParser$.sanitizeStyle_(`background-color: ${bgcolor}`, baseuri, (ret) => {
                    ArrayUt.addAll_(errors, ...An.resultList_(ret[Key.errors]));
                    if (errors.length > 0) {
                        toasters$.warn_(errors);
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    const styles = ret[Key.style] as SStringMap;
                    const bgcolor = styles[PK.BackgroundColor] ?? "";
                    done(bgcolor);
                });
            });
    }

    /**
     * @param iwidth 0 for multiple image output. In that case, prompt for a single dimension instead of width, height.
     * @param topath The suggested output filepath, context relative or iframe relative.
     * In case output is a staging photo, path is null.
     */
    static promptOutputImageBase_(
        topath: string,
        basedir: BasedirX,
        frompath: stringX,
        iwidth: number,
        iheight: number,
        zindex: number,
        defsize: number,
        defquality: number,
        allowdataurl: boolean,
        dataurl: stringX
    ): CompositeDialog {
        const hasdim = (iwidth > 0 && iheight > 0) || defsize == 0;
        let wh: [Int, Int] = [0, 0];
        if (hasdim && defsize > 0) {
            const idim = MediaUtil.limitImageDimensionAndArea_(iwidth, iheight, defsize);
            wh = [idim.x, idim.y];
        }
        const tnsize = 160;
        const infos = new Array<IDialogFIeldSpec>(
            allowdataurl ? new ImageFilepathFolderField(
                "",
                _Util._XFILEPATH,
                new HumanFilepath(topath),
                RS.PlaceholderRequiredFilepath,
                basedir,
                Callbacks.onWriteImageFolderButton_,
            ) : new FilepathFolderField(
                "",
                _Util._XFILEPATH,
                new HumanFilepath(topath),
                RS.PlaceholderRequiredFilepath,
                basedir,
                Callbacks.onWriteImageFolderButton_,
            ),
            new CheckboxField(
                "",
                _Util._XCROP,
                "false",
                MSG.string_(RS.Crop)
            ),
            new ImageDimFIeld(
                "",
                _Util._XWXH,
                RS.Width,
                RS.Height,
                cache$.ui$.buttonSize_(),
                [iwidth, iheight],
                wh,
                defsize,
                IMAGE_SIZE_LIST,
            ),
            new SelectFIeld(
                "", _Util._XROTATION, "0 deg", RS.Rotation,
                ["0 deg", "90 deg", "180 deg", "270 deg"],
            ),
            new SelectFIeld(
                "", _Util._XEFFECT, EffectUtil.Names[Effect.NONE], RS.Effects,
                EffectUtil.Names
            ),
            new SliderField(
                "", _Util._XADJUST, EffectUtil.getDefaultAdjust_(Effect.NONE), RS.Adjust,
                0, 100, 0.5, 10.0, `${cache$.ui$.buttonSize_()}px`),
            new InputField(
                "",
                _Util._XQUALITY,
                `${defquality}`,
                RS.QualityPercent
            ),
        );
        if (dataurl != null) {
            infos.push(new DataUrlField(
                "",
                _Util._XPREVIEW,
                dataurl,
                `${tnsize}px`,
                `${tnsize}px`
            ));
        }
        const d = new CompositeDialog(accessories$, infos);
        d.titleKey_(RS.PromptDimensionTitle)
            .onPreview((host, srcuri) => {
                if (dataurl == null) return null;
                let url = ((frompath != null)
                    ? An.uriOfFilepath2_(native$.getIFrameUri_(), frompath)?.toAbsolute_()?.toString()
                    : srcuri) ?? srcuri;
                const rotation: Int = _Util.getRotation_(d.getValue_(_Util._XROTATION), 0);
                const effect: Int = EffectUtil.get_(d.getValue_(_Util._XEFFECT));
                const adjust: Double = EffectUtil.getAdjust(effect, d.getValue_(_Util._XADJUST));
                const quality: Int = An.parseInt_(d.getValue_(_Util._XQUALITY), DEF.jpegQualityHigh);
                const dim = An.parseWxh_(d.getValue_(_Util._XWXH), [0, 0]);
                return Callbacks.onPreviewImage_(host, url, dim[0], dim[1], rotation, effect, adjust, quality);
            })
            .zindex_(zindex)
            .setVisible_(_Util._XCROP, false)
            .setVisible_(_Util._XADJUST, false)
            .setVisible_(_Util._XFILEPATH, topath != null);
        _Util.setQualityVisibility_(d, topath);
        return d;
    }

    /// Like promptOutputImage1 but default to empty width/height and do not update defimagesize.
    static promptOutputImage0_(
        pathcallback: Fun11<string, string>,
        basedir: string,
        frompath: stringX,
        width: number,
        height: number,
        zindex: number,
        dataurl: stringX,
        dimconverter: DimensionConverter,
        callback: PromptOutputImageCallback,
        dialogcallback: Fun10<CompositeDialog>) {
        _Util.getImageDefaultOutputSize_((defformat, defsize: Int, defquality: Int) => {
            const d = _Util.promptOutputImage_(
                pathcallback(defformat), basedir, frompath, width, height, zindex,
                0, defquality,
                false, dataurl, dimconverter, (outputinfo) => {
                    _Util.updateImageDefaultOutputSize_(
                        defformat, defsize, defquality,
                        Basepath.lcSuffix_(outputinfo.cpath), 0, outputinfo.quality,
                        () => {
                            callback(outputinfo);
                        });
                });
            dialogcallback(d);
        });
    }

    static promptOutputImage1_(
        pathcallback: Fun11<string, string>,
        basedir: string,
        frompath: stringX,
        width: number,
        height: number,
        zindex: number,
        dataurl: stringX,
        dimconverter: DimensionConverter,
        callback: PromptOutputImageCallback,
        dialogcallback: Fun10<CompositeDialog>) {
        _Util.getImageDefaultOutputSize_((defformat: string, defsize: Int, defquality: Int) => {
            const d = _Util.promptOutputImage_(
                pathcallback(defformat), basedir, frompath, width, height, zindex,
                defsize, defquality,
                false, dataurl, dimconverter, (outputinfo) => {
                    const size = Math.max(outputinfo.width, outputinfo.height);
                    _Util.updateImageDefaultOutputSize_(
                        defformat, defsize, defquality,
                        Basepath.lcSuffix_(outputinfo.cpath), size, outputinfo.quality,
                        () => {
                            callback(outputinfo);
                        });
                });
            dialogcallback(d);
        });
    }

    static promptOutputImage_(
        topath: string,
        basedir: BasedirX,
        frompath: stringX,
        iwidth: number,
        iheight: number,
        zindex: number,
        defsize: number,
        defquality: number,
        allowdataurl: boolean,
        dataurl: stringX,
        dimconverter: DimensionConverter,
        callback: PromptOutputImageCallback
    ): CompositeDialog {
        let lastEffect = Effect.NONE;
        const hasdim = (iwidth > 0 && iheight > 0);
        const d = _Util.promptOutputImageBase_(
            topath, basedir, frompath, iwidth, iheight, zindex,
            defsize, defquality,
            allowdataurl, dataurl);
        if (hasdim) {
            d.message_(`${MSG.string_(RS.OriginalSize)}: ${iwidth}x${iheight}`);
        }
        d.onChange_((field) => {
            const key = field.spec$.key$;
            if (_Util._XFILEPATH == key) {
                _Util.setQualityVisibility_(d, d.getValue_(_Util._XFILEPATH));
            } else if (_Util._XEFFECT == key) {
                lastEffect = _Util.onEffectChanged_(d, lastEffect, dataurl);
            } else if (_Util._XROTATION == key || _Util._XADJUST == key) {
                _Util.updateThumbnail_(d, dataurl);
            }
        });
        d.onOK_((d, okcallback) => {
            const errors = sarray_();
            const filepath = d.getValue_(_Util._XFILEPATH);
            const cpath = An.dataUrlScheme_(filepath) != null ? filepath : An.cpathOfFilepath2_(basedir, filepath);
            if (cpath == null) {
                d.warn_([MSG.string_(RS.InvalidFilepath), filepath]);
                okcallback(false);
                return;
            }
            const effect = EffectUtil.get_(d.getValue_(_Util._XEFFECT));
            const adjust = EffectUtil.getAdjust(effect, d.getValue_(_Util._XADJUST));
            const quality = _Util._onValidatePercent(errors, MSG.string_(RS.QualityPercent), d.getValue_(_Util._XQUALITY), DEF.jpegQualityHigh);
            const rotation = _Util.getRotation_(d.getValue_(_Util._XROTATION), 0);
            let dim: Point<number> | null = null;
            const width = d.getValue_(_Util._XWXH, 0);
            const height = d.getValue_(_Util._XWXH, 1);
            An.onValidateOptionalInt_(errors, MSG.string_(RS.Width), width);
            An.onValidateOptionalInt_(errors, MSG.string_(RS.Height), height);
            dim = dimconverter(width, height, iwidth, iheight);
            if (dim == null) {
                d.warnKey_(RS.InvalidDimensionAbort);
                okcallback(false);
                return;
            }
            const dim1 = dim;
            if (hasdim) {
                _Util._onValidateOutputImage(errors, filepath, basedir, zindex, ret => {
                    if (d.warn_(ret)) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    _Util._promptOutputImageOK(dim1, filepath, cpath, rotation, quality, effect, adjust, callback);
                });
            } else {
                _Util._onValidateOutputImageWithoutCheckingOverwriting(errors, filepath, basedir).onFail_(() => {
                    d.warn_(smap1_(Key.errors, errors));
                    okcallback(false);
                })?.onOK_((cpath) => {
                    okcallback(true);
                    _Util._promptOutputImageOK(dim1, filepath, cpath, rotation, quality, effect, adjust, callback);
                    return null;
                });
            }
        });
        return d;
    }

    private static _promptOutputImageOK(
        dim: Point<number>,
        filepath: string,
        cpath: string,
        rotation: number,
        quality: number,
        effect: number,
        adjust: number,
        callback: PromptOutputImageCallback,
    ): void {
        dim = MediaUtil.limitImageArea_(dim.x, dim.y);
        callback(new ImageOutputInfo(filepath, cpath, dim.x, dim.y, rotation, effect, adjust, quality));
    }

    static promptRect_(cpath: string, zindex: number, callback: Fun10<MutRect>): void {
        host$.localImageThumbnail_(cpath, DEF.previewPhotoSize, DEF.jpegQuality, null, ret => {
            if (toasters$.warn_(ret)) return;
            const width = ret[Key.width];
            const height = ret[Key.height];
            const dataurl = ret[Key.result];
            _Util._promptRect1(zindex, width, height, dataurl, callback);
        });
    }

    private static _promptRect1(
        zindex: number,
        width: number,
        height: number,
        dataurl: string,
        callback: Fun10<MutRect>
    ): void {
        new ShapePicker$.PromptRect(
            accessories$,
            gestureHandler$,
            cache$.ui$.buttonSize_(),
            zindex,
            0.0,
            new Point(width, height),
            [0.0, 0.0, 1.0, 1.0],
            dataurl)
            .onOK_((rect) => callback(rect))
            .onConfirmCancel_(null)
            .show_();
    }

    static prompQuad_() {
        new ShapePicker$.PromptQuad(accessories$, gestureHandler$, cache$.ui$.buttonSize_(), DEF.zindexPrompt, 1.0, new Point(320, 240), [], "data:fixme");
    }

    static promptOutputPerspective_(
        path: string,
        basedir: string,
        width: number,
        height: number,
        quality: number,
        zindex: number,
        callback: (filepath: string, outcpath: string, quality: number) => void
    ): ICompositeDialog {
        const d = new CompositeDialog(accessories$, [
            new FilepathFolderField(
                "",
                _Util._XFILEPATH,
                new HumanFilepath(path),
                RS.PlaceholderRequiredFilepath,
                basedir,
                Callbacks.onWriteImageFolderButton_,
            ),
            new InputField(
                "",
                _Util._XQUALITY,
                `${quality}`,
                RS.QualityPercent,
            ),
        ]);
        d.titleKey_(RS.PromptDimensionTitle);
        d.message_([
            `${MSG.string_(RS.FixPerspectiveUncroppedSize)}: ${width}x${height}`,
        ]);
        d.zindex_(zindex);
        d.setVisible_(_Util._XQUALITY, MimeUtil.isLossyImageLcSuffix_(Basepath.lcSuffix_(path)));
        d.setVisible_(_Util._XFILEPATH, path != null);
        d.onChange_((field) => {
            const key = field.spec$.key$;
            if (_Util._XFILEPATH == key) {
                _Util.setQualityVisibility_(d, d.getValue_(_Util._XFILEPATH));
            }
        });
        d.onOK_((d, okcallback) => {
            const filepath = d.getValueAt_(0);
            const cpath = An.cpathOfFilepath2_(basedir, filepath);
            if (cpath == null) {
                d.warn_([MSG.string_(RS.InvalidFilepath), filepath]);
                okcallback(false);
                return;
            }
            const errors = sarray_();
            const quality = _Util._onValidatePercent(errors, MSG.string_(RS.QualityPercent), d.getValueAt_(1), DEF.jpegQualityHigh);
            if (path != null) {
                _Util._onValidateOutputImage(errors, filepath, basedir, zindex, ret => {
                    if (d.warn_(ret)) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    callback(filepath, cpath, quality);
                });
            } else {
                if (errors.length > 0) {
                    d.warn_(smap1_(Key.errors, errors));
                    okcallback(false);
                    return;
                }
                okcallback(true);
                callback(filepath, cpath, quality);
            }
        });
        return d;
    }

    private static _onValidateOutputImageWithoutCheckingOverwriting(errors: string[], filepath: string, basedir: BasedirX): IBotResult<string, string[]> {
        if (An.isempty_(filepath)) {
            errors.push(MSG.string_(RS.InvalidPath));
        } else if (An.dataUrlScheme_(filepath) != null) {
            return BotResult.ok_(filepath);
        } else {
            const cpath = An.cpathOfFilepath2_(basedir, filepath);
            const lcsuffix = Basepath.lcSuffix_(cpath);
            if (MimeUtil.isWritableImageLcSuffix_(lcsuffix)) {
                return BotResult.ok_(cpath);
            }
            errors.push(MSG.string1_(RS.UnsupportedOutputFormat_, lcsuffix));
        }
        return BotResult.fail_(errors);
    }

    static _onValidateOutputImage(
        errors: string[], filepath: string, basedir: BasedirX, zindex: number, callback: JSONCallback): void {
        _Util._onValidateOutputImageWithoutCheckingOverwriting(errors, filepath, basedir).onFail_(() => {
            callback(smap1_(Key.errors, errors));
        })?.onOK_((cpath) => {
            if (An.dataUrlScheme_(cpath) != null) {
                callback(smap1_(Key.result, {}));
            } else {
                _Util.checkFileWritableAndConfirmOverwrite_(cpath, zindex + 10, callback);
            }
            return null;
        });
    }

    static checkFileWritableAndConfirmOverwrite_(cpath: string, _zindex: number, callback: JSONCallback): void {
        fileinfoUt$.checkFileWritable2_(cpath, (msg) => {
            callback(smap1_(Key.errors, msg));
        }, (fileinfo) => {
            if (fileinfo.exists$) {
                DialogUt.confirmOverwriting_(Basepath.filename_(cpath), yes => {
                    callback(yes
                        ? smap1_(Key.result, {})
                        : An.jsonError_(RS.DestinationExistsNotOverwriting));
                });
                return;
            }
            callback(smap1_(Key.result, {}));
        });
    }

    static getImageDefaultOutputSize_(callback: Fun30<string, Int, Int>): void {
        host$.getSessionPreferences_(ret => {
            let format = MimeUtil.defaultWritableImageFormat$;
            let size = settings$.current_().imageDimension$;
            let quality = DEF.jpegQuality;
            if (!toasters$.warn_(ret)) {
                const prefs = ret[Key.result];
                format = prefs[SessionPreferencesKey.imageDefaultOutputFormat] ?? format;
                quality = prefs[SessionPreferencesKey.imageDefaultOutputQuality] ?? quality;
                size = prefs[SessionPreferencesKey.imageDefaultOutputSize] ?? size;
            }
            callback(format, size, quality);
        });
    }

    static updateImageDefaultOutputSize_(
        defformat: string, defsize: Int, defquality: Int,
        format: string, size: Int, quality: Int,
        callback: Fun00): void {
        if (format != defformat || size != defsize || quality != defquality) {
            host$.updateSessionPreferences_(json_(
                [SessionPreferencesKey.imageDefaultOutputFormat, format],
                [SessionPreferencesKey.imageDefaultOutputSize, size],
                [SessionPreferencesKey.imageDefaultOutputQuality, quality],
            ), ret => {
                toasters$.warn_(ret);
                callback();
            });
            return;
        }
        callback();
    }

    static _onValidatePercent(errors: string[], key: string, value: string, def: number): number {
        const n = An.parseInt_(value, -1);
        if (n < 0 || n > 100) {
            errors.push(MSG.format3_(RS.nameValueOutOfRange, key, value, "[0, 100]"));
            return def;
        }
        return n;
    }

    static promptInsertImg1_(
        titlekey: StringId,
        attrs: stringX,
        baseuri: BaseUriX,
        foldercallback: PromptFilepathCallback,
        callback: PromptInsertImgCallback
    ): PromptInsertImg {
        return _Util.promptInsertImg_(titlekey, attrs, baseuri, foldercallback, result => {
            if (result == null) {
                return callback(null);
            }
            const cpath = An.cpathOfUri_(result.src);
            _Util.setImageOrientationOfPath_(result.attrs, cpath, () => {
                callback(result);
            });
        });
    }

    static promptInsertImg_(
        titlekey: StringId,
        attrs: stringX,
        baseuri: BaseUriX,
        foldercallback: PromptFilepathCallback,
        callback: PromptInsertImgCallback,
    ): PromptInsertImg {
        const d = new PromptInsertImg(accessories$, "", attrs, baseuri, foldercallback);
        return d.titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt)
            .onThumbnailButton_(Callbacks.onThumbnailButton_)
            .onCancel_(() => {
                callback(null);
            })
            .onOK_((dialog, xsrc, xcaption, xattrs, xhref, okcallback) => {
                Sanitizers.checkRequiredImageOptionalLink_(xsrc, xhref, baseuri).onFail_(msgs => {
                    d.warn_(msgs);
                    okcallback(false);
                })?.onOK_(([srcuri, linkuri]) => {
                    Sanitizers.checkAttrs_(xattrs, baseuri, (ret) => {
                        if (dialog.warn_(ret)) {
                            okcallback(false);
                            return;
                        }
                        okcallback(true);
                        toasters$.warn_(ret[Key.warns]);
                        const sanitized = (ret[Key.attrs] as StringMap<string>);
                        callback({
                            src: srcuri,
                            caption: xcaption,
                            attrs: sanitized,
                            link: linkuri
                        });
                    });
                });
            });
    }

    static promptImageUrl2_(
        titlekey: StringId, zindex: number,
        osrc: HumanLink, attrs: string, ohref: HumanLink, baseuri: BaseUri,
        foldercallback: PromptFilepathCallback,
        onok: Fun40<UriX, StringMap<string>, boolean, UriX>,
    ): PromptImageUrl2 {
        return _Util.promptImageUrl21_(new PromptImageUrl2(accessories$, osrc, attrs, ohref, baseuri, foldercallback)
            .titleKey_(titlekey)
            .zindex_(zindex)
            .onThumbnailButton(Callbacks.onThumbnailButton_),
            baseuri,
            onok);
    }

    static promptAudioUrl2_(
        titlekey: StringId, zindex: number,
        osrc: HumanLink, attrs: string, ohref: HumanLink, baseuri: BaseUri,
        foldercallback: PromptFilepathCallback,
        onok: Fun40<UriX, StringMap<string>, boolean, UriX>,
    ): PromptImageUrl2 {
        return _Util.promptImageUrl21_(new PromptImageUrl2(
            accessories$, osrc, attrs, ohref, baseuri, foldercallback,
            false, Callbacks.onAudioPlaybackFolderButton_)
            .titleKey_(titlekey)
            .zindex_(zindex)
            .onThumbnailButton(Callbacks.onThumbnailButton_),
            baseuri,
            onok);
    }

    static promptImageUrl21_(
        d: PromptImageUrl2,
        baseuri: BaseUriX,
        onok: Fun40<UriX, StringMap<string>, boolean, UriX>,
    ): PromptImageUrl2 {
        return d.onChange_((field) => {
            if (field.spec$.key$ == "#0") {
                const src = d.getValueAt_(0);
                const cpath = An.cpathOfHref2_(baseuri, src);
                if (cpath == null) return;
                const value1 = d.getValueAt_(1);
                const attrs = An.attributesFromEditString_(value1);
                _Util.setImageOrientationOfPath_(attrs, cpath, () => {
                    const s = An.attributesToStringForEdit_(JsUtil.sortedAttributes1_(attrs), " ", []);
                    d.setValueAt_(1, s);
                });
            }
        }).onOK_((d, src, attrs, createlink, link, okcallback) => {
            Sanitizers.checkAttrs_(attrs, baseuri, (ret) => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                const sanitized = (ret[Key.attrs] as StringMap<string>) ?? smap_<string>();
                if (src.length == 0) {
                    okcallback(true);
                    onok(null, sanitized, createlink, null);
                    return;
                }
                Sanitizers.checkRequiredImageOptionalLink_(src, link, baseuri).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(([srcuri, linkuri]) => {
                    okcallback(true);
                    onok(srcuri, sanitized, createlink, linkuri);
                });
            });
        });
    }

    static promptBasename_(
        titlekey: StringId,
        msg: stringX,
        dir: BasedirX,
        filename: string,
        usexrefs: boolean,
    ): PromptRename {
        const ofilename = new Basepath(filename);
        return new PromptRename(
            accessories$,
            [
                new BasenameFIeld(
                    "",
                    "",
                    ofilename.filename$,
                    RS.Filename,
                    dir,
                    Callbacks.onBasenameFolderButton_,
                    (host) => host.actionOK_(),
                ),
            ],
            usexrefs,
            DEF.BASIS_25)
            .titleKey_(titlekey)
            .message_(msg)
            .zindex_(DEF.zindexPrompt);
    }

    static promptCssOutputUrl_(
        titlekey: StringId,
        msg: string,
        initvalue: HumanLink,
        filepickerkind: FilepickerKind,
        baseuri: BaseUri,
        placeholder: StringId): PromptLink {
        const ret = new PromptLink(accessories$, initvalue, baseuri, placeholder, (path, basedir, zindex, callback) => {
            Callbacks.onFolderButton_(RS.CSS, FilepickerCssDelegate.singleton$, filepickerkind, path, basedir, zindex, callback);
        })
            .titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt);
        if (msg != null) ret.message_(msg);
        return ret;
    }

    static promptLink_(titlekey: StringId, msg: string, value: HumanLink, baseuri: BaseUri, placeholder: string): PromptLink {
        const ret = new PromptLink(accessories$, value, baseuri, placeholder, (path, basedir, zindex, callback) => {
            Callbacks.onFolderButton_(
                titlekey, FilepickerLinkDelegate.singleton$, FilepickerKind.EXISTING_FILE, path, basedir, zindex, callback);
        })
            .titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt);
        if (msg != null) ret.message_(msg);
        return ret;
    }

    static promptLink2_(titlekey: StringId, href: HumanLink, attrs: string, baseuri: BaseUri, callback: UriXAttrsCallback): PromptLink2 {
        return _Util.promptLink21_(titlekey, href, attrs, baseuri, Callbacks.onLinkFolderButton_, callback);
    }

    static promptLink21_(
        titlekey: StringId,
        href: HumanLink,
        attrs: string,
        baseuri: BaseUri,
        onfoldercallback: PromptFilepathCallback,
        callback: UriXAttrsCallback
    ): PromptLink2 {
        return new PromptLink2(accessories$, href, attrs, baseuri, onfoldercallback)
            .titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt)
            .onOK_((d, href, attr, okcallback) => {
                Sanitizers.checkOptionalHref_(href, baseuri).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(uri => {
                    Sanitizers.checkAttrs_(attr, baseuri, (ret) => {
                        if (d.warn_(ret)) {
                            okcallback(false);
                            return;
                        }
                        okcallback(true);
                        toasters$.warn_(ret[Key.warns]);
                        const attrs = ret[Key.attrs] as SStringMap;
                        callback(uri, attrs);
                    });
                });
            });
    }

    static promptLink3_(
        titlekey: StringId,
        autofill: boolean,
        uri: HumanLink,
        text: string,
        attrs: string,
        baseuri: BaseUri,
        callback: UriXTextAttrsCallback
    ): PromptLink3 {
        const ret = new PromptLink3(accessories$, uri, text, attrs, baseuri);
        return ret.titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt)
            .onChange_((field, input) => {
                if (field.spec$.key$ == RS.URL) {
                    const textfield = ret.getFieldAt_(1);
                    const text = textfield.getValue_();
                    if (autofill || text.length == 0) {
                        let path = HumanLink.fromInput_(input as AnInputElement).filepath$;
                        if (path != null) {
                            const basepath = (path.startsWith(FS) ? new Basepath(path)
                                : new Basepath(baseuri.path$).changeFilename_(path));
                            textfield.setValue_(An.labelFromBasepath_(basepath));
                        }
                    }
                }
            })
            .onOK_((d, href, text, attr, okcallback: BoolCallback) => {
                Sanitizers.checkOptionalHref_(href, baseuri).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(uri => {
                    Sanitizers.checkAttrs_(attr, baseuri, (ret) => {
                        if (d.warn_(ret)) {
                            okcallback(false);
                            return;
                        }
                        okcallback(true);
                        toasters$.warn_(ret[Key.warns]);
                        const attrs = (ret[Key.attrs] as StringMap<string>);
                        callback(uri, text, attrs);
                    });
                });
            });
    }

    static promptValues_(titlekey: StringId, infos: IDialogFIeldSpec[]): CompositeDialog {
        return new CompositeDialog(accessories$, infos).titleKey_(titlekey);
    }

    static promptInsertElement_(): PromptInsertElement {
        return new PromptInsertElement(accessories$)
            .titleKey_(RS.InsertElementTitle)
            .zindex_(DEF.zindexPrompt)
            .tag_("DIV")
            .onValidate_((tag: string, attrs: string, callback: JSONCallback) => {
                Sanitizers.checkTagAttrs_(tag, attrs, native$.getIFrameUri_(), callback);
            });
    }

    static promptInsertText_(fontfamily: stringX, handler: IPromptSymbolHandler | null): PromptInsertText {
        return new PromptInsertText(
            accessories$,
            cache$.ui$.buttonSize_(),
            fontfamily,
            settings$.dateFormat_(),
            settings$.timeFormat_(),
            handler)
            .titleKey_(RS.InsertTextTitle)
            .zindex_(DEF.zindexPrompt);
    }

    static promptFont_(ofamily: string, zindex: number = DEF.zindexContextmenu + 100): PromptFont {
        return new PromptFont(
            accessories$,
            cache$.ui$.buttonSize_(),
            ofamily,
            DEFUtil.fontSamplerList,
            PATH._assetsFontsPng)
            .zindex_(zindex);
    }

    static getNonSystemFontFamilies_(fonts: FontInfo[]): string[] {
        const ret = sarray_();
        for (const info of fonts) {
            if (info.category$ == FontCategories.System) {
                continue;
            }
            const name = info.fontname$;
            const styles = info.styles$;
            for (const style of styles) {
                const family = FontUtil.fontFamilyOf_(name, style);
                ret.push(family);
            }
        }
        return ret;
    }

    static promptFilepath_(title: string, openmode: FilepickerKind, rootdir: stringX, docdir: stringX, path: string): Filepicker {
        let [dir, filename] = Basepath.splitPath_(path);
        return new Filepicker(
            accessories$,
            title,
            openmode,
            rootdir,
            docdir,
            dir,
            filename,
            fileinfoUt$)
            .onPaste(Callbacks.pasteFromClipboard_)
            .onCopy(Callbacks.copyToClipboard_)
            .onView_(Callbacks.onViewLocalImage_)
            .onDragstart_(Callbacks.filepickerDragstartHandler_)
            .dateFormat_(settings$.dateFormat_())
            .maxWidth_(640);
    }

    static promptFilepathKey_(titlekey: StringId, openmode: FilepickerKind, rootdir: stringX, docdir: stringX, path: string): Filepicker {
        return this.promptFilepath_(MSG.string_(titlekey), openmode, rootdir, docdir, path);
    }

    static promptZipEntry_(zipfile: string, zindex: Int, callback: Fun10<string>) {
        host$.listZip_(zipfile, (ret) => {
            if (toasters$.warn_(ret)) return;
            const tree = ret[Key.result];
            new ZipFilepicker(
                accessories$,
                MSG.string_(RS.Unzip),
                FilepickerKind.EXISTING_ANY,
                new FileInfoUtil(new ZipFilepickerHandler(tree))
            )
                .onPaste(Callbacks.pasteFromClipboard_)
                .onCopy(Callbacks.copyToClipboard_)
                .onDragstart_(Callbacks.filepickerDragstartHandler_)
                .dateFormat_(settings$.dateFormat_())
                .setDelegate_(FilepickerRestoreDataDelegate.singleton$)
                .maxWidth_(640)
                .zindex_(zindex)
                .onOK_((okcallback, src, fileinfo) => {
                    const lcsuffix = Basepath.lcSuffix_(src);
                    if (fileinfo.isfile$ && !MimeUtil.isImportableLcSuffix_(lcsuffix)) {
                        toasters$.warn_(MSG.string1_(RS.UnsupportedInputFormat_, lcsuffix));
                        return okcallback(false);
                    }
                    okcallback(true);
                    if (fileinfo.isdir$) src = Basepath.ensureTrailing_(src);
                    callback(src);
                }).show_();
        });
    }

    static promptName_(titlekey: StringId, msg: any, key: string, value: string, callback: StringCallback): CompositeDialog {
        return new CompositeDialog(accessories$, [
            new InputField(
                "",
                key,
                value,
                RS.Name,
                (host) => host.actionOK_(),
            ),
        ])
            .titleKey_(titlekey)
            .message_(msg)
            .zindex_(DEF.zindexPrompt)
            .onOK_((d, okcallback) => {
                const name = d.getValueAt_(0);
                if (An.isempty_(name) || name == ".") {
                    d.warnKey_(RS.InputMustNotBeEmpty);
                    okcallback(false);
                    return;
                }
                for (let i = 0, len = name.length; i < len; ++i) {
                    const c = name.codePointAt(i);
                    const s = name.substring(i, i + 1);
                    if (c === undefined || i == 0 && !An.isXmlNameStart_(c, s) || i != 0 && !An.isXmlName_(c, s)) {
                        d.warn_(`${MSG.string_(RS.InvalidCharacter_)}${s}, offset=${i}`);
                        okcallback(false);
                        return;
                    }
                }
                okcallback(true);
                callback(name);
            });
    }

    //////////////////////////////////////////////////////////////////////

    /**
       * @param def The optional default directory, with trailing /.
       * @return The current iframe document directory or the given default directory with trailing /.
       */
    static getCurrentDir_(def: stringX = null): string {
        const cpath = native$.getIFrameContextPath_();
        return cpath != null ? Basepath.dir_(cpath) + FS : (def != null ? def : PathUtil.getHomeDir());
    }

    /**
       * Note that callback is not called if there no suitable directory is found, eg. failed to create the default directory,
       * or error getting the fileinfo.
       * @return The directory path, which is either the current directory or a default directory, with trailing /.
       */
    static getAudioOutputDir_(callback: StringCallback): void {
        _Util._getCurrentDirInfo((dir, fileinfo) => {
            if (dir != null && fileinfo != null /* && PathUtil.isDocumentsSubtree(dir) */ && fileinfo.writable$) {
                callback(dir);
                return;
            }
            const d = PathUtil.getIncomingDir();
            fileinfoUt$.mkDirs_(d, ret => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                callback(d);
            });
        });
    }

    /**
     * Note that callback is not called if there no suitable directory is found, eg. failed to create the default directory,
     * or error getting the fileinfo.
     * @return The directory path, which is either the current directory or a default directory, with trailing /.
     */
    static getVideoOutputDir_(callback: StringCallback): void {
        _Util._getCurrentDirInfo((dir, fileinfo) => {
            if (dir != null && fileinfo != null /* && PathUtil.isDocumentsSubtree(dir) */ && fileinfo.writable$) {
                callback(dir);
                return;
            }
            const d = PathUtil.getIncomingDir();
            fileinfoUt$.mkDirs_(d, ret => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                callback(d);
            });
        });
    }

    /**
       * Note that callback is not called if there no suitable directory is found, eg. failed to create the default directory,
       * or error getting the fileinfo.
       * @return The directory path, which is either the current directory or a default directory, with trailing /.
       */
    static getNewPageDir_(callback: StringCallback): void {
        _Util._getCurrentDirInfo((dir, fileinfo) => {
            if (dir != null && fileinfo != null && fileinfo.writable$) {
                callback(dir);
                return;
            }
            callback(PathUtil.getDraftsDir());
        });
    }

    /**
       * @return The directory that contains the current iframe document, with trailing /, and its FileInfo.
       * Otherwise return null, null.
       */
    private static _getCurrentDirInfo(callback: (dir: stringX, fileinfo: FileInfo | null) => void): void {
        const cpath = native$.getIFrameContextPath_();
        const dir = cpath == null ? null : Basepath.dir_(cpath);
        if (cpath == null || dir == null) {
            callback(null, null);
            return;
        }
        fileinfoUt$.fileInfo_(dir, ret => {
            if (An.hasResult_(ret)) {
                callback(null, null);
                return;
            }
            callback(dir + FS, FileInfo.of_(ret[Key.fileinfo]));
        });
    }

    //////////////////////////////////////////////////////////////////////

    static getUriOfKind1_(button: HTMLElement, uri: Uri): Uri {
        const kind = DialogUt.getPathKind_(button);
        return Callbacks.getUriOfKind_(kind, uri);
    }

    static newPageFromTemplateName_(tname: string): void {
        const info = settings$.htmlTemplatesWithAliases_().get(tname);
        if (info === undefined) {
            toasters$.warnKey_(RS.InvalidTemplate);
            return;
        }
        _Util.onSaveOrDiscard_(() => {
            const cpath = _Util.defaultNewPageFilepath_(info);
            _Util.newPageFromTemplate1_(cpath, tname);
        });
    }

    static newPageFromTemplate1_(cpath: string, tname: string): void {
        fileinfoUt$.mkparent_(cpath, () => {
            
            const d = _Util.promptFilepath_(tname, FilepickerKind.WRITE_FILE, "", _Util.getCurrentDir_(), cpath);
            d.setDelegate_(FilepickerHtmlDelegate.singleton$);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((okcallback, path) => {
                okcallback(true);
                _Util.newPageFromTemplate3_(path, tname);
            });
            d.show_();
        });
    }

    static newPageFromTemplate3_(cpath: string, tname: string): void {
        host$.addPage_(cpath, tname, ret => {
            if (toasters$.error_(ret)) {
                return;
            }
            mainPanel$.addIFrameReadyOneshotCallback(next => mainPanel$.startEditCallback(next));
            _Util.browseFile_(cpath);
        });
    }

    static defaultNewPageFilename_(info: TemplateInfo): stringX {
        const now = DateTime.now_();
        const cat = info.cat$;
        if (cat == TemplateCat.Blog) {
            return An.to02d_(now.day$) + ".html";
        }
        return cat.toLowerCase() + "-" + An.simpleDateTimeString_(now) + ".html";
    }

    static defaultNewPageFilepath_(info: TemplateInfo): string {
        return _Util.getCurrentDir_() + _Util.defaultNewPageFilename_(info);
    }

    static getBlogMonthPath_(date: DateTime): string {
        const year = An.to04d_(date.year$);
        const month = An.to02d_(date.month$);
        return `${PathUtil.getHomeDir()}blog/${year}/${month}`;
    }

    static getBlogDayHtmlPath_(date: DateTime): string {
        const day = An.to02d_(date.day$);
        return `${this.getBlogMonthPath_(date)}/${day}/${day}.html`;
    }

    static _getTemplateFilename(info: TemplateInfo): stringX {
        const filename = info.template$;
        if (filename == null) {
            toasters$.error_(MSG.string_(RS.InvalidTemplate));
            return null;
        }
        return filename;
    }

    static getTemplateHtmlFromInfo_(info: TemplateInfo | null | undefined): stringX {
        if (info === null || info === undefined) return null;
        const filename = _Util._getTemplateFilename(info);
        if (filename == null) return null;
        const lccat = info.lcCat$;
        return `/assets/templates/${lccat}/${filename}`;
    }

    static getTemplateHtml_(name: string): stringX {
        const info = settings$.htmlTemplatesWithAliases_().get(name);
        if (info === undefined) { return null; }
        return _Util.getTemplateHtmlFromInfo_(info);
    }

    static openExisting_(cpath: string): void {
        mainPanel$.addIFrameReadyOneshotCallback(next => mainPanel$.startEditCallback(next));
        _Util.browseFile_(cpath);
    }

    static getImageOrientation_(imageinfo: MediaInfo): stringX {
        const w = imageinfo.width$;
        const h = imageinfo.height$;
        if (w != null && h != null) {
            return (w > h ? CSS.xLandscape : CSS.xPortrait);
        }
        return null;
    }

    static setImageOrientation_(attrs: StringMap<stringX>, imageinfo: MediaInfo | null): void {
        if (imageinfo != null) {
            const c = _Util.getImageOrientation_(imageinfo);
            if (c != null) {
                An.removeAddClasses_(attrs, [CSS.xLandscape, CSS.xPortrait], [c]);
            }
        }
    }

    static setImageOrientationOfElement_(target: HTMLElement, imageinfo: MediaInfo | null): void {
        if (imageinfo != null) {
            const c = _Util.getImageOrientation_(imageinfo);
            if (c != null) {
                native$.removeAddClasses_(target, [CSS.xLandscape, CSS.xPortrait], [c]);
            }
        }
    }

    static setImageOrientationOfPath_(attrs: StringMap<string>, cpath: string, callback: Fun00): void {
        host$.localImageInfo_(cpath, false, ret => {
            if (!An.hasResult_(ret)) {
                const imageinfo = MediaInfo.of_(ret[Key.result]);
                _Util.setImageOrientation_(attrs, imageinfo);
            }
            callback();
        });
    }

    static importBackupKey_(cpath: string, alias: string) {
        const d = new PromptImportKey(accessories$, settings$.dateFormat_(), cpath, native$.getIFrameDir_(), alias)
            .zindex_(DEF.zindexPrompt)
            .onOK_((alias, cpath, okcallback) => {
                host$.importBackupKey_(alias, cpath, (ret) => {
                    if (d.warn_(ret))
                        return okcallback(false);
                    okcallback(true);
                    toasters$.ok_(MSG.actionOK_(RS.Import));
                });
            })
            .show_();
    }

}

abstract class Sanitizers {

    static checkIsImageLcSuffix_(lcsuffix: string): IBotResult<boolean, string[]> {
        return (MimeUtil.isImageLcSuffix_(lcsuffix))
            ? BotResult.ok_(true)
            : BotResult.fail_([MSG.string1_(RS.UnsupportedFileType_, lcsuffix)]);
    }

    static checkIsImageUri_(uri: Uri): IBotResult<Uri, string[]> {
        return this.checkIsImageLcSuffix_(Basepath.lcSuffix_(uri.path$)).mapOK_(uri);
    }

    static checkIsImageFilepath_(path: string): IBotResult<string, string[]> {
        return this.checkIsImageLcSuffix_(Basepath.lcSuffix_(path)).mapOK_(path);
    }

    static checkIsSameSuffix_(uri: Uri, osuffix: string): IBotResult<Uri, string[]> {
        return (UriUt.lcSuffix_(uri) != osuffix)
            ? BotResult.fail_([MSG.string1_(RS.ExpectingFileExt_, osuffix)])
            : BotResult.ok_(uri);
    }

    static checkUri_(uri: Uri): IBotResult<Uri, string[]> {
        const errors = this.checkUri1_(sarray_(), uri);
        return (errors.length == 0) ? BotResult.ok_(uri) : BotResult.fail_(errors);
    }

    static checkRequiredUri_(uri: UriX): IBotResult<Uri, string[]> {
        return (uri == null) ? BotResult.failArrayKey_(RS.URLInputMustNotBeEmpty) : this.checkUri_(uri);
    }

    static checkImageUri_(uri: Uri): IBotResult<Uri, string[]> {
        return this.checkUri_(uri).ifOK_(uri => {
            return this.checkIsImageUri_(uri);
        });
    }

    static checkOptionalImageUri_(uri: UriX): IBotResult<UriX, string[]> {
        if (uri == null) return BotResult.ok_(null);
        return this.checkUri_(uri).ifOK_(uri => {
            return this.checkIsImageUri_(uri);
        });
    }

    static checkHref_(href: string, baseuri: BaseUriX): IBotResult<Uri, string[]> {
        const uri = An.parseUriSafe_(href, baseuri);
        if (uri == null) return BotResult.failArrayKey_(RS.InvalidURL);
        return this.checkUri_(uri);
    }

    static checkImageDataHref(href: string): IBotResult<Uri, string[]> {
        if (MimeUtil.isImageDataUrl_(href)) {
            const uri = An.parseUriSafe_(href, null);
            if (uri == null) return BotResult.failArrayKey_(RS.InvalidURL);
            return BotResult.ok_(uri);
        }
        return BotResult.failArrayKey_(RS.InvalidURL);
    }

    static checkImageHref_(href: string, baseuri: BaseUriX): IBotResult<Uri, string[]> {
        return this.checkImageDataHref(href).ifFail_(() => {
            return this.checkHref_(href, baseuri).ifOK_(uri => {
                return this.checkIsImageUri_(uri);
            });
        });
    }

    static checkOptionalHref_(href: string, baseuri: BaseUri): IBotResult<UriX, string[]> {
        if (href.length == 0 || href == ".") return BotResult.ok_(null);
        return this.checkHref_(href, baseuri);
    }

    static checkRequiredHref_(href: string, baseuri: BaseUriX): IBotResult<Uri, string[]> {
        if (href.length == 0 || href == ".") return BotResult.failArrayKey_(RS.URLInputMustNotBeEmpty);
        return this.checkHref_(href, baseuri);
    }

    static checkRequiredImageHref_(href: string, baseuri: BaseUriX): IBotResult<Uri, string[]> {
        if (href.length == 0 || href == ".") return BotResult.failArrayKey_(RS.URLInputMustNotBeEmpty);
        return this.checkImageHref_(href, baseuri);
    }

    static checkFilepath_(path: string): IBotResult<string, string[]> {
        const errors = sarray_();
        this.sanitizeFilepath_(path.split(FS), (e) => errors.push(e));
        return errors.length == 0 ? BotResult.ok_(path) : BotResult.fail_(errors);
    }

    static checkImageFilepath_(path: string): IBotResult<string, string[]> {
        return this.checkIsImageFilepath_(path).ifOK_(path => {
            return this.checkFilepath_(path);
        });
    }

    static checkRequiredImageFilepath_(path: string): IBotResult<string, string[]> {
        if (path.length == 0 || path == ".") return BotResult.failArrayKey_(RS.FilepathInputMustNotBeEmpty);
        return this.checkImageFilepath_(path);
    }

    static checkRequiredInputImage_(path: string, basedir: string, callback: BotResultCallback<string, string[]>): void {
        this.checkRequiredImageFilepath_(path).onFail_((_, result) => {
            callback(result);
        })?.onOK_(path => {
            const cpath = An.cpathOfFilepath2_(basedir, path);
            if (cpath == null) return callback(BotResult.failArrayKey_(RS.InvalidFilepath));
            fileinfoUt$.fileInfo_(cpath, ret => {
                const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (fileinfo == null || !fileinfo.exists$) {
                    callback(BotResult.failArrayKey_(RS.ImageNotFound));
                } else {
                    callback(BotResult.ok_(cpath));
                }
            });
        });
    }

    static checkRequiredImageOptionalLink_(src: string, link: string, baseuri: BaseUriX): IBotResult<[Uri, UriX], string[]> {
        if (src.length == 0) return BotResult.failArrayKey_(RS.URLInputMustNotBeEmpty);
        return Sanitizers.checkImageHref_(src, baseuri).ifOK_(srcuri => {
            if (link.length == 0) return BotResult.ok_([srcuri, null]);
            return Sanitizers.checkHref_(link, baseuri).ifOK_(uri => {
                const linkuri = An.addViewParam_(uri, baseuri);
                if (linkuri == null) return BotResult.fail_([MSG.string_(RS.InvalidURL)]);
                return BotResult.ok_([srcuri, linkuri]);
            });
        });
    }

    private static readonly _URI_PART_ILLEGAL = Ut.charcodes_("?#[]\u007f\\");
    private static _checkUriPart<T extends Array<string>>(errors: T, part: string): void {
        const illegals = new Array<Int>();
        for (const c of Ut.charcodes_(part)) {
            if (c === undefined || c < 0x20 || this._URI_PART_ILLEGAL.includes(c) || !Unicode$.isValidUnicode_(c)) {
                illegals.push(c ?? -1);
            }
        }
        if (illegals.length > 0) {
            errors.push(MSG.string_(RS.InvalidUriChar_) + this.escIllegals_(illegals));
        }
    }

    static checkUri1_(errors: string[], uri: Uri): string[] {
        this.sanitizeFilepath_(uri.pathSegments$, (e) => errors.push(e));
        if (uri.search$.length > 1) this._checkUriPart(errors, uri.search$.substring(1));
        if (uri.hash$.length > 1) this._checkUriPart(errors, uri.hash$.substring(1));
        return errors;
    }

    static checkTagAttrs2_(params: JSONObject, baseuri: BaseUriX, callback: Fun20<string[], JSONObject>): void {
        host$.sanitizeTagAttrs_(params, (ret) => {
            const errors = An.resultList_(ret);
            const sanitized = (ret[Key.attrs] as StringMap<stringX>);
            const style = sanitized ? sanitized["style"] : null;
            if (style) {
                cssParser$.sanitizeStyle_(style, baseuri, (ret1) => {
                    errors.push(...An.resultList_(ret1));
                    const styles = ret1[Key.style] as SStringMap;
                    if (styles) {
                        ret[Key.style] = styles;
                        sanitized["style"] = CSSUtil.joinStyles1_(Object.entries(styles));
                    }
                    callback(errors, ret);
                });
            }
            else {
                callback(errors, ret);
            }
        });
    }

    static checkTagAttrs_(tag: string, attr: string, baseuri: BaseUriX, callback: JSONCallback): void {
        if (tag.length == 0) return callback(smap1_(Key.errors, MSG.string_(RS.TagIsRequired)));
        this.checkTagAttrs2_(smap_(
            [Key.tag, tag],
            [Key.attrs, attr],
        ), baseuri, (errors, ret) => {
            if (errors.length > 0) return callback(smap1_(Key.errors, errors));
            callback(ret);
        });
    }

    static checkAttrs_(attr: string, baseuri: BaseUriX, callback: JSONCallback): void {
        this.checkTagAttrs2_(smap1_(Key.attrs, attr), baseuri, (errors, ret) => {
            if (errors.length > 0) return callback(smap1_(Key.errors, errors));
            callback(ret);
        });
    }

    static sanitizeFilepath_(segments: string[], onerror: Fun10<string>): void {
        const illegals = new Array<number>();
        for (let segment of segments) {
            this._sanitizeFilenameStrict0(illegals, segment, onerror);
        }
        if (illegals.length > 0) {
            onerror(MSG.string_(RS.InvalidFilenameCharacter_) + this.escIllegals_(illegals));
        }
    }

    private static _sanitizeFilenameStrict0(illegals: number[], filename: string, onerror: Fun10<string>): void {
        if (filename == null) {
            onerror(MSG.string_(RS.FilenameMustNotBeNull));
            return;
        }
        const len = filename.length;
        if (len == 0) return;
        if (filename.startsWith(".") && len != 1 && filename != "..") {
            onerror(MSG.string_(RS.FilenameMustNotStartsWithDot));
        }
        if (An.isWhitespace_(filename.codePointAt(0))) {
            onerror(MSG.string_(RS.FilenameMustNotStartsWithSpaces));
        }
        if (An.isWhitespace_(filename.codePointAt(len - 1))) {
            onerror(MSG.string_(RS.FilenameMustNotEndsWithSpaces));
        }
        this._sanitizeFilename1(illegals, filename, len);
    }

    static readonly _INVALID_FILENAME_CHARS: number[] = Ut.charcodes_("\\?#%;[]") as number[];
    static _sanitizeFilename1(
        illegals: number[], filename: string, len: number): void {
        for (let i = 0; i < len; ++i) {
            let c = filename.codePointAt(i) ?? -1;
            if (this._INVALID_FILENAME_CHARS.includes(c)) {
                illegals.push(c);
            } else if (c != 0x20 && An.isWhitespace_(c)) {
                illegals.push(c);
            }
        }
    }

    static escIllegals_(illegals: number[]): string {
        let b = "";
        for (let c of illegals) {
            if (c >= 0x20 && c < 0x7f && c != 0x5c /* "\\" */) {
                b += String.fromCharCode(c);
            } else {
                let s = c.toString(16).padStart(4, "0");
                b += `{0x${s}}`;
            }
        }
        return b.toString();
    }

    static onValidateStyles_(styles: Map<string, string>, baseuri: BaseUriX, callback: JSONCallback): void {
        if (styles.size > 0) {
            cssParser$.sanitizeStyle_(CSSUtil.joinStylesRemovingEmptyValues_(styles), baseuri, (ret) => {
                const sanitized = ret[Key.style];
                if (sanitized) {
                    for (const [key, value] of styles.entries()) {
                        if (value.trim().length == 0) {
                            sanitized[key] = "";
                        }
                    }
                    ret[Key.result] = sanitized;
                }
                callback(ret);
            });
        } else {
            callback(smap1_(Key.result, {}));
        }
    }

    static onValidateNonEmptyValues_(errors: string[], labels: Map<string, string>, d: ICompositeDialog, keys: string[]): void {
        for (const key of keys) {
            if (An.isempty_(d.getValue_(key))) {
                const label = labels.get(key);
                if (label !== undefined) {
                    errors.push(MSG.string1_(RS.inputMustNotBeEmpty_, label));
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////

class _ContextmenuBase extends ContextmenuBase {
    constructor(contextmenu: HTMLElement) {
        super(contextmenu);
        this.onTooltipsKey_(toasters$.onTooltipsKey_);
        this.onShow_(() => {
            if (this.smokescreen$ == null) {
                this.smokescreen$ = new Smokescreen(accessories$, An.zindexOf_(this._contextmenu, DEF.zindexUnder, DEF.zindexPrompt + DEF.zindexUnder));
            }
            this.smokescreen$.show_((sm: Smokescreen) => {
                const elm = sm.element_()!;
                _Util.createContentScroller_(elm, () => this.cancel_());
            });
        });
    }
}

class PageContextmenu extends _ContextmenuBase {
    constructor(container: HTMLElement) {
        super(PageContextmenu.createContextmenu(container));
        const b = new DomBuilderEx(this._contextmenu)
            .div1_(CSS.AnVerticalMenu)
            .div1_(CSS.AnVerticalViewport)
            .div1_(CSS.AnTextList, CSS.AnBulletList).push_();
        this._populate(b);
        if (Conf.useFlash$) {
            new Flash(b.pop_().cursor_(), `div[${ATTR.AnAction}]`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        this.onContextmenu_((_target, e) => {
            An.stopevent_(e);
        });
    }

    static createContextmenu(container: HTMLElement): HTMLElement {
        return new DomBuilderEx(container).div_({
            "class": CSS.AnContextmenu,
            "style": "display: none; visibility: hidden;",
            "name": NAME.contextmenuPage,
        }).cursor_();
    }

    private _populate(b: DomBuilderEx): void {
        b.push_();
        const map = settings$.htmlTemplates_();
        const infos = new Map<string, TemplateInfo>();
        for (const a of map.values()) {
            for (const info of a) {
                infos.set(info.name$, info);
            }
        }
        const sorted = Array.from(infos.entries()).sort((a, b) => a[0].localeCompare(b[0]));
        for (const [name, info] of sorted) {
            b.peek_()
                .div2_(ATTR.AnAction, name)
                .append1_("span", info.classes$)
                .text_(info.label$);
        }
        b.pop_();
    }

    hide_() {
        this.destroy_();
    }
}

///////////////////////////////////////////////////////////////////////

class GalleryContextmenu extends _ContextmenuBase {
    _descendingCheckbox: HTMLInputElement;
    _singleCheckbox: HTMLInputElement;
    _recursive1Checkbox: HTMLInputElement;
    _recursiveCheckbox: HTMLInputElement;
    _preserveCheckbox: HTMLInputElement;
    _largeThumbnails: HTMLInputElement;
    _scrollableThumbnails: HTMLInputElement;

    constructor(container: HTMLElement) {
        super(GalleryContextmenu.createContextmenu(container));
        const b = new DomBuilderEx(this._contextmenu)
            .div1_(CSS.AnVerticalMenu)
            .div1_(CSS.AnVerticalViewport)
            .table1_().push_();
        this._descendingCheckbox = this._createCheckbox(b, RS.Descending);
        this._singleCheckbox = this._createCheckbox(b, RS.SingleSection);
        this._largeThumbnails = this._createCheckbox(b, RS.ThumbnailLarge);
        this._scrollableThumbnails = this._createCheckbox(b, RS.ThumbnailScrollable);
        this._recursiveCheckbox = this._createCheckbox(b, RS.Recursive);
        this._recursive1Checkbox = this._createCheckbox(b, RS.Recursive1);
        this._preserveCheckbox = this._createCheckbox(b, RS.PreserveExisting, true, true);
        b.peek_().tr_().td_().hr2_("style", `height:0;width:100%;border-top:${DEF.themeBorder};`);
        for (const name of [
            TemplateName.homeSimpler,
            TemplateName.mediaSticker,
            TemplateName.mediaWall
        ]) {
            const info = settings$.htmlTemplatesWithAliases_().get(name);
            if (info === undefined) continue;
            b.peek_().tr1_().td_(
                ["class", CSS.AnBulletRow],
                [ATTR.AnAction, name],
            );
            b.append1_("span", info.classes$);
            b.text_(info.label$);
        }
        if (Conf.useFlash$) {
            new Flash(b.pop_().cursor_(), `td[${ATTR.AnAction}]`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        this.onContextmenu_((_elm, e) => {
            An.stopevent_(e);
        });
    }

    private static createContextmenu(container: HTMLElement): HTMLElement {
        return new DomBuilderEx(container).div_({
            "class": CSS.AnContextmenu,
            "style": "display: none; visibility: hidden;",
            "name": NAME.contextmenuGallery,
        }).cursor_();
    }

    private _createCheckbox(b: DomBuilderEx, textkey: StringId, checked: boolean = false, _border: boolean = false): HTMLInputElement {
        const row = b.push_().tr_().td1_(CSS.AnBulletRow).cursor_();
        const ret = b.input2_("type", "checkbox").cursor_() as HTMLInputElement;
        b.up_().text_(MSG.string_(textkey)).pop_();
        ret.checked = checked;
        An.onClick_(row, e => {
            const target = DomUt.asHTMLElement_(e.target);
            if (target != null && target.nodeName == "INPUT") return;
            An.stopevent_(e);
            ret.checked = !ret.checked;
        });
        return ret;
    }

    options_(): GalleryOptions {
        return new GalleryOptions(
            new GalleryGeneratorOptions(
                this._descendingCheckbox?.checked ?? false,
                this._singleCheckbox?.checked ?? false,
                this._largeThumbnails?.checked ?? false,
                this._scrollableThumbnails?.checked ?? false,
                this._preserveCheckbox?.checked ?? false,
            ),
            this._recursiveCheckbox?.checked ?? false,
            this._recursive1Checkbox?.checked ?? false,
        );
    }

    hide_(): void {
        super.destroy_();
    }
}

///////////////////////////////////////////////////////////////////////

class CSSClassesContextmenu extends _ContextmenuBase {
    private _input: HTMLTextAreaElement;
    constructor(
        container: HTMLElement,
        private readonly _classes: string[],
        private readonly _existing: string[],
        callback: Fun10<string>,
    ) {
        super(CSSClassesContextmenu._create(container));
        const b = new DomBuilderEx(this._contextmenu)
            .table1_(CSS.AnContextmenu).push_();
        this._input = this._createInput(b, (value) => {
            const ret = value.trim();
            if (!CSSUtil.validateClass(ret)) {
                toasters$.warnKey_(RS.InvalidCSSClassName);
                return;
            }
            this.destroy_();
            callback(ret);
        });
        b.peek_().tr_().td_().div_({
            "class": CSS.AnVerticalViewport,
            "style": "padding-top:5px;max-height:calc(75vh - 8ex);"
        }).div1_(CSS.AnTextList).push_();
        for (const name of this._classes) {
            b.peek_().div2_(ATTR.AnAction, name);
            if (this._existing.includes(name)) b.b_();
            b.text_(name);
        }
        if (Conf.useFlash$) {
            new Flash(b.pop_().cursor_(), `div[${ATTR.AnAction}]`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        this.onContextmenu_((_elm, e) => {
            An.stopevent_(e);
        });
        this.onAction_((action) => {
            this.destroy_();
            callback(action);
        });
        An.onContextmenuMatching_(this._contextmenu, `div[${ATTR.AnAction}]`, (elm, e) => {
            An.stopevent_(e);
            const name = elm.getAttribute(ATTR.AnAction) ?? "";
            DialogUt.confirm_(container, MSG.format1_(RS.ClientActionClassesConfirmDelete, name), (yes) => {
                if (yes) {
                    ArrayUt.delete_(this._classes, name);
                    elm.remove();
                }
            }).showWarning_();
        });
    }

    hide_() {
        this.destroy_();
    }

    private static _create(container: HTMLElement): HTMLElement {
        return new DomBuilderEx(container).div_({
            "class": CSS.AnContextmenu,
            "style": "display:none;visibility:hidden;",
            "name": NAME.contextmenuClasses,
        }).cursor_();
    }

    private _createInput(b: DomBuilderEx, callback: Fun10<string>): AnInputElement {
        const attrs = StringMap.copyOf_(INPUT.info_(INPUT.PromptInput));
        attrs["placeholder"] = _DialogUt.placeholder_(RS.ClientActionClassesPlaceholder);
        const input = b.push_().tr1_().td_({
            "class": CSS.AnFlexCenter,
            "style": "padding:10px;",
        }).child_(Conf.input$, attrs).cursor_() as AnInputElement;
        b.pop_();
        An.onInputFocusSelect_(this._input);
        An.onInputChange_(input, () => callback(input.value));
        An.onInputEnterKey_(input, () => callback(input.value));
        return input;
    }
}

////////////////////////////////////////////////////////////////////////

class ScribblerHandler implements IScribblerHandler {

    showKeyboard_(): void {
        host$.showKeyboard_();
    }

    hideKeyboard_(callback: Fun00): void {
        host$.hideKeyboard_(callback);
    }

    loadFont_(family: string, callback: Fun00): void {
        native$.onFontLoaded_(family, null, callback);
    }

    promptImportImage_(width: number, height: number, zindex: number, callback: PromptInputImageCallback): void {
        const basedir = native$.getIFrameDir_();
        if (basedir == null) {
            return;
        }
        _Util.promptInputImage_(RS.PickImage, basedir, width, height, zindex, callback).show_();
    }

    promptExportImage_(
        filepath: string,
        frompath: stringX,
        width: number,
        height: number,
        zindex: number,
        callback: PromptOutputImageCallback
    ): void {
        const basedir = native$.getIFrameDir_();
        if (basedir == null) return;
        _Util.promptOutputImage1_(
            (() => filepath), basedir, frompath, width, height, zindex,
            null, MediaUtil.optionalDimension_,
            callback, (d) => {
                d.setVisible_(_Util._XROTATION, false);
                d.setVisible_(_Util._XEFFECT, false);
                d.setVisible_(_Util._XADJUST, false);
                d.show_();
            });
    }

    info_(msg: TestResult, options?: ToasterAtBottomOption): void {
        toasters$.info_(msg, options);
    }

    warn_(msg: TestResult, options?: ToasterAtTopOption): boolean {
        return toasters$.warn_(msg, options);
    }

    ok_(msg: TestResult, options?: ToasterAtBottomOption): void {
        toasters$.ok_(msg, options);
    }

    warn0_(msg: TestResult): boolean {
        return toasters$.warn0_(msg);
    }

    getFileinfoUtil(): FileInfoUtil {
        return fileinfoUt$;
    }

    getSettings_(): Settings {
        return settings$;
    }

    saveImage_(cpath: string, dataurl: string, callback: JSONCallback): void {
        host$.saveBase64Image_(cpath, dataurl, callback);
    }

    getContextPath(href: string): stringX {
        return An.cpathOfHref2_(native$.getIFrameUri_(), href);
    }

}

//////////////////////////////////////////////////////////////////////

class ElementResizerInfo {

    constructor(
        readonly target: HTMLElement,
        readonly canReposition: boolean,
        readonly canResize: boolean,
        readonly canRotate: boolean,
        readonly position: string,
        readonly left: numberX,
        readonly top: numberX,
        readonly width: numberX,
        readonly height: numberX
    ) { }
}

class ElementResizer implements IDraggerHandler {
    static readonly _rotateRegex = new RegExp("^(.*?)rotate\\((.*?)\\)(.*)$", "i");
    _dragger: Dragger;

    _doneCallback: Fun00X = null;
    _rect0: MutRect | null = null;
    _path0: ArrayX<number> = null;
    _path: number[];
    _savedPath: number[];

    _style: CSSStyleDeclaration | null = null;
    _transform0: stringX = null;
    _angle0: numberX = null;
    _rotation0: number = 0.0;
    _rotation: number = 0.0;
    _hasPrefix: boolean = false;
    _match0: RegExpExecArray | null = null;
    #destroyed = false;

    constructor(
        private _smokescreen: Smokescreen,
        private _info: ElementResizerInfo
    ) {
        let x = 0;
        let y = 0;
        let w = 0;
        let h = 0;
        if (_info.canReposition) {
            x = _info.left == null ? 0 : Math.round(_info.left);
            y = _info.top == null ? 0 : Math.round(_info.top);
        }
        if (_info.canRotate) {
            this._style = _info.target.style;
            this._transform0 = (this._style == null ? null : this._style.transform);
            if (this._transform0 != null && this._transform0.length > 0) {
                this._match0 = ElementResizer._rotateRegex.exec(this._transform0);
                if (this._match0 != null) {
                    this._hasPrefix = this._match0[1].trim().length > 0;
                    this._rotation0 = this._parseRotation1(this._match0[2]);
                    this._rotation = this._rotation0;
                }
            }
        }
        if (_info.canResize) {
            w = _info.width == null ? 0 : Math.round(_info.width);
            h = _info.height == null ? 0 : Math.round(_info.height);
        }
        this._rect0 = new MutRect(x, y, w, h);
        this._savedPath = [x, y, x + w, y + h];
        this._normalize(this._savedPath);
        this._path = [];
        this._showValues(this._rect0, this._rotation0);
        this._dragger = new Dragger(_smokescreen.element_()!, this, new FrameLimiter(2));
    }

    onDone(cb: Fun00): void {
        this._doneCallback = cb;
    }

    bind(): void {
        if (this._info.canRotate && this._style == null) {
            toasters$.warn_(MSG.string_(RS.InvalidSelection), { attop: true });
            this.close();
            return;
        }
        this._dragger.bind_();
    }

    close(): void {
        this.destroy();
        if (this._doneCallback != null) {
            this._doneCallback();
        }
    }

    destroy(): void {
        if (this.#destroyed) { return; }
        this.#destroyed = true;
        this._dragger.destroy_();
        this._smokescreen.destroy_();
    }

    onDragstart_(dragger: Dragger, target: EventTarget, x: number, y: number): boolean {
        if (!this._info.canReposition && !this._info.canRotate && !this._info.canResize) {
            return false;
        }
        if (dragger.element_() !== target) {
            return false;
        }
        this._path = this._canvasloc1([], x, y);
        const state = dragger.state_();
        if (state.touches == 2) {
            if (this._info.canRotate) {
                this._rotation0 = this._rotation;
                this._angle0 = this._angle(state.pointers);
                
            }
            if (this._info.canResize) {
                this._path0 = An.intArrayCopy_([], state.pointers);
            }
        }
        
        return true;
    }

    onDragmove_(dragger: Dragger): void {
        const state = dragger.state_();
        const cx = this._csnapx(state.pageX);
        const cy = this._csnapy(state.pageY);
        
        const styles = this._info.target.style;
        if (state.touches == 2) {
            if (this._info.canRotate) {
                this._rotate(state);
            }
            if (this._info.canResize) {
                this._scale(state);
            }
            const snap = this._snaplist(this._savedPath);
            const r = An.getRect_(snap);
            if (this._info.canResize) {
                styles.width = `${r.w}px`;
                styles.height = `${r.h}px`;
            }
            this._showValues(r, this._rotation);
        } else {
            this._translate(cx, cy);
            const snap = this._snaplist(this._savedPath);
            const r = An.getRect_(snap);
            styles.left = `${r.x}px`;
            styles.top = `${r.y}px`;
            this._showValues(r, this._rotation);
        }
    }

    onDragend_(dragger: Dragger, e: UIEvent): void {
        An.stopevent_(e);
        const state = dragger.state_();
        if (!state.moved) {
            this.close();
        }
    }

    private _rotate(state: DraggerState): void {
        const angle = this._angle(state.pointers);
        if (this._angle0 == null) {
            this._angle0 = angle;
        }
        if (this._angle0 == null || angle == null || angle == this._angle0) return;
        const rotation = this._degree(angle - this._angle0);
        let degree = Math.round((this._rotation0 + rotation) * 2) / 2.0;
        while (degree > 180) {
            degree -= 360;
        }
        while (degree < -180) {
            degree += 360;
        }
        
        this._setTransform(degree);
    }

    private _scale(state: DraggerState): void {
        if (this._path0 == null) { return; }
        
        const dx0 = this._path0[2] - this._path0[0];
        const dy0 = this._path0[3] - this._path0[1];
        const a = An.intArrayCopy_([], state.pointers);
        
        const dx1 = a[2] - a[0];
        const dy1 = a[3] - a[1];
        const ddx = dx1 - dx0;
        const ddy = dy1 - dy0;
        if (ddx != 0 || ddy != 0) {
            if ((ddy > Dragger.THRESHOLD || ddy < -Dragger.THRESHOLD) || (ddx > Dragger.THRESHOLD || ddx < -Dragger.THRESHOLD)) {
                this._path0 = a;
                this._savedPath[2] += this._threshold(ddx, Dragger.THRESHOLD);
                this._savedPath[3] += this._threshold(ddy, Dragger.THRESHOLD);
                this._floor(this._savedPath, 2, 0);
                this._floor(this._savedPath, 3, 1);
            }
        }
    }

    private _translate(cx: number, cy: number): void {
        let dx = cx - this._path[0];
        let dy = cy - this._path[1];
        this._path[0] = cx;
        this._path[1] = cy;
        dx = this._threshold(dx, 3);
        dy = this._threshold(dy, 3);
        this._savedPath[0] += dx;
        this._savedPath[1] += dy;
        this._savedPath[2] += dx;
        this._savedPath[3] += dy;
    }

    private _floor(a: number[], i2: number, i1: number): void {
        if (a[i2] < a[i1]) {
            a[i2] = a[i1];
        }
    }

    private _showValues(r: MutRect, rotation: number): void {
        const msg = sarray_();
        if (this._info.canReposition) {
            msg.push(`${MSG.string_(RS.Position)}: ${r.x},${r.y}`);
        }
        if (this._info.canResize) {
            msg.push(`${MSG.string_(RS.Size)}: ${r.w}x${r.h}`);
        }
        if (this._info.canRotate) {
            msg.push(`${MSG.string_(RS.Rotation)}: ${rotation.toFixed(1)}`);
        }
        toasters$.info_(msg, { attop: true });
    }

    private _normalize(a: number[]): number[] {
        const swapx = (a[2] < a[0]);
        const swapy = (a[3] < a[1]);
        return swapx
            ? (swapy ? [a[2], a[3], a[0], a[1]] : [a[2], a[1], a[0], a[3]])
            : (swapy ? [a[0], a[3], a[2], a[1]] : [a[0], a[1], a[2], a[3]]);
    }

    private _threshold(dx: number, delta: number): number {
        return dx > 0 ? Math.max(0, dx - delta) : (dx < 0 ? Math.min(0, dx + delta) : 0);
    }

    private _canvasloc1(ret: number[], x: number, y: number): number[] {
        const cx = this._csnapx(x);
        const cy = this._csnapy(y);
        ret.push(cx);
        ret.push(cy);
        return ret;
    }

    private _snap(x: number, grid: number = 5): number {
        return (grid > 1) ? Math.round(x / grid) * grid : x;
    }

    private _csnapx(x: number, grid: number = 5): number {
        return Math.max(0, this._snap(x, grid));
    }

    private _csnapy(y: number, grid: number = 5): number {
        return Math.max(0, this._snap(y, grid));
    }

    private _snaplist(path: number[]): number[] {
        const ret = new Array<number>();
        for (let i = 0, len = path.length; i < len; ++i) {
            ret.push(this._snap(path[i]));
        }
        return ret;
    }

    private _degree(radian: number): number {
        return (radian * 180 / Math.PI);
    }

    private _angle(pointers: number[]): numberX {
        if (pointers != null && pointers.length >= 4) {
            const x0 = pointers[0];
            const y0 = pointers[1];
            const x1 = pointers[2];
            const y1 = pointers[3];
            let ret: number;
            if (y1 == y0) {
                ret = (x1 > x0) ? -Math.PI / 2 : Math.PI / 2;
            } else if (y1 > y0) {
                ret = -Math.atan((x1 - x0) * 0.2 / (y1 - y0));
            } else if (x1 >= x0) {
                ret = -Math.atan((x1 - x0) * 0.2 / (y1 - y0)) - Math.PI;
            } else {
                ret = -Math.atan((x1 - x0) * 0.2 / (y1 - y0)) + Math.PI;
            }
            
            return ret;
        }
        return null;
    }

    private _parseRotation1(s: string): number {
        const pair = An.doubleValueUnit_(s);
        if (pair == null) return 0.0;
        const unit = pair[1].toLowerCase();
        switch (unit) {
            case "rad":
                return this._degree(pair[0]);
            case "grad":
                return (pair[0] * 360 / 400);
            case "turn":
                return pair[0] * 360;
            default:
                return pair[0];
        }
    }

    private _setTransform(degree: number): void {
        if (degree == this._rotation) return;
        this._rotation = degree;
        const deg = degree.toFixed(1);
        const rotate = (deg == "0.0" || deg == "-0.0")
            ? "rotate(0deg)"
            : `rotate(${deg}deg)`;
        let tx: string;
        if (An.isempty_(this._transform0)) {
            tx = rotate;
        } else if (this._match0 == null) {
            tx = `${rotate} ${this._transform0}`.trim();
        } else {
            tx = `${this._match0[1]}${rotate}${this._match0[3]}`.trim();
        }
        if (this._style != null) {
            this._style.transform = tx;
        }
    }
}

class PinchZoomListener {
    _pointers: Array<number> = [];
    _dist1: number = 0;
    _center: Point<number> | null = null;
    _delta: number = 0.0;
    _subscriptions = new Array<Map<string, any>>();

    constructor(
        private _target: HTMLElement | Document,
        private _useTouch: boolean,
        private _callback: Fun21<Point<number> | null, number, number>
    ) {
        native$.iAddEventListener_(this._target, Conf.pointerstart$, (e) => this.onTouchStart(e), false);
    }

    onTouchStart(e: Event): void {
        this._pointers = this._useTouch
            ? this._touchPointers(e as TouchEvent)
            : this._mousePointers(e as MouseEvent, this._pointers);
        if (this._pointers.length == 0) {
            this._reset();
            return;
        }
        JsUtil.stopevent_(e);
        if (this._pointers.length < 4) return;
        
        this._subscriptions.push(native$.iAddEventListener_(this._target, Conf.pointermove$, (e) => this.onTouchMove(e), false));
        this._subscriptions.push(native$.iAddEventListener_(this._target, Conf.pointerend$, (e) => this.onTouchEnd(e), false));
        this._dist1 = An.dist1_(this._pointers, 0.0);
        this._delta = 0.0;
        const x0 = this._useTouch ? this._midx(this._pointers) : this._pointers[0];
        const y0 = this._useTouch ? this._midy(this._pointers) : this._pointers[1];
        this._center = new Point(x0, y0);
        this._callback(this._center, 0.0);
    }

    onTouchMove(e: Event): void {
        const pointers = this._useTouch
            ? this._touchPointers(e as TouchEvent)
            : this._mousePointers(e as MouseEvent, this._pointers);
        JsUtil.stopevent_(e);
        if (pointers.length == 0) return this._reset();
        if (pointers.length < 4) return;
        const dist1 = An.dist1_(pointers, null);
        
        if (dist1 != null) {
            this._delta = this._callback(null, this._delta + dist1 - this._dist1);
            this._dist1 = dist1;
        }
    }

    onTouchEnd(e: Event): void {
        const pointers = this._useTouch
            ? this._touchPointers(e as TouchEvent)
            : this._mousePointers(e as MouseEvent, this._pointers);
        JsUtil.stopevent_(e);
        
        if (pointers.length >= 4) {
            const dist1 = An.dist1_(pointers, null);
            if (dist1 != null) this._callback(null, this._delta + dist1 - this._dist1);
        }
        this._reset();
    }

    private _touchPointers(e: TouchEvent): Array<number> {
        const touches = Array.from(e.touches);
        const ret = [];
        if (touches.length == 2) {
            for (const touch of touches) {
                ret.push(Math.floor(touch.screenX));
                ret.push(Math.floor(touch.screenY));
            }
        }
        return ret;
    }

    private _mousePointers(e: MouseEvent, pointers: Array<number>): Array<number> {
        const ret = [];
        if (e.ctrlKey && e.buttons > 0) {
            if (pointers.length >= 2) {
                ret.push(pointers[0]);
                ret.push(pointers[1]);
            }
            ret.push(Math.floor(e.screenX));
            ret.push(Math.floor(e.screenY));
        }
        return ret;
    }

    private _reset(): void {
        
        this._pointers = [];
        this._dist1 = 0;
        this._center = null;
        this._delta = 0.0;
        native$.removeEventSubscriptions_(this._subscriptions);
        this._subscriptions = [];
    }

    private _midx(a: number[]): number {
        return (a[0] + a[2]) / 2;
    }

    private _midy(a: number[]): number {
        return (a[1] + a[3]) / 2;
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class _AlarmUtil {
    static createId_(ms: numberX = null): string {
        if (ms == null) ms = DateTime.ms_();
        return `${CSS.xAlarm}${ms}`;
    }
}

////////////////////////////////////////////////////////////////////////

abstract class _Hacks {
    static fixBody(): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc != null) {
            const body = idoc.body;
            if (body != null) {
                _Hacks.fixBodyXroot(idoc, body);
            }
        }
    }

    static fixBodyXroot(idoc: Document, body: HTMLElement): void {
        const html = idoc.documentElement;
        if (html != null) {
            html.style.height = "100%";
        }
        const iwidth = window.innerWidth;
        const iheight = window.innerHeight - cache$.ui$.toolbarHeight_();
        
        const style = body.style;
        style.width = `${iwidth}px`;
        style.maxWidth = `${iwidth}px`;
        style.padding = "0";
        style.margin = "0";
        style.height = `${iheight}px`;
        style.maxHeight = `${iheight}px`;
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class _COF {
    static readonly setsel = "XxXEl";
    static readonly getsel = "XxXvf";
    static readonly parse = "XxXP4";
    static readonly size = "XxXgs";
    static readonly onkeypress = "XxX2R";
    static readonly init = "XxXCy";
    static readonly edit = "XxXYf";
    static readonly onscroll = "XxXcN";
    static readonly find = "XxXpe";
    static readonly text = "XxXDb";
    static readonly undo = "XxX10";
    static readonly browse = "XxXMt";
    static readonly focus = "XxXGk";
    static readonly goto = "XxXyC";
    static readonly revert = "XxXbB";
    static readonly save = "XxX1B";
    static readonly down = "XxXz1";
    static readonly redo = "XxXTz";
}

abstract class CSSEditorBase extends DialogBase {
    static _LINECOL: RegExp = new RegExp("^(\\d+)(?:[:, ](\\d+))?\$");
    protected static readonly _TOP_MARGIN: number = 10;
    protected static readonly _LEFT_MARGIN: number = 20;
    protected _content!: HTMLIFrameElement;
    protected _editor!: any;
    protected _mainbar!: Toolbar;
    protected _mainLineInput!: HTMLTextAreaElement;
    protected _searchbar: Toolbar | null = null;
    protected _searchbox: HTMLTextAreaElement | null = null;
    protected _searchSpotlight: Spotlight | null = null;
    protected _searchLineInput: HTMLTextAreaElement | null = null;
    protected _contextmenu: Contextmenu | null = null;
    protected _editing: boolean = false;
    protected _modified: boolean = false;
    protected _selection = [1, 1];

    constructor(
        container: HTMLElement,
        protected _cpath: string,
        protected _editable: boolean,
        protected _startEdit: boolean,
        protected _initialContent: string,
        draghandler: IDraggerHandler | null,
    ) {
        super(container, draghandler);
        super.init_(this.create_(container));
        this.largeWidth_();
    }

    protected abstract create_(container: HTMLElement): HTMLElement;
    protected abstract _onCancel(): void;
    protected abstract _onOK(content: string, node: CSSNode, okcallback: Fun10<boolean>): void;
    protected abstract _initialContentOrTemplate(): string;

    protected _getContextmenu(): Contextmenu {
        if (this._contextmenu == null) {
            this._contextmenu = new Contextmenu(this.container_(), An.above_(this.element_()), [
                BUT.infos_(
                    BUT.CopyToLocalClipboard,
                    BUT.CutToLocalClipboard,
                    BUT.PasteFromLocalClipboard,
                ),
                BUT.infos_(
                    BUT.Redo,
                    BUT.Undo,
                ),
                BUT.infos_(
                    BUT.Folder,
                    BUT.Font,
                    BUT.Color,
                ),
            ]).onTooltips_(toasters$.onTooltipsKey_)
                .onDrag_(Contextmenu.contextmenuDragOK_)
                .onShow_(() => {
                    this._updateToolbarState();
                    this._updateContextmenuState();
                })
                .onAction_(action => this._contextActions(action));
        }
        return this._contextmenu;
    }

    private _notmodified(content: string): boolean {
        return content == this._initialContent || (this._initialContent.length == 0 && content == DEF.templateCSSRuleset);
    }

    protected _setuplinenumber(input: HTMLTextAreaElement): void {
        input.value = "1:1";
        An.onInputEnterKey_(input, () => {
            this._gotoline(input);
        });
        An.onChange_(input, () => {
            this._gotoline(input);
        });
    }

    private _gotoline(input: HTMLTextAreaElement): void {
        const value = input.value.trim();
        const match = CSSEditor._LINECOL.exec(value);
        if (match == null) {
            toasters$.warnKey_(RS.InvalidLineNumber);
            return;
        }
        const linestr = match[1];
        const colstr = match[2];
        const line = An.parseInt_(linestr, null);
        const ch = An.parseInt_(colstr, 1);
        if (line == null || line <= 0 || ch <= 0) {
            toasters$.warnKey_(RS.InvalidLineNumber);
            return;
        }
        
        this._searchSpotlight?.hide_();
        toasters$.hideAll_();
        host$.hideKeyboard_(() => {
            this._gotoline1(line, ch);
        });
    }

    protected _gotoline1(line: Int, ch: Int) {
        this._editor[_COF.goto](line, ch, (range: RangeX) => this._gotolineCallback(range));
    }

    private _gotolineCallback(range: RangeX): void {
        if (range == null) return;
        
        this._spotlight(range);
    }

    /// @param line 1-based line number.
    /// @param ch 1-based column number.
    protected _onselectionchanged(line: number, ch: number): void {
        this._selection = [line, ch];
        const value = (line == null ? "" : `${line}:${ch}`);
        this._mainLineInput.value = value;
        if (this._searchLineInput != null) {
            this._searchLineInput.value = value;
        }
    }

    onResize_(): void {
    }

    protected actionNextMatch() {
        if (this._searchbar == null) return;
        An.toggleButtonOn_(this._searchbar.button_(BUT.NextMatch));
        An.toggleButtonOff_(this._searchbar.button_(BUT.PrevMatch));
        this._search(false);
    }

    protected _toolbarActions(action: string, e: MouseEvent) {
        toasters$.hideAll_();
        if (this._editor == null) return;
        switch (action) {
            case BUT.Toolbar1:
                this._showSearchbar();
                break;
            case BUT.Toolbar2:
                this._showMainbar();
                break;
            case BUT.NextMatch:
                this.actionNextMatch();
                break;
            case BUT.PrevMatch:
                if (this._searchbar != null) {
                    An.toggleButtonOff_(this._searchbar.button_(BUT.NextMatch));
                    An.toggleButtonOn_(this._searchbar.button_(BUT.PrevMatch));
                    this._search(true);
                }
                break;
            case BUT.RulesetAdd:
                
                this._editor[_COF.text](DEF.templateCSSRuleset);
                this._updateToolbarState();
                break;
            case BUT.RuleAdd:
                
                this._editor[_COF.text](DEF.templateCSSRule);
                this._updateToolbarState();
                break;
            case BUT.Discard:
                this._actionDiscard();
                break;
            case BUT.Cancel:
                this._onCancel();
                break;
            case BUT.OK:
                this._actionOK();
                break;
            case BUT.Save:
                this._actionSave();
                break;
            case BUT.Edit:
                if (this._editable) {
                    this._onedit();
                }
                break;
            case BUT.Contextmenu:
                this._getContextmenu().show_(e);
                break;
            default:
                this.actionInvalid_(action);
        }
    }

    protected _showSearchbar() {
        if (this._searchbar == null) return;
        this._mainbar.hide_();
        this._searchbar.show_();
        Timer.sleep00_(() => {
            if (this._searchbox == null) return;
            this._searchbox.focus();
            const sel: stringX = this._editor[_COF.getsel]();
            if (sel != null) this._searchbox.value = sel;
        });
    }

    protected _showMainbar() {
        this._searchbar?.hide_();
        this._mainbar.show_();
    }

    private _actionDiscard() {
        if (this._editable && this._editing) {
            host$.hideKeyboard_(() => {
                const content = this._editor[_COF.save]();
                if (this._notmodified(content)) {
                    if (this._startEdit) {
                        this._onCancel();
                    } else {
                        this._onsaved();
                    }
                } else {
                    DialogUt.confirmKeySmall_(accessories$, RS.ConfirmDiscard, An.above_(this.element_()), (yes: boolean) => {
                        if (!yes) return;
                        if (this._startEdit) {
                            this._onCancel();
                        } else {
                            this._onrevert();
                        }
                    });
                }
            });
        } else {
            this._onCancel();
        }
    }

    private _actionOK() {
        host$.hideKeyboard_(() => {
            
            const content = this._editor[_COF.save]();
            const [node, errors] = this._editor[_COF.parse](content);
            if (CSSEditor._onerror(errors, content)) {
                return;
            }
            this._onOK(content, node as CSSNode, (ok) => {
                this.actionOKConfirmed_(ok);
            });
        });
    }

    private _actionSave() {
        if (this._editable) {
            host$.hideKeyboard_(() => {
                
                const content = this._editor[_COF.save]();
                const [node, errors] = this._editor[_COF.parse](content);
                if (CSSEditor._onerror(errors, content)) {
                    return;
                }
                this._onOK(content, node, (ok) => {
                    if (!ok) return;
                    if (this._startEdit) {
                        this._onCancel();
                    } else {
                        this._onsaved();
                    }
                });
            });
        }
    }

    static _onerror(errors: Array<[number, string]>, content: string): boolean {
        if (errors.length == 0) { return false; }
        const msgs = [MSG.string_(RS.CSSSyntaxError_)];
        const linemap = new LineMap(content);
        for (const [offset, msg] of errors) {
            if (msgs.length > 10) {
                msgs.push("...");
                break;
            }
            msgs.push(`@${linemap.lineCol(offset)}: ${msg}`);
        }
        toasters$.warn_(msgs, { attop: true });
        return true;
    }

    private _onrevert(): void {
        this._editor[_COF.revert](this._initialContentOrTemplate());
        this._onsaved();
    }

    private _onsaved(): void {
        this._editing = false;
        this._updateToolbarState();
        this._editor[_COF.browse]();
    }

    protected _onedit(): void {
        this._editor[_COF.edit]();
        this._editing = true;
        this._updateToolbarState();
    }

    protected _updateToolbarState(): void {
        this._mainbar.showButton_(BUT.Cancel, !this._editing);
        this._mainbar.showButton_(BUT.Edit, this._editable && !this._editing);
        this._mainbar.showButtons_([
            BUT.Contextmenu,
            BUT.RulesetAdd,
            BUT.Discard,
            BUT.Save
        ], this._editable && this._editing);
    }

    protected _contextActions(action: string) {
        toasters$.hideAll_();
        if (this._editor == null) return;
        if (!this._editing) return;
        const contextmenu = this._getContextmenu();
        switch (action) {
            case BUT.Redo:
                 ``;
                this._editor[_COF.redo]();
                this._updateContextmenuState();
                break;
            case BUT.Undo:
                
                this._editor[_COF.undo]();
                this._updateContextmenuState();
                break;
            default: {
                contextmenu.hide_();
                switch (action) {
                    case BUT.CopyToLocalClipboard: {
                        const text = this._editor[_COF.getsel]();
                        if (text != null) clipboard$.string_(text);
                        break;
                    }
                    case BUT.CutToLocalClipboard: {
                        const text = this._editor[_COF.getsel]();
                        if (text != null) {
                            clipboard$.string_(text);
                            this._editor[_COF.text]("");
                        }
                        break;
                    }
                    case BUT.PasteFromLocalClipboard: {
                        const content = clipboard$.get_();
                        if (content != null) {
                            const value = native$.getClipboardText_(content);
                            this._editor[_COF.text](value);
                        } else {
                            toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
                        }
                        break;
                    }
                    case BUT.Font:
                        host$.hideKeyboard_(() => {
                            const d = _Util.promptFont_("", An.above_(this.element_()));
                            d.onOK_((familystyle: string) => {
                                this._editor[_COF.text](familystyle);
                            });
                            d.show_();
                        });
                        break;
                    case BUT.Color:
                        host$.hideKeyboard_(() => {
                            const sel = this._editor[_COF.getsel]();
                            const d = Callbacks.promptColor_(cache$.ui$.buttonSize_(), An.above_(this.element_()), sel, ColorValue.X_WHITE);
                            d.onOK_((c, format) => {
                                if (c != null) {
                                    this._editor[_COF.text](ColorUtil.formatCSSString_(format, c));
                                }
                            });
                            d.show_();
                        });
                        break;
                    case BUT.Folder:
                        host$.hideKeyboard_(() => {
                            this._actionFilepath();
                        });
                        break;
                    case BUT.Indent:
                        this._actionIndent();
                        break;
                    default:
                        this.actionInvalid_(action);
                }
            }
        }
    }

    private _actionIndent() {
        
        const dir = Basepath.dir_(this._cpath);
        const dir1 = dir == null ? null : An.ensureTrailingSlash_(dir);
        const baseuri = dir1 == null ? null : An.uriOfFilepath2_(null, dir1);
        if (baseuri == null) {
            toasters$.warn_(MSG.string_(RS.ParameterMissingBaseurl));
            return;
        }
        FormatOptions.getPreference((options) => {
            const content = this._editor[_COF.save]();
            const errors = sarray_();
            const formatted = CSSFormatter.formatStylesheet_(content, options);
            
            
            if (toasters$.warn_(errors)) return;
            if (formatted.replace(RX.Spaces_g, "") != content.replace(RX.Spaces_g, "")) {
                toasters$.warnKey_(RS.FormatActionError);
                return;
            }
            this._editor[_COF.revert](formatted);
        });
    }

    protected _updateContextmenuState(): void {
        const contextmenu = this._getContextmenu();
        if (this._editor == null || !this._editable) {
            contextmenu.enableButton_(BUT.Redo, false);
            contextmenu.enableButton_(BUT.Undo, false);
            return;
        }
        const status = this._editor[_COF.size]();
        const redocount = status["redo"];
        const undocount = status["undo"];
        contextmenu.enableButton_(BUT.Redo, redocount > 0);
        contextmenu.enableButton_(BUT.Undo, undocount > 0);
        contextmenu.enableButton_(BUT.PasteFromLocalClipboard, !clipboard$.isEmpty_());
    }

    private _search(backward: boolean): void {
        this._searchSpotlight?.hide_();
        toasters$.hideAll_();
        host$.hideKeyboard_(() => {
            if (this._searchbox == null) return;
            const query = this._searchbox.value;
            this._editor[_COF.find](query, backward, true, (range: RangeX) => {
                if (range == null) {
                    toasters$.warn_(MSG.string_(RS.NoMatchFound));
                    return;
                }
                this._spotlight(range);
            });
        });
    }

    private _spotlight(range: RangeX): void {
        if (range == null) return;
        Timer.sleep0_(() => {
            const rect = range.getBoundingClientRect();
            
            if (rect.top == 0 && rect.left == 0 && rect.width == 0 && rect.height == 0) return;
            const top = rect.top + cache$.ui$.toolbarHeight_();
            this._searchSpotlight?.show_(
                rect.left + CSSEditor._LEFT_MARGIN,
                top + CSSEditor._TOP_MARGIN,
                rect.width,
                rect.height,
                () => this._searchSpotlight?.hide_());
            this._editor[_COF.onscroll](() => this._spotlightOff());
        });
    }

    protected _spotlightOff(): void {
        this._searchSpotlight?.hide_();
    }

    protected _searchOff(): void {
        this._searchbar?.hide_();
        this._mainbar.show_();
    }

    close_(): void {
        this._editor = null;
        this._contextmenu?.destroy_();
        this._contextmenu = null;
        super.close_();
    }

    private _actionFilepath(): void {
        const dir = Basepath.dir_(this._cpath);
        const dir1 = dir == null ? null : An.ensureTrailingSlash_(dir);
        const baseuri = dir1 == null ? null : An.uriOfFilepath2_(null, dir1);
        if (baseuri == null || dir == null || dir1 == null) {
            toasters$.warn_(MSG.string_(RS.ParameterMissingBaseurl));
            return;
        }
        let sel = this._editor[_COF.getsel]();
        if (An.isempty_(sel)) {
            this._actionFilepath1(dir, dir1, baseuri);
            return;
        }
        const cpath = An.cpathOfHref2_(baseuri, sel);
        if (cpath == null) {
            this._actionFilepath1(dir, dir1, baseuri);
            return;
        }
        fileinfoUt$.fileInfo_(cpath, ret => {
            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
            if (An.hasResult_(ret[Key.errors]) || fileinfo == null) {
                this._actionFilepath1(dir, dir1, baseuri);
                return;
            }
            Callbacks.copyToSystemClipboard_(RS.CopiedToSystemClipboard_, cpath, () => {
                if (!fileinfo.exists$) {
                    this._actionFilepath1(dir, dir1, baseuri);
                    return;
                }
                this._actionFilepath1(dir, cpath, baseuri);
            });
        });
    }

    private _actionFilepath1(dir: string, opath: string, baseuri: BaseUri): void {
        const d = _Util.promptFilepathKey_(RS.Filepath, FilepickerKind.ANY, "", dir, opath);
        d.above_(this.element_());
        d.setDelegate_(FilepickerLinkDelegate.singleton$);
        d.onOK_((okcallback, cpath) => {
            okcallback(true);
            const href = An.uriOfFilepath2_(baseuri, cpath)?.toString() ?? null;
            if (href == null) {
                toasters$.warn_(MSG.string_(RS.InvalidURL));
                return;
            }
            Callbacks.copyToSystemClipboard_(RS.CopiedToSystemClipboard_, href, () => {
                this._editor[_COF.text](href);
            });
        });
        d.show_();
    }
}

class StyleEditor extends CSSEditorBase {
    private static _REGEX = new RegExp("^.*?\\{(.*)\\}.*?$", "s");
    private _okCallback: Fun20X<string, Fun10<boolean>> = null;
    constructor(
        container: HTMLElement,
        cpath: string,
        initialcontent: string,
    ) {
        super(container, cpath, true, true, initialcontent, new DialogDraggerHandler());
    }

    protected create_(container: HTMLElement): HTMLElement {
        const ret = this.createDialog_(
            container,
            (top) => this._createContent(top),
            (top) => this._createToolbar(top),
            (action, e) => this._toolbarActions(action, e));
        return ret;
    }

    private _createToolbar(top: HTMLElement): Toolbar {
        this._mainbar = new Toolbar(top, [
            INPUT.info_(INPUT.LineNumber),
            BUT.info_(BUT.Spacer),
            BUT.info_(BUT.Contextmenu),
            BUT.info_(BUT.OK),
            BUT.info_(BUT.Cancel),
        ]);
        this._mainbar.onAction_((action, e) => this._toolbarActions(action, e));
        this._mainLineInput = this._mainbar.querySelector_(`${Conf.input$}.${CSS.AnLineNumberInput}`) as AnInputElement;
        this._setuplinenumber(this._mainLineInput);
        return this._mainbar;
    }

    private _createContent(top: HTMLElement): void {
        const b = new DomBuilderEx(top).addStyles_(smap_(
            ["display", "flex"],
            ["margin-top", "5px"],
            [PK.Border, "1px solid rgba(0, 0, 0, 0.5)"],
            [PK.BorderRadius, "5px"],
        ));
        this._content = b.iframe_({
            "seamless": "true",
            "border": "0",
            "sandbox": "allow-same-origin allow-scripts",
            "style": "width:100%;height:32ex;max-height:40vh;border:none;",
            "src": PATH._assetsCSSEditorHtml,
        }).cursor_() as HTMLIFrameElement;
        An.onLoad_(this._content, () => {
            
            const content = this._initialContentOrTemplate();
            this._editor = native$.cssEditor_(this._content, content, settings$.fontFaces_(), (line: number, ch: number) => {
                this._onselectionchanged(line, ch);
            });
            this._editor[_COF.focus](() => this._searchOff());
            this._editor[_COF.down](() => this._spotlightOff());
            if (this._editable && this._startEdit) this._onedit();
        });
    }

    protected _updateToolbarState(): void {
    }

    protected _onCancel(): void {
        host$.hideKeyboard_(() => {
            if (!this._modified) {
                this.actionCancelConfirmed_();
                return;
            }
            DialogUt.confirmKeySmall_(accessories$, RS.ConfirmDiscard, An.above_(this.element_()), (yes: boolean) => {
                if (!yes) return;
                this.actionCancelConfirmed_();
            });
        });
    }

    protected _initialContentOrTemplate(): string {
        return MSG.string_(RS.StyleEditorHint) + " {\n  " + this._initialContent + "\n}";
    }

    protected _onOK(content: string, node: CSSNode, okcallback: Fun10<boolean>) {
        
        content = content.trim();
        if (content.length >= 0) {
            if (!CSSParser.hasSingleRuleset_(node)) {
                this.warn_(MSG.string_(RS.StyleEditorExpectingSingleRulesetOnly));
                okcallback(false);
                return;
            }
            const m = StyleEditor._REGEX.exec(content);
            if (m == null) {
                this.warn_(MSG.string_(RS.ErrorParsingStyle));
                okcallback(false);
                return;
            }
            content = m[1].trim();
        }
        this._okCallback?.(content, okcallback);
    }

    onOK_(callback: Fun20<string, Fun10<boolean>>): this {
        this._okCallback = callback;
        return this;
    }
}

class CSSEditor extends CSSEditorBase {
    constructor(
        container: HTMLElement,
        private _gestureHandler: IGestureHandler | null,
        cpath: string,
        editable: boolean,
        startedit: boolean,
        initialcontent: string,
        private _initialPosition: [Int, Int] | null,
    ) {
        super(container, cpath, editable, startedit, initialcontent, null);
    }

    protected create_(container: HTMLElement): HTMLElement {
        const ret = this.createFullscreenDialog_(
            container,
            (b) => this._createFullscreenToolbar(b),
            (b) => this._createFullscreenContent(b));
        this._searchSpotlight = new Spotlight(ret, DEFUtil.searchHighlightDuration$);
        return ret;
    }

    createFullscreenDialog_(
        container: HTMLElement,
        toolbarcreator: (b: DomBuilderEx) => Toolbar,
        contentcreator: (b: DomBuilderEx) => void
    ): HTMLElement {
        const b = DomBuilderEx.offline_(container.ownerDocument, "table", {
            "class": CSS.AnWindow,
            "style": "display: none; visibility: hidden;",
        }).push_();
        const ret = b.cursor_();
        this._toolbar = toolbarcreator(b.tr_().td_());
        contentcreator(b.pop_().tr_().td_());
        container.append(ret);
        return ret;
    }

    show_(): this {
        if (this._shown) {
            return this;
        }
        this._shown = true;
        An.showHidden_(this._dialog, "block");
        this._onWindowResize(() => this.onResize_());
        if (this._gestureHandler != null) this._gestureHandler.pause_();
        return this._show();
    }

    close_(): void {
        if (this._gestureHandler != null) {
            this._gestureHandler.resume_();
            this._gestureHandler = null;
        }
        super.close_();
    }

    private _createFullscreenToolbar(b: DomBuilderEx): Toolbar {
        this._mainbar = FullscreenDialogBase.fullscreenToolbarCreator_(b, null, [
            INPUT.info_(INPUT.LineNumber),
            BUT.info_(BUT.Spacer),
            BUT.info_(BUT.Contextmenu),
            BUT.info_(BUT.RulesetAdd),
            BUT.info_(BUT.Edit),
            BUT.info_(BUT.Discard),
            BUT.info_(BUT.Cancel),
            BUT.info_(BUT.Save),
            BUT.info_(BUT.Toolbar1),
        ]);
        this._mainbar.showButton_(BUT.Edit, this._editable);
        this._mainbar.showButtons_([
            BUT.Contextmenu,
            BUT.RulesetAdd,
            BUT.Discard,
            BUT.Save], false);
        this._mainbar.onAction_((action, e) => this._toolbarActions(action, e));
        this._mainLineInput = this._mainbar.querySelector_(`${Conf.input$}.${CSS.AnLineNumberInput}`) as AnInputElement;
        this._searchbar = new Toolbar(b.cursor_(), [
            INPUT.info_(INPUT.LineNumber),
            BUT.info_(BUT.Spacer),
            INPUT.info_(INPUT.SearchBox),
            BUT.info_(BUT.NextMatch),
            BUT.info_(BUT.PrevMatch),
            BUT.info_(BUT.Toolbar2),
        ]);
        this._searchbar.onAction_((action, e) => this._toolbarActions(action, e));
        this._searchbar.onTooltips_(toasters$.onTooltipsKey_);
        this._searchbar.hide_();
        this._searchbar.element_().style.width = "100vw";
        this._searchLineInput = this._searchbar.querySelector_(`${Conf.input$}.${CSS.AnLineNumberInput}`) as AnInputElement;
        const searchbox = this._searchbar.querySelector_(`${Conf.input$}.${CSS.AnSearchbox}`) as AnInputElement;
        this._searchbox = searchbox;
        An.onFocus_(searchbox, () => {
            toasters$.hideAll_();
            An.select_(searchbox);
        });
        An.onKeypress_(searchbox, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this.actionNextMatch();
            }
        });
        this._setuplinenumber(this._mainLineInput);
        this._setuplinenumber(this._searchLineInput);
        return this._mainbar;
    }

    private _createFullscreenContent(b: DomBuilderEx): void {
        this._content = b.iframe_({
            "seamless": "true",
            "border": "0",
            "sandbox": "allow-same-origin allow-scripts",
            "style": `height: calc(100vh - ${cache$.ui$.toolbarHeight_()}px);` +
                " width: 100vw;" +
                " box-sizing: border-box;" +
                ` padding: ${CSSEditor._TOP_MARGIN}px 10px 10px ${CSSEditor._LEFT_MARGIN}px;`,
            "src": PATH._assetsCSSEditorHtml,
        }).cursor_() as HTMLIFrameElement;
        An.onLoad_(this._content, () => {
            
            const content = this._initialContentOrTemplate();
            this._editor = native$.cssEditor_(this._content, content, settings$.fontFaces_(), (line: number, ch: number) => {
                this._onselectionchanged(line, ch);
            });
            this._editor[_COF.focus](() => this._searchOff());
            this._editor[_COF.down](() => this._spotlightOff());
            this._editor[_COF.onkeypress]((e: KeyboardEvent) => {
                if (e.ctrlKey && (e.key == "f" || e.key == "F")) {
                    An.stopevent_(e);
                    if (e.shiftKey) this._showMainbar();
                    else this._showSearchbar();
                }
            });
            if (this._initialPosition != null) {
                this._gotoline1(this._initialPosition[0], this._initialPosition[1]);
            }
            if (this._editable && this._startEdit) this._onedit();
        });
    }

    protected _show(): this {
        this.onResize_();
        Timer.sleep00_(() => {
            An.setVisible_(this.element_());
        });
        return this;
    }

    protected _initialContentOrTemplate(): string {
        return this._initialContent.length > 0 ? this._initialContent : DEF.templateCSSRuleset;
    }

    protected _onCancel(): void {
        host$.updateSessionPreferences_(json1_(SessionPreferencesKey.filePositions, [this._cpath, this._selection]), (ret) => {
            toasters$.warn_(ret);
            if (!this._modified) {
                this.actionCancelConfirmed_();
                return;
            }
            mainPanel$.onSaveCSS(this._cpath, () => {
                this.actionCancelConfirmed_();
            });
        });
    }

    protected _onOK(content: string, _node: CSSNode, okcallback: Fun10<boolean>): this {
        const infos = json_();
        infos[XrefKey.POSITION] = this._selection;
        host$.saveCSS_(this._cpath, content, infos, (ret) => {
            if (toasters$.warn_(ret)) {
                okcallback(false);
                return;
            }
            if (!this._modified && content != this._initialContent) {
                this._modified = true;
            }
            this._initialContent = content;
            okcallback(true);
        });
        return this;
    }
}

////////////////////////////////////////////////////////////////////////

type IFrameReadyCallback = (next: Fun00) => void;

interface IFrameMediaViewer {
    content_(): HTMLElement;
    show_(): void;
    hide_(): void;
    resize_(): void;
    onclick_(callback: IFrameEventCallback): void;
    onPause_(): void;
    onResume_(): void;
}

interface IIFrameImageViewer extends IFrameMediaViewer {
    rotate_(): void;
    export_(callback: Fun10<string>): void;
    filter_(name: string, value: string, toggle: boolean): string;
    getVisibleRegion_(): [MutRect, Int, Double];
}

interface _IClientAction {
    run_(button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>): void;
}

class ClientActionInfo {
    private static _regex = RegExp("^(.*?)[/,].*");
    static of_(json: JSONObjectX): ClientActionInfo | null {
        if (json == null) return null;
        return new ClientActionInfo(json);
    }
    private constructor(private readonly json$: JSONObject) {
    }
    public action1_(): string | null {
        const action = JSONUt.string(this.json$, TemplateMenuKey.action, null);
        if (action == null || action.length == 0) return null;
        const m = action.match(ClientActionInfo._regex);
        return m == null ? action : m[1];
    }
    public static actionOf_(action: string): string {
        const ret = action.split(FS);
        return (ret.length < 1) ? "" : ret[0];
    }
    public action_(): [string[], string[], string, string, string] | null {
        const ret = JSONUt.string(this.json$, TemplateMenuKey.action, null)?.split(FS) ?? null;
        if (ret == null || ret.length < 1) return null;
        let action = ret.splice(0, 1)[0].split(RX.CommaSeparated);
        if (ret.length < 1 || action.length < 1) return null;
        const [markers, context, parent, singleton] = this._markers(ret);
        if (markers == null) return null;
        return [action, markers, context, parent, singleton];
    }
    private _markers(a: string[]): [string[] | null, string, string, string] {
        const markers = CSSUtil.validateClassesOf(a[0]);
        const context = a.length > 1 ? a[1] : "";
        const parent = a.length > 2 ? a[2] : "";
        const singleton = a.length > 3 ? a[3] : "";
        return [markers, context, parent, singleton];
    }
    public classes_(): string[] | null {
        return JSONUt.string(this.json$, TemplateMenuKey.classes, null)?.split(RX.Spaces).filter(s => s.length > 0) ?? null;
    }
}

/// This action should only be active in editing mode.
class _ClientActionAnnotation implements _IClientAction {
    private constructor() { }
    static parse_(editing: boolean): _ClientActionAnnotation | null {
        if (!editing) return null;
        return new _ClientActionAnnotation();
    }
    static from_(editing: boolean): _ClientActionAnnotation | null {
        return this.parse_(editing);
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        if (toasters$.warn_(JsUtil.actionWrapOK_(range)) || range == null) {
            callback?.(range);
            return;
        }
        _WidgetTemplates._annotation(range, native$.getIFrameUri_(), () => {
            callback?.(range);
        });
    }
}

/// This action should only be active in editing mode.
class _ClientActionDelete implements _IClientAction {
    private constructor(private _markers: string[]) { }
    static parse_(editing: boolean, a: string[], markers: string[]): _ClientActionDelete | null {
        if (!editing) return null;
        if (a.length < 2 || a[1].length == 0) return null;
        return new _ClientActionDelete(markers);
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionDelete | null {
        if (!editing) return null;
        return With.notnull_(info.action_(), ([_action, markers]) => {
            return new _ClientActionDelete(markers);
        });
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        const node = native$.getTemplateMarker_(range, null, this._markers);
        const marker = _MainPanel.getmarker_(node, this._markers);
        if (marker != null) {
            if (node == null) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                callback?.(null);
                return;
            }
            _Util.confirmSmall_(MSG.format1_(RS.confirmDeletingTemplateInstance, marker), DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                JsUtil.remove_(node);
                callback?.(null);
            });
        }
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionDrag implements _IClientAction {
    private constructor(private _markers: string[]) { }
    static parse_(_editing: boolean, a: string[], markers: string[]): _ClientActionDrag | null {
        if (a.length < 2 || a[1].length == 0) return null;
        return new _ClientActionDrag(markers);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionDrag | null {
        return With.notnull_(info.action_(), ([_action, markers]) => {
            if (markers.length < 1) return null;
            return new _ClientActionDrag(markers);
        });
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        const elm = native$.getTemplateMarker_(range, null, this._markers);
        const marker = _MainPanel.getmarker_(elm, this._markers);
        if (marker != null) {
            if (elm == null) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                callback?.(range);
                return;
            }
            mainPanel$.actionEditSize0_(elm, () => {
                callback?.(range);
            });
        }
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionMove implements _IClientAction {
    private constructor(
        private _marker: string
    ) { }
    static parse_(_editing: boolean, _a: string[], markers: string[]): _ClientActionMove | null {
        return new _ClientActionMove(markers.length > 0 ? markers[0] : CSS.xDraggable);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionMove | null {
        return With.notnull_(info.action_(), ([_action, markers]) => {
            return new _ClientActionMove(markers.length > 0 ? markers[0] : CSS.xDraggable);
        });
    }
    run_(elm: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        host$.hideKeyboard_(() => {
            this._clientActionMove(elm);
            callback?.(range);
        });
    }
    private _clientActionMove(elm: HTMLElement): void {
        let marker = this._marker;
        const parent = JsUtil.ancestorOrSelfWithClasses_(elm, [CSS.xDraggable, marker]);
        if (parent != null && !An.isBodyElement_(parent.nodeName)) {
            const info = _MainPanel._resizeInfo(parent as HTMLElement, false, true);
            if (info != null && info.canReposition) {
                
                Timer.sleep1_(() => {
                    mainPanel$.actionEditSize1_(info);
                });
                return;
            }
        }
        toasters$.warnKey_(RS.InvalidSelection);
    }
}

/// This action should only be be active in editing mode.
class _ClientActionTemplate implements _IClientAction {
    private constructor(
        private _markers: string[],
        private _context: string,
        private _parent: string
    ) { }
    static parse_(editing: boolean, a: string[], markers: string[]): _ClientActionTemplate | null {
        if (!editing) return null;
        if (a.length < 2 || a[1].length == 0) return null;
        const context = (a.length > 2 ? a[2] : "");
        const parent = (a.length > 3 ? a[3] : "");
        return new _ClientActionTemplate(markers, context, parent);
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionTemplate | null {
        return With.notnull_(editing ? info.action_() : null, ([_action, markers, context, parent]) => {
            return new _ClientActionTemplate(markers, context, parent);
        });
    }
    run_(button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        let template: NodeX = native$.iQuery(`[${ATTR.xTemplate}]`, button);
        if (template == null) {
            toasters$.warnKey_(RS.InvalidTemplate);
            callback?.(null);
            return;
        }
        if (template.nodeName == "TEMPLATE") template = (template as HTMLTemplateElement).content;
        history$.startGroup_(RS.history_templateButtonAction, this._markers.join(" "));
        _ClientActionTemplate._insertTemplate(template, range, this._markers, this._context, this._parent, (range) => {
            history$.endGroup_();
            callback?.(range);
        });
    }
    private static _insertTemplate(
        template: Node,
        iframerange: RangeX,
        markers: string[],
        context: string,
        parentmarker: string,
        callback: Fun10<RangeX>
    ): void {
        let [parent, node] = _ClientActionUt.findInsertTarget_(iframerange, markers, context, parentmarker);
        if (parent == null) {
            toasters$.warnKey_(RS.TemplateMarkerNotFound);
            callback(null);
            return;
        }
        _ClientActionTemplate.insertTemplate_(template, parent, node, callback);
    }

    static insertTemplate_(template: Node, parent: HTMLElement, node: NodeX, callback: Fun10<RangeX>) {
        const clone = native$.cloneTemplate_(template);
        if (clone == null) {
            callback(null);
            return;
        }
        const xtps = native$.iQueryAll_<HTMLElement>(`[${ATTR.xTemplatePlaceholder}]`, clone);
        for (let i = 0, len = xtps.length; i < len; ++i) {
            const elm = xtps[i];
            const value = native$.removeAttribute_(elm, ATTR.xTemplatePlaceholder);
            JsUtil.setAttribute_(elm, ATTR.xPlaceholder, value);
        }
        let placeholder = native$.iQuery(`.${CSS.xPlaceholder}`, clone);
        parent.insertBefore(clone, node);
        mainPanel$.processPlaceholders_(xtps, (range) => {
            if (range != null) {
                native$.iRevealNode_(RangeUtil.rangeStart_(range));
            } else if (placeholder != null && placeholder.parentElement != null && placeholder.ownerDocument != null) {
                range = native$.iSetCaretAtStart_(placeholder, true);
            }
            callback(range);
        });
    }
}

class WidgetKind {
    static readonly SECTION = new WidgetKind();
    static readonly TEXT = new WidgetKind();
    static readonly PDF = new WidgetKind();
    static readonly IMAGE_FILE = new WidgetKind();
    static readonly PHOTO_TAKING = new WidgetKind();
    static readonly AUDIO_FILE = new WidgetKind();
    static readonly AUDIO_RECORDING = new WidgetKind();
    static readonly VIDEO_FILE = new WidgetKind();
    static readonly VIDEO_RECORDING = new WidgetKind();

}

class WidgetCat {
    static readonly MEDIA_WALL = new WidgetCat();
    static readonly MEDIA_STICKER = new WidgetCat();
    static readonly FORM = new WidgetCat();
    static readonly TEMPLATE = new WidgetCat();
}

abstract class WidgetUt {
    static catOf_(action: string): WidgetCat | null {
        switch (action) {
            case "media-wall": return WidgetCat.MEDIA_WALL;
            case "media-sticker": return WidgetCat.MEDIA_STICKER;
            case "form": return WidgetCat.FORM;
            case "template": return WidgetCat.TEMPLATE;
            default: return null;
        }
    }

    static kindOf_(action: string): WidgetKind | null {
        switch (action) {
            case "section": return WidgetKind.SECTION;
            case "text": return WidgetKind.TEXT;
            case "pdf": return WidgetKind.PDF;
            case "image": return WidgetKind.IMAGE_FILE;
            case "photo": return WidgetKind.PHOTO_TAKING;
            case "audio-file": return WidgetKind.AUDIO_FILE;
            case "audio-recording": return WidgetKind.AUDIO_RECORDING;
            case "video-file": return WidgetKind.VIDEO_FILE;
            case "video-recording": return WidgetKind.VIDEO_RECORDING;
            default: return null;
        }
    }

    static kindFromLcSuffix_(lcsuffix: string): WidgetKind | null {
        return lcsuffix == Suffix.PDF$ ? WidgetKind.PDF
            : MimeUtil.isImageLcSuffix_(lcsuffix) ? WidgetKind.IMAGE_FILE
                : MimeUtil.isVideoLcSuffix_(lcsuffix) ? WidgetKind.VIDEO_FILE
                    : MimeUtil.isAudioLcSuffix_(lcsuffix) ? WidgetKind.AUDIO_FILE
                        : null;
    }

    static createXaudio_(b: DomBuilderEx, href: stringX, attrs: StringMap<string>) {
        const url = href ?? PATH._assetsAudioSample;
        b.push_().div1_(CSS.xMediaPhoto, XX.xxAudio)
            .img1_(PATH._assetsImagesSamplesAngels, CSS.xAudioholder, CSS.xAudioPoster, CSS.xLandscape)
            .attr_(ATTR.xHref, url);
        b.peek_().child_("audio", smap_(
            ["src", url],
            ["class", CSS.xAudio],
            ["controls", "true"],
            ["preload", "metadata"],
        )).attrs_(attrs);
        b.pop_();
    }
    static createVideo_(b: DomBuilderEx, href: stringX, attrs: StringMap<string>) {
        b.push_().div1_(XX.xxVideo).child_("video", smap_(
            ["src", (href ?? PATH._assetsVideoSample)],
            ["class", CSS.xVideo],
            ["controls", "true"],
            ["preload", "metadata"],
        )).attrs_(attrs).pop_();
    }
    static createXvideo_(b: DomBuilderEx, _poster: stringX, href: stringX, attrs: StringMap<string>) {
        this.createVideo_(b, href, attrs);
    }
    static _captionWithVideoInfo(b: DomBuilderEx) {
        return b.div1_(CSS.xMediaCaption).indent_(
            b.push_().div1_(CSS.xVideoFilename).text_("???"),
            b.peek_().div1_(CSS.xGray).indent_(
                b.push_().span1_(CSS.xVideoDuration).text_("??:??"),
                b.peek_().text_(" \u2022 "),
                b.pop_().span1_(CSS.xVideoResolution).text_("?? x ??")
            ),
            b.pop_().div1_(CSS.xMediaContent).div_().indent_(
                b.push_().span1_(CSS.xBullet, CSS.xMediaStatus).text_("\uf1db"),
                b.peek_().text_(" "),
                b.pop_().span1_(CSS.xPlaceholder).text_(XXX)));
    }

    static _captionWithAudioInfo(b: DomBuilderEx) {
        return b.div1_(CSS.xMediaCaption).indent_(
            b.push_().div1_(CSS.xAudioFilename).text_("???"),
            b.peek_().div1_(CSS.xGray).indent_(
                b.push_().span1_(CSS.xAudioDuration).text_("??:??"),
                b.peek_().text_(" \u2022 "),
                b.peek_().span1_(CSS.xAudioRate).text_("??"),
                b.peek_().text_(" \u2022 "),
                b.peek_().span1_(CSS.xAudioChannels),
                b.pop_().text_(" ch")),
            b.pop_().div1_(CSS.xMediaContent).div_().indent_(
                b.push_().span1_(CSS.xBullet, CSS.xMediaStatus).text_("\uf1db"),
                b.peek_().text_(" "),
                b.pop_().span1_(CSS.xPlaceholder).text_(XXX)));
    }
}

/// This action should only be be active in editing mode.
class _ClientActionWidget implements _IClientAction {
    private constructor(
        private _action: string[],
        private _markers: string[],
        private _context: string,
        private _parent: string,
        private _cat: WidgetCat | null,
        private _kind: WidgetKind | null,
    ) { }
    static parse_(editing: boolean, a: string[], markers: string[]): _ClientActionWidget | null {
        if (!editing) return null;
        if (a.length < 2 || a[1].length == 0) return null;
        const action = a[0].split(RX.CommaSeparated);
        const context = (a.length > 2 ? a[2] : "");
        const parent = (a.length > 3 ? a[3] : "");
        return new _ClientActionWidget(action, markers, context, parent, WidgetUt.catOf_(action[1]), WidgetUt.kindOf_(action[2]));
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionWidget | null {
        if (!editing) return null;
        return With.notnull_(info.action_(), ([action, markers, context, parent]) => {
            return new _ClientActionWidget(action, markers, context, parent,
                WidgetUt.catOf_(action[1]),
                WidgetUt.kindOf_(action[2]),
            );
        });
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        this._insertWidget(range, (range) => {
            callback?.(range);
        });
    }
    private _insertWidget(
        iframerange: RangeX,
        callback: Fun10<RangeX>
    ): void {
        let [parent, node] = _ClientActionUt.findInsertTarget_(iframerange, this._markers, this._context, this._parent);
        if (parent == null) {
            toasters$.warnKey_(RS.TemplateMarkerNotFound);
            callback(null);
            return;
        }
        if (this._cat == WidgetCat.TEMPLATE) {
            _ClientActionWidget._insertTemplate((this._action[3] ?? null), parent, node, callback);
            return;
        }
        if (this._kind == WidgetKind.IMAGE_FILE) {
            const d = _Util.promptInsertImg1_(
                RS.InsertImageTitle,
                null,
                native$.getIFrameUri_(),
                Callbacks.onAnyImageFolderButton_,
                result => {
                    if (result == null) {
                        return callback(null);
                    }
                    let caption: stringX = result.caption;
                    if (caption.length == 0)
                        caption = ArrayUt.last_(result.src.pathSegments$) ?? null;
                    const src = result.src.toString();
                    this._insertWidget1(parent!, node, caption, json_(
                        [Key.src, src],
                        [Key.url, src],
                        [Key.attrs, result.attrs],
                    ), callback);
                });
            const field0 = d.getFieldAt_(0);
            field0.setButtonEnable_(BUT.CreateLink, false);
            field0.setButtonEnable_(BUT.CreateThumbnail, false);
            d.onCancel_(() => {
                callback(null);
            }).show_();
            return;
        }
        if (this._kind == WidgetKind.VIDEO_FILE) {
            const baseuri = native$.getIFrameUri_();
            const uri = Uri.from_((native$.getIFrameDir_() ?? PATH._assetsVideoSample).split(FS), "", "", baseuri);
            _MainPanel.promptEditMedia_(RS.Video, uri.encoded$ + FS, null, baseuri, Callbacks.onVideoPlaybackFolderButton_, (uri) => {
                const caption = ArrayUt.last_(uri.pathSegments$) ?? XXX;
                this._insertWidget1(parent!, node, caption, json_(
                    [Key.url, uri.encoded$],
                ), callback);
            }).onCancel_(() => {
                callback(null);
            }).show_();
            return;
        }
        if (this._kind == WidgetKind.AUDIO_FILE) {
            const baseuri = native$.getIFrameUri_();
            const uri = Uri.from_((native$.getIFrameDir_() ?? PATH._assetsVideoSample).split(FS), "", "", baseuri);
            _MainPanel.promptEditMedia_(RS.Audio, uri.encoded$ + FS, null, baseuri, Callbacks.onAudioPlaybackFolderButton_, (uri) => {
                const caption = ArrayUt.last_(uri.pathSegments$) ?? XXX;
                this._insertWidget1(parent!, node, caption, json_(
                    [Key.url, uri.encoded$],
                ), callback);
            }).onCancel_(() => {
                callback(null);
            }).show_();
            return;
        }
        this._insertWidget1(parent, node, null, null, callback);
    }

    private _insertWidget1(
        parent: HTMLElement,
        node: NodeX,
        caption: stringX = null,
        info: JSONObjectX = null,
        callback: Fun10<RangeX>,
    ) {
        const widget = this._createWidget((parent as HTMLElement).ownerDocument, caption, info);
        if (widget == null) {
            callback(null);
            return;
        }
        history$.startGroup_(RS.history_templateButtonAction, this._action.join(","));
        this._insertWidget2(parent as HTMLElement, node, widget, (range) => {
            history$.endGroup_();
            callback(range);
        });
    }

    private _insertWidget2(parent: HTMLElement, node: NodeX, widget: DocumentFragment, callback: Fun10<RangeX>) {
        const xtps = native$.iQueryAll_<HTMLElement>(`[${ATTR.xPlaceholder}]`, widget);
        const placeholder = native$.iQuery(`.${CSS.xPlaceholder}`, widget);
        parent.insertBefore(widget, node);
        mainPanel$.processPlaceholders_(xtps, (range) => {
            if (range != null) {
                native$.iRevealNode_(RangeUtil.rangeStart_(range));
            } else if (placeholder != null && placeholder.parentElement != null && placeholder.ownerDocument != null) {
                range = native$.iSetCaretAtStart_(placeholder, true);
            }
            callback(range);
        });
    }

    private _createWidget(doc: Document, caption: stringX = null, info: JSONObjectX = null): DocumentFragment | null {
        switch (this._cat) {
            case WidgetCat.MEDIA_WALL: return _ClientActionWidget._createMediaWallWidget(doc, this._kind, caption, info);
            case WidgetCat.MEDIA_STICKER: return _ClientActionWidget._createMediaStickerWidget(doc, this._kind, caption, info);
            case WidgetCat.FORM: return _ClientActionWidget._createFormWidget(doc, this._kind, caption, info);
            default: return null;
        }
    }

    private static _SUBJECT = MSG.string_(RS.Subject);

    static _insertTemplate(
        name: stringX,
        parent: HTMLElement,
        node: NodeX,
        callback: Fun10<RangeX>,
    ) {
        if (name == null) return callback(null);
        const doc = parent.ownerDocument;
        const template = doc.querySelector<HTMLTemplateElement>(`div#${ID.xRightSidebar} template[name="${name}"]`);
        if (template == null) return callback(null);
        const fragment = template.content;
        if (fragment == null) return callback(null);
        _ClientActionTemplate.insertTemplate_(fragment, parent, node, callback);
    }

    static _createFormWidget(
        _doc: Document,
        _kind: WidgetKind | null,
        _caption: stringX = null,
        _info: JSONObjectX = null,
    ): DocumentFragment | null {
        return null;
    }

    static _createMediaStickerWidget(
        doc: Document,
        kind: WidgetKind | null,
        caption: stringX = null,
        info: JSONObjectX = null,
    ): DocumentFragment | null {
        const sticker = (b: DomBuilderEx, css: string[], content: Fun00) => {
            b.div1_(
                CSS.xSticker,
                CSS.xStickOnDocument,
                CSS.xDraggable,
                CSS.xZTop,
                XX.xxStyle00,
                ...css);
            content();
        };
        const item = (b: DomBuilderEx, css: string[], subject: Fun00, caption: Fun00) => {
            sticker(b, css, () => {
                b.indent_(
                    b.push_().div1_(CSS.xSubject).indent_(
                        b.push_(),
                        this._clientMoveButton(b),
                        this._clientZindexStickerButton(b.peek_()),
                        b.pop_(),
                        subject()),
                    b.peek_(),
                    caption(),
                    b.pop_());
            });
        };

        const b = DomBuilderEx.offline_(doc, "div");
        const url = info?.[Key.url];
        switch (kind) {
            case WidgetKind.SECTION:
                sticker(b, [XX.xxSection], () => {
                    b.push_().div1_(CSS.xPlaceholder).text_(XXX).pop_();
                });
                break;
            case WidgetKind.TEXT: {
                sticker(b, [XX.xxComment], () => {
                    b.push_().div1_(CSS.xPlaceholder).text_(XXX).pop_();
                });
                break;
            }
            case WidgetKind.PDF: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const attrs = smap1_("class", `${CSS.xPdf} ${XX.xxPhoto}`);
                    const u = url ?? PATH._pdfSample;
                    const poster = info?.[Key.poster] ?? PATH._pdfPoster;
                    const orientation = info?.[Key.orientation] ?? CSS.xPortrait;
                    const filename = (caption ?? Basepath.filename_(PATH._pdfSample));
                    b.div_().indent_(
                        b.push_().div_(attrs)
                            .ahref1_(u + `?${Param.view}&${Param.poster}=1`)
                            .img1_(poster, CSS.xImageholder, orientation),
                        b.pop_().div1_(CSS.xMediaCaption));
                    b.span_().text_(filename);
                });
                break;
            }
            case WidgetKind.IMAGE_FILE: {
                const css = info?.[Key.css]?.split(RX.Spaces) ?? [];
                item(b, [XX.xxMedia, ...css], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const attrs = smap1_("class", `${CSS.xPhoto} ${XX.xxPhoto}`);
                    if (url == null) attrs[ATTR.xPlaceholder] = Placeholder.xpImage;
                    const link = url ?? PATH._assetsImagesPortraitSample;
                    const src = info?.[Key.src] ?? link;
                    const orientation = info?.[Key.orientation] ?? CSS.xPortrait;
                    b.div_().indent_(
                        b.push_().div_(attrs)
                            .ahref1_(link + `?${Param.view}`)
                            .img_(src, smap_(
                                ["class", `${CSS.xImageholder} ${orientation}`],
                                [ATTR.xAction, XAction.view],
                            )),
                        b.pop_().div1_(CSS.xMediaCaption));
                    if (caption == null || caption.length == 0) b.span1_(CSS.xPlaceholder).text_(XXX);
                    else b.span_().text_(caption);
                });
                break;
            }
            case WidgetKind.VIDEO_FILE: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const poster = info?.[Key.poster];
                    b.div_([ATTR.xPlaceholder, Placeholder.xpVideoinfo]);
                    WidgetUt.createXvideo_(b, poster, url, {});
                    WidgetUt._captionWithVideoInfo(b);
                });
                break;
            }
            case WidgetKind.AUDIO_FILE: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    b.div_([ATTR.xPlaceholder, Placeholder.xpAudioinfo]);
                    WidgetUt.createXaudio_(b, url, {});
                    WidgetUt._captionWithAudioInfo(b);
                });
                break;
            };
            case WidgetKind.PHOTO_TAKING: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const attrs = smap1_("class", `${CSS.xPhoto} ${XX.xxPhoto}`);
                    if (url == null) attrs[ATTR.xPlaceholder] = Placeholder.xpPhoto;
                    const orientation = info?.[Key.orientation] ?? CSS.xPortrait;
                    b.div_().indent_(
                        b.push_().div_(attrs)
                            .ahref1_((url ?? PATH._assetsImagesPortraitSample) + `?${Param.view}`)
                            .img_((url ?? PATH._assetsImagesPortraitSample), smap_(
                                ["class", `${CSS.xImageholder} ${orientation}`],
                                [ATTR.xAction, XAction.view],
                            )),
                        b.pop_().div1_(CSS.xMediaCaption));
                    if (caption == null || caption.length == 0) b.span1_(CSS.xPlaceholder).text_(XXX);
                    else b.span_().text_(caption);
                });
                break;
            }
            case WidgetKind.VIDEO_RECORDING: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const poster = info?.[Key.poster];
                    const attrs = (url == null ? smap1_(ATTR.xPlaceholder, Placeholder.xpVideo) : smap_<string>());
                    b.div_([ATTR.xPlaceholder, Placeholder.xpVideoinfo]);
                    WidgetUt.createXvideo_(b, poster, url, attrs);
                    WidgetUt._captionWithVideoInfo(b);
                });
                break;
            };
            case WidgetKind.AUDIO_RECORDING: {
                item(b, [XX.xxMedia], () => {
                    b.span_().text_(this._SUBJECT);
                }, () => {
                    const attrs = (url == null ? smap1_(ATTR.xPlaceholder, Placeholder.xpAudio2) : smap_<string>());
                    b.div_([ATTR.xPlaceholder, Placeholder.xpAudioinfo]);
                    WidgetUt.createXaudio_(b, url, attrs);
                    WidgetUt._captionWithAudioInfo(b);
                });
                break;
            }
        }
        const ret = new DocumentFragment();
        ret.appendChild(b.cursor_());
        return ret;
    }

    private static _clientMoveButton(b: DomBuilderEx) {
        b.span_(
            ["class", `${CSS.xFloatRightClearNone} ${CSS.xShowInEdit} fa fa-arrows`],
            [ATTR.xButton, ClientAction.move],
        );
    }

    private static _clientZindexStickerButton(b: DomBuilderEx) {
        b.span_(
            ["class", `${CSS.xFloatRightClearNone} ${CSS.xShowInEdit} fa fa-retweet`],
            [ATTR.xButton, `c/${CSS.xZTop} ${CSS.xZUpper} ${CSS.xZMiddle} ${CSS.xZLower} ${CSS.xZBottom}/${CSS.xSticker}`]);
    }

    static _createMediaWallWidget(
        doc: Document,
        kind: WidgetKind | null,
        caption: stringX = null,
        info: JSONObjectX = null,
    ): DocumentFragment | null {
        function item_(b: DomBuilderEx, css: string[], body: Fun00, caption: Fun00) {
            const li = b.li1_(...css).cursor_();
            body();
            b.setCursor_(li);
            caption();
            b.setCursor_(li);
        }

        function caption_(b: DomBuilderEx, caption: stringX) {
            b.div1_(CSS.xMediaCaption);
            if (caption == null || caption.length == 0)
                b.div1_(CSS.xPlaceholder).text_(XXX);
            else b.text_(caption);
        }
        const b = DomBuilderEx.offline_(doc, "div");
        const url: stringX = info?.[Key.url];
        switch (kind) {
            case WidgetKind.SECTION: {
                const subject = MSG.string_(RS.Subject);
                b.div1_(XX.xxSection).push_().indent_(
                    b.push_().div1_(XX.xxHeader).text_(subject),
                    b.peek_().div1_(XX.xxSubheader),
                    b.pop_().ul1_(XX.xxMedias))
                    .pop_();
                break;
            }
            case WidgetKind.TEXT: {
                b.li1_(XX.xxMedia).push_().div1_(XX.xxComment).div1_(CSS.xPlaceholder).text_(XXX).pop_();
                break;
            }
            case WidgetKind.PDF: {
                const attrs = smap1_("class", `${CSS.xPdf} ${XX.xxPhoto}`);
                const u = url ?? PATH._assetsImagesPortraitSample;
                const poster = info?.[Key.poster] ?? PATH._pdfPoster;
                const orientation = info?.[Key.orientation] ?? CSS.xPortrait;
                item_(b, [XX.xxMedia], () => {
                    b.div_(attrs)
                        .ahref_(u + `?${Param.view}&${Param.poster}=1`)
                        .img1_(poster, CSS.xImageholder, orientation);
                }, () => caption_(b, caption));
                break;
            }
            case WidgetKind.IMAGE_FILE: {
                const css: string[] = info?.[Key.css]?.split(RX.Spaces) ?? [];
                const dattrs = smap1_("class", `${CSS.xPhoto} ${XX.xxPhoto}`);
                if (url == null)
                    dattrs[ATTR.xPlaceholder] = Placeholder.xpImageNoCaption;
                const link = url ?? PATH._assetsImagesPortraitSample;
                const src = info?.[Key.src] ?? link;
                const iattrs = info?.[Key.attrs] ?? smap_();
                An.removeAddClasses_(iattrs, [], [CSS.xImageholder]);
                iattrs[ATTR.xAction] = XAction.view;
                item_(b, [XX.xxMedia, ...css], () => {
                    b.div_(dattrs).push_()
                        .ahref_(link + `?${Param.view}`)
                        .img_(src, iattrs);
                }, () => caption_(b, caption));
                break;
            }
            case WidgetKind.VIDEO_FILE: {
                item_(b, [XX.xxMedia], () => {
                    const poster = info?.[Key.poster];
                    b.attr_(ATTR.xPlaceholder, Placeholder.xpVideoinfo);
                    WidgetUt.createXvideo_(b, poster, url, {});
                }, () => WidgetUt._captionWithVideoInfo(b));
                break;
            }
            case WidgetKind.AUDIO_FILE: {
                item_(b, [XX.xxMedia], () => {
                    b.attr_(ATTR.xPlaceholder, Placeholder.xpAudioinfo);
                    WidgetUt.createXaudio_(b, url, {});
                }, () => WidgetUt._captionWithAudioInfo(b));
                break;
            };
            case WidgetKind.PHOTO_TAKING: {
                const orientation = info?.[Key.orientation] ?? CSS.xPortrait;
                item_(b, [XX.xxMedia], () => {
                    b.div_(
                        ["class", `${CSS.xPhoto} ${XX.xxPhoto}`],
                        [ATTR.xPlaceholder, Placeholder.xpPhoto],
                    ).push_()
                        .ahref_(PATH._assetsImagesPortraitSample + `?${Param.view}`)
                        .img_(PATH._assetsImagesPortraitSample, smap_(
                            ["class", `${CSS.xImageholder} ${orientation}`],
                            [ATTR.xAction, XAction.view],
                        ));
                }, () => caption_(b, caption));
                break;
            }
            case WidgetKind.VIDEO_RECORDING: {
                item_(b, [XX.xxMedia], () => {
                    const poster = info?.[Key.poster];
                    const attrs = smap1_("class", `${CSS.xVideo}`);
                    if (url == null) attrs[ATTR.xPlaceholder] = Placeholder.xpVideo;
                    b.attr_(ATTR.xPlaceholder, Placeholder.xpVideoinfo);
                    WidgetUt.createXvideo_(b, poster, url, attrs);
                }, () => WidgetUt._captionWithVideoInfo(b));
                break;
            }
            case WidgetKind.AUDIO_RECORDING: {
                item_(b, [XX.xxMedia], () => {
                    b.attr_(ATTR.xPlaceholder, Placeholder.xpAudioinfo);
                    const attrs = (url == null ? smap1_(ATTR.xPlaceholder, Placeholder.xpAudio2) : smap_<string>());
                    WidgetUt.createXaudio_(b, url, attrs);
                }, () => WidgetUt._captionWithAudioInfo(b));
                break;
            }
        }
        const ret = new DocumentFragment();
        ret.appendChild(b.cursor_());
        return ret;
    }

}

class _ClientActionUt {
    static findTarget_(range: RangeX, markers: string[], contexts: string[], parent: string): HTMLElementX {
        if (markers.length == 0) {
            toasters$.warnKey_(RS.InvalidTemplate);
            return null;
        }
        if (parent.length > 0) {
            return _MainPanel.findMarker_(parent);
        } else if (contexts.length > 0) {
            return native$.getTemplateMarker_(range, null, contexts);
        }
        toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
        return null;
    }
    private static findInsertTarget1_(range: RangeX, markers: string[], context: string, parentmarker: string): [HTMLElementX, HTMLElementX] {
        let node: HTMLElementX = null;
        let parentmarkernode: HTMLElementX = null;
        let searchcontext: HTMLElementX = null;
        if (range != null) {
            node = native$.getTemplateMarker_(range, context, markers);
            if (node != null && parentmarker.length > 0 && node.classList.contains(parentmarker)) {
                parentmarkernode = node;
                node = null;
            } else if (node != null && context.length > 0 && node.classList.contains(context)) {
                searchcontext = node;
                node = null;
            } else if (node == null && parentmarker.length > 0) {
                parentmarkernode = native$.getTemplateMarker_(range, null, [parentmarker]);
            }
        }
        if (node == null && parentmarkernode == null && searchcontext == null) {
            if (parentmarker.length > 0) {
                parentmarkernode = _MainPanel.findMarker_(parentmarker);
            } else if (context.length > 0) {
                searchcontext = _MainPanel.findMarker_(context);
            }
        }
        if (node == null && parentmarkernode == null && searchcontext != null) {
            if (parentmarker.length > 0) {
                parentmarkernode = native$.iQuery(`.${parentmarker}`, searchcontext);
            }
            if (parentmarkernode == null) {
                const sel = markers.map(value => "." + value).join(",");
                node = native$.iQuery(sel, searchcontext);
            }
        }
        if (node != null && parentmarkernode == null && parentmarker.length > 0 && node.classList.contains(parentmarker)) {
            parentmarkernode = node;
            node = null;
        }
        return [node, parentmarkernode];
    }

    static findInsertTarget_(range: RangeX, markers: string[], context: string, parentmarker: string): [HTMLElementX, NodeX] {
        let [elm, parent] = _ClientActionUt.findInsertTarget1_(range, markers, context, parentmarker);
        if (elm != null) {
            return [elm.parentElement, elm.nextSibling];
        } else if (parent != null) {
            return [parent, parent.firstChild];
        } else {
            return [null, null];
        }
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionStyle implements _IClientAction {
    private constructor(
        private _markers: string[],
        private _singleton: string,
        private _prefix: string,
        private _style: string
    ) { }
    static parse_(_editing: boolean, a: string[], markers: string[]): _ClientActionStyle | null {
        if (a.length < 4 || a[3].length == 0) return null;
        let singleton = a[2];
        const prefix = a[3];
        let style = "";
        if (singleton.length > 0 && !CSSUtil.validateClass(singleton)) return null;
        if (a.length > 4) {
            style = a[4];
            if (style.length > 0 && !CSSUtil.validateClass(style)) return null;
        }
        return new _ClientActionStyle(markers, singleton, prefix, style);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionStyle | null {
        return With.notnull_(info.action_(), ([_action, markers, singleton, prefix, style]) => {
            if (prefix.length == 0) return null;
            if (style.length > 0 && !CSSUtil.validateClass(style)) return null;
            return new _ClientActionStyle(markers, singleton, prefix, style);
        });
    }
    /// @enter This may be called in both browsing and editing mode.
    run_(_elm: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        Timer.sleep1_(() => {
            let node = (this._markers.length == 0)
                ? RangeUtil.rangeStartElement_(range)
                : native$.getTemplateMarker_(range, null, this._markers);
            if (node == null && this._singleton.length > 0) {
                node = _MainPanel.findMarker_(this._singleton);
            }
            if (node == null || !JsUtil.isElementWIthName_(node)) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                callback?.(range);
                return;
            }
            if (mainPanel$.isEditing()) {
                history$.startGroup_(RS.history_templateStyleAction, this._markers.join(" "));
                this._styleTemplate(node, this._prefix, this._style, () => {
                    history$.endGroup_();
                    callback?.(range);
                });
            } else {
                this._styleTemplate(node, this._prefix, this._style, () => {
                    callback?.(range);
                });
            }
        });
    }
    _styleTemplate(node: Node, prefix: string, style: string, callback: Fun00): void {
        const elm = node as HTMLElement;
        const classes = elm.classList;
        const removes = sarray_();
        const addes = (style.length == 0) ? [] : [style];
        if (prefix.length > 0) {
            classes.forEach(value => {
                if (value.startsWith(prefix)) {
                    removes.push(value);
                }
            });
        }
        native$.removeAddClasses_(elm, removes, addes);
        callback();
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionCycle implements _IClientAction {
    private constructor(
        private _action: string,
        private _markers: string[],
        private _contexts: string[],
        private _parent: string
    ) { }
    static parse_(_editing: boolean, a: string[], markers: string[]): _ClientActionCycle | null {
        if (a.length < 3 ||
            a[1].length == 0 ||
            (a[2].length == 0 && (a.length < 4 || a[3].length == 0 || !CSSUtil.validateClass(a[3])))) {
            return null;
        }
        const parent = (a.length > 3 ? a[3] : "");
        return new _ClientActionCycle(a[0], markers, a[2].trim().split(RX.Spaces).filter(s => s.length > 0), parent);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionCycle | null {
        return With.notnull_(info.action_(), ([action, markers, context, parent]) => {
            if (context.length == 0 && parent.length == 0) return null;
            const contexts = CSSUtil.validateClassesOf(context);
            if (contexts == null) return null;
            return new _ClientActionCycle(action[0], markers, contexts, parent);
        });
    }
    /// @enter This may be called in both browsing and editing mode.
    run_(_elm: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        Timer.sleep1_(() => {
            if (mainPanel$.isEditing()) {
                history$.startGroup_(RS.history_templateCycleAction, this._markers.join(" "));
                this._cycle(range, true, () => {
                    history$.endGroup_();
                    callback?.(range);
                });
            } else {
                this._cycle(range, true, () => {
                    callback?.(range);
                });
            }
        });
    }
    /// @return The marker node.
    private _cycle(range: RangeX, toast: boolean, callback: Fun00): void {
        try {
            const target = _ClientActionUt.findTarget_(range, this._markers, this._contexts, this._parent);
            if (target == null)
                return;
            const classes = target.classList;
            let remove = null;
            let add: stringX = this._markers[0];
            classes.forEach(c => {
                let index = this._markers.indexOf(c);
                if (index < 0) {
                    return;
                }
                remove = c;
                ++index;
                if (index == this._markers.length) {
                    add = (this._action == TemplateAction.cycle ? null : this._markers[0]);
                } else {
                    add = this._markers[index];
                }
            });
            native$.removeAddClasses_(target, (remove == null ? null : [remove]), (add == null ? null : [add]));
            if (toast) {
                toasters$.info_((add == null ? MSG.string_(RS.None) : add), { attop: false });
            }
        } finally {
            callback();
        }
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionToggle implements _IClientAction {
    private constructor(
        private _markers: string[],
        private _contexts: string[],
        private _parent: string,
    ) { }
    static parse_(_editing: boolean, a: string[], markers: string[]): _ClientActionToggle | null {
        if (a.length < 3 ||
            a[1].length == 0 ||
            (a[2].length == 0 && (a.length < 4 || a[3].length == 0 || !CSSUtil.validateClass(a[3])))) {
            return null;
        }
        const parent = (a.length > 3 ? a[3] : "");
        return new _ClientActionToggle(markers, a[2].trim().split(RX.Spaces).filter(s => s.length > 0), parent);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionToggle | null {
        return With.notnull_(info.action_(), ([_action, markers, context, parent]) => {
            if (context.length == 0 && parent.length == 0) return null;
            const contexts = CSSUtil.validateClassesOf(context);
            if (contexts == null) return null;
            return new _ClientActionToggle(markers, contexts, parent);
        });
    }
    /// @enter This may be called in both browsing and editing mode.
    run_(_elm: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        Timer.sleep1_(() => {
            if (mainPanel$.isEditing()) {
                history$.startGroup_(RS.ActionTemplateToggleTitle, this._markers[0]);
                this._toggle(range, true, () => {
                    history$.endGroup_();
                    callback?.(range);
                });
            } else {
                this._toggle(range, true, () => {
                    callback?.(range);
                });
            }
        });
    }
    private _toggle(range: RangeX, toast: boolean, callback: Fun00): void {
        try {
            const node = _ClientActionUt.findTarget_(range, this._markers, this._contexts, this._parent);
            if (node == null) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                return;
            }
            let remove: string[] = [];
            let add: stringX = this._markers[0];
            node.classList.forEach(c => {
                if (c == this._markers[0]) add = null;
                if (this._markers.includes(c)) remove.push(c);
            });
            native$.removeAddClasses_(node, remove, (add == null ? null : [add]));
            if (toast) {
                toasters$.info_((add == null ? MSG.string_(RS.None) : add), { attop: false });
            }
        } finally {
            callback();
        }
    }
}

/// This action should only be be active in editing mode.
class _ClientActionCut implements _IClientAction {
    constructor(
        private _action: string,
        private _markers: string[],
        private _item: string,
        private _context: string
    ) { }
    static parse_(editing: boolean, a: string[], markers: string[]): _ClientActionCut | null {
        if (!editing) return null;
        if (a.length < 4 ||
            !CSSUtil.validateClass(a[2]) ||
            !CSSUtil.validateClass(a[3])) {
            return null;
        }
        return new _ClientActionCut(a[0], markers, a[2], a[3]);
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionCut | null {
        if (!editing) return null;
        return With.notnull_(info.action_(), ([action, markers, item, context]) => {
            if (action.length == 0 || item.length == 0 || context.length == 0) return null;
            return new _ClientActionCut(action[0], markers, item, context);
        });
    }
    run_(_button: HTMLElement, _range: RangeX, callback: Fun10X<RangeX>) {
        try {
            switch (this._action) {
                case TemplateAction.cutMarked: {
                    this._actionCutMarked(this._markers, this._item);
                    break;
                }
                case TemplateAction.cutNotMarked: {
                    this._actionCutNotMarked(this._markers, this._item, this._context);
                    break;
                }
                default:
                    toasters$.warnKey_(RS.InvalidTemplate);
                    break;
            }
        } finally {
            callback?.(null);
        }
    }
    private _actionCutNotMarked(markers: string[], item: string, context: string): void {
        if (native$.iGetMetaVersion_() < 2) {
            toasters$.warn_(MSG.format1_(RS.ActionRequireDocumentVersion_0_OrAbove, "2"));
            return;
        }
        const nodes = native$.iQueryAll_(`.${context}`);
        const tocut: Node[] = [];
        for (const node of nodes) {
            let result: NodeX = null;
            let parent: HTMLElementX = node;
            for (; parent != null; parent = parent.parentElement) {
                const parentclasses = An.classlist_(parent);
                if (parentclasses.contains_(item)) {
                    if (parentclasses.containsAll_(...markers)) {
                        result = null;
                        break;
                    }
                    result = parent;
                } else if (parentclasses.contains_(CSS.xRightSidebarContent)) {
                    result = null;
                    break;
                }
                if (parent.nodeName == "BODY") {
                    break;
                }
            }
            if (result != null) {
                tocut.push(result);
            }
        }
        const tocutlen = tocut.length;
        if (tocutlen == 0) {
            toasters$.warnKey_(RS.NoItemFound);
            return;
        }
        native$.iClearSelection_();
        native$.iSelectMulti_(tocut);
        const msg = MSG.format1_(RS.cut0ItemsToClipboard, `${tocutlen}`);
        DialogUt.confirm_(accessories$, msg, (yes: boolean) => {
            if (!yes) { return; }
            const parent = tocut[0].parentNode;
            if (parent == null) { return; }
            history$.group_(RS.Tooltips_CutNotDone, "", () => {
                const context = JsUtil.getContextHtml_(parent);
                clipboard$.dom_(native$.serializeCutAll_(context, tocut), context);
                _MainPanel.recalculateTotals_();
            });
            native$.iClearSelection_();
            toasters$.ok_(msg + " " + MSG.string_(RS.OK));
        }).show_();
    }
    private _actionCutMarked(markers: string[], item: string): void {
        const nodes = native$.iQueryAll_(`.${item}.${markers.join(".")}`);
        const tocut = new Array<Node>();
        for (const node of nodes) {
            let cut = true;
            for (let parent = node.parentElement; parent != null; parent = parent.parentElement) {
                const parentclasses = parent.classList;
                if (parentclasses.contains(CSS.xRightSidebarContent)) {
                    cut = false;
                    break;
                }
                if (parent.nodeName == "BODY") {
                    break;
                }
            }
            if (cut) {
                tocut.push(node);
            }
        }
        const tocutlen = tocut.length;
        if (tocutlen == 0) {
            toasters$.warnKey_(RS.NoItemFound);
            return;
        }
        native$.iClearSelection_();
        native$.iSelectMulti_(tocut);
        const msg = MSG.format1_(RS.cut0ItemsToClipboard, `${tocutlen}`);
        DialogUt.confirm_(accessories$, msg, (yes: boolean) => {
            if (!yes) { return; }
            const parent = tocut[0].parentNode;
            if (parent == null) { return; }
            history$.group_(RS.Tooltips_CutDone, "", () => {
                const context = JsUtil.getContextHtml_(parent);
                clipboard$.dom_(native$.serializeCutAll_(context, tocut), context);
                _MainPanel.recalculateTotals_();
            });
            native$.iClearSelection_();
            toasters$.ok_(msg + " " + MSG.string_(RS.OK));
        }).show_();
    }
}

/// This action may be be active in browsing or editing mode.
class _ClientActionRadio implements _IClientAction {
    private constructor(
        private _markers: string[],
        private _on: string,
        private _off: string
    ) { }
    static parse_(_editing: boolean, a: string[], markers: string[]): _ClientActionRadio | null {
        if (a.length < 2 || markers.length != 2) return null;
        return new _ClientActionRadio(markers, markers[0], markers[1]);
    }
    static from_(_editing: boolean, info: ClientActionInfo): _ClientActionRadio | null {
        return With.notnull_(info.action_(), ([_action, markers]) => {
            if (markers.length != 2) return null;
            return new _ClientActionRadio(markers, markers[0], markers[1]);
        });
    }
    run_(elm: HTMLElement, _range: RangeX, callback: Fun10X<RangeX>) {
        Timer.sleep1_(() => {
            if (mainPanel$.isEditing()) {
                history$.startGroup_(RS.history_templateRadioAction, this._markers.join(" "));
                this._radioTemplate(elm, false, (range) => {
                    history$.endGroup_();
                    callback?.(range);
                });
            } else {
                this._radioTemplate(elm, false, (range) => {
                    native$.iClearSelection_();
                    callback?.(range);
                });
            }
        });
    }
    /// @return The radio button item.
    private _radioTemplate(elm: HTMLElementX, toast: boolean, callback: Fun10<RangeX>): void {
        try {
            const on = this._on;
            const off = this._off;
            let group = null;
            let item = null;
            let marker = null;
            DONE:
            for (let node = elm; node != null; node = node.parentElement) {
                const classes = node.classList;
                for (const c of this._markers) {
                    if (classes.contains(c)) {
                        item = node;
                        marker = c;
                        break DONE;
                    }
                }
            }
            if (item == null || An.isHtmlElement_(item.nodeName)) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                return;
            }
            group = item.parentNode;
            if (group == null) {
                toasters$.warnKey_(RS.PleaseSelectAnItemForTheAction);
                return;
            }
            JsUtil.toggleClasses_(item, this._markers);
            if (marker == on) {
                if (toast) {
                    toasters$.info_(off, { attop: false });
                }
                return;
            }
            for (let child = group.firstElementChild; child != null; child = child.nextElementSibling) {
                if (child != item && child.classList.contains(on)) {
                    An.classlist_(child as HTMLElement).remove_(on).add_(off);
                }
            }
            if (toast) {
                toasters$.info_(on, { attop: false });
            }
        } finally {
            callback(native$.iSelectNode_(elm, null, true));
        }
    }

}

/// This action should only be be active in browsing mode.
class _ClientActionBlog implements _IClientAction {
    private static _regex = RegExp("^(.*?/blog/)(\\d+)/(\\d+)/(\\d+/)?(\\d+)\\.html$");
    private constructor(
        private _next: boolean
    ) { }
    static parse_(editing: boolean, a: string[]): _ClientActionBlog | null {
        if (editing) return null;
        if (a.length != 2 || a[1] != "next" && a[1] != "prev") return null;
        return new _ClientActionBlog(a[1] == "next");
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionBlog | null {
        if (editing) return null;
        return With.notnull_(info.action_(), ([_action, markers]) => {
            if (markers.length == 0) return null;
            const value = markers[0];
            if (value != "next" && value != "prev") return null;
            return new _ClientActionBlog(value == "next");
        });
    }
    run_(_elm: HTMLElement, _range: RangeX, _callback: Fun10X<RangeX>) {
        const error = () => {
            toasters$.warnKey_(RS.ActionOnlyWorksWhenCurrentDocumentIsABlogPage);
            return;
        };
        const cpath = native$.getIFrameContextPath_();
        const match = cpath?.match(_ClientActionBlog._regex);
        if (match == null) return error();
        const year = An.parseInt_(match[2], null);
        const month = An.parseInt_(match[3], null);
        const day = An.parseInt_(match[5], null);
        if (year == null || month == null || day == null) return error();
        host$.findBlog_(year, month, day, this._next, (ret) => {
            if (toasters$.warn_(ret)) return;
            const cpath = ret[Key.result];
            if (cpath != null) {
                _Util.onSaveOrDiscard_(() => {
                    _Util.browseFile_(cpath, null, false);
                });
            }
        });
    }
}

/// This action should only be be active in editing mode.
class _ClientActionClasses implements _IClientAction {
    private _classes = sarray_();
    private constructor(
        _markers: string[]
    ) {
        for (const marker of _markers) {
            if (this._classes.includes(marker)) continue;
            this._classes.push(marker);
        }
    }
    static parse_(editing: boolean, markers: string[]): _ClientActionClasses | null {
        if (!editing) return null;
        return new _ClientActionClasses(markers);
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionClasses | null {
        if (!editing) return null;
        return With.notnull_(info.action_(), ([_action, markers]) => {
            return new _ClientActionClasses(markers);
        });
    }
    run_(button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            callback?.(null);
            return;
        }
        let node = native$.getSingleSelectedOrCollapsedElementOfRange_(range);
        let elm: HTMLElementX = null;
        let ok = true;
        if (node != null && node.nodeType == Node.ELEMENT_NODE) {
            elm = node as HTMLElement;
            if (range.collapsed) range = native$.iSelectNode_(elm);
        } else {
            ok = RangeUtil.isTextSelection_(range);
        }
        if (!ok) {
            toasters$.warnKey_(RS.InvalidSelection);
            callback?.(range);
            return;
        }
        let offset = button.getBoundingClientRect();
        toasters$.info_((elm == null ? "" : _JsUtil.elementInfo_(elm) + "\n")
            + MSG.string_(RS.ClientActionClassesDeleteTooltips), { attop: false });
        const existing = (elm == null ? [] : Array.from(elm.classList));
        new CSSClassesContextmenu(accessories$, ArrayUt.unique_([...this._classes, ...existing]).sort(), existing, (value) => {
            toasters$.hideInfo_();
            if (value.length == 0) return;
            if (!CSSUtil.validateClass(value)) {
                toasters$.warnKey_(RS.InvalidCSSClassName);
                callback?.(range);
                return;
            }
            history$.group_(RS.ClientActionClassesTitle, value, () => {
                if (elm == null) {
                    if (range != null) {
                        const span = RangeUtil.wrapRange_("span", { "class": value }, range);
                        range = native$.iSelectNode_(span);
                    }
                } else {
                    const classlist = elm.classList;
                    if (classlist.contains(value)) classlist.remove(value); else classlist.add(value);
                }
            });
            ArrayUt.delete_(this._classes, value);
            if (this._classes.length >= DEF.maxClientActionClassesLength) this._classes.shift();
            this._classes.push(value);
            button.setAttribute(ATTR.xTemplate, `${TemplateAction.classes}/${this._classes.join(" ")}`);
            callback?.(range);
        })
            .onCancel_(() => toasters$.hideInfo_())
            .show_(offset.x, offset.y, true);
    }
}

/// This action may only be active in editing mode.
class _ClientActionPostAlarm implements _IClientAction {
    private constructor() {
    }
    static parse_(editing: boolean, _markers: string[]): _ClientActionPostAlarm | null {
        if (!editing) return null;
        return new _ClientActionPostAlarm();
    }
    static from_(editing: boolean, _info: ClientActionInfo): _ClientActionPostAlarm | null {
        if (!editing) return null;
        return new _ClientActionPostAlarm();
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            callback?.(null);
            return;
        }
        _ClientActionPostAlarm.post_(range, (found) => {
            if (!found) {
                toasters$.warnKey_(RS.TodoItemNotFound);
                callback?.(null);
                return;
            }
            callback?.(range);
        });
    }
    static post_(range: Range, callback: Fun10<boolean>) {
        const elm = native$.getSingleSelectedOrCollapsedElementOfRange_(range);
        let parent: HTMLElementX = null;
        if (elm != null) {
            const items = DomUt.queryAll_(elm, `li.${XX.xxTodo}, li.${CSS.xWidgetTodo}, tr.${XX.xxTodo}`);
            if (items.length > 0) {
                this._post(items, callback);
                return;
            }
            parent = JsUtil.ancestorOrSelfWith_(elm, (elm) => {
                const name = elm.nodeName;
                const classlist = elm.classList;
                return (name == "LI" && (classlist.contains(XX.xxTodo) || classlist.contains(CSS.xWidgetTodo))
                    || name == "TR" && classlist.contains(XX.xxTodo));
            });
        }
        if (elm == null || parent == null) {
            callback(false);
            return;
        }
        this._post([parent], callback);
    }
    private static _post(parents: HTMLElement[], callback: Fun10<boolean>) {
        sidePanel$.showEventsPanel_((eventspanel) => {
            if (eventspanel == null) {
                toasters$.warnKey_(RS.ActionNotPermitted);
                return;
            };
            An.iterateList_(parents, (parent, _index, next) => {
                _ClientActionPostAlarm._post1(eventspanel, parent, () => next(false));
            }, () => {
                callback(true);
            });
        });
    }
    private static _post1(eventspanel: _EventsPanel, parent: HTMLElement, callback: Fun00) {
        let alarm: JSONObjectX = null;
        if (parent.nodeName == "TR") alarm = this._fromShopping(parent);
        else if (parent.classList.contains(CSS.xWidgetTodo)) alarm = this._fromTodoWidget(parent);
        else alarm = this._fromTodoItem(parent);
        if (alarm == null) {
            callback();
            return;
        }
        const xinfo = An.parseJSONObjectOrNull_(parent.getAttribute(ATTR.AnInfo));
        if (xinfo != null) {
            const color = xinfo[EventKey.Color];
            if (!An.isempty_(color)) alarm[EventKey.Color] = color;
            const done = alarm[EventKey.Done] === true;
            if (done) {
                const donems = xinfo[EventKey.DoneMs] ?? null;
                if (donems != null) alarm[EventKey.DoneMs] = donems;
            }
        }
        const href = this._getrole(parent, EventKey.Url)?.textContent;
        if (href != null && href.length > 0) {
            alarm[EventKey.Url] = href;
        } else {
            const id = alarm[EventKey.Id];
            const uri = native$.getIFrameUri_();
            if (uri != null) {
                let name = parent.id ?? parent.getAttribute("name") ?? "";
                if (name.length == 0) {
                    parent.setAttribute("name", id);
                    name = id;
                }
                alarm[EventKey.Url] = `${uri.encodedPath$}#${name}`;
            }
        }
        const event = new EventInfo(alarm);
        eventspanel?.promptAlarm_(event, callback);
    }
    private static _fromShopping(parent: HTMLElement): JSONObject {
        const done = this._getDone(parent);
        const descelm = DomUt.query_(parent, `td.${XX.xxDesc}`);
        const date = this._getDate(descelm, `.${XX.xxDate}[${ATTR.xDateFormat}]`);
        const desc = this._getDesc(descelm);
        const repeat = this._getRepeat(descelm);
        return json_(
            [EventKey.Done, done],
            [EventKey.Id, _AlarmUtil.createId_()],
            [EventKey.Ms, date],
            [EventKey.Repeat, repeat],
            [EventKey.Description, desc],
        );
    }
    private static _fromTodoItem(parent: HTMLElement): JSONObject {
        const date = this._getDate(parent, `.${XX.xxHighlight}[${ATTR.xDateFormat}]`);
        const repeat = this._getRepeat(parent);
        const desc = DomUt.query_(parent, `span.${XX.xxHighlight}`)?.textContent ?? "";
        return json_(
            [EventKey.Done, this._getDone(parent)],
            [EventKey.Id, _AlarmUtil.createId_()],
            [EventKey.Ms, date],
            [EventKey.Repeat, repeat],
            [EventKey.Description, desc],
        );
    }
    private static _fromTodoWidget(parent: HTMLElement): JSONObject {
        const date = this._getDate(parent, `.${XX.xxDate}[${ATTR.xDateFormat}]`);
        const desc = (DomUt.query_(parent, `[${ATTR.xRole}~="${EventKey.Description}"]`)
            ?? DomUt.query_(parent, `span.${CSS.xWidgetTodoSubject}`))
            ?.textContent ?? "";
        const repeat = this._getRepeat(parent);
        return json_(
            [EventKey.Done, this._getDone(parent)],
            [EventKey.Id, _AlarmUtil.createId_()],
            [EventKey.Ms, date],
            [EventKey.Description, desc],
            [EventKey.Repeat, repeat],
        );
    }
    private static _getDone(elm: HTMLElement): boolean {
        const classlist = elm.classList;
        if (classlist.contains(XX.xxDone) || classlist.contains(CSS.xTodoDone)) {
            const roles = (elm.getAttribute(ATTR.xRole) ?? "").split(RX.Spaces);
            return roles.includes(EventKey.Done);
        }
        return false;
    }
    private static _getDate(elm: HTMLElementX, selector: string): Long {
        if (elm != null) {
            let dateelm = this._getrole(elm, EventKey.Ms)
                ?? DomUt.query_(elm, selector);
            if (dateelm != null) {
                const info = elm.getAttribute(ATTR.xDateFormat);
                if (info != null) {
                    const a = info.split(";");
                    if (a.length >= 3) {
                        const ms = An.parseInt_(a[2], null);
                        if (ms != null) return ms;
                    }
                }
            }
        }
        return DateTime.ms_();
    }
    private static _getDesc(elm: HTMLElementX): string {
        if (elm != null) {
            let ret = this._getrole(elm, EventKey.Description)?.textContent;
            if (ret != null) return ret;
            ret = "";
            for (const c of Array.from(elm.childNodes)) {
                if (c.nodeType == Node.TEXT_NODE) {
                    ret += c.nodeValue;
                }
            }
            return ret;
        }
        return "";
    }
    private static _getRepeat(elm: HTMLElementX): string {
        if (elm != null) {
            let e = this._getrole(elm, EventKey.Repeat)
                ?? DomUt.query_(elm, `.${CSS.xBulletFa}.fa-bell-o`);
            if (e == null) {
                const a = DomUt.queryAll_(elm, `li.${CSS.xList} span.${CSS.xBullet}`);
                for (const aa of a) {
                    if (aa.textContent?.trim() == "\u{f0a2}") {
                        const aaa = aa.nextElementSibling as HTMLElement;
                        if (aaa?.nodeName == "SPAN") {
                            e = aaa;
                            break;
                        }
                    }
                }
            }
            if (e != null) {
                const text = e.textContent ?? "";
                for (const value of EventRepeat.values) {
                    if (text.toLowerCase().startsWith(value.toLowerCase())) return value;
                }
            }
        }
        return EventRepeat.Once;
    }
    private static _getrole(elm: HTMLElement, role: string): HTMLElementX {
        return DomUt.query_(elm, `[${ATTR.xRole}~="${role}"]`);
    }
}

/// This action should only be be active in editing mode.
class _ClientActionBg implements _IClientAction {
    private constructor(private _markers: string[]) { }
    static parse_(editing: boolean, markers: string[]): _ClientActionBg | null {
        if (!editing)
            return null;
        return new _ClientActionBg(markers);
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionBg | null {
        if (!editing)
            return null;
        return With.notnull_(info.action_(), ([_action, markers]) => {
            return new _ClientActionBg(markers);
        });
    }
    run_(_button: HTMLElement, range: RangeX, callback: Fun10X<RangeX>) {
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            callback?.(null);
            return;
        }
        const elm = range.collapsed ? native$.getTemplateMarker_(range, null, this._markers)
            : native$.getSingleSelectedOrCollapsedElementOfRange_(range);
        if (elm == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            callback?.(range);
            return;
        }
        const target = elm;
        if (range.collapsed) range = native$.iSelectNode_(target);
        const bgkeys = [PK.BackgroundImage, PK.BackdropFilter, PK.BackgroundColor, PK.Color];
        const cstyles = native$.getComputedStylesOf_(target, null, bgkeys);
        const bgimg = cstyles.get(PK.BackgroundImage) ?? "";
        const backdropfilter = cstyles.get(PK.BackdropFilter) ?? "";
        const bgcolor = cstyles.get(PK.BackgroundColor) ?? "";
        const fgcolor = cstyles.get("color") ?? "";
        const border = (function () {
            const borderstyles = PromptBorders.getBorderStyles_(target);
            return PromptBorders.normalizeBorderStyles_((name) => borderstyles.get(name) ?? "");
        })();
        const baseuri = native$.getIFrameUri_();
        new PromptBgImg(
            accessories$,
            cache$.ui$.buttonSize_(),
            baseuri,
            [bgimg, backdropfilter],
            [bgcolor, fgcolor, border],
            settings$.getBgImgSamples(),
            DEF.zindexPrompt)
            .onOK_((cssstyle) => {
                history$.group_(RS.history_imageholder, native$.filenameFromCSSURL_(bgimg, baseuri), () => {
                    _JsUtil.setStyleUrlValue_(target, PK.BackgroundImage, cssstyle.backgroundImage, An.noop_);
                    native$.replaceStyle_(target, PK.BackdropFilter, cssstyle.getPropertyValue(PK.BackdropFilter));
                    native$.replaceStyle_(target, PK.BackgroundColor, cssstyle.backgroundColor);
                    native$.replaceStyle_(target, PK.Color, cssstyle.color);
                    native$.replaceStyle_(target, PK.BorderTop, cssstyle.borderTop);
                    native$.replaceStyle_(target, PK.BorderRight, cssstyle.borderRight);
                    native$.replaceStyle_(target, PK.BorderBottom, cssstyle.borderBottom);
                    native$.replaceStyle_(target, PK.BorderLeft, cssstyle.borderLeft);
                    native$.replaceStyle_(target, PK.BorderTopLeftRadius, cssstyle.borderTopLeftRadius);
                    native$.replaceStyle_(target, PK.BorderTopRightRadius, cssstyle.borderTopRightRadius);
                    native$.replaceStyle_(target, PK.BorderBottomLeftRadius, cssstyle.borderBottomLeftRadius);
                    native$.replaceStyle_(target, PK.BorderBottomRightRadius, cssstyle.borderBottomRightRadius);
                    native$.replaceStyle_(target, PK.BoxShadow, cssstyle.boxShadow);
                });
                callback?.(range);
            })
            .onCancel_(() => {
                toasters$.hideInfo_();
                callback?.(range);
            })
            .show_();
    }
}

/// This action should only be be active in browsing mode.
class _ClientActionPlayAll implements _IClientAction {
    private constructor() { }
    static parse_(editing: boolean): _ClientActionPlayAll | null {
        if (editing) return null;
        return new _ClientActionPlayAll();
    }
    static from_(editing: boolean, info: ClientActionInfo): _ClientActionPlayAll | null {
        if (editing) return null;
        return With.notnull_(info.action_(), () => {
            return new _ClientActionPlayAll();
        });
    }
    run_(_elm: HTMLElement, _range: RangeX, _callback: Fun10X<RangeX>) {
        const audios = native$.iQueryAll_(`audio.${CSS.xAudio}`);
        if (audios.length == 0) {
            toasters$.warnKey_(RS.NoSuitableMediaFileFound);
            return;
        }
        const baseuri = native$.getIFrameUri_();
        const infos = new Array<AudioPlayerInfo>();
        audios.forEach((audio) => {
            const src = audio.getAttribute("src");
            if (src == null) return;
            const uri = An.parseUriSafe_(src, baseuri)?.toAbsolute_();
            if (uri == null) return;
            const seek = An.parseDouble_(uri.searchParams$.get(Param.seek), null);
            infos.push(new AudioPlayerInfo(uri.path$, uri, seek));
        });
        _AudioPlayerDialog.createAndShowAll_(accessories$, infos, true);
    }
}

class _TemplateAction {

    static parse_(input: stringX): _IClientAction | null {
        let input1 = input?.trim();
        if (input1 == null || input1.length == 0) {
            return null;
        }
        if (input1.startsWith("{")) {
            return this.clientActionFrom_(ClientActionInfo.of_(An.parseJSONObjectOrNull_(input1)));
        }
        const a = input1.split("/").map((s) => s.trim());
        if (a.length < 1) {
            return null;
        }
        let markers = sarray_();
        if (a.length > 1) {
            if (a[1].length > 0) {
                markers = a[1].split(RX.Spaces).filter(s => s.length > 0);
                if (!CSSUtil.validateClasses(markers)) {
                    return null;
                }
            }
        }
        const editing = mainPanel$.isEditing();
        if (a[0].startsWith(`${TemplateAction.widget},`))
            return _ClientActionWidget.parse_(editing, a, markers);
        switch (a[0]) {
            case TemplateAction.annotation:
                return _ClientActionAnnotation.parse_(editing);
            case TemplateAction.delete:
                return _ClientActionDelete.parse_(editing, a, markers);
            case TemplateAction.drag:
                return _ClientActionDrag.parse_(editing, a, markers);
            case TemplateAction.template:
                return _ClientActionTemplate.parse_(editing, a, markers);
            case TemplateAction.style:
                return _ClientActionStyle.parse_(editing, a, markers);
            case TemplateAction.cycle:
            case TemplateAction.cycle1:
                return _ClientActionCycle.parse_(editing, a, markers);
            case TemplateAction.toggle:
                return _ClientActionToggle.parse_(editing, a, markers);
            case TemplateAction.cutMarked:
            case TemplateAction.cutNotMarked:
                return _ClientActionCut.parse_(editing, a, markers);
            case TemplateAction.radio:
                return _ClientActionRadio.parse_(editing, a, markers);
            case TemplateAction.move:
                return _ClientActionMove.parse_(editing, a, markers);
            case TemplateAction.blog:
                return _ClientActionBlog.parse_(editing, a);
            case TemplateAction.classes:
                return _ClientActionClasses.parse_(editing, markers);
            case TemplateAction.postAlarm:
                return _ClientActionPostAlarm.parse_(editing, markers);
            case TemplateAction.bg:
                return _ClientActionBg.parse_(editing, markers);
            case TemplateAction.playall:
                return _ClientActionPlayAll.parse_(editing);
            default:
                return null;
        }
    }

    static clientActionFrom_(info: ClientActionInfo | null): _IClientAction | null {
        if (info == null) return null;
        return With.notnull_(info?.action1_(), (action) => {
            const editing = mainPanel$.isEditing();
            switch (action) {
                case TemplateAction.annotation:
                    return _ClientActionAnnotation.from_(editing);
                case TemplateAction.delete:
                    return _ClientActionDelete.from_(editing, info);
                case TemplateAction.drag:
                    return _ClientActionDrag.from_(editing, info);
                case TemplateAction.template:
                    return _ClientActionTemplate.from_(editing, info);
                case TemplateAction.style:
                    return _ClientActionStyle.from_(editing, info);
                case TemplateAction.cycle:
                case TemplateAction.cycle1:
                    return _ClientActionCycle.from_(editing, info);
                case TemplateAction.toggle:
                    return _ClientActionToggle.from_(editing, info);
                case TemplateAction.cutMarked:
                case TemplateAction.cutNotMarked:
                    return _ClientActionCut.from_(editing, info);
                case TemplateAction.radio:
                    return _ClientActionRadio.from_(editing, info);
                case TemplateAction.move:
                    return _ClientActionMove.from_(editing, info);
                case TemplateAction.blog:
                    return _ClientActionBlog.from_(editing, info);
                case TemplateAction.classes:
                    return _ClientActionClasses.from_(editing, info);
                case TemplateAction.postAlarm:
                    return _ClientActionPostAlarm.from_(editing, info);
                case TemplateAction.bg:
                    return _ClientActionBg.from_(editing, info);
                case TemplateAction.widget:
                    return _ClientActionWidget.from_(editing, info);
                default:
                    return null;
            }
        });
    }

}

////////////////////////////////////////////////////////////////////////

class _State {
    static readonly INVALID: _State = new _State("INVALID");
    static readonly BROWSING: _State = new _State("BROWSING");
    static readonly TEXT: _State = new _State("TEXT");
    static readonly IMAGE: _State = new _State("IMAGE");
    static readonly AUDIO: _State = new _State("AUDIO");
    static readonly EDITING: _State = new _State("EDITING");
    static readonly PDF: _State = new _State("PDF");
    static readonly VIDEO: _State = new _State("VIDEO");

    _name: string;

    constructor(name: string) {
        this._name = name;
    }

    isEditing_(): boolean {
        return this == _State.EDITING;
    }

    toString(): string {
        return this._name;
    }
}
let state$ = _State.BROWSING;

////////////////////////////////////////////////////////////////////////

class MainToolbarActions {
    static readonly _HOME = "XxX7j";
    static readonly _FORWARD = "XxXwI";
    static readonly _TOOLBAR_TOOLBAR = "XxXk7";
    static readonly _IMAGE_ROTATE = "XxXJ8";
    static readonly _TOGGLE_LEFTSIDEPANEL = "XxXno";
    static readonly _SEARCH_PREV = "XxXRN";
    static readonly _IMAGE_MENU = "XxX35";
    static readonly _CANCEL = "XxXad";
    static readonly _SEARCH_REPLACE = "XxXAv";
    static readonly _TOOLBAR_PLAYBACK = "XxXD0";
    static readonly _BROWSING_MENU = "XxXmd";
    static readonly _EDITING_MENU = "XxX6M";
    static readonly _EDIT_NODE = "XxX80";
    static readonly _SAVE = "XxXyJ";
    static readonly _SPACER = "XxXcn";
    static readonly _SEARCHBAR_RECORDING = "XxXj0";
    static readonly _SEARCH_IGNORECASE = "XxX40";
    static readonly _SEARCHBAR = "XxXET";
    static readonly _BACK = "XxXkR";
    static readonly _TOOLBAR_RECORDING = "XxXbS";
    static readonly _SEARCH_NEXT = "XxXqc";
    static readonly _SELECT = "XxXaY";
    static readonly _SEARCHBAR_PLAYBACK = "XxXYw";
    static readonly _SEARCHBAR_TOOLBAR = "XxXkg";
    static readonly _EDIT = "XxXvm";
}

class _MainToolbar {
    static readonly _BUTTONS = json_(
        [MainToolbarActions._TOOLBAR_TOOLBAR, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
            ["enable", [_State.BROWSING, _State.EDITING, _State.TEXT]],
        )],
        [MainToolbarActions._SEARCHBAR_TOOLBAR, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
            [ATTR.xTooltips, RS.Tooltips_Toolbar],
            ["enable", [_State.BROWSING, _State.EDITING, _State.TEXT]],
        )],
        [MainToolbarActions._BROWSING_MENU, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaToggleDown}`],
            [ATTR.xTooltips, RS.Tooltips_Contextmenu],
            ["enable", [_State.BROWSING]],
        )],
        [MainToolbarActions._EDITING_MENU, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaToggleDown}`],
            [ATTR.xTooltips, RS.Tooltips_Contextmenu],
            ["enable", [_State.EDITING]],
        )],
        [MainToolbarActions._EDIT_NODE, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEdit}`],
            [ATTR.xTooltips, RS.Tooltips_EditNode],
            ["enable", [_State.EDITING]],
        )],
        [MainToolbarActions._SELECT, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaChevronCircleUp}`],
            [ATTR.xTooltips, RS.Tooltips_SelectParent],
            ["enable", [/* _State.BROWSING, */ _State.EDITING]],
        )],
        [MainToolbarActions._EDIT, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaEdit}`],
            [ATTR.xTooltips, RS.Tooltips_Edit],
            ["enable", [_State.BROWSING, _State.TEXT]],
        )],
        [MainToolbarActions._BACK, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleLeft}`],
            [ATTR.xTooltips, RS.Tooltips_GoBackInHistory],
            ["enable", [
                _State.INVALID,
                _State.BROWSING,
                _State.IMAGE,
                _State.AUDIO,
                _State.PDF,
                _State.TEXT,
                _State.VIDEO,
            ]]
        )],
        [MainToolbarActions._FORWARD, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleRight}`],
            [ATTR.xTooltips, RS.Tooltips_GoForwardInHistory],
            ["enable", [
                _State.INVALID,
                _State.BROWSING,
                _State.IMAGE,
                _State.AUDIO,
                _State.PDF,
                _State.TEXT,
                _State.VIDEO,
            ]]
        )],
        [MainToolbarActions._HOME, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaHome}`],
            [ATTR.xTooltips, RS.Tooltips_Home],
            ["enable", [
                _State.INVALID,
                _State.BROWSING,
                _State.IMAGE,
                _State.AUDIO,
                _State.PDF,
                _State.TEXT,
                _State.VIDEO,
            ]]
        )],
        [MainToolbarActions._SAVE, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSave}`],
            [ATTR.xTooltips, RS.Tooltips_SaveAndQuit],
            ["enable", [_State.EDITING]],
        )],
        [MainToolbarActions._CANCEL, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaTrash}`],
            [ATTR.xTooltips, RS.Tooltips_QuitWithoutSave],
            ["enable", [_State.EDITING]],
        )],
        [MainToolbarActions._IMAGE_MENU, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaToggleDown}`],
            [ATTR.xTooltips, RS.Tooltips_ImageViewerContextmenu],
            ["enable", [_State.IMAGE]],
        )],
        [MainToolbarActions._IMAGE_ROTATE, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaRotateRight}`],
            [ATTR.xTooltips, RS.Tooltips_RotateImage],
            ["enable", [_State.IMAGE]],
        )],
        [MainToolbarActions._TOGGLE_LEFTSIDEPANEL, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaToggleRight}`],
            [ATTR.xTooltips, RS.Tooltips_ShowOrHideLeftSidepanel],
            ["enable", [
                _State.INVALID,
                _State.BROWSING,
                _State.EDITING,
                _State.IMAGE,
                _State.AUDIO,
                _State.PDF,
                _State.TEXT,
                _State.VIDEO,
            ]]
        )],
        [MainToolbarActions._TOOLBAR_RECORDING, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMicrophone}`],
            [ATTR.xTooltips, RS.Tooltips_StopAudioRecording],
            ["enable", null],
        )],
        [MainToolbarActions._SEARCHBAR_RECORDING, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMicrophone}`],
            [ATTR.xTooltips, RS.Tooltips_StopAudioRecording],
            ["enable", null],
        )],
        [MainToolbarActions._TOOLBAR_PLAYBACK, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaVolumeUp}`],
            [ATTR.xTooltips, RS.Tooltips_StopAudioPlayback],
            ["enable", null],
        )],
        [MainToolbarActions._SEARCHBAR_PLAYBACK, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaVolumeUp}`],
            [ATTR.xTooltips, RS.Tooltips_StopAudioPlayback],
            ["enable", null],
        )],

        [MainToolbarActions._SEARCH_REPLACE, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaSearchPlus} toogle`],
            [ATTR.xTooltips, RS.Tooltips_Replace],
            ["enable", []],
        )],
        [MainToolbarActions._SEARCH_NEXT, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaArrowCircleDown}`],
            [ATTR.xTooltips, RS.Tooltips_NextMatch],
            ["enable", []],
        )],
        [MainToolbarActions._SEARCH_PREV, json_(
            ["class", `${CSS.AnButton} ${CSS.AnToggleOff} ${CSS.Fa} ${CSS.FaArrowCircleUp}`],
            [ATTR.xTooltips, RS.Tooltips_PreviousMatch],
            ["enable", []],
        )],
        [MainToolbarActions._SEARCH_IGNORECASE, json_(
            ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaInfo}`],
            [ATTR.xTooltips, RS.Tooltips_ToggleIgnoreCase],
            ["enable", []],
        )],
    );

    static _homeCount: number = 0;
    private _mainbar: HTMLElement;
    private _searchbar: HTMLElement;
    private _toolbar: HTMLElement;
    private _searchbox: HTMLTextAreaElement;
    private _matcher: SearchMatcher | null = null;
    private _buttons = new Map<string, HTMLElement>();
    private _toolbarButtons = new Map<string, HTMLElement>();
    private _tooltipsShown: boolean = false;
    private _enabled: boolean = false;
    private _clickTime: number = 0;
    private _tooltipsTimer: Timer | null = null;
    private _clickTimer: Timer | null = null;
    private _enableTimer: Timer | null = null;

    /**
       * _MainToolbar constructor
       * @param container The div#${ID.toolbar} element.
       */
    constructor(container: HTMLElement) {
        
        const b = DomBuilderEx.offline_(document, "div").push_();
        this._mainbar = b
            .peek_()
            .div_({
                "class": CSS.AnToolbar, //as
                "style": "padding-left: 12px;",
            })
            .push_()
            .cursor_();
        this._toolbar = this._mainbar;
        _MainToolbar._createtoolbarbuttons(b, this._buttons, this._toolbarButtons, false, [
            MainToolbarActions._TOGGLE_LEFTSIDEPANEL,
            MainToolbarActions._TOOLBAR_RECORDING,
            MainToolbarActions._TOOLBAR_PLAYBACK,
            MainToolbarActions._SPACER,
            MainToolbarActions._BROWSING_MENU,
            MainToolbarActions._EDITING_MENU,
            MainToolbarActions._EDIT_NODE,
            MainToolbarActions._BACK,
            MainToolbarActions._FORWARD,
            MainToolbarActions._SELECT,
            MainToolbarActions._IMAGE_ROTATE,
            MainToolbarActions._CANCEL,
            MainToolbarActions._SAVE,
            MainToolbarActions._EDIT,
            MainToolbarActions._HOME,
            MainToolbarActions._IMAGE_MENU,
            MainToolbarActions._TOOLBAR_TOOLBAR,
        ]);
        this._searchbar = b
            .peek_()
            .div_({
                "class": CSS.AnToolbar,
                "style": "padding-left: 12px;display:none",
            })
            .push_()
            .cursor_();
        _MainToolbar._createtoolbarbuttons(b.peek_(), this._buttons, null, true, [
            MainToolbarActions._TOGGLE_LEFTSIDEPANEL,
            MainToolbarActions._SEARCHBAR_RECORDING,
            MainToolbarActions._SEARCHBAR_PLAYBACK,
            MainToolbarActions._SPACER,
        ]);
        this._searchbox = b.peek_().child_(Conf.input$, json_(
            ["class", CSS.AnSearchbox],
            ["rows", "1"],
            ["placeholder", MSG.string_(RS.Tooltips_Search)],
            ["tabindex", "1"],
            [ATTR.autocapitalize, "none"],
            [ATTR.autocomplete, "off"],
            [ATTR.autocorrect, "off"],
            [ATTR.spellcheck, "false"],
        )).cursor_() as AnInputElement;
        _MainToolbar._createtoolbarbuttons(b.peek_(), this._buttons, null, true, [
            MainToolbarActions._SEARCH_IGNORECASE,
            MainToolbarActions._SEARCH_NEXT,
            MainToolbarActions._SEARCH_PREV,
            MainToolbarActions._SEARCHBAR_TOOLBAR,
        ]);
        this._setup(container);
    }

    private _setup(container: HTMLElement): void {
        
        new DomBuilderEx(container).empty_()
            .appendNodes_(this._mainbar)
            .appendNodes_(this._searchbar);
        An.onFocus_(this._searchbox, () => {
            
            this._matcher = _MainToolbar._createSearchMatcher();
            toasters$.hideAll_();
            An.select_(this._searchbox);
        });
        An.onClick_(this._searchbox, e => {
            
            An.stopevent_(e);
            this._searchbox.blur();
            this._searchbox.focus();
        });
        An.onKeypress_(this._searchbox, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this._searchNext();
            }
        });
        An.onInput_(this._searchbox, () => {
            
            this._actionIncrementalSearch(null);
        });
        this._matcher = null;

        An.onClick_(container, e => {
            An.stopevent_(e);
            const target = DomUt.matchingTarget_(e, `div[${ATTR.AnAction}]`) as HTMLElement;
            if (target == null || !this._enabled || target.classList.contains(CSS.AnDisabled)) {
                
                native$.iClearSelection_();
                host$.hideKeyboard_();
                if (target == null) {
                    this._tryDoubleClick();
                }
                return;
            }
            const action = target.getAttribute(ATTR.AnAction);
            if (action != null && action.length > 0) {
                
                this._toolbarActions(action, target, e);
            }
        });
        An.onEventMatching_(container, Conf.pointerstart$, `div[${ATTR.xTooltips}]`, (target, e) => {
            this._stopTooltipsTimer();
            this._tooltipsShown = false;
            this._tooltipsTimer = new Timer(DEFUtil.durationTooltips$, () => {
                this._tooltipsTimer = null;
                this._tooltipsShown = true;
                toasters$.onTooltipsKey_(target, e);
            });
        });
        An.onPointerEnd_(container, e => {
            this._stopTooltipsTimer();
            if (this._tooltipsShown) {
                this._tooltipsShown = false;
                An.stopevent_(e);
            }
        });
        this.updateAudioStatus_();
        if (Conf.useFlash$) {
            new Flash(container, `div.${CSS.AnButton}`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
    }

    button(action: string): HTMLElementX {
        return this._buttons.get(action) ?? null;
    }

    private _tryDoubleClick(): void {
        const prev = this._clickTime;
        if (prev == 0) {
            this._clickTime = An.ms_();
            this._clickTimer = new Timer(DEFUtil.doubleClickDuration$, () => {
                this._clickTimer = null;
                this._clickTime = 0;
            });
        } else {
            this._clickTimer?.cancel_();
            this._clickTimer = null;
            this._clickTime = 0;
            this._doubleClick();
        }
    }

    private _doubleClick(): void {
        if (mainPanel$.isBrowsing() || mainPanel$.isEditing()) {
            const root = native$.iQuery(`.${CSS.xRoot}`);
            if (root != null) {
                if (root.scrollTop != 0) {
                    root.scrollTop = 0;
                } else {
                    const top = root.scrollHeight - window.innerHeight + cache$.ui$.toolbarHeight_();
                    
                    if (top > 0) {
                        root.scrollTop = top;
                    }
                }
            }
        }
    }

    private _stopTooltipsTimer(): void {
        this._tooltipsTimer?.cancel_();
        this._tooltipsTimer = null;
    }

    updateAudioStatus_(): void {
        host$.getAudioStatus_(ret => {
            this.updateAudioStatus1_(ret);
        });
    }

    updateAudioStatus1_(ret: JSONObject): void {
        const msg = ret[Key.text];
        if (msg != null) {
            toasters$.ok_(msg, { attop: true });
        }
        const recorder = ret[Key.recorder];
        const isrecording = recorder?.[Key.status] ?? false;
        for (const action of [
            MainToolbarActions._TOOLBAR_RECORDING,
            MainToolbarActions._SEARCHBAR_RECORDING,
        ]) {
            this._show(action, isrecording);
        }
        const player = ret[Key.player];
        const isplayback = player?.[Key.status] ?? false;
        for (const action of [
            MainToolbarActions._TOOLBAR_PLAYBACK,
            MainToolbarActions._SEARCHBAR_PLAYBACK,
        ]) {
            this._show(action, isplayback);
        }
    }

    static _createtoolbarbuttons(
        b: DomBuilderEx,
        buttons: Map<string, HTMLElement>,
        table: Map<string, HTMLElement> | null,
        visible: boolean,
        actions: string[]
    ): void {
        for (const action of actions) {
            if (action == MainToolbarActions._SPACER) {
                b.peek_().div_({ "style": "flex:1 1 auto;" });
            } else {
                const button = _MainToolbar._BUTTONS[action];
                const attrs = smap_(
                    [ATTR.AnAction, action],
                    ["class", button["class"] as string],
                    [ATTR.xTooltips, button[ATTR.xTooltips] as string],
                );
                if (!visible) {
                    attrs["style"] = "display:none";
                }
                b.peek_().div_(attrs);
                buttons.set(action, b.cursor_());
                if (table != null) {
                    table.set(action, b.cursor_());
                }
            }
        }
    }

    setEnabled(yes: boolean): void {
        if (this._enableTimer != null) {
            this._enableTimer.cancel_();
            this._enableTimer = null;
        }
        this._enabled = yes;
        if (!yes) {
            this._enableTimer = new Timer(5000, () => {
                this._enabled = true;
                this._enableTimer = null;
            });
        }
    }

    private _show(button: string, yes: boolean): void {
        const but = this._buttons.get(button);
        if (but === undefined) throw new Error(MSG.string1_(RS.NotFound_, button));
        if (yes) {
            An.show_(but);
        } else {
            An.hide_(but);
        }
    }

    private _setButtonEnable(button: string, enable: boolean): void {
        const but = this._buttons.get(button);
        if (but === undefined) throw new Error(MSG.string1_(RS.NotFound_, button));
        An.enableButton_(but, enable);
    }

    onresize_(): void { }

    onStateChange_(): void {
        
        //// _buttons[_IMAGE_FIT].classes.remove(CSS.AnToggleOff);
        //// _buttons[_VIDEO_FIT].classes.remove(CSS.AnToggleOff);
        for (const [action, button] of this._toolbarButtons.entries()) {
            const info = _MainToolbar._BUTTONS[action];
            const states = (info["enable"] as Array<_State>);
            if (states == null) {
                continue;
            }
            const enable = (states.indexOf(state$) >= 0);
            if (enable) {
                An.show_(button);
            } else {
                An.hide_(button);
            }
        }
        this.showMainbar_();
        if (state$ == _State.BROWSING) {
            if (docInfo$ != null && docInfo$.hasInfo$ && docInfo$.fileInfo$.writable$) {
                this._setButtonEnable(MainToolbarActions._EDIT, true);
            } else {
                this._setButtonEnable(MainToolbarActions._EDIT, false);
            }
            this._updateToolbarStatus();
        } else if (state$ == _State.TEXT) {
            this._setButtonEnable(MainToolbarActions._EDIT, false);
        }
    }

    private _searchPrev(): void {
        An.toggleButtonOff_(this._buttons.get(MainToolbarActions._SEARCH_NEXT)!);
        An.toggleButtonOn_(this._buttons.get(MainToolbarActions._SEARCH_PREV)!);
        this._resetAnchor();
        host$.hideKeyboard_(() => {
            this._actionIncrementalSearch(null);
        });
    }

    private _searchNext(): void {
        An.toggleButtonOn_(this._buttons.get(MainToolbarActions._SEARCH_NEXT)!);
        An.toggleButtonOff_(this._buttons.get(MainToolbarActions._SEARCH_PREV)!);
        this._resetAnchor();
        host$.hideKeyboard_(() => {
            this._actionIncrementalSearch(null);
        });
    }

    private _toolbarActions(action: string, target: HTMLElement, e: MouseEvent) {
        toasters$.hideAll_();
        switch (action) {
            case MainToolbarActions._SEARCH_IGNORECASE:
                An.toggleOnOffButton_(this._buttons.get(MainToolbarActions._SEARCH_IGNORECASE)!);
                break;
            case MainToolbarActions._SEARCH_PREV:
                this._searchPrev();
                break;
            case MainToolbarActions._SEARCH_NEXT:
                this._searchNext();
                break;
            case MainToolbarActions._TOOLBAR_TOOLBAR:
                this.showSearchbar_();
                break;
            case MainToolbarActions._SEARCHBAR_TOOLBAR:
                this.showMainbar_();
                break;
            default:
                mainPanel$.toolbarActions_(e, target, action);
        }
    }

    showMainbar_(): void {
        if (this._toolbar != this._mainbar) {
            An.hide_(this._searchbar);
            An.show_(this._mainbar);
            this._toolbar = this._mainbar;
            this.updateAudioStatus_();
        }
    }

    toggleSearchbar_(e: KeyboardEvent) {
        if (sidePanel$.isShown_()) return;
        An.stopevent_(e);
        if (e.shiftKey) {
            mainPanel$?._mainToolbar?.showMainbar_();
        } else {
            mainPanel$?._mainToolbar?.showSearchbar_();
        }
    }

    showSearchbar_(): void {
        if (this._toolbar != this._searchbar) {
            An.hide_(this._mainbar);
            An.show_(this._searchbar);
            this._toolbar = this._searchbar;
        }
        const range = native$.getIFrameSelectionRange_();
        if (range != null && !range.collapsed) {
            const text = range.toString();
            if (text != null && text.length > 0) {
                this._searchbox.value = text.trim();
            }
        }
        this._searchbox.focus();
    }

    private _updateToolbarStatus(): void {
    }

    private _resetAnchor(): void {
        if (this._matcher == null) {
            this._matcher = _MainToolbar._createSearchMatcher();
        } else {
            this._matcher.setAnchor(native$.getIFrameSelectionRange_());
        }
    }

    static _createSearchMatcher(): SearchMatcher | null {
        const body = native$.getIFrameBody_();
        if (body == null) return null;
        let range = native$.getValidIFrameSelectionRange_();
        if (range == null) {
            range = native$.iSelectNode_(body, true);
        }
        return new SearchMatcher(body, range);
    }

    private _actionIncrementalSearch(top: booleanX): void {
        try {
            searchSpotlight$.hide_();
            toasters$.hideAll_();
            if (this._matcher == null) {
                this._matcher = _MainToolbar._createSearchMatcher();
            }
            if (this._matcher == null) {
                return;
            }
            const m = this._matcher;
            let value = this._searchbox.value;
            const length = value.length;
            if (length == 0) {
                const range = m.getAnchor();
                native$.iSelectRange_(range, true);
                return;
            }
            const ignorecase = !An.isButtonOff_(this._buttons.get(MainToolbarActions._SEARCH_IGNORECASE)!);
            const backward = An.isButtonOff_(this._buttons.get(MainToolbarActions._SEARCH_NEXT)!);
            let text: string;
            if (ignorecase) {
                text = m.getLowerCaseText();
                value = value.toLowerCase();
            } else {
                text = m.getText();
            }
            const textlength = text.length;
            let anchor = m.getAnchorOffset(backward);
            const msg: string[] = [];
            if (anchor == null) {
                if (backward) {
                    msg.push(MSG.string_(RS.SearchFromEnd));
                    anchor = textlength;
                } else {
                    msg.push(MSG.string_(RS.SearchFromStart));
                    anchor = 0;
                }
            }
            if (backward) {
                --anchor;
            }
            const c0 = value[0];
            const delta = backward ? -1 : 1;
            NEXT:
            for (let offset = anchor; offset < textlength && offset >= 0; offset += delta) {
                if (text[offset] == c0) {
                    for (let i = 1; (i < length) && (offset + i < textlength); ++i) {
                        if (text[offset + i] != value[i]) {
                            continue NEXT;
                        }
                    }
                    const range = m.getRangeOf(offset, offset + length);
                    if (range == null) { continue; }
                    const parent = range.commonAncestorContainer;
                    _MainPanel._revealHierarchy(parent);
                    native$.iSelectRange_(range, true, top);
                    if (parent != null && !native$.isVisible_(parent)) {
                        msg.push(MSG.string_(RS.MatchFoundButNotVisible));
                    } else if (range != null) {
                        this._showSelection(range);
                        if (msg.length > 0) {
                            msg.push(MSG.string_(RS.MatchFound));
                        }
                    }
                    if (msg.length > 0) {
                        toasters$.info_(msg, { attop: false });
                    }
                    return;
                }
            }
            native$.iClearSelection_();
            msg.push(MSG.string_(backward ? RS.ReachedStartOfDocument : RS.ReachedEndOfDocument));
            msg.push(MSG.string_(RS.NoMatchFound));
            toasters$.warn_(msg, { attop: false });
        } catch (e) {
            
        }
    }

    private _showSelection(_range: Range): void {
    }

    onIFrameLoad(_uri: UriX): void {
        this._matcher = null;
        
        this.onStateChange_();
        native$.iAddEventListener_(native$.getIFrameWindow_(), "keypress", (event) => {
            const e = event as KeyboardEvent;
            if (!e.ctrlKey) return;
            switch (e.key) {
                case "f": case "F": {
                    mainPanel$?._mainToolbar?.toggleSearchbar_(e);
                    break;
                }
                case "i": case "I": {
                    if (e.shiftKey) {
                        An.stopevent_(e);
                        host$.showDeveloperTools_();
                    }
                    break;
                }
                case "w": case "W": case "r": case "R": {
                    
                    e.stopImmediatePropagation();
                    An.stopevent_(e);
                    break;
                }
            }
        }, true, true);
        this.setEnabled(true);
    }

    onIFrameUnload(): void {
        searchSpotlight$.hide_();
        this._matcher = null;
        this.setEnabled(false);
    }
}

class BrowsingContextActions {
    static readonly _SYSTEM_QUIT = "XxXqit";
    static readonly _SYSTEM_PRINT = "XxX4A";
    static readonly _SYSTEM_MANAGE_BACKUP_KEYS = "XxXtu";
    static readonly _SYSTEM_RESET_USER_SETTINGS = "XxXfN";
    static readonly _SYSTEM_CLEAN_HOME = "XxXrud";
    static readonly _SYSTEM_FACTORY_RESET = "XxXgP";
    static readonly _COPY = "XxXcpy";
    static readonly _CALCULATOR = "XxXcal";
    static readonly _SCREENSHOT = "XxXssh";
}

class BrowsingContextmenu extends _ContextmenuBase {
    static _BUTTONS = smap_<SStringMap>(
        [BrowsingContextActions._COPY, smap_(
            [ATTR.AnAction, BrowsingContextActions._COPY],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCopy}`],
            [ATTR.xTooltips, RS.Tooltips_CopySelection],
        )],
        [BrowsingContextActions._SYSTEM_PRINT, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPrint}`],
            [ATTR.xTooltips, RS.Tooltips_Print],
        )],
        [BrowsingContextActions._SYSTEM_QUIT, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaToggleOff}`],
            [ATTR.xTooltips, RS.ActionQuitTooltips],
        )],
        [BrowsingContextActions._SYSTEM_FACTORY_RESET, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaWarning}`],
            [ATTR.xTooltips, RS.FactoryResetTooltips],
        )],
        [BrowsingContextActions._SYSTEM_MANAGE_BACKUP_KEYS, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaKey}`],
            [ATTR.xTooltips, RS.BackupKeyManagerTooltips],
        )],
        [BrowsingContextActions._SYSTEM_CLEAN_HOME, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaShower}`],
            [ATTR.xTooltips, RS.ActionCleanHomeTooltips],
        )],
        [BrowsingContextActions._SYSTEM_RESET_USER_SETTINGS, json_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaTimesCircle}`],
            [ATTR.xTooltips, RS.ResetUserSettingsTooltips],
        )],
        [BrowsingContextActions._CALCULATOR, smap_(
            [ATTR.AnAction, BrowsingContextActions._CALCULATOR],
            [ATTR.xTooltips, RS.Tooltips_Calculator],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCalculator}`],
        )],
        [BrowsingContextActions._SCREENSHOT, smap_(
            [ATTR.AnAction, BrowsingContextActions._SCREENSHOT],
            [ATTR.xTooltips, RS.ActionScreenshotTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCameraRetro}`],
        )],
    );

    _buttons = new Map<string, HTMLElement>();

    /// @param The div.AnContextmenu element.
    constructor(container: HTMLElement) {
        super(ContextmenuBase.createContextmenu_(container, NAME.browsingContextmenu));
        const b = new DomBuilderEx(this._contextmenu);
        b.table_({
            "class": CSS.AnContextmenu,
        }).push_();
        _ContextmenuBase.createButtons_(this._buttons, b, [
            [
                BrowsingContextActions._SYSTEM_CLEAN_HOME,
                BrowsingContextActions._SYSTEM_FACTORY_RESET,
                BrowsingContextActions._SYSTEM_QUIT,
            ],
            [
                BrowsingContextActions._SYSTEM_MANAGE_BACKUP_KEYS,
                BrowsingContextActions._SYSTEM_RESET_USER_SETTINGS,
                DEF.NOOP,
            ],
            [
                BrowsingContextActions._COPY,
                BrowsingContextActions._SCREENSHOT,
                BrowsingContextActions._CALCULATOR,
            ],
        ], BrowsingContextmenu._BUTTONS);
        container.appendChild(this._contextmenu);
        super.setupHandlers_(this._contextmenu, `td.${CSS.AnContextButton}`);
        this.onAction_((action) => this._contextActions(action));
        this.onCancel_(() => native$.focusIFrame_());
        this.onContextmenu_(toasters$.onTooltipsKey_);
    }
    _contextActions(action: string) {
        this.hide_();
        switch (action) {
            case BrowsingContextActions._SYSTEM_QUIT: {
                host$.actionQuit_();
                break;
            }
            case BrowsingContextActions._SYSTEM_PRINT: {
                break;
            }
            case BrowsingContextActions._SYSTEM_MANAGE_BACKUP_KEYS:
                _SystemActionsHelper.actionManageBackupKeys_(settings$.dateFormat_());
                break;
            case BrowsingContextActions._SYSTEM_RESET_USER_SETTINGS:
                host$.actionResetUserSettings_();
                break;
            case BrowsingContextActions._SYSTEM_CLEAN_HOME:
                host$.actionCleanHome_();
                break;
            case BrowsingContextActions._SYSTEM_FACTORY_RESET:
                host$.actionFactoryReset_();
                break;
            case BrowsingContextActions._CALCULATOR:
                _MainPanel._actionCalculator();
                break;
            case BrowsingContextActions._SCREENSHOT: {
                _Util.actionScreenshot_();
                break;
            }
            case BrowsingContextActions._COPY:
                _MainPanel._actionCopy();
                break;
            default:
                Assert.notReach_();
        }
    }

    onPause_() {
    }

    onResume_() {
    }

    resetIFrame_() {
    }

}

class MainContextActions {
    static readonly _SPAWN_NODE = "XxX05";
    static readonly _CUT = "XxXWn";
    static readonly _INSERT_SYMBOL = "XxXKi";
    static readonly _FONT_NAME = "XxXHk";
    static readonly _LIST_ITEM_DATE = "XxXWV";
    static readonly _INSERT_WIDGET = "XxXYS";
    static readonly _INSERT_CANVAS = "XxXJP";
    static readonly _UNDO = "XxXvd";
    static readonly _DELETE = "XxXj3";
    static readonly _LIST_SYMBOLS = "XxX61";
    static readonly _LIST_ITEM_SYMBOL = "XxXxE";
    static readonly _SUBMENU_FONT = "XxX0x";
    static readonly _INSERT_AUDIO = "XxXH0";
    static readonly _TO_NBSP = "XxXzU";
    static readonly _CHAR_HIDDEN = "XxXoP";
    static readonly _CHAR_STYLES = "XxXrY";
    static readonly _LIST_OL = "XxXwN";
    static readonly _EDIT_STYLE_RAW = "XxXqf";
    static readonly _EDIT_SIZE = "XxXwQ";
    static readonly _INSERT_LINK = "XxXPH";
    static readonly _INSERT_CALENDAR = "XxX7o";
    static readonly _SELECT_NEXT_SIBLING = "XxXMR";
    static readonly _SUBMENU_CHAR = "XxXzq";
    static readonly _COPY = "XxXZm";
    static readonly _PARA_STYLES = "XxXba";
    static readonly _RECORD_VIDEO = "XxXEd";
    static readonly _LINEBREAK = "XxXiD";
    static readonly _ANNOTATE_IMG = "XxXag";
    static readonly _REDO = "XxXX7";
    static readonly _LIST_UL_NONE = "XxXPb";
    static readonly _TAKE_PHOTO = "XxXrW";
    static readonly _PARA_HIDDEN = "XxXCp";
    static readonly _FONT_BG = "XxXSB";
    static readonly _DESTRUCT_WIDGET = "XxXNf";
    static readonly _INSERT_VIDEO = "XxXTf";
    static readonly _RECORD_AUDIO = "XxX4T";
    static readonly _LIST_UL_NONE_INDENTED = "XxX2s";
    static readonly _FONT_CATEGORY = "XxX9U";
    static readonly _EDIT_NODE_RAW = "XxXbg";
    static readonly _INSERT_IMG = "XxXM7";
    static readonly _INSERT_ALARM = "XxXia";
    static readonly _PASTE_CHILD = "XxXdK";
    static readonly _TOGGLE_RIGHTSIDEBAR = "XxXyB";
    static readonly _EDIT_ALIGN = "XxX8w";
    static readonly _TO_SPACE = "XxXra";
    static readonly _INSERT_ELEMENT = "XxXWH";
    static readonly _PASTE_SIBLING = "XxXQH";
    static readonly _CALCULATOR = "XxXpn";
    static readonly _PASTE_FROM_SYSTEM_CLIPBOARD = "XxXpfs";
    static readonly _SCREENSHOT = "XxXssh";
    static readonly _INSERT_DATE = "XxXUn";
    static readonly _LIST_ITEM_TEXT = "XxXKl";
    static readonly _PARAGRAPH = "XxXYz";
    static readonly _MOVETO_PREV = "XxXNG";
    static readonly _SUBMENU_PARA = "XxXGe";
    static readonly _LIST_DATE = "XxXQI";
    static readonly _MOVETO_PARENT = "XxXoJ";
    static readonly _FONT_BG_IMG = "XxX2o";
    static readonly _LIST_COMPACT = "XxXBM";
    static readonly _LIST_ITEM = "XxXkR";
    static readonly _LIST_ITEM_TIME = "XxXAQ";
    static readonly _INSERT_NAMED_ANCHOR = "XxXeS";
    static readonly _SUBMENU_LIST = "XxXJI";
    static readonly _WRAP = "XxXSW";
    static readonly _HIGHLIGHT_STYLES = "XxXzY";
    static readonly _FONT_FG_STYLE = "XxXuy";
    static readonly _SUBMENU_MEDIA = "XxXN9";
    static readonly _BORDER = "XxXLm";
    static readonly _LIST_EXPAND = "XxX4C";
    static readonly _FONT_STYLE = "XxXBf";
    static readonly _MOVETO_NEXT = "XxXaH";
    static readonly _UNDO_HISTORY = "XxXlh";
    static readonly _EDIT_STYLE = "XxXnw";
    static readonly _PARENT_NODE = "XxX9Y";
    static readonly _EDIT_NODE = "XxX0W";
    static readonly _LIST_UL = "XxXM6";
    static readonly _UNWRAP = "XxXNb";
    static readonly _SUBMENU_OTHERS = "XxX4q";
    static readonly _INSERT_TEXT = "XxXHW";
    static readonly _FONT_SIZE = "XxXQp";
    static readonly _FONT_FG = "XxXIf";

    static readonly _STYLE_ALIGN_CENTER: string = CSS.xAlignCenter;
    static readonly _STYLE_ALIGN_JUSTIFY: string = CSS.xAlignJustify;
    static readonly _STYLE_ALIGN_LEFT: string = CSS.xAlignLeft;
    static readonly _STYLE_ALIGN_RIGHT: string = CSS.xAlignRight;
    static readonly _STYLE_BOLD: string = CSS.xBold;
    static readonly _STYLE_FLOAT_LEFT: string = CSS.xFloatLeft;
    static readonly _STYLE_FLOAT_RIGHT: string = CSS.xFloatRight;
    static readonly _STYLE_NOWRAP: string = CSS.xNowrap;
    static readonly _STYLE_ITALIC: string = CSS.xItalic;
    static readonly _STYLE_STRIKETHROUGH: string = CSS.xStrikethrough;
    static readonly _STYLE_SUBSCRIPT: string = CSS.xSubscript;
    static readonly _STYLE_SUPERSCRIPT: string = CSS.xSuperscript;
    static readonly _STYLE_UNDERLINE: string = CSS.xUnderline;
}

class _MainContextmenu extends _ContextmenuBase {

    static _BUTTONS = smap_<SStringMap>(
        [MainContextActions._COPY, smap_(
            [ATTR.AnAction, MainContextActions._COPY],
            [ATTR.xTooltips, RS.Tooltips_CopySelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCopy}`],
        )],
        [MainContextActions._CUT, smap_(
            [ATTR.AnAction, MainContextActions._CUT],
            [ATTR.xTooltips, RS.Tooltips_CutSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCut}`],
        )],
        [MainContextActions._PASTE_CHILD, smap_(
            [ATTR.AnAction, MainContextActions._PASTE_CHILD],
            [ATTR.xTooltips, RS.Tooltips_PasteAsChild],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaHandORight}`],
        )],
        [MainContextActions._PASTE_FROM_SYSTEM_CLIPBOARD, smap_(
            [ATTR.AnAction, MainContextActions._PASTE_FROM_SYSTEM_CLIPBOARD],
            [ATTR.xTooltips, RS.Tooltips_PasteFromSystemClipboard],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPaste} ${CSS.AnDisabled}`],
        )],
        [MainContextActions._PASTE_SIBLING, smap_(
            [ATTR.AnAction, MainContextActions._PASTE_SIBLING],
            [ATTR.xTooltips, RS.Tooltips_PasteAsNextSibling],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaHandODown}`],
        )],
        [MainContextActions._UNDO, smap_(
            [ATTR.AnAction, MainContextActions._UNDO],
            [ATTR.xTooltips, RS.Tooltips_Undo],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaReply}`],
        )],
        [MainContextActions._UNDO_HISTORY, smap_(
            [ATTR.AnAction, MainContextActions._UNDO_HISTORY],
            [ATTR.xTooltips, RS.Tooltips_UndoHistory],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaReplyAll}`],
        )],
        [MainContextActions._REDO, smap_(
            [ATTR.AnAction, MainContextActions._REDO],
            [ATTR.xTooltips, RS.Tooltips_Redo],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaShare}`],
        )],
        [MainContextActions._PARENT_NODE, smap_(
            [ATTR.AnAction, MainContextActions._PARENT_NODE],
            [ATTR.xTooltips, RS.Tooltips_SelectParent],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaChevronCircleUp}`],
        )],
        [MainContextActions._SELECT_NEXT_SIBLING, smap_(
            [ATTR.AnAction, MainContextActions._SELECT_NEXT_SIBLING],
            [ATTR.xTooltips, RS.Tooltips_ExtendSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaArrowCircleDown}`],
        )],
        [MainContextActions._WRAP, smap_(
            [ATTR.AnAction, MainContextActions._WRAP],
            [ATTR.xTooltips, RS.Tooltips_WrapSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPlusSquare}`],
        )],
        [MainContextActions._UNWRAP, smap_(
            [ATTR.AnAction, MainContextActions._UNWRAP],
            [ATTR.xTooltips, RS.Tooltips_UnwrapSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaMinusSquare}`],
        )],
        [MainContextActions._INSERT_ELEMENT, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_ELEMENT],
            [ATTR.xTooltips, RS.Tooltips_InsertElement],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCode}`],
        )],
        [MainContextActions._INSERT_TEXT, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_TEXT],
            [ATTR.xTooltips, RS.Tooltips_InsertText],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaTumblr}`],
        )],
        [MainContextActions._SPAWN_NODE, smap_(
            [ATTR.AnAction, MainContextActions._SPAWN_NODE],
            [ATTR.xTooltips, RS.Tooltips_SpawnSibling],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaDeviantart}`],
        )],
        [MainContextActions._EDIT_SIZE, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_SIZE],
            [ATTR.xTooltips, RS.Tooltips_ResizeElement],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaArrows}`],
        )],
        [MainContextActions._EDIT_ALIGN, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_ALIGN],
            [ATTR.xTooltips, RS.Tooltips_EditAlignments],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaExchange}`],
        )],
        [MainContextActions._EDIT_STYLE, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_STYLE],
            [ATTR.xTooltips, RS.Tooltips_EditStyle],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaThList}`],
        )],
        [MainContextActions._EDIT_STYLE_RAW, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_STYLE_RAW],
            [ATTR.xTooltips, RS.Tooltips_EditStyleAsRawText],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPencilSquare}`],
        )],
        [MainContextActions._EDIT_NODE, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_NODE],
            [ATTR.xTooltips, RS.Tooltips_EditNode],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [MainContextActions._EDIT_NODE_RAW, smap_(
            [ATTR.AnAction, MainContextActions._EDIT_NODE_RAW],
            [ATTR.xTooltips, RS.Tooltips_EditNodeAsRawText],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEdit}`],
        )],
        [MainContextActions._ANNOTATE_IMG, smap_(
            [ATTR.AnAction, MainContextActions._ANNOTATE_IMG],
            [ATTR.xTooltips, RS.Tooltips_AnnotateImage],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPencil}`],
        )],
        [MainContextActions._MOVETO_NEXT, smap_(
            [ATTR.AnAction, MainContextActions._MOVETO_NEXT],
            [ATTR.xTooltips, RS.Tooltips_SwapPositionWithNextSibling],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAngleDoubleDown}`],
        )],
        [MainContextActions._MOVETO_PREV, smap_(
            [ATTR.AnAction, MainContextActions._MOVETO_PREV],
            [ATTR.xTooltips, RS.Tooltips_SwapPositionWithPrevSibling],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAngleDoubleUp}`],
        )],
        [MainContextActions._MOVETO_PARENT, smap_(
            [ATTR.AnAction, MainContextActions._MOVETO_PARENT],
            [ATTR.xTooltips, RS.Tooltips_MoveUpAsNextSiblingOfParent],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAngleDoubleLeft}`],
        )],
        [MainContextActions._TOGGLE_RIGHTSIDEBAR, smap_(
            [ATTR.AnAction, MainContextActions._TOGGLE_RIGHTSIDEBAR],
            [ATTR.xTooltips, RS.Tooltips_ShowOrHideRightSidebar],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaToggleRight}`],
        )],
        [MainContextActions._LINEBREAK, smap_(
            [ATTR.AnAction, MainContextActions._LINEBREAK],
            [ATTR.xTooltips, RS.Tooltips_InsertLinebreak],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaGbp}`],
        )],
        [MainContextActions._PARAGRAPH, smap_(
            [ATTR.AnAction, MainContextActions._PARAGRAPH],
            [ATTR.xTooltips, RS.Tooltips_InsertParagraph],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaRub}`],
        )],
        [MainContextActions._DELETE, smap_(
            [ATTR.AnAction, MainContextActions._DELETE],
            [ATTR.xTooltips, RS.Tooltips_Delete],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [MainContextActions._CHAR_HIDDEN, smap_(
            [ATTR.AnAction, MainContextActions._CHAR_HIDDEN],
            [ATTR.xTooltips, RS.Tooltips_HideSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEyeSlash}`],
        )],
        [MainContextActions._CHAR_STYLES, smap_(
            [ATTR.AnAction, MainContextActions._CHAR_STYLES],
            [ATTR.xTooltips, RS.Tooltips_CharacterStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEllipsisV}`],
        )],
        [MainContextActions._HIGHLIGHT_STYLES, smap_(
            [ATTR.AnAction, MainContextActions._HIGHLIGHT_STYLES],
            [ATTR.xTooltips, RS.Tooltips_HighlightStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSpinner}`],
        )],
        [MainContextActions._PARA_HIDDEN, smap_(
            [ATTR.AnAction, MainContextActions._PARA_HIDDEN],
            [ATTR.xTooltips, RS.Tooltips_HideSelection],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEyeSlash}`],
        )],
        [MainContextActions._PARA_STYLES, smap_(
            [ATTR.AnAction, MainContextActions._PARA_STYLES],
            [ATTR.xTooltips, RS.Tooltips_ParagraphStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEllipsisV}`],
        )],
        [MainContextActions._INSERT_LINK, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_LINK],
            [ATTR.xTooltips, RS.Tooltips_InsertLinkElement],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaLink}`],
        )],
        [MainContextActions._INSERT_AUDIO, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_AUDIO],
            [ATTR.xTooltips, RS.InsertAudioTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaFileAudioO}`],
        )],
        [MainContextActions._INSERT_VIDEO, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_VIDEO],
            [ATTR.xTooltips, RS.InsertVideoTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaFileVideoO}`],
        )],
        [MainContextActions._INSERT_IMG, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_IMG],
            [ATTR.xTooltips, RS.Tooltips_InsertImageElement],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaImage}`],
        )],
        [MainContextActions._TAKE_PHOTO, smap_(
            [ATTR.AnAction, MainContextActions._TAKE_PHOTO],
            [ATTR.xTooltips, RS.Tooltips_TakePhoto],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCamera}`],
        )],
        [MainContextActions._RECORD_AUDIO, smap_(
            [ATTR.AnAction, MainContextActions._RECORD_AUDIO],
            [ATTR.xTooltips, RS.Tooltips_RecordAudio],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaMicrophone}`],
        )],
        [MainContextActions._RECORD_VIDEO, smap_(
            [ATTR.AnAction, MainContextActions._RECORD_VIDEO],
            [ATTR.xTooltips, RS.Tooltips_RecordVideo],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaVideoCamera}`],
        )],
        [MainContextActions._SCREENSHOT, smap_(
            [ATTR.AnAction, MainContextActions._SCREENSHOT],
            [ATTR.xTooltips, RS.ActionScreenshotTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCameraRetro}`],
        )],
        [MainContextActions._CALCULATOR, smap_(
            [ATTR.AnAction, MainContextActions._CALCULATOR],
            [ATTR.xTooltips, RS.Tooltips_Calculator],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCalculator}`],
        )],
        [MainContextActions._INSERT_DATE, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_DATE],
            [ATTR.xTooltips, RS.Tooltips_InsertDateTimeString],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaClockO}`],
        )],
        [MainContextActions._INSERT_CALENDAR, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_CALENDAR],
            [ATTR.xTooltips, RS.Tooltips_InsertCalendar],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCalendar}`],
        )],
        [MainContextActions._INSERT_ALARM, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_ALARM],
            [ATTR.xTooltips, RS.Tooltips_CreateEvent],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaBellO}`],
        )],
        [MainContextActions._INSERT_NAMED_ANCHOR, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_NAMED_ANCHOR],
            [ATTR.xTooltips, RS.ActionInsertNamedAnchorTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaTag}`],
        )],
        [MainContextActions._TO_NBSP, smap_(
            [ATTR.AnAction, MainContextActions._TO_NBSP],
            [ATTR.xTooltips, RS.Tooltips_ConvertSpacesToNonBreakSpaces],
            ["class", `${CSS.AnContextButton} ${CSS.AnFaNbsp}`],
        )],
        [MainContextActions._TO_SPACE, smap_(
            [ATTR.AnAction, MainContextActions._TO_SPACE],
            [ATTR.xTooltips, RS.Tooltips_ConvertNonBreakSpacesToSpaces],
            ["class", `${CSS.AnContextButton} ${CSS.AnFaSpace}`],
        )],
        [MainContextActions._INSERT_SYMBOL, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_SYMBOL],
            [ATTR.xTooltips, RS.Tooltips_InsertSymbol],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSmileO}`],
        )],
        [MainContextActions._INSERT_CANVAS, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_CANVAS],
            [ATTR.xTooltips, RS.Tooltips_InsertCanvas],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPaintBrush}`],
        )],
        [MainContextActions._INSERT_WIDGET, smap_(
            [ATTR.AnAction, MainContextActions._INSERT_WIDGET],
            [ATTR.xTooltips, RS.Tooltips_InsertWidget],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSquare}`],
        )],
        [MainContextActions._DESTRUCT_WIDGET, smap_(
            [ATTR.AnAction, MainContextActions._DESTRUCT_WIDGET],
            [ATTR.xTooltips, RS.Tooltips_DestructWidget],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaShareSquare} ${CSS.FaFlipHorizontal}`],
        )],
        [MainContextActions._BORDER, smap_(
            [ATTR.AnAction, MainContextActions._BORDER],
            [ATTR.xTooltips, RS.ActionAddBorderTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSquareO}`],
        )],
        [MainContextActions._STYLE_BOLD, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_BOLD],
            [ATTR.xTooltips, RS.Tooltips_Bold],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaBold}`],
        )],
        [MainContextActions._STYLE_ITALIC, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_ITALIC],
            [ATTR.xTooltips, RS.Tooltips_Italic],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaItalic}`],
        )],
        [MainContextActions._STYLE_UNDERLINE, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_UNDERLINE],
            [ATTR.xTooltips, RS.Tooltips_Underline],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaUnderline}`],
        )],
        [MainContextActions._STYLE_STRIKETHROUGH, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_STRIKETHROUGH],
            [ATTR.xTooltips, RS.Tooltips_StrikeThrough],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaStrikethrough}`],
        )],
        [MainContextActions._STYLE_SUBSCRIPT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_SUBSCRIPT],
            [ATTR.xTooltips, RS.Tooltips_Subscript],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSubscript}`],
        )],
        [MainContextActions._STYLE_SUPERSCRIPT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_SUPERSCRIPT],
            [ATTR.xTooltips, RS.Tooltips_Superscript],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSuperscript}`],
        )],
        [MainContextActions._STYLE_FLOAT_LEFT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_FLOAT_LEFT],
            [ATTR.xTooltips, RS.Tooltips_FloatLeft],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignLeft}`],
        )],
        [MainContextActions._STYLE_FLOAT_RIGHT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_FLOAT_RIGHT],
            [ATTR.xTooltips, RS.Tooltips_FloatRight],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignRight}`],
        )],
        [MainContextActions._STYLE_NOWRAP, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_NOWRAP],
            [ATTR.xTooltips, RS.StyleNowrapTooltips],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaWon}`],
        )],
        [MainContextActions._STYLE_ALIGN_LEFT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_ALIGN_LEFT],
            [ATTR.xTooltips, RS.Tooltips_AlignLeft],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignLeft}`],
        )],
        [MainContextActions._STYLE_ALIGN_RIGHT, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_ALIGN_RIGHT],
            [ATTR.xTooltips, RS.Tooltips_AlignRight],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignRight}`],
        )],
        [MainContextActions._STYLE_ALIGN_CENTER, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_ALIGN_CENTER],
            [ATTR.xTooltips, RS.Tooltips_AlignCenter],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignCenter}`],
        )],
        [MainContextActions._STYLE_ALIGN_JUSTIFY, smap_(
            [ATTR.AnAction, MainContextActions._STYLE_ALIGN_JUSTIFY],
            [ATTR.xTooltips, RS.Tooltips_AlignJustify],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaAlignJustify}`],
        )],
        [MainContextActions._LIST_OL, smap_(
            [ATTR.AnAction, MainContextActions._LIST_OL],
            [ATTR.xTooltips, RS.Tooltips_ListOrdered],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaListOl}`],
        )],
        [MainContextActions._LIST_UL, smap_(
            [ATTR.AnAction, MainContextActions._LIST_UL],
            [ATTR.xTooltips, RS.Tooltips_ListUnordered],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaListUl}`],
        )],
        [MainContextActions._LIST_UL_NONE_INDENTED, smap_(
            [ATTR.AnAction, MainContextActions._LIST_UL_NONE_INDENTED],
            [ATTR.xTooltips, RS.Tooltips_ListWithoutBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaIndent}`],
        )],
        [MainContextActions._LIST_UL_NONE, smap_(
            [ATTR.AnAction, MainContextActions._LIST_UL_NONE],
            [ATTR.xTooltips, RS.Tooltips_ListWithoutBulletAndIndent],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaBars}`],
        )],
        [MainContextActions._LIST_ITEM, smap_(
            [ATTR.AnAction, MainContextActions._LIST_ITEM],
            [ATTR.xTooltips, RS.Tooltips_ListItem],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaMinus}`],
        )],
        [MainContextActions._LIST_SYMBOLS, smap_(
            [ATTR.AnAction, MainContextActions._LIST_SYMBOLS],
            [ATTR.xTooltips, RS.Tooltips_ListWithSymbolBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCommentsO}`],
        )],
        [MainContextActions._LIST_DATE, smap_(
            [ATTR.AnAction, MainContextActions._LIST_DATE],
            [ATTR.xTooltips, RS.Tooltips_ListWithDateBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCalendar}`],
        )],
        [MainContextActions._LIST_COMPACT, smap_(
            [ATTR.AnAction, MainContextActions._LIST_COMPACT],
            [ATTR.xTooltips, RS.Tooltips_MakeListCompact],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCompress}`],
        )],
        [MainContextActions._LIST_EXPAND, smap_(
            [ATTR.AnAction, MainContextActions._LIST_EXPAND],
            [ATTR.xTooltips, RS.Tooltips_MakeListNotCompact],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaExpand}`],
        )],
        [MainContextActions._LIST_ITEM_SYMBOL, smap_(
            [ATTR.AnAction, MainContextActions._LIST_ITEM_SYMBOL],
            [ATTR.xTooltips, RS.Tooltips_ListItemWithSymbolBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCommentO}`],
        )],
        [MainContextActions._LIST_ITEM_TEXT, smap_(
            [ATTR.AnAction, MainContextActions._LIST_ITEM_TEXT],
            [ATTR.xTooltips, RS.Tooltips_ListItemWithTextBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaTumblr}`],
        )],
        [MainContextActions._LIST_ITEM_DATE, smap_(
            [ATTR.AnAction, MainContextActions._LIST_ITEM_DATE],
            [ATTR.xTooltips, RS.Tooltips_ListItemWithDateBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCalendarO}`],
        )],
        [MainContextActions._LIST_ITEM_TIME, smap_(
            [ATTR.AnAction, MainContextActions._LIST_ITEM_TIME],
            [ATTR.xTooltips, RS.Tooltips_ListItemWithTimeBullet],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaClockO}`],
        )],
        [MainContextActions._SUBMENU_FONT, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_FONT],
            [ATTR.xTooltips, RS.Tooltips_FontStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaFont}`],
        )],
        [MainContextActions._SUBMENU_CHAR, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_CHAR],
            [ATTR.xTooltips, RS.Tooltips_CharacterStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaStrikethrough}`],
        )],
        [MainContextActions._SUBMENU_PARA, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_PARA],
            [ATTR.xTooltips, RS.Tooltips_ParagraphStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaParagraph}`],
        )],
        [MainContextActions._SUBMENU_LIST, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_LIST],
            [ATTR.xTooltips, RS.Tooltips_ListStyles],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaList}`],
        )],
        [MainContextActions._SUBMENU_MEDIA, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_MEDIA],
            [ATTR.xTooltips, RS.Tooltips_InsertObjects],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPaperclip}`],
        )],
        [MainContextActions._SUBMENU_OTHERS, smap_(
            [ATTR.AnAction, MainContextActions._SUBMENU_OTHERS],
            [ATTR.xTooltips, RS.Tooltips_OtherActions],
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaEllipsisH}`],
        )],
    );

    static _info(key: string): SStringMap {
        return _MainContextmenu._BUTTONS[key];
    }

    _buttons = new Map<string, HTMLElement>();
    _menubarButtons = new Map<string, HTMLElement>();
    _menubarPanels = new Map<string, HTMLElement>();
    _upperMainmenu: HTMLElement;
    _upperFontmenu: HTMLElement;
    _inputFontcat!: SelectOptions;
    _inputFontname!: SelectOptions;
    _inputFontstyle!: SelectOptions;
    _inputFontsize!: HTMLElement;
    _inputFontsample!: HTMLElement;
    _inputFG!: HTMLElement;
    _inputFGStyle!: HTMLElement;
    _inputFGColor!: HTMLElement;
    _inputBG!: HTMLElement;
    _inputBGImage!: HTMLElement;
    _inputBGColor!: HTMLElement;

    /**
       * _MainContextmenu constructor.
       * @param The div.AnContextmenu element.
       */
    constructor(container: HTMLElement) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenu));
        const b = new DomBuilderEx(this._contextmenu);
        b.table_({
            "class": CSS.AnContextmenu,
        }).push_();
        this._upperMainmenu = b.tr1_(CSS.AnUpperMainMenu).cursor_();
        b.td_().table_().push_();
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._COPY,
                MainContextActions._CUT,
                MainContextActions._PASTE_CHILD,
                MainContextActions._PASTE_SIBLING,
                MainContextActions._SELECT_NEXT_SIBLING,
                MainContextActions._PARENT_NODE,
            ],
            [
                MainContextActions._MOVETO_PARENT,
                MainContextActions._MOVETO_PREV,
                MainContextActions._MOVETO_NEXT,
                MainContextActions._REDO,
                MainContextActions._UNDO_HISTORY,
                MainContextActions._UNDO,
            ],
            [
                MainContextActions._PARAGRAPH,
                MainContextActions._INSERT_TEXT,
                MainContextActions._INSERT_ELEMENT,
                MainContextActions._SPAWN_NODE,
                MainContextActions._EDIT_NODE_RAW,
                MainContextActions._EDIT_STYLE_RAW,
            ],
            [
                MainContextActions._INSERT_LINK,
                MainContextActions._INSERT_IMG,
                MainContextActions._INSERT_SYMBOL,
                MainContextActions._INSERT_DATE,
                MainContextActions._UNWRAP,
                MainContextActions._WRAP,
            ],
            [
                MainContextActions._LIST_SYMBOLS,
                MainContextActions._LIST_ITEM_SYMBOL,
                MainContextActions._LIST_DATE,
                MainContextActions._LIST_ITEM_DATE,
                MainContextActions._DESTRUCT_WIDGET,
                MainContextActions._INSERT_WIDGET,
            ]
        ]);
        this._upperFontmenu = b.pop_().peek_().tr1_(CSS.AnUpperFontMenu).cursor_();
        An.hide_(this._upperFontmenu);
        b.td_().table_().push_();
        this._createUpperFontmenu(b);
        b.pop_().peek_();
        _MainContextmenu._createmenubar(this._menubarButtons, b, [
            MainContextActions._SUBMENU_FONT,
            MainContextActions._SUBMENU_CHAR,
            MainContextActions._SUBMENU_PARA,
            MainContextActions._SUBMENU_LIST,
            MainContextActions._SUBMENU_MEDIA,
            MainContextActions._SUBMENU_OTHERS,
        ]);
        b.peek_().tr_().td_({ "class": CSS.AnRuler, "colspan": "6" });
        b
            .peek_()
            .tr_()
            .td_({
                "class": CSS.AnSubmenuContainer,
                "colspan": "6"
            })
            .push_()
            .cursor_();
        this._menubarPanels.set(MainContextActions._SUBMENU_FONT, b.peek_().table_({
            "name": NAME.submenuFont,
            "style": "display: none;",
        }).cursor_());
        this._createLowerFontmenu(b);
        this._menubarPanels.set(MainContextActions._SUBMENU_CHAR, b.peek_().table_({
            "name": NAME.submenuChar,
            "style": "display: none;",
        }).cursor_());
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._STYLE_BOLD,
                MainContextActions._STYLE_ITALIC,
                MainContextActions._STYLE_UNDERLINE,
                MainContextActions._STYLE_STRIKETHROUGH,
                MainContextActions._STYLE_SUBSCRIPT,
                MainContextActions._STYLE_SUPERSCRIPT,
            ],
            [
                MainContextActions._STYLE_FLOAT_LEFT,
                MainContextActions._STYLE_FLOAT_RIGHT,
                MainContextActions._STYLE_NOWRAP,
                MainContextActions._CHAR_HIDDEN,
                MainContextActions._HIGHLIGHT_STYLES,
                MainContextActions._CHAR_STYLES,
            ]
        ]);
        this._menubarPanels.set(MainContextActions._SUBMENU_PARA, b.peek_().table_({
            "name": NAME.submenuPara,
            "style": "display: none;",
        }).cursor_());
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._STYLE_ALIGN_LEFT,
                MainContextActions._STYLE_ALIGN_CENTER,
                MainContextActions._STYLE_ALIGN_JUSTIFY,
                MainContextActions._STYLE_ALIGN_RIGHT,
                MainContextActions._EDIT_ALIGN,
                MainContextActions._EDIT_STYLE,
            ],
            [
                MainContextActions._BORDER,
                MainContextActions._EDIT_SIZE,
                DEF.NOOP,
                DEF.NOOP,
                MainContextActions._PARA_HIDDEN,
                MainContextActions._PARA_STYLES,
            ],
        ]);
        this._menubarPanels.set(MainContextActions._SUBMENU_LIST, b.peek_().table_({
            "name": NAME.submenuList,
            "style": "display: none;",
        }).cursor_());
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._LIST_OL,
                MainContextActions._LIST_UL,
                MainContextActions._LIST_UL_NONE_INDENTED,
                MainContextActions._LIST_UL_NONE,
                MainContextActions._LIST_COMPACT,
                MainContextActions._LIST_EXPAND,
            ],
            [
                MainContextActions._LIST_ITEM_TIME,
                MainContextActions._LIST_ITEM_TEXT,
                MainContextActions._LIST_ITEM,
                DEF.NOOP,
                DEF.NOOP,
                DEF.NOOP,
            ]
        ]);
        this._menubarPanels.set(MainContextActions._SUBMENU_MEDIA, b.peek_().table_({
            "name": NAME.submenuMedia,
            "style": "display: none;",
        }).cursor_());
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._CALCULATOR,
                MainContextActions._INSERT_CALENDAR,
                MainContextActions._INSERT_ALARM,
                MainContextActions._INSERT_NAMED_ANCHOR,
                MainContextActions._INSERT_CANVAS,
                MainContextActions._ANNOTATE_IMG,
                MainContextActions._SCREENSHOT,
            ],
            [
                MainContextActions._PASTE_FROM_SYSTEM_CLIPBOARD,
                MainContextActions._INSERT_VIDEO,
                MainContextActions._INSERT_AUDIO,
                MainContextActions._TAKE_PHOTO,
                MainContextActions._RECORD_VIDEO,
                MainContextActions._RECORD_AUDIO,
            ],
        ]);
        this._menubarPanels.set(MainContextActions._SUBMENU_OTHERS, b.peek_().table_({
            "name": NAME.submenuOthers,
            "style": "display: none;",
        }).cursor_());
        _MainContextmenu._createbuttons(this._buttons, b, [
            [
                MainContextActions._TO_SPACE,
                MainContextActions._TO_NBSP,
                DEF.NOOP,
                DEF.NOOP,
                DEF.NOOP,
                MainContextActions._TOGGLE_RIGHTSIDEBAR,
            ],
        ]);
        container.appendChild(this._contextmenu);
        this._buttons.get(MainContextActions._ANNOTATE_IMG)!.style.display = "none";
        super.setupHandlers_(this._contextmenu, `td.${CSS.AnContextButton}`);
    }

    static _setStyle2(name: string, value: stringX): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const node = native$.getSingleSelectedNodeOfRange_(range);
        _MainContextmenu._setStyle3(range, node, name, value);
    }

    static _setStyle3(range: Range, node: Node | null, name: string, value: stringX): void {
        history$.group_(RS.Tooltips_EditStyle, `${name}: ${value}`, () => {
            if (node == null || node.nodeType != Node.ELEMENT_NODE) {
                node = RangeUtil.wrapRange_("span", {}, range);
            }
            native$.replaceStyle_(node as HTMLElement, name, value);
        });
    }

    private _createUpperFontmenu(b: DomBuilderEx): void {
        const css = CSS.AnMenurow;
        b.push_().tr1_(css).td_();
        this._inputFontcat = new SelectOptions(accessories$,
            b.div1_(CSS.AnMenuSelect, CSS.AnWidth6).cursor_())
            .setOptions_(settings$.fontCategories_());
        b.peek_().tr1_(css).td_();
        this._inputFontname = new SelectOptions(accessories$,
            b.div1_(CSS.AnMenuSelect, CSS.AnWidth6).cursor_());
        DialogUt.populateFontName_(this._inputFontname, [""], settings$.fontFamilies_(), this._inputFontcat.getValue_(""), "");
        b.peek_().tr1_(css).td_();
        this._inputFontstyle = new SelectOptions(accessories$,
            b.div1_(CSS.AnMenuSelect, CSS.AnWidth6).cursor_());
        this._inputFontsize = b.peek_().tr1_(css).td_().div1_(CSS.AnMenurow6).cursor_();
        this._inputFG = b
            .peek_()
            .tr1_(css)
            .td_()
            .push_()
            .div1_(CSS.AnColorInput2, CSS.AnColorFG, CSS.AnWidth1)
            .text_(MSG.string_(RS.FGColor))
            .cursor_();
        this._inputFGStyle = b.peek_().div_(
            ["class", `${CSS.AnColorCell}`],
            ["style", "overflow:hidden;display:flex;height:-webkit-fill-availalble;"]
        ).div_(
            ["class", `${CSS.AnColorCell}`],
            ["style", "border:none;"],
        ).cursor_();
        b.div1_(CSS.AnFlexCenter, CSS.AnFill).text_("A");
        this._inputFGColor = b.peek_().div1_(CSS.AnColorCell, CSS.AnColorFG).cursor_();
        this._inputBG = b
            .peek_()
            .div1_(CSS.AnColorInput2, CSS.AnColorBG, CSS.AnWidth1)
            .text_(MSG.string_(RS.BGColor))
            .cursor_();
        this._inputBGImage = b.peek_().div1_(CSS.AnColorCell).cursor_();
        this._inputBGColor = b.peek_().div1_(CSS.AnColorCell, CSS.AnColorBG).cursor_();
        b.pop_(2);
    }

    private _createLowerFontmenu(b: DomBuilderEx): void {
        const x1 = cache$.ui$.buttonSize_();
        b.push_().tr1_(CSS.AnMenurow).td_();
        this._inputFontsample = b.div_({
            "class": CSS.AnMenurow6,
            "style": "white-space:nowrap;overflow:hidden;" + `min-height:${x1}px;`,
        }).cursor_();
        b.pop_();
        this._setupFontmenuHandlers();
    }

    getActionButton(action: string): HTMLElementX {
        return this._buttons.get(action) ?? null;
    }

    getMenubarButton(submenu: string): HTMLElementX {
        return this._menubarButtons.get(submenu) ?? null;
    }

    updateFontSubmenuState(range0: Range): void {
        const start = native$.getNearestSelectedElementOfRange_(range0);
        if (start != null) {
            const cssstyle = start.style;
            const style = native$.getStyleOrComputedStyle_(start, null, [
                PK.FontFamily, PK.FontSize, PK.Color, PK.BackgroundColor, PK.TextShadow,
                PK.BackgroundImage, PK.BackdropFilter, PK.Filter,
            ]);
            style.set(PK.Transform, CSSUtil.ignoreInheritNone(cssstyle.transform));
            style.set(PK.TransformOrigin, CSSUtil.ignoreInheritNone(cssstyle.transformOrigin));
            const fontstack = style.get(PK.FontFamily)!;
            const namestyle = FontUtil.getFontStackNameStyle_(settings$, fontstack);
            if (namestyle != null) {
                this._inputFontname.setValue_(namestyle[0]);
                DialogUt.populateFontStyle_(
                    this._inputFontstyle,
                    [],
                    settings$.fontInfo_(namestyle[0]),
                    namestyle[1]);
                const family = FontUtil.fontFamilyOf_(namestyle[0], namestyle[1]);
                this._setFontsize(style.get(PK.FontSize)!);
                const fg = CSSUtil.ignoreInherit(style.get(PK.Color));
                const bg = CSSUtil.ignoreInherit(style.get(PK.BackgroundColor));
                const bgimg = CSSUtil.humanCSSUrls_(CSSUtil.ignoreInheritNone(style.get(PK.BackgroundImage)), native$.getIFrameUri_());
                const filter = CSSUtil.ignoreInheritNone(style.get(PK.Filter));
                const backdropfilter = CSSUtil.ignoreInheritNone(style.get(PK.BackdropFilter));
                let textshadow = CSSUtil.ignoreInherit(style.get(PK.TextShadow));
                let transform = CSSUtil.ignoreInheritNone(style.get(PK.Transform));
                let transformorigin = CSSUtil.ignoreInheritNone(style.get(PK.TransformOrigin));
                this._inputFGStyle.style.textShadow = textshadow;
                this._inputFGStyle.style.transform = transform;
                this._inputFGStyle.style.transformOrigin = transformorigin;
                this._inputFGStyle.style.filter = filter;
                this._inputFGStyle.setAttribute(ATTR.AnInfo, stringify_(
                    [PK.TextShadow, textshadow],
                    [PK.Transform, transform],
                    [PK.TransformOrigin, transform.length > 0 ? transformorigin : ""],
                    [PK.Filter, filter],
                ));
                this._inputFGColor.style.backgroundColor = fg;
                this._inputFGColor.setAttribute(ATTR.AnInfo, fg);
                this._inputBGImage.style.backgroundImage = bgimg;
                this._inputBGImage.style.setProperty(PK.BackdropFilter, backdropfilter);
                this._inputBGImage.setAttribute(ATTR.AnInfo, JSON.stringify([bgimg, backdropfilter]));
                this._inputBGColor.style.backgroundColor = bg;
                this._inputBGColor.setAttribute(ATTR.AnInfo, bg);
                this._inputFontsample.textContent = family;
                const samplestyle = this._inputFontsample.style;
                samplestyle.fontFamily = family;
                samplestyle.color = fg;
                samplestyle.textShadow = textshadow;
                samplestyle.transform = transform;
                samplestyle.transformOrigin = transform.length > 0 ? transformorigin : "";
                samplestyle.filter = filter;
                samplestyle.backgroundColor = bg;
                samplestyle.backgroundImage = bgimg;
                samplestyle.setProperty(PK.BackdropFilter, backdropfilter);
            }
        }
    }

    showSubmenu_(name: string): void {
        const button = this._menubarButtons.get(name);
        const panel = this._menubarPanels.get(name);
        if (button === undefined || panel === undefined) return;
        button.classList.add(CSS.AnSelected);
        An.show_(panel);
        if (name == MainContextActions._SUBMENU_FONT) {
            An.hide_(this._upperMainmenu);
            An.show_(this._upperFontmenu);
            const range0 = native$.getIFrameSelectionRange_();
            if (range0 != null) {
                this.updateFontSubmenuState(range0);
            }
        } else {
            An.hide_(this._upperFontmenu);
            An.show_(this._upperMainmenu);
        }
    }

    hideSubmenu_(name: string): void {
        const button = this._menubarButtons.get(name);
        const panel = this._menubarPanels.get(name);
        if (button === undefined || panel === undefined) return;
        button.classList.remove(CSS.AnSelected);
        An.hide_(panel);
    }

    static _createbuttons(buttons: Map<string, HTMLElement>, table: DomBuilderEx, keys: Array<Array<string>>): void {
        ContextmenuBase.createButtons_(buttons, table, keys, _MainContextmenu._BUTTONS);
    }

    static _createmenubar(table: Map<string, HTMLElement>, b: DomBuilderEx, keys: string[]): HTMLElement {
        const ret = b.push_().tr1_(CSS.AnMenubar).cursor_();
        b.push_();
        ContextmenuBase.createButtonRow_(table, b, keys, _MainContextmenu._BUTTONS);
        b.pop_(2);
        return ret;
    }

    static _setSampleFontFamily(inputsample: HTMLElement, family: string): void {
        inputsample.style.fontFamily = family;
        inputsample.textContent = family.length == 0 ? MSG.string_(RS.FontSample) : family;
        _MainContextmenu._setStyle2("font-family", family);
    }

    static _getComputedStyle(name: string): stringX {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return null;
        }
        let node = native$.getSingleSelectedNodeOfRange_(range);
        while (node != null && node.nodeType != Node.ELEMENT_NODE) {
            node = node.parentNode;
        }
        if (node == null || An.isBodyElement_(node.nodeName)) {
            return null;
        }
        return native$.getComputedStyle1_(node as HTMLElement, null, name);
    }

    private _setFontsize(size: string): void {
        const sizeunit = An.doubleStringSizeUnit_(size);
        const value = (sizeunit == null ? size : sizeunit.join(""));
        this._inputFontsize.textContent = value;
        this._inputFontsample.style.fontSize = size;
    }

    private _setupFontmenuHandlers(): void {
        this._inputFontcat.onChange_(cat => {
            const family = this._inputFontname.getValue_("");
            DialogUt.populateFontName_(this._inputFontname, [""], settings$.fontFamilies_(), cat, family);
        });
        this._inputFontname.onChange_((name: string) => {
            const style = this._inputFontstyle.getValue_("");
            const selectedstyle = DialogUt.populateFontStyle_(this._inputFontstyle, [], settings$.fontInfo_(name), style);
            const family = FontUtil.fontFamilyOf_(name, selectedstyle);
            _MainContextmenu._setSampleFontFamily(this._inputFontsample, family);
        });
        this._inputFontstyle.onChange_((style: string) => {
            const name = this._inputFontname.getValue_("");
            const family = FontUtil.fontFamilyOf_(name, style);
            _MainContextmenu._setSampleFontFamily(this._inputFontsample, family);
        });
        An.onClick_(this._inputFontname.element_(), () => {
            host$.hideKeyboard_();
        });
        An.onClick_(this._inputFontcat.element_(), () => {
            host$.hideKeyboard_();
        });
        An.onClick_(this._inputFontstyle.element_(), () => {
            host$.hideKeyboard_();
        });
        const buttonsize = cache$.ui$.buttonSize_();
        An.onClick_(this._inputFontsize, () => {
            host$.hideKeyboard_(() => {
                let sizeunit = An.doubleStringSizeUnit_(this._inputFontsize.textContent?.trim() ?? "");
                if (sizeunit == null) {
                    const value = native$.getComputedStyle1_(this._inputFontsample, null, "font-size") ?? "";
                    sizeunit = An.doubleStringSizeUnit_(value);
                    if (sizeunit == null) {
                        toasters$.warn_(MSG.string1_(RS.InvalidValue_, value));
                        this._setFontsize("");
                        _MainContextmenu._setStyle2("font-size", "");
                        return;
                    }
                }
                const d = new PromptCSSLength(accessories$, RS.FontSize, sizeunit, RS.FontSize);
                d.above_(this._contextmenu);
                d.onOK_(size => {
                    this._setFontsize(size);
                    _MainContextmenu._setStyle2("font-size", size);
                });
                d.show_();
            });
        });
        An.onClick_(this._inputFontsample, e => {
            An.stopevent_(e);
            host$.hideKeyboard_(() => {
                const d = _Util.promptFont_(this._inputFontsample.style.fontFamily);
                d.onOK_((familystyle: string) => {
                    const namestyle = FontUtil.splitNameStyle_(familystyle);
                    if (namestyle[0] != this._inputFontname.getValue_("") || namestyle[1] != this._inputFontstyle.getValue_("")) {
                        this._inputFontname.setValue_(namestyle[0]);
                        DialogUt.populateFontStyle_(
                            this._inputFontstyle,
                            [],
                            settings$.fontInfo_(namestyle[0]),
                            namestyle[1]);
                        _MainContextmenu._setSampleFontFamily(this._inputFontsample, familystyle);
                    }
                });
                d.show_();
            });
        });
        const colorhandler = (cell: HTMLElement, style: string, def: ColorValue, e: MouseEvent) => {
            An.stopevent_(e);
            host$.hideKeyboard_(() => {
                const d = Callbacks.promptColor_(buttonsize, DEF.zindexPrompt, cell.getAttribute(ATTR.AnInfo) ?? "", def);
                d.onOK_((color, format) => {
                    if (color == null) {
                        _MainContextmenu._setStyle2(style, null);
                        color = ColorUtil.getColorValue_(_MainContextmenu._getComputedStyle(style));
                        if (color != null) {
                            const css = color.toCSSString_();
                            cell.style.backgroundColor = css;
                            cell.setAttribute(ATTR.AnInfo, css);
                            this._inputFontsample.style.setProperty(style, css);
                        }
                        return;
                    }
                    const formatted = ColorUtil.formatCSSString_(format, color);
                    
                    cell.style.backgroundColor = formatted;
                    cell.setAttribute(ATTR.AnInfo, formatted);
                    this._inputFontsample.style.setProperty(style, formatted);
                    _MainContextmenu._setStyle2(style, formatted);
                });
                d.show_();
            });
        };

        const fghandler = (e: MouseEvent) => {
            colorhandler(this._inputFGColor, "color", ColorValue.X_BLACK, e);
        };
        const bghandler = (e: MouseEvent) => {
            colorhandler(this._inputBGColor, PK.BackgroundColor, ColorValue.X_WHITE, e);
        };
        An.onClick_(this._inputFG, fghandler);
        An.onClick_(this._inputFGStyle.parentElement!!, () => {
            const range = native$.getIFrameSelectionRange_();
            if (range == null) return;
            const node = native$.getSingleSelectedNodeOfRange_(range);
            const setstyles = (styles: SStringMap) => {
                this._inputFGStyle.setAttribute(ATTR.AnInfo, JSON.stringify(styles));
                for (const [name, value] of Object.entries(styles)) {
                    this._inputFGStyle.style.setProperty(name, value);
                    this._inputFontsample.style.setProperty(name, value);
                    _MainContextmenu._setStyle3(range, node, name, value);
                }
            };
            const target = DomUt.asHTMLElement_(node);
            const ostyles = JSON.parse(this._inputFGStyle.getAttribute(ATTR.AnInfo) ?? "{}");
            new PromptFgStyle(accessories$, target, buttonsize, this._inputFontsample.style, ostyles, PromptFgStyle._SAMPLES, DEF.zindexPrompt)
                .onOK_((styles) => {
                    setstyles(styles);
                })
                .onCancel_(() => {
                    if (target != null) setstyles(ostyles);
                })
                .show_();
        });
        An.onClick_(this._inputFGColor, fghandler);
        An.onClick_(this._inputBG, bghandler);
        An.onClick_(this._inputBGColor, bghandler);
        An.onClick_(this._inputBGImage, () => {
            const range = native$.getIFrameSelectionRange_();
            if (range == null) return;
            const node = native$.getSingleSelectedNodeOfRange_(range);
            const baseuri = native$.getIFrameUri_();
            if (baseuri == null) return;
            const target = DomUt.asHTMLElement_(node);
            let bgstyles = An.parseJSONArrayOrNull_<string>(this._inputBGImage.getAttribute(ATTR.AnInfo))
                ?? An.getComputedStylesArray_(target, PK.BackgroundImage, PK.BackdropFilter);
            new PromptBgImg(
                accessories$,
                buttonsize,
                baseuri,
                [bgstyles[0], bgstyles[1]],
                null,
                settings$.getBgImgSamples(),
                DEF.zindexPrompt)
                .onOK_((cssstyle) => {
                    const bgimg = cssstyle.backgroundImage;
                    const backdropfilter = cssstyle.getPropertyValue(PK.BackdropFilter);
                    this._inputBGImage.style.backgroundImage = bgimg;
                    this._inputBGImage.style.setProperty(PK.BackdropFilter, backdropfilter);
                    this._inputBGImage.setAttribute(ATTR.AnInfo, JSON.stringify([bgimg, backdropfilter]));
                    this._inputFontsample.style.backgroundImage = bgimg;
                    this._inputFontsample.style.setProperty(PK.BackdropFilter, backdropfilter);
                    _MainContextmenu._setStyle3(range, node, PK.BackgroundImage, bgimg);
                    _MainContextmenu._setStyle3(range, node, PK.BackdropFilter, backdropfilter);
                })
                .onCancel_(() => {
                    if (target != null) {
                        _MainContextmenu._setStyle3(range, node, PK.BackgroundImage, bgstyles[0]);
                        _MainContextmenu._setStyle3(range, node, PK.BackdropFilter, bgstyles[1]);
                    }
                })
                .show_();
        });
    }

    submenuActions_(td: HTMLElement, menu: string): void {
        if (!td.classList.contains(CSS.AnDisabled)) {
            for (const e of this._menubarButtons.values()) {
                e.classList.remove(CSS.AnSelected);
            }
            td.classList.add(CSS.AnSelected);
            for (const panel of this._menubarPanels.values()) {
                An.hide_(panel);
            }
            With.optional_(this._menubarPanels.get(menu), panel => An.show_(panel));
            if (menu == MainContextActions._SUBMENU_FONT) {
                An.hide_(this._upperMainmenu);
                An.show_(this._upperFontmenu);
                With.optional_(native$.getIFrameSelectionRange_(), range0 => this.updateFontSubmenuState(range0));
            } else {
                An.hide_(this._upperFontmenu);
                An.show_(this._upperMainmenu);
            }
        }
    }
}

class _ImageContextmenu extends _ContextmenuBase {
    static readonly _SCAN_BARCODE = "XxXua";
    static readonly _IMAGE_BGCOLOR = "XxXLx";
    static readonly _CROP = "XxXPf";
    static readonly _FIX_PERSPECTIVE = "XxXNQ";
    static readonly _PREVIEW = "XxXMb";
    static readonly _IMAGE_EXPORT = "XxXOs";
    static readonly _OCR = "XxXfa";
    static readonly _ANNOTATE_IMAGE = "XxXyu";
    static readonly _IMAGE_MOVE = "XxXmim";
    static readonly _SCREENSHOT = "XxXgB";
    static readonly _IMAGE_INFO = "XxXFf";
    static readonly _IMAGE_FILTER = "XxXW0";

    static readonly _BUTTONS = smap_(
        [_ImageContextmenu._ANNOTATE_IMAGE, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaPencil}`],
            [ATTR.xTooltips, RS.Tooltips_Annotation],
        )],
        [_ImageContextmenu._IMAGE_EXPORT, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaExternalLink}`],
            [ATTR.xTooltips, RS.Tooltips_ExportImage],
        )],
        [_ImageContextmenu._IMAGE_MOVE, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaTruck}`],
            [ATTR.xTooltips, RS.ActionFileMoveFixingXrefsTooltips],
        )],
        [_ImageContextmenu._IMAGE_BGCOLOR, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaSpinner}`],
            [ATTR.xTooltips, RS.Tooltips_SetBackgroundColor],
        )],
        [_ImageContextmenu._IMAGE_FILTER, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaFilter}`],
            [ATTR.xTooltips, RS.ImageFilter],
        )],
        [_ImageContextmenu._IMAGE_INFO, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaInfoCircle}`],
            [ATTR.xTooltips, RS.Tooltips_ShowInfo],
        )],
        [_ImageContextmenu._SCAN_BARCODE, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaQrcode}`],
            [ATTR.xTooltips, RS.BarcodeScanTooltips],
        )],
        [_ImageContextmenu._SCREENSHOT, smap_(
            ["class", `${CSS.AnContextButton} ${CSS.Fa} ${CSS.FaCameraRetro}`],
            [ATTR.xTooltips, RS.ActionScreenshotTooltips],
        )],
    );

    constructor(container: HTMLElement, buttons: string[][]) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuImage));
        const b = new DomBuilderEx(this._contextmenu);
        b.table_({
            "class": CSS.AnContextmenu,
        }).push_();
        const table = b.tr_().td_().table_().push_().cursor_();
        ContextmenuBase.createButtons_(null, b, buttons, _ImageContextmenu._BUTTONS);
        container.appendChild(this._contextmenu);
        super.setupHandlers_(table, `td.${CSS.AnContextButton}`);
    }

    hide_(): void {
        super.destroy_();
    }
}

class PromptAncestors extends DialogBase {
    private _selected: HTMLElementX = null;
    private _selectedIndex: IntX = null;
    private _content!: HTMLElement;
    private _okCallback: Fun20X<Node, boolean> = null;
    constructor(
        container: HTMLElement,
        private _ancestors: Node[],
    ) {
        super(container);
        this.init_(this.create_(container));
        An.onClickMatching_(this._content, `div[${ATTR.AnAction}]`, (elm, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(elm.getAttribute(ATTR.AnAction), -1);
            this._select(elm as HTMLElement, index);
        });
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infos_(BUT.Child, BUT.After, BUT.Cancel),
            (action) => this._toolbarActions(action)
        );
    }

    private _createContent(content: HTMLElement): void {
        this._content = new DomBuilderEx(content)
            .div1_(CSS.AnVerticalViewportWide).addStyle_("margin-top", "10px")
            .div1_(CSS.AnTextList).push_().cursor_();
        this._populate(this._content);
    }

    private _populate(content: HTMLElement): void {
        const b = new DomBuilderEx(content).empty_().push_();
        for (let i = 0; i < this._ancestors.length; ++i) {
            const node = this._ancestors[i];
            const name = node.nodeName;
            const isbody = "BODY" == name;
            b
                .peek_()
                .div2_(ATTR.AnAction, i.toString())
                .div_()
                .child1_("span", (isbody ? CSS.AnSec : CSS.AnTag))
                .text_(name);
            if (!isbody && node.nodeType == Node.ELEMENT_NODE) {
                const css = (node as HTMLElement).getAttribute("class");
                if (css != null && css.length > 0) {
                    b.up_().text_("\u00a0").span1_(CSS.AnAtt).text_(` .${css.replace(RX.Spaces, " .")}`);
                }
            }
        }
    }

    onSmokescreenCreated_(sm: Smokescreen) {
        super.onSmokescreenCreated_(sm);
        sm.on_(Conf.pointerend$, (e) => {
            An.stopevent_(e);
            this.actionCancelConfirmed_();
        });
    }

    onOK_(callback: Fun20<Node, boolean>): this {
        this._okCallback = callback;
        return this;
    }

    private _select(elm: HTMLElement, index: number): void {
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelected);
            if (this._selectedIndex == index) {
                this._selected = null;
                this._selectedIndex = null;
                return;
            }
        }
        elm.classList.add(CSS.AnSelected);
        this._selected = elm;
        this._selectedIndex = index;
    }

    private _toolbarActions(action: string): void {
        this.clearStatus_();
        switch (action) {
            case BUT.Cancel:
                const cb = this._cancelCallback;
                this.close_();
                cb?.();
                break;
            case BUT.Child:
            case BUT.After:
                const node = this._ancestors[this._selectedIndex ?? 0];
                this.close_();
                this._okCallback?.(node, action == BUT.After);
                this._okCallback = null;
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

/// class _AncestorsContextmenu
class _AncestorsContextmenu extends _ContextmenuBase {
    /**
       * @param The container element.
       */
    constructor(
        container: HTMLElement,
        private _ancestors: Node[],
        private _focus: boolean,
        private _done: Fun00X = null) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuSelect));
        const b = new DomBuilderEx(this._contextmenu)
            .table1_(CSS.AnContextmenu).tr_().td_()
            .div1_(CSS.AnVerticalViewport)
            .div1_(CSS.AnTextList).push_();
        this._create(b, this._ancestors);
        container.appendChild(this._contextmenu);
        super.setupHandlers_(b.pop_().cursor_(), `div[${ATTR.AnAction}]`);
        this.onAction_((action) => {
            if (this._focus) {
                native$.focusIFrame_();
            }
            const index = An.parseInt_(action, -1);
            if (index >= 0 && index < _ancestors.length - 1) {
                const node = _ancestors[index];
                native$.iSelectNode_(node, null, true);
                this.hide_();
                this._done?.();
            }
        });
    }

    private _create(b: DomBuilderEx, ancestors: Node[]): void {
        for (let i = 0; i < ancestors.length; ++i) {
            const node = ancestors[i];
            const name = node.nodeName;
            const isbody = "BODY" == name;
            b.peek_();
            if (isbody) b.div_(); else b.div2_(ATTR.AnAction, i.toString());
            b.div_()
                .child1_("span", (isbody ? CSS.AnSec : CSS.AnTag))
                .text_(name);
            if (!isbody && node.nodeType == Node.ELEMENT_NODE) {
                const css = (node as HTMLElement).getAttribute("class");
                if (css != null && css.length > 0) {
                    b.up_().text_("\u00a0").span1_(CSS.AnAtt).text_(` .${css.replace(RX.Spaces, " .")}`);
                }
            }
        }
    }

    hide_(): void {
        super.destroy_();
    }
}

class _CharContextmenu extends _ContextmenuBase {
    constructor(container: HTMLElement) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuChar));
        const b = new DomBuilderEx(this._contextmenu)
            .table1_(CSS.AnContextmenu).tr_().td_()
            .div1_(CSS.AnVerticalViewport)
            .div1_(CSS.AnTextList).push_();
        this._createstyles(b, settings$.charStyles_());
        container.appendChild(this._contextmenu);
        super.setupHandlers_(b.pop_().cursor_(), `div[${ATTR.AnAction}]`);
    }

    private _createstyles(b: DomBuilderEx, styles: StyleInfo[]): void {
        for (const style of styles) {
            const name = style.name$;
            let override = "margin:0";
            if (name == CSS.xHidden) {
                override += ";display:inline !important";
            }
            b.peek_()
                .div2_(ATTR.AnAction, name)
                .span_({
                    "class": name,
                    "style": override,
                })
                .text_(style.label$);
        }
    }

    hide_(): void {
        super.destroy_();
    }
}

class _HighlightContextmenu extends _ContextmenuBase {
    constructor(container: HTMLElement) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuHighlight));
        const b = new DomBuilderEx(this._contextmenu)
            .table1_(CSS.AnContextmenu).push_();
        this._createstyles(b, settings$.highlightStyles_());
        container.appendChild(this._contextmenu);
        super.setupHandlers_(b.pop_().cursor_(), `td.${CSS.AnContextButton}`);
    }

    private _createstyles(b: DomBuilderEx, styles: StyleInfo[]): void {
        b.push_().tr_().push_();
        let col = 0;
        for (let i = 0; i < styles.length; ++i) {
            if (++col > 6) {
                col = 1;
                b.pop_().peek_().tr_().push_();
            }
            const style = styles[i];
            const name = style.name$;
            const label = style.label$;
            const attrs = smap_(
                [ATTR.AnAction, name],
                [ATTR.xTooltips, label],
                ["class", `${CSS.AnContextButton} ${name}`],
            );
            b.peek_().td_(attrs).text_("Aa");
        }
        for (; ++col <= 6;) {
            b.peek_().td_({
                "class": CSS.AnContextButton,
            }).text_("\u00a0");
        }
        b.pop_(2);
    }
}

////////////////////////////////////////////////////////////////////////

class _ParaContextmenu extends _ContextmenuBase {
    constructor(container: HTMLElement) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuPara));
        const b = new DomBuilderEx(this._contextmenu)
            .table1_(CSS.AnContextmenu).tr_().td_()
            .div1_(CSS.AnVerticalViewport)
            .div1_(CSS.AnTextList).push_();
        this._createstyles(b, settings$.paraStyles_());
        container.appendChild(this._contextmenu);
        super.setupHandlers_(b.pop_().cursor_(), `div[${ATTR.AnAction}]`);
    }

    private _createstyles(b: DomBuilderEx, styles: StyleInfo[]): void {
        for (let i = 0; i < styles.length; ++i) {
            const style = styles[i];
            const name = style.name$;
            let override = "margin:0;width:100%";
            if (name == CSS.xHidden) {
                override += ";display:block !important";
            }
            b
                .peek_()
                .div2_(ATTR.AnAction, name)
                .div_({
                    "class": name,
                    "style": override,
                })
                .text_(style.label$);
        }
    }

    hide_(): void {
        super.destroy_();
    }
}

///////////////////////////////////////////////////////////////////////

class _WidgetContextmenu extends _ContextmenuBase {
    constructor(container: HTMLElement, infos: Array<Array<string>>) {
        super(ContextmenuBase.createContextmenu_(container, NAME.contextmenuWidget));
        const b = new DomBuilderEx(this._contextmenu)
            .div1_(CSS.AnVerticalMenu)
            .div1_(CSS.AnVerticalViewport)
            .div1_(CSS.AnTextList, CSS.AnBulletList).push_();
        this._populate(b, infos);
        container.appendChild(this._contextmenu);
        super.setupHandlers_(b.pop_().cursor_(), `[${ATTR.AnAction}`);
    }

    private _populate(b: DomBuilderEx, infos: Array<Array<string>>): void {
        for (let i = 0; i < infos.length; ++i) {
            const info = infos[i];
            const action = info[0];
            const classes = (info.length > 1 ? info[1] : "");
            b.peek_()
                .div2_(ATTR.AnAction, action)
                .append1_("span", classes)
                .text_(MSG.string_(action));
        }
    }

    hide_(): void {
        super.destroy_();
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class _Metainfo {
    info$: JSONObject;

    constructor(value: stringX = null) {
        try {
            const ret = An.parseJSONObjectOrNull_(value);
            if (ret != null && typeof (ret) === "object") {
                this.info$ = (ret as JSONObject);
                const calc = this.info$["calc"];
                if (calc != null) {
                    this.info$.remove("calc");
                    if (typeof (calc) === "boolean" && calc == true) {
                        this.addFeature(MetainfoKey.FeatureCalc);
                    }
                }
                return;
            }
        } catch (e) {
            
        }
        this.info$ = smap_();
    }

    stringify(): string {
        return JSON.stringify(this.info$);
    }

    get createdBy$(): number {
        return An.ifnull_(this.info$[MetainfoKey.CreatedBy], 0);
    }

    get modifiedBy$(): number {
        return An.ifnull_(this.info$[MetainfoKey.ModifiedBy], 0);
    }

    setCreatedBy(value: number = BUILD_VERSION): void {
        this.info$[MetainfoKey.CreatedBy] = value;
    }

    setModifiedBy(value: number = BUILD_VERSION): void {
        this.info$[MetainfoKey.ModifiedBy] = value;
    }

    hasPatch(patch: string): boolean {
        const s = this.info$[MetainfoKey.Patches];
        return !An.isempty_(s) && s.indexOf(patch) >= 0;
    }

    hasFeature(feature: string): boolean {
        const s = this.info$[MetainfoKey.Features];
        return !An.isempty_(s) && s.indexOf(feature) >= 0;
    }

    addPatch(patch: string): boolean {
        return this._add(MetainfoKey.Patches, patch);
    }

    addFeature(feature: string): boolean {
        return this._add(MetainfoKey.Features, feature);
    }

    private _add(key: string, value: string): boolean {
        const s = this.info$[key];
        if (An.isempty_(s)) {
            this.info$[key] = value;
            return true;
        } else if (s.indexOf(value) < 0) {
            this.info$[key] = s + value;
            return true;
        }
        return false;
    }
}

class _Fixer {

    constructor(private _info: _Metainfo) { }

    fix(): void {
        if (this._info.modifiedBy$ < 201101) {
            _Fixer.fixRightSidebarStyleMenuImages();
        }
    }

    static fixRightSidebarStyleMenuImages(): void {
        const rsb = native$.iGetElementById_(ID.xRightSidebar);
        if (rsb == null) return;
        for (const target of Array.from(native$.iQueryAll_(`div.${CSS.xTemplateButton}.fa-toggle-down`, rsb))) {
            const json = target.getAttribute(ATTR.xTemplate);
            if (json == null || !json.startsWith("{")) continue;
            let cf: JSONObject;
            try {
                cf = JSON.parse(json);
            } catch (e) {
                
                continue;
            }
            const lccat = cf[TemplateMenuKey.lcCat];
            if (lccat == null || !(typeof (lccat) === "string")) continue;
            try {
                switch (lccat) {
                    case "canvas":
                    case "home":
                    case "memo":
                    case "shopping":
                    case "todo":
                        const menu = cf[TemplateMenuKey.menu];
                        if (menu == null || !(menu instanceof Array)) {
                            break;
                        }
                        const pat = new RegExp(`^(\\./${lccat})(-\\d+-button\\.jpg)\$`);
                        let count = 0;
                        for (const row of (menu as Array<Array<JSONObject>>)) {
                            for (const cell of row) {
                                const bgimage = cell[TemplateMenuKey.backgroundImage];
                                if (bgimage == null || !(typeof (bgimage) === "string")) continue;
                                const match = pat.exec(bgimage);
                                if (match == null) {
                                    
                                    continue;
                                }
                                const fixed = match[1] + "-v2" + match[2];
                                cell[TemplateMenuKey.backgroundImage] = fixed;
                                ++count;
                                
                            }
                        }
                        if (count > 0) {
                            JsUtil.setAttribute_(target, ATTR.xTemplate, JSON.stringify(cf));
                            
                        }
                }
            } catch (e) {
                
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _MainPanel {
    _mainToolbar: _MainToolbar;
    _contextmenu: _MainContextmenu;
    _browsingContextmenu: BrowsingContextmenu;
    _highlightContextmenu: _HighlightContextmenu | null = null;

    _isTransparent: boolean = false;

    _iframeReadyCallbacks: IFrameReadyCallback[] = [];
    _iframeReadyOneshotCallbacks: IFrameReadyCallback[] = [];
    _iframeUnloadCallbacks: Fun00[] = [];
    _onResumeOneshotCallbacks: Fun00[] = [];
    _metainfo: _Metainfo | null = null;

    _videographer: JSONCallback | null = null;
    _iframeMediaViewer: IFrameMediaViewer | null = null;
    _iframeEditListeners = new Array<Map<string, any>>();
    _clientHidden: HTMLElementX = null;
    _lastIFrameSelectionRange: Range | null = null;
    _docClickX: number = 0;
    _docClickY: number = 0;
    _docTarget: HTMLElementX = null;
    _navigation: number = RecentsCmd.INFO;

    _hideRightSidebarTimer: Timer | null = null;

    constructor(container: HTMLElement) {
        const doc = container.ownerDocument;
        this._mainToolbar = new _MainToolbar(doc.getElementById(ID.toolbar)!);
        this._contextmenu = this._createMainContextmenu();
        this._browsingContextmenu = new BrowsingContextmenu(accessories$);
        native$.addCallback_(AjaxAction.audioStatusChanged, (s) => { return this.onAudioStatusChanged(s); });
        native$.addCallback_(AjaxAction.pause, (s) => { return this.onPauseCallback(s); });
        native$.addCallback_(AjaxAction.resume, (s) => { return this.onResumeCallback(s); });
        native$.addCallback_(AjaxAction.browse, (s) => { return this.onBrowse(s); });
        native$.addCallback_(AjaxAction.toaster, (s) => { return this.onPostToaster(s); });
        native$.addCallback_(AjaxAction.toasterOnLoad, (s) => { return this.onPostToasterOnLoad(s); });
        native$.addCallback_(AjaxAction.takePhotoResult, (s) => { return this.photoResult(s); });
        _Main._windowResizer = new _WindowResizer(window);
        native$.addCallback_(AjaxAction.onResizeWindow, () => { return _Main._onResizeWindow(); });
        native$.addCallback_(AjaxAction.gesture, (s) => { return _Main._onGestureEvent(s); });
        native$.addCallback_(AjaxAction.videoRecordingResult, (s) => { return this.videoRecordingResult(s); });
        native$.addCallback_(AjaxAction.showIncoming, (dirpath) => { return _MainPanel._showIncoming(dirpath ?? PATH._HomeIncoming); });
    }

    private _createMainContextmenu(): _MainContextmenu {
        const menu = new _MainContextmenu(accessories$);
        menu.onAction_((action, target, e) => this._contextActions(action, target, e));
        menu.onCancel_(() => native$.focusIFrame_());
        menu.onContextmenu_(toasters$.onTooltipsKey_);
        return menu;
    }

    onAudioStatusChanged(json: stringX): stringX {
        const ret = An.parseJSONObjectOrNull_(json);
        if (ret == null) return null;
        if (!toasters$.warn_(ret)) {
            if (!toasters$.warn_(ret[Key.warns])) {
                toasters$.ok_(ret[Key.text], { attop: true });
            }
        }
        this._mainToolbar.updateAudioStatus1_(ret);
        const recorder = ret[Key.recorder];
        if (recorder != null) {
            const yes = recorder[Key.status] ?? false;
            if (!yes && mainPanel$ != null && mainPanel$.isEditing() && history$ != null) {
                history$.startGroup_(RS.action_UpdateAudioInfo, "");
                mainPanel$._updateAudioInfos(() => {
                    history$.endGroup_();
                });
            }
        }
        return null;
    }

    onBrowse(param: stringX): stringX {
        const params = An.parseJSONObjectOrNull_(param);
        if (params == null) return null;
        const cpath = params[Param.path];
        if (An.isempty_(cpath)) {
            return null;
        }
        const fragment = params[Param.fragment];
        if (state$.isEditing_()) {
            _Util.promptSave_(() => {
                this._onbrowse1(cpath, fragment);
            })
                .show_();
        } else {
            const d = DialogUt.confirm_(
                accessories$,
                MSG.format1_(RS.confirmOpenDocument1, Basepath.filename_(cpath)),
                (yes: boolean) => {
                    if (yes) {
                        this._onbrowse1(cpath, fragment);
                    }
                });
            d.zindex_(DEF.zindexPromptSave);
            d.showWarning_();
        }
        return null;
    }

    private _onbrowse1(cpath: string, hash: string): void {
        Timer.sleep0_(() => {
            Timer.sleep_(250, () => {
                if (An.isempty_(hash)) {
                    _Util.browseFile_(cpath);
                } else {
                    const uri = An.uriFromSafe_(null, cpath.split(FS), "", hash);
                    _Util.browse_(uri, cpath + "#" + hash);
                }
            });
        });
    }

    onSaveCSS(cpath: string, callback: Fun00): void {
        if (state$ == _State.BROWSING || state$ == _State.EDITING) {
            native$.updateIFrameStylesheets_(cpath, callback);
        } else {
            callback();
        }
    }

    onPostToaster(param: stringX): stringX {
        const params = An.parseJSONObjectOrNull_(param);
        if (params == null) return null;
        const text = params[Key.text];
        const hold = (true == params[Key.hold]);
        if (text != null) {
            toasters$.ok_(text, { attop: true, hold: hold });
        }
        const warns = params[Key.warns];
        if (warns != null) {
            toasters$.warn_(warns, { attop: true, hold: hold });
        }
        return null;
    }

    onPostToasterOnLoad(param: stringX): stringX {
        const params = An.parseJSONObjectOrNull_(param);
        if (params == null) return null;
        this.addIFrameReadyOneshotCallback0(() => {
            const text = params[Key.text];
            const hold = (true == params[Key.hold]);
            if (text != null) {
                toasters$.ok_(text, { attop: true, hold: hold });
            }
            const warns = params[Key.warns];
            if (warns != null) {
                toasters$.warn_(warns, { attop: true, hold: hold });
            }
        });
        return null;
    }

    onEmptyChanged(isempty: boolean): void {
        if (this._contextmenu != null && this._contextmenu.isShown_()) {
            this._setbutton(MainContextActions._UNDO, !isempty);
            this._setbutton(MainContextActions._UNDO_HISTORY, !isempty);
        }
    }

    onRedoEmpty(isempty: boolean): void {
        if (this._contextmenu != null && this._contextmenu.isShown_()) {
            this._setbutton(MainContextActions._REDO, !isempty);
        }
    }

    onUndone(label: stringX): void {
        const msg = (label == null || label.length == 0) ? "OK" : label + " OK";
        toasters$.info_(`${MSG.string_(RS.Undo)}: ${msg}`, { attop: false });
    }

    onRedone(label: stringX): void {
        const msg = (label == null || label.length == 0) ? "OK" : label + " OK";
        toasters$.info_(`${MSG.string_(RS.Redo)}: ${msg}`, { attop: false });
    }

    onPauseCallback(_dontcare: stringX): stringX {
        
        if (this._iframeMediaViewer != null) {
            this._iframeMediaViewer.onPause_();
        }
        this._browsingContextmenu.onPause_();
        if (_AudioPlayerDialog.singleton$ != null) {
            _AudioPlayerDialog.singleton$.onPause_();
        }
        if (this.isEditing()) {
            
            const src = this._onBeforeSaveForPause();
            if (src != null) {
                host$.saveRecovery_(src, ret => {
                    
                    toasters$.warn_(ret);
                    this._enableEditActions(true);
                });
            }
        }
        const uri = native$.getIFrameUri_();
        if (uri == null) return "[]";
        const state = this.saveSession1_(uri);
        host$.hideKeyboard_();
        return JSON.stringify([uri.path$, state]);
    }

    addOnResumeOneshotCallback_(callback: Fun00): void {
        if (Conf.useTouch$) {
            this._onResumeOneshotCallbacks.push(callback);
        }
    }

    onResumeCallback(json: stringX): stringX {
        if (json != null && json.length > 0) {
            try {
                const a = An.parseJSONObjectOrNull_(json);
                if (a != null) {
                    toasters$.warn_(a[Key.warns], { hold: true });
                }
            } catch (e) {
            }
        }
        if (this._iframeMediaViewer != null) {
            this._iframeMediaViewer.onResume_();
        }
        this._browsingContextmenu.onResume_();
        if (_AudioPlayerDialog.singleton$ != null) {
            _AudioPlayerDialog.singleton$.onResume_();
        }
        An.fireOneshotCallbacks_(this._onResumeOneshotCallbacks);
        return null;
    }

    isEditing(): boolean {
        return state$ == _State.EDITING;
    }

    isBrowsing(): boolean {
        return state$ == _State.BROWSING;
    }

    saveEdit(reloadcallback: StringCallback | null = null): void {
        const startgroup = _MainPanel._startGroup(RS.action_Save, "");
        this._onBeforeSave((src) => {
            this._processPlaceholdersOnSave(() => {
                if (src != null) {
                    if (this._metainfo == null) {
                        this._metainfo = new _Metainfo();
                    }
                    this._metainfo.setModifiedBy();
                    native$.iSetMetainfo_(this._metainfo.stringify());
                    const content = native$.serializeIFrameDocument_();
                    _MainPanel._endGroup(startgroup);
                    this._savenow(src, content, reloadcallback);
                }
            });
        });
    }

    private _onBeforeSaveForPause(): stringX {
        const doc = native$.getIFrameDocument_();
        if (doc == null) {
            toasters$.warnKey_(RS.InvalidDocument);
            return null;
        }
        const src = native$.getIFrameContextPath_();
        if (src == null) {
            toasters$.warnKey_(RS.InvalidDocument);
            return null;
        }
        this._onStopEdit0();
        return src;
    }

    private _onBeforeSave(callback: StringXCallback): void {
        host$.hideKeyboard_(() => {
            const src = this._onBeforeSaveForPause();
            _MainPanel.recalculateTotals_();
            native$.fixIFrameOnSave_();
            callback(src);
        });
    }

    /* Prepare to save or cancel edit. */
    private _onStopEdit0(): void {
        
        native$.iRemoveSelections_();
        native$.setDisplayById_(ID.xRightSidepanel, "none");
        native$.setDisplayById_(ID.xLeftSidepanel, "none");
        const rsb = native$.iGetElementById_(ID.xRightSidebar);
        if (rsb != null) {
            rsb.classList.remove(CSS.xHidetemp);
        }
        this._clientActionHideDone();
        this._enableEditActions(false);
        this._hideAnnotations();
    }

    private _onStopEdit(callback: Fun00): void {
        
        while (this._iframeEditListeners.length != 0) {
            native$.iRemoveEventListener_(this._iframeEditListeners.pop()!);
        }
        host$.hideKeyboard_(() => {
            if (history$ != null) {
                history$.disconnect_();
            }
            this._onStopEdit0();
            const idoc = native$.getIFrameDocument_();
            if (idoc != null) {
                const editable = idoc.body;
                native$.removeAttributes_(editable, [
                    ATTR.contenteditable,
                    ATTR.autocapitalize,
                    ATTR.AnUndoing,
                    ATTR.AnRedoing,
                    ATTR.AnToggleGroup,
                ]);
            }
            this._lastIFrameSelectionRange = null;
            callback();
        });
    }

    private _savenow(path: string, content: string, reloadcallback: StringCallback | null = null): void {
        
        const timer = new StepTimer();
        this._mainToolbar.setEnabled(false);
        host$.saveHtml_(path, content, ret => {
            if (toasters$.warn_(ret)) {
                this._enableEditActions(true);
                this._mainToolbar.setEnabled(true);
                return;
            }
            const path = ret[Key.result];
            this.stopEdit(false, () => {
                timer.debug_(`# saveEdit(): ${path}`);
                if (reloadcallback != null) {
                    state$ = _State.BROWSING;
                    this._mainToolbar.onStateChange_();
                    this._mainToolbar.setEnabled(true);
                    reloadcallback(path);
                    return;
                }
                const uri = native$.getIFrameUri_();
                if (uri?.searchParams$.has(Param.edit) != true) {
                    state$ = _State.BROWSING;
                    this._mainToolbar.onStateChange_();
                    this._mainToolbar.setEnabled(true);
                    return;
                }
                const state = this.saveSession_(null);
                this.addIFrameReadyOneshotCallback(next => {
                    this._restoreSession(state);
                    this._mainToolbar.setEnabled(true);
                    next();
                });
                //// Keep toolbar disabled on reload.
                Timer.sleep00_(() => {
                    native$.reload_();
                });
            });
        });
    }

    /// @param callback() Callback when started editing, not called if failed to start editing.
    /// @param cancelcallback() Callback if failed to start editing.
    startEdit(startcallback: Fun00, cancelcallback: Fun00X = null): void {
        const docinfo = docInfo$;
        if (docinfo == null || !docinfo.fileInfo$.writable$) {
            toasters$.warnKey_(RS.DocumentIsNotEditable);
            cancelcallback?.();
            return;
        }
        if (docinfo.uri$?.searchParams$.has(Param.searchtext) ?? false) {
            Timer.sleep0_(() => {
                const cpath = docinfo.uri$?.path$ ?? null;
                if (cpath != null) {
                    const state = this.saveSession_(null);
                    this.addIFrameReadyOneshotCallback(next => {
                        this._restoreSession(state);
                        next();
                    });
                    _Util.browseFile_(cpath, null, true);
                }
            });
            cancelcallback?.();
            return;
        }
        state$ = _State.EDITING;
        const iwin = native$.getIFrameWindow_();
        if (iwin == null) {
            cancelcallback?.();
            return;
        }
        const idoc = iwin.document;
        const body = idoc.body;
        JsUtil.setAttribute_(body, ATTR.contenteditable, "true");
        JsUtil.setAttribute_(body, ATTR.autocapitalize, "none");
        JsUtil.setAttribute_(body, ATTR.AnRedoing, "");
        JsUtil.setAttribute_(body, ATTR.AnUndoing, "");
        JsUtil.setAttribute_(body, ATTR.AnToggleGroup, "");
        JsUtil.setAttribute_(body, ATTR.autocomplete, "on");
        JsUtil.setAttribute_(body, ATTR.autocorrect, "on");
        JsUtil.setAttribute_(body, ATTR.spellcheck, "true");
        idoc.execCommand("enableObjectResizing", true, "true");
        idoc.execCommand("enableInlineTableEditing", true, "true");
        idoc.execCommand("insertBrOnReturn", true, "true");
        this._iframeEditListeners.push(native$.iAddEventListener_(iwin, "keydown", (e) => this._keydownListener(e), false, true));
        this._iframeEditListeners.push(native$.iAddEventListener_(iwin, "keypress", (e) => this._keypressListener(e), false, true));
        this._iframeEditListeners.push(native$.iAddEventListener_(idoc, "paste", (e) => this._pasteListener(e), false, true));
        this._iframeEditListeners.push(native$.iAddEventListener_(iwin, Conf.pointerstart$, (e) => this._touchStartListener(e), false, true));
        const range = native$.getValidIFrameSelectionRange_();
        if (range == null) {
            const xroot = native$.iQuery(`.${CSS.xRoot}`);
            native$.iSelect_(xroot != null ? xroot : body, 0, 0);
        }
        if (this._metainfo != null
            &&
            this._metainfo.modifiedBy$ < BUILD_VERSION) {
            new _Fixer(this._metainfo).fix();
        }
        this._enableEditActions(true);
        const recalc = (native$.iQuery(`.${CSS.xCalcContext}`) != null);
        docInfo$?.setRecalc_(recalc);
        history$.addOnUndoEmptyListener_((isempty) => this.onEmptyChanged(isempty));
        history$.addOnUndoneListener_((label) => this.onUndone(label));
        history$.addOnRedoEmptyListener_((isempty) => this.onRedoEmpty(isempty));
        history$.addOnRedoneListener_((label) => this.onRedone(label));
        history$.connect_();
        state$ = _State.EDITING;
        this._mainToolbar.onStateChange_();
        const placeholders = native$.iQueryAll_<HTMLElement>(`[${ATTR.xPlaceholder}]`).filter((e) => {
            const value = e.getAttribute(ATTR.xPlaceholder);
            return value != Placeholder.xpVideoinfo && value != Placeholder.xpAudioinfo;
        });
        this.processPlaceholders_(placeholders, () => {
            startcallback?.();
        });
    }

    private _touchStartListener(e: Event): void {
        
        this._lastIFrameSelectionRange = null;
        let touches = 1;
        let event: Touch | MouseEvent | null = null;
        if (Conf.pointerstart$ == "touchstart") {
            const ee = e as TouchEvent;
            touches = ee.touches.length;
            if (touches > 0) {
                event = ee.touches[0];
            }
        } else {
            event = e as MouseEvent;
            if (event.ctrlKey) {
                touches = 2;
            }
        }
        const target = e.target as HTMLElement;
        if (target == null || target.nodeType != Node.ELEMENT_NODE) {
            return;
        }
        if (touches < 2) {
            const ret = target.classList;
            if (ret.contains(CSS.xTemplateButton)) {
                this._lastIFrameSelectionRange = native$.getIFrameSelectionRange_();
            }
            if ((ret.contains(CSS.xCalcPrice) || ret.contains(CSS.xCalcQuantity))
                && !JsUtil.isInput_(target)
                && event != null) {
                JsUtil.stopevent_(e);
                const pagex = event.pageX;
                const pagey = event.pageY;
                
                this._onCalcCell(target, pagex, pagey);
            }
        }
    }

    private _keypressListener(e: Event): void {
        const ee = e as KeyboardEvent;
        if (ee.key == "Enter") {
            
            if (_MainPanel._actionOnEnter()) {
                JsUtil.stopEventImmediately_(e);
            }
        }
    }

    private _keydownListener(e: Event): void {
        const ee = e as KeyboardEvent;
        const key = ee.key;
        if (this.isEditing() && key == "Backspace") {
            
            if (_MainPanel._actionOnBackspace()) {
                JsUtil.stopevent_(e);
            }
        }
    }

    private _pasteListener(e: Event): void {
        
        JsUtil.stopevent_(e);
        try {
            const data = (e as ClipboardEvent).clipboardData;
            if (data != null) {
                const items = Array.from(data.items);
                if (items != null) {
                    for (const mime of [Mime.TXT$, Mime.HTML$]) {
                        for (const item of items) {
                            const type = item.type;
                            const kind = item.kind;
                            if (mime == type && "string" == kind) {
                                
                                this._pasteText(item);
                                return;
                            }
                        }
                    }
                    for (const item of items) {
                        const kind = item.kind;
                        if ("string" == kind) {
                            
                            this._pasteText(item);
                            return;
                        }
                    }
                }
            }
        } catch (e) {
            
        }
        toasters$.warn_(MSG.stringArray_(RS.ClipboardPasteStringOnly));
    }

    private _pasteText(item: DataTransferItem): void {
        item.getAsString((value) => {
            this._pasteText1(value);
        });
    }

    private _pasteText1(value: string): void {
        const range = native$.getIFrameSelectionRange_();
        
        if (value != null && range != null) {
            if (history$ != null) {
                history$.group_(RS.Tooltips_PasteFromSystemClipboard, "", () => {
                    this._pasteText2(range, value);
                });
            } else {
                this._pasteText2(range, value);
            }
        }
    }

    private _pasteText2(range: Range, value: string): void {
        const doc = RangeUtil.rangeOwnerDocument_(range);
        if (doc == null) return;
        const text = doc.createTextNode(value);
        RangeUtil.replaceRange_(range, text);
    }

    private _dragStartListener(e: Event): void {
        
        JsUtil.stopevent_(e);
    }

    private _dragListener(e: Event): void {
        
        JsUtil.stopevent_(e);
    }

    private _dropListener(e: Event): void {
        
        JsUtil.stopevent_(e);
        toasters$.warn_(MSG.string_(RS.DropActionNotSupported));
    }

    startEditCallback(next: Fun00): void {
        this.startEdit(() => {
            next();
        }, () => {
            next();
        });
    }

    private _addIFrameUnloadCallback(cb: Fun00): void {
        this._iframeUnloadCallbacks.push(cb);
    }

    saveSession1_(uri: Uri): JSONObjectX {
        return this.saveSession_(state$ == _State.VIDEO ? uri?.searchParams$ : null);
    }

    /// @param queries @nullable Current only used in state==VIDEO.
    saveSession_(queries: URLSearchParams | null): JSONObjectX {
        if (state$ == _State.EDITING || state$ == _State.BROWSING) {
            let x = 0;
            let y = 0;
            let type = null;
            const root = native$.iQuery(`.${CSS.xRoot}`);
            if (root != null) {
                x = root.scrollLeft;
                y = root.scrollTop;
                type = SessionParam.XROOT;
            }
            return json_(
                [SessionParam.type, type],
                [SessionParam.x, x],
                [SessionParam.y, y],
            );
        } else if (state$ == _State.AUDIO) {
            if (this._iframeMediaViewer == null) {
                return null;
            }
            const player = (this._iframeMediaViewer as _AudioPlayerDialog);
            if (player == null) {
                return smap_(
                    [SessionParam.x, 0],
                    [SessionParam.y, 0],
                );
            } else {
                return player.saveSession_();
            }
        } else if (state$ == _State.IMAGE) {
            return {};
        } else if (state$ == _State.VIDEO) {
            const ret = json_();
            const poster = (queries == null ? null : An.parseInt_(queries.get(Param.poster), null));
            if (poster != null) {
                ret[SessionParam.poster] = poster;
            }
            const seek = (queries == null ? null : An.parseInt_(queries.get(Param.seek), null));
            if (seek != null) {
                ret[SessionParam.x] = seek;
            }
            return ret;
        } else if (state$ == _State.PDF) {
            return {};
        } else if (state$ == _State.TEXT) {
            return {};
        } else {
            return null;
        }
    }

    static _showAnnotation0(div: HTMLElement): void {
        host$.hideKeyboard_(() => {
            _MainPanel._showAnnotation1(div);
        });
    }

    /**
       * @param div The div.x-annotation element.
       * @param event The iframe click event.
       * @return true if annotation is shown.
       */
    static _showAnnotation1(div: HTMLElement): boolean {
        let target = JsUtil.childElementWithClass_(div, CSS.xAnnotationTarget);
        if (target == null) {
            target = JsUtil.childElementWithClass_(div, CSS.xAnnotation);
        }
        const sm = JsUtil.childElementWithClass_(div, CSS.xSmokescreen);
        if (target == null || sm == null) {
            //// Invalid annotation structure.
            return false;
        }
        const content = JsUtil.childElementWithClass_(sm, CSS.xAnnotationContent);
        if (content == null) {
            //// Invalid annotation structure.
            return false;
        }
        const startgroup = _MainPanel._startGroup(RS.action_AnnotationShow, "");
        try {
            native$.iClearSelection_();
            _MainPanel._showAnnotation2(sm, target, content);
        } finally {
            _MainPanel._endGroup(startgroup);
            return true;
        }
    }

    static _showAnnotation2(sm: HTMLElement, target: HTMLElement, content: HTMLElement): void {
        const iwinwidth = cache$.ui$.iwinWidth_();
        const iwinheight = cache$.ui$.iwinHeight_();
        const imargin = DEF.contextmenuMargin;
        native$.setStyles_(sm, map_(
            ["top", "0px"],
            ["left", "0px"],
            ["width", "100%"],
            [PK.Height, "100%"],
            ["visibility", "hidden"],
            ["display", "block"],
        ));
        const smbound = native$.getBoundingClientRect_(sm);
        let ismx = Math.round(smbound.left);
        let ismy = Math.round(smbound.top);
        let ismw = Math.round(smbound.width);
        let ismh = Math.round(smbound.height);
        
        let smleft: number;
        let smtop: number;
        if (ismx < 0) {
            smleft = -ismx;
            ismx = 0;
        } else {
            smleft = 0;
        }
        if (ismy < 0) {
            smtop = -ismy;
            ismy = 0;
        } else {
            smtop = 0;
        }
        native$.setStyles_(sm, map_(
            ["left", `${smleft}px`],
            ["top", `${smtop}px`],
        ));
        let maxwidth = Math.min(iwinwidth - ismx, ismw) - imargin * 2;
        maxwidth = Math.min(maxwidth, iwinwidth * 3 / 4);
        let maxheight = Math.min(iwinheight - ismy, ismh) - imargin * 2;
        maxheight = Math.min(maxheight, iwinheight * 3 / 4);
        native$.setStyles_(content, map_(
            ["top", `${imargin}px`],
            ["left", `${imargin}px`],
            ["max-width", `${maxwidth}px`],
            ["max-height", `${maxheight}px`],
        ));
        const contentbound = native$.getBoundingClientRect_(content);
        
        //// span a large area, the popup may not be adjacent to the click.
        const bound = native$.getBoundingClientRect_(target);
        
        const x = Math.round(bound.left + bound.width / 2);
        const y = Math.round(bound.top);
        let width = Math.round(contentbound.width);
        let height = Math.round(contentbound.height);
        let top = y - height - imargin / 2 - ismy;
        let left = x - (width / 2) - ismx;
        if (top < imargin) {
            top = imargin;
        }
        if ((left + ismx + width + imargin) > iwinwidth) {
            left = iwinwidth - ismx - width - imargin;
        }
        if (left < imargin) {
            left = imargin;
        }
        
        native$.setStyles_(content, map_(
            ["top", `${top + ismy}px`],
            ["left", `${left + ismx}px`],
        ));
        native$.setStyles_(sm, map_(
            ["top", `-${ismy - smtop}px`],
            ["left", `-${ismx - smleft}px`],
            ["width", `${iwinwidth}px`],
            [PK.Height, `${iwinheight}px`],
            ["visibility", null],
        ));
    }

    private _hideAnnotations(): void {
        const list = native$.iQueryAll_<HTMLElement>(`div.${CSS.xAnnotation} > div.${CSS.xSmokescreen}`);
        for (const sm of list) {
            _MainPanel._hideAnnotation1(sm);
        }
    }

    showMainbar_() {
        this._mainToolbar.showMainbar_();
    }

    static _hideAnnotation1(sm: HTMLElement): void {
        const startgroup = _MainPanel._startGroup(RS.action_AnnotationHide, "");
        native$.setStyles_(sm, map_(
            ["display", null],
            ["top", null],
            ["left", null],
            ["width", null],
            ["height", null],
        ));
        const content = JsUtil.childElementWithClass_(sm, CSS.xAnnotationContent);
        if (content != null) {
            native$.setStyles_(content, map_(
                ["top", null],
                ["left", null],
                ["max-width", null],
                ["max-height", null],
            ));
        }
        _MainPanel._endGroup(startgroup);
    }

    private _enableEditActions(enable: boolean): void {
        const tabs = native$.iQueryAll_<HTMLElement>(`.${CSS.xTemplateButton}`);
        const display = enable ? "block" : null;
        for (const tab of tabs) {
            native$.setDisplay_(tab, display);
        }
        const rightsidebar = native$.iGetElementById_(ID.xRightSidebar);
        if (rightsidebar != null) {
            rightsidebar.classList.remove(CSS.xHidden);
        }
    }

    private _processPlaceholdersOnSave(callback: Fun00): void {
        callback();
    }

    private _updateAudioInfos(callback: Fun00): void {
        const elms = native$.iQueryAll_<HTMLElement>(`[${ATTR.xPlaceholder}]`);
        const infos = new Array<HTMLElement>();
        for (const elm of elms) {
            const action = elm.getAttribute(ATTR.xPlaceholder);
            if (Placeholder.xpAudioinfo == action) {
                infos.push(elm);
            }
        }
        _MainPanel._processPlaceholdersAudioInfos(infos, callback);
    }

    /**
       * @param callback(JsObject placeholders) The NodeList of placeholders found.
       */
    processPlaceholders_(placeholders: HTMLElement[], callback: Fun10<Range | null>): void {
        const baseuri = native$.getIFrameUri_();
        if (placeholders == null || placeholders.length == 0 || baseuri == null) {
            callback(null);
            return;
        }
        this._processPlaceholders1(placeholders, baseuri, callback);
    }

    private _processPlaceholders1(holders: HTMLElement[], baseuri: BaseUri, callback: Fun10<Range | null>): void {
        const startgroup = _MainPanel._startGroup(RS.history_placeholders, "");
        //// Process synchronous placeholders that do not require user intervention first
        //// and can be completed synchronously.
        const audioinfos = new Array<HTMLElement>();
        const videoinfos = new Array<HTMLElement>();
        const clone = Array.from(holders);
        for (let len = clone.length; len > 0;) {
            const elm = clone[--len];
            const holder = elm.getAttribute(ATTR.xPlaceholder);
            let dateformatter = null;
            switch (holder) {
                case Placeholder.xpDate:
                case Placeholder.xpDateAuto:
                case Placeholder.xpDateShort:
                case Placeholder.xpDatetime:
                case Placeholder.xpDatetimeShort:
                case Placeholder.xpTime:
                case Placeholder.xpTimeShort:
                    dateformatter = new _PlaceholderDateFormatter(elm, holder);
                    break;
                case Placeholder.xpAudioinfo:
                    audioinfos.push(elm);
                    holders.splice(len, 1);
                    break;
                case Placeholder.xpVideoinfo:
                    videoinfos.push(elm);
                    holders.splice(len, 1);
                    break;
            }
            if (dateformatter != null && dateformatter.datestring != null) {
                elm.removeAttribute(ATTR.xPlaceholder);
                An.setDatetime(elm, dateformatter);
                holders.splice(len, 1);
            }
        }
        _MainPanel._processPlaceholdersAudioInfos(audioinfos, () => {
            _MainPanel._processPlaceholdersVideoInfos(videoinfos, () => {
                this._processPlaceholders2(holders, baseuri, ret => {
                    _MainPanel._endGroup(startgroup);
                    callback(ret);
                });
            });
        });
    }

    /// Process interactive actions.
    private _processPlaceholders2(holders: HTMLElement[], baseuri: BaseUri, callback: Fun10<Range | null>): void {
        let sel: Range | null = null;
        const basedir = An.cdirOfUri_(baseuri);
        An.iterateList_(holders, (elm, _index, next) => {
            const holder = elm.getAttribute(ATTR.xPlaceholder);
            switch (holder) {
                case Placeholder.xpCanvas:
                    if (!elm.classList.contains(CSS.xCanvas)) {
                        next(false);
                    }
                    elm.removeAttribute(ATTR.xPlaceholder);
                    this._actionAnnotateCanvas0(elm, (ok: boolean) => {
                        if (!ok) _MainPanel._destroyDrawing(elm);
                        next(false);
                    });
                    break;
                case Placeholder.xpCanvasImage:
                    if (!native$.hasClass_(elm, CSS.xCanvas)) {
                        next(false);
                    }
                    elm.removeAttribute(ATTR.xPlaceholder);
                    this._actionAnnotateCanvasImage(elm, basedir, (ok: boolean) => {
                        if (!ok) _MainPanel._destroyDrawing(elm);
                        next(false);
                    });
                    break;
                case Placeholder.xpAudio:
                case Placeholder.xpAudio2:
                    next(false);
                    break;
                case Placeholder.xpVideo:
                    next(false);
                    break;
                case Placeholder.xpPhoto:
                case Placeholder.xpAnnotationPhoto:
                case Placeholder.xpCanvasPhoto:
                    next(false);
                    break;
                case Placeholder.xpImage: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    sel = native$.iSelectContents_(elm);
                    const baseuri = native$.getIFrameUri_();
                    if (sel != null && baseuri != null) {
                        _MainPanel._actionInsertImg1(sel, _MainPanel._getimageattrs(elm), baseuri, () => {
                            next(false);
                        }).show_();
                    }
                    break;
                }
                case Placeholder.xpImageNoCaption: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    sel = native$.iSelectContents_(elm);
                    const baseuri = native$.getIFrameUri_();
                    if (sel != null && baseuri != null) {
                        const d = _MainPanel._actionInsertImg1(sel, _MainPanel._getimageattrs(elm), baseuri, () => {
                            next(false);
                        });
                        d.showCaption_(false);
                        d.show_();
                    }
                    break;
                }
                case Placeholder.xpCalendar: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    const buttonsize = cache$.ui$.buttonSize_();
                    const d = new PromptCalendar(
                        accessories$,
                        buttonsize);
                    d.titleKey_(RS.PromptDateTimeTitle);
                    d.zindex_(DEF.zindexPrompt);
                    d.dateFormat_(settings$.monthFormat_());
                    d.onOK_((date: DateTime, width: string, height: string, formatted: string) => {
                        if (formatted == null) {
                            formatted = settings$.monthString_(date);
                        }
                        const idoc = native$.getIFrameDocument_();
                        if (idoc != null) {
                            const node = _MainPanel._createCalendar(idoc, date, null, width, height, formatted);
                            //// Reuse node
                            new DomBuilderEx(elm).empty_().appendNodes_(node);
                            const span = native$.iQuery(`div.${CSS.xCalHead} span`, node);
                            if (span != null) {
                                sel = native$.iSetCaretAtStart_(span);
                            }
                        }
                        next(false);
                    });
                    d.onCancel_(() => {
                        next(false);
                    });
                    d.show_();
                    break;
                }
                case Placeholder.xpAnnotationImage: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    const text = DomBuilderEx.createText_(MSG.XXX$);
                    new DomBuilderEx(elm).empty_().appendNodes_(text);
                    const range = native$.iSelectNode_(elm);
                    if (range == null) {
                        next(false);
                    } else {
                        _WidgetTemplates._annotationImage(range, () => {
                            next(false);
                        });
                    }
                    break;
                }
                case Placeholder.xpAnnotation: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    const text = DomBuilderEx.createText_(MSG.XXX$);
                    new DomBuilderEx(elm).empty_().appendNodes_(text);
                    const range = native$.iSelectNode_(elm);
                    if (range != null) {
                        _WidgetTemplates._annotation(range, baseuri, () => {
                            sel = native$.iSelectNode_(text);
                            next(false);
                        });
                    }
                    break;
                }
                case Placeholder.xpDraggable: {
                    elm.removeAttribute(ATTR.xPlaceholder);
                    this.actionEditSize0_(elm, () => {
                        next(false);
                    });
                    break;
                }
                default:
                    next(false);
            }
        }, () => {
            callback(sel);
        });
    }

    static _getimageattrs(elm: HTMLElement): string {
        const img = native$.iQuery("img", elm);
        if (img == null) return `class ${CSS.xImageholder}`;
        const classlist = Array.from(img.classList);
        classlist.push(CSS.xImageholder);
        const sorted = JsUtil.sortedAttributes_(img);
        sorted.set("class", classlist.join(" "));
        return An.attributesToStringForEdit_(sorted, " ", ["xmlns", "src", "href"]);
    }

    static _destroyDrawing(elm: HTMLElement): void {
        const parent = JsUtil.ancestorOrSelfWithClasses_(elm, [CSS.xxDrawing]);
        if (parent != null) {
            JsUtil.remove_(parent);
        }
    }

    static _startGroup(labelkey: StringId, details: string): boolean {
        if (history$ != null) {
            history$.startGroup_(labelkey, details);
            return true;
        }
        return false;
    }

    static _endGroup(started: boolean): void {
        if (started && history$ != null) {
            history$.endGroup_();
        }
    }

    static audioInfos_(cpath: string, callback: JSONCallback): void {
        host$.audioInfos_([
            json_(
                [Key.path, cpath],
                [Key.time, 0],
            ),
        ], ret => {
            callback(ret[Key.result]?.[cpath]);
        });
    }

    static videoInfos_(cpath: string, callback: JSONCallback): void {
        host$.videoInfos_([
            json_(
                [Key.path, cpath],
                [Key.time, 0],
            ),
        ], ret => {
            callback(ret[Key.result]?.[cpath]);
        });
    }

    static _updateAudioInfo(audioinfo: HTMLElement, callback: Fun00): void {
        const startgroup = _MainPanel._startGroup(RS.action_UpdateAudioInfo, "");
        audioinfo.removeAttribute(ATTR.xTooltips);
        _MainPanel._processPlaceholdersAudioInfos([audioinfo], () => {
            _MainPanel._endGroup(startgroup);
            callback();
        });
    }

    static _updateVideoInfo(videoinfo: HTMLElement, callback: Fun00): void {
        const startgroup = _MainPanel._startGroup(RS.action_UpdateVideoInfo, "");
        videoinfo.removeAttribute(ATTR.xTooltips);
        _MainPanel._processPlaceholdersVideoInfos([videoinfo], () => {
            _MainPanel._endGroup(startgroup);
            callback();
        });
    }

    static _getPlaceholderInfo(anchor: HTMLElement): stringX {
        const tag = anchor.tagName;
        if (tag == "AUDIO" || tag == "VIDEO") {
            return anchor.getAttribute(ATTR.xInfo);
        }
        return null;
    }

    static _processPlaceholdersAudioInfos(audioinfos: HTMLElement[], callback: Fun00): void {
        const baseuri = native$.getIFrameUri_();
        if (audioinfos.length == 0 || baseuri == null) {
            callback();
            return;
        }
        const requests = new Array<JSONObject>();
        const anchors = new Array<HTMLElementX>();
        for (const elm of audioinfos) {
            let cpath = null;
            const anchor = _MainPanel._audioInfoAnchor(elm);
            anchors.push(anchor);
            if (anchor != null) {
                const href = anchor.getAttribute(ATTR.xHref) ?? anchor.getAttribute("src") ?? anchor.getAttribute("href");
                cpath = An.cpathOfHref2_(baseuri, href);
            }
            if (cpath == null) {
                requests.push({});
                continue;
            }
            const timestamp = An.parseInt_(elm.getAttribute(ATTR.xTooltips), -1);
            requests.push(json_(
                [Key.path, cpath],
                [Key.time, timestamp],
            ));
        }
        host$.audioInfos_(requests, ret => {
            if (An.hasResult_(ret)) {
                callback();
                return;
            }
            const result = (ret[Key.result] ?? null) as StringMap<JSONObject>;
            
            if (result == null) {
                callback();
                return;
            }
            const startgroup = _MainPanel._startGroup(RS.action_UpdateAudioInfo, "");
            Ut.asyncIterate_(audioinfos, (elm, i, next) => {
                const request = requests[i];
                const cpath = request[Key.path];
                if (cpath != null && result != null) {
                    const info = result[cpath];
                    if (info != null && Object.keys(info).length == 0) {
                        next();
                        return;
                    }
                }
                const anchor = anchors[i];
                const elmfilename = native$.iQuery(`.${CSS.xAudioFilename}`, elm);
                const elmfilesize = native$.iQuery(`.${CSS.xAudioFilesize}, .${CSS.xMediaFilesize}`, elm);
                const elmdatetime = native$.iQuery(`.${CSS.xAudioDatetime}`, elm);
                const elmduration = native$.iQuery(`.${CSS.xAudioDuration}`, elm);
                const elmrate = native$.iQuery(`.${CSS.xAudioRate}`, elm);
                const elmchannels = native$.iQuery(`.${CSS.xAudioChannels}`, elm);
                const infos: Array<Array<HTMLElementX>> = [
                    [elmdatetime, elmduration],
                    [elmfilename, elmrate],
                    [elmfilesize, elmchannels]
                ];
                if (cpath == null || result == null) {
                    _MainPanel._mediaInfoError(elm, anchor, infos);
                    next();
                    return;
                }
                const res = result[cpath];
                const info = MediaInfo.of_(res);
                const error = info?.error$ ?? null;
                const exists = info?.fileExists$ ?? false;
                if (info == null || error != null || !exists) {
                    
                    _MainPanel._mediaInfoError(elm, anchor, infos);
                    next();
                    return;
                }
                const lastmodified = info.fileDate$ ?? 0;
                JsUtil.setAttribute_(elm, ATTR.xTooltips, lastmodified.toString());
                _MainPanel._updateAudioinfo0(
                    anchor,
                    elmfilename,
                    elmfilesize,
                    elmdatetime,
                    elmduration,
                    elmrate,
                    elmchannels,
                    cpath,
                    MediaInfo.of_(res));
                this._updateMediaInfo(res, anchor, () => {
                    _MainPanel._updateAudioinfo0(
                        anchor,
                        elmfilename,
                        elmfilesize,
                        elmdatetime,
                        elmduration,
                        elmrate,
                        elmchannels,
                        cpath,
                        MediaInfo.of_(res));
                });
                next();
            }, () => {
                _MainPanel._endGroup(startgroup);
                callback();
            });
        });
    }

    static _updateMediaInfo(result: JSONObject, anchor: HTMLElementX, callback: Fun00) {
        if (anchor == null || (anchor.tagName != "AUDIO" && anchor.tagName != "VIDEO")) {
            return;
        }
        const updater = () => {
            result[MediaInfo.Duration] = media.duration;
            if (media.tagName == "VIDEO") {
                const video = (media as HTMLVideoElement);
                result[MediaInfo.Width] = video.videoWidth;
                result[MediaInfo.Height] = video.videoHeight;
            }
            callback();
        };
        const media = (anchor as HTMLMediaElement);
        if (!isNaN(media.duration)) {
            updater();
            return;
        }
        const src = media.getAttribute("src");
        if (src == null || src.length == 0) return;
        media.setAttribute("preload", "none");
        media.setAttribute("src", "");
        Timer.frame11_(() => {
            const listener = () => {
                media.removeEventListener("loadedmetadata", listener);
                updater();
            };
            media.addEventListener("loadedmetadata", listener);
            media.setAttribute("src", src);
            media.setAttribute("preload", "metadata");
        });
    }

    static _updateAudioInfo1(content: HTMLElement, cpath: string, info: MediaInfo): void {
        const anchor = native$.iQuery(`a.${CSS.xAudio}`, content);
        const elmfilename = native$.iQuery(`.${CSS.xAudioFilename}`, content);
        const elmfilesize = native$.iQuery(`.${CSS.xAudioFilesize}, .${CSS.xMediaFilesize}`, content);
        const elmdatetime = native$.iQuery(`.${CSS.xAudioDatetime}`, content);
        const elmduration = native$.iQuery(`.${CSS.xAudioDuration}`, content);
        const elmrate = native$.iQuery(`.${CSS.xAudioRate}`, content);
        const elmchannels = native$.iQuery(`.${CSS.xAudioChannels}`, content);
        const error = info.error$;
        const exists = info.fileExists$;
        if (info == null || error != null || !exists) {
            const elms: Array<Array<HTMLElementX>> = [
                [elmdatetime, elmduration],
                [elmfilename, elmrate],
                [elmfilesize, elmchannels]
            ];
            _MainPanel._mediaInfoError(content, anchor, elms);
        } else {
            _MainPanel._updateAudioinfo0(anchor, elmfilename, elmfilesize, elmdatetime, elmduration, elmrate, elmchannels, cpath, info);
        }
    }

    static _updateAudioinfo0(
        anchor: HTMLElementX,
        elmfilename: HTMLElementX,
        elmfilesize: HTMLElementX,
        elmdatetime: HTMLElementX,
        elmduration: HTMLElementX,
        elmrate: HTMLElementX,
        elmchannels: HTMLElementX,
        cpath: string,
        info: MediaInfo | null
    ): void {
        if (info == null) return;
        if (elmfilename != null) {
            new DomBuilderEx(elmfilename).empty_().text_(Basepath.filename_(cpath));
        }
        if (elmfilesize != null) {
            const b = new DomBuilderEx(elmfilesize).empty_();
            const size = info.fileSize$;
            if (size != null) {
                b.text_(" \u2022 " + An.filesizeUnit4_(size));
            }
        }
        if (elmdatetime != null) {
            const creationdate = info.creationDate$;
            const duration = Math.round(info.duration1_(0.0) * 1000);
            const lastmodified = info.fileDate$ ?? duration;
            const date = (creationdate != null
                ? DateTime.fromMs_(Math.max(0, creationdate - duration), true)
                : DateTime.fromMs_(Math.max(0, lastmodified - duration), false));
            const creationstring = JsUtil.datetimeStringWithXFormat_(elmdatetime, settings$.dateFormat_(), "", date);
            new DomBuilderEx(elmdatetime).empty_().addClass_(CSS.xDate).text_(creationstring);
        }
        if (elmduration != null) {
            const duration = info.duration$;
            const durationstring = (duration == null || isNaN(duration) || !isFinite(duration)
                ? "??:??"
                : An.timeStringFromSeconds_(duration));
            new DomBuilderEx(elmduration).empty_().text_(durationstring);
        }
        if (elmrate != null) {
            let ratestring = "??";
            const bitrate = info.bitrate$;
            const b = new DomBuilderEx(elmrate).empty_();
            if (bitrate != null && bitrate > 0) {
                ratestring = `${An.decUnit4_(bitrate)}${MSG.string_(RS.BitPerSecond)}`;
            }
            b.text_(ratestring);
        }
        if (elmchannels != null) {
            let channelstring = "?";
            const channels = info.channels$;
            if (channels != null) {
                channelstring = `${channels}`;
            }
            new DomBuilderEx(elmchannels).empty_().text_(channelstring);
        }
        if (anchor != null) {
            anchor.classList.remove(CSS.xxError);
        }
    }

    /**
       * @param elms The elements to update. Elements in the first array default to "??:??".
       *  HTMLElement in second array default to "??" and element in third array default to empty.
       */
    static _mediaInfoError(elm: HTMLElement, anchor: HTMLElementX, elms: Array<Array<HTMLElementX>>): void {
        elm.removeAttribute(ATTR.xTooltips);
        if (anchor != null) {
            anchor.classList.add(CSS.xxError);
        }
        if (elms.length >= 1) {
            for (const e of elms[0]) {
                if (e != null) {
                    new DomBuilderEx(e).empty_().text_("??:??");
                }
            }
            if (elms.length >= 2) {
                for (const e of elms[1]) {
                    if (e != null) {
                        new DomBuilderEx(e).empty_().text_("??");
                    }
                }
                if (elms.length >= 3) {
                    for (const elm of elms[2]) {
                        if (elm != null) {
                            if (elm.classList.contains(CSS.xVideoPoster)) {
                                _MainPanel._emptyPosterElement(elm);
                            } else {
                                new DomBuilderEx(elm).empty_();
                            }
                        }
                    }
                }
            }
        }
    }

    static _audioInfoAnchor(elm: HTMLElement): HTMLElementX {
        if (elm.classList.contains(CSS.xAudio)) return elm;
        if (elm.classList.contains(CSS.xAudioholder)) return elm;
        return native$.iQuery(`audio.${CSS.xAudio}, div.${CSS.xAudio}, a.${CSS.xAudio}`, elm)
            ?? native$.iQuery(`.${CSS.xAudioholder}`, elm);
    }

    static _videoInfoAnchor(elm: HTMLElement): HTMLElementX {
        if (elm.classList.contains(CSS.xVideo)) return elm;
        if (elm.classList.contains(CSS.xVideoholder)) return elm;
        return native$.iQuery(`video.${CSS.xVideo}, div.${CSS.xVideo}, a.${CSS.xVideo}`, elm)
            ?? native$.iQuery(`.${CSS.xVideoholder}`, elm);
    }

    static _processPlaceholdersVideoInfos(elms: HTMLElement[], callback: Fun00): void {
        const baseuri = native$.getIFrameUri_();
        if (elms.length == 0 || baseuri == null) {
            callback();
            return;
        }
        const requests: JSONObject[] = [];
        const anchors: Array<HTMLElementX> = [];
        for (const elm of elms) {
            let cpath = null;
            const anchor = _MainPanel._videoInfoAnchor(elm);
            anchors.push(anchor);
            if (anchor != null) {
                const href = anchor.getAttribute(ATTR.xHref) ?? anchor.getAttribute("src") ?? anchor.getAttribute("href");
                if (href != null) {
                    cpath = An.cpathOfHref2_(baseuri, href);
                }
            }
            if (cpath == null) {
                requests.push({});
                continue;
            }
            const timestamp = An.parseInt_(elm.getAttribute(ATTR.xTooltips), -1);
            requests.push(json_(
                [Key.path, cpath],
                [Key.time, timestamp],
            ));
        }
        host$.videoInfos_(requests, ret => {
            if (An.hasResult_(ret)) {
                callback();
                return;
            }
            const result = ret[Key.result] ?? null;
            
            if (result == null) {
                callback();
                return;
            }
            const startgroup = _MainPanel._startGroup(RS.action_UpdateVideoInfo, "");
            Ut.asyncIterate_(elms, (elm, i, next) => {
                const request = requests[i];
                const cpath = request[Key.path] ?? null;
                if (cpath == null) {
                    next();
                    return;
                }
                if (result != null) {
                    const info = result[cpath];
                    if (info != null && Object.keys(info).length == 0) {
                        next();
                        return;
                    }
                }
                const anchor = anchors[i];
                const res = result[cpath];
                _MainPanel._updateVideoInfo0(elm, anchor, cpath, MediaInfo.of_(res));
                this._updateMediaInfo(res, anchor, () => {
                    _MainPanel._updateVideoInfo0(elm, anchor, cpath, MediaInfo.of_(res));
                });
                next();
            }, () => {
                _MainPanel._endGroup(startgroup);
                callback();
            });
        });
    }

    static _updateAudioDuration(audioinfo: HTMLElement, duration: Double): void {
        const elmduration = native$.iQuery(`.${CSS.xAudioDuration}`, audioinfo);
        this._updateDuration(elmduration, duration);
    }

    static _updateVideoDuration(videoinfo: HTMLElement, duration: Double): void {
        const elmduration = native$.iQuery(`.${CSS.xVideoDuration}`, videoinfo);
        this._updateDuration(elmduration, duration);
    }

    static _updateVideoInfo0(videoinfo: HTMLElement, anchor: HTMLElementX, cpath: string, info: MediaInfo | null): void {
        
        const elmfilename = native$.iQuery(`.${CSS.xVideoFilename}`, videoinfo);
        const elmfilesize = native$.iQuery(`.${CSS.xVideoFilesize}, .${CSS.xMediaFilesize}`, videoinfo);
        const elmdatetime = native$.iQuery(`.${CSS.xVideoDatetime}`, videoinfo);
        const elmduration = native$.iQuery(`.${CSS.xVideoDuration}`, videoinfo);
        const elmresolution = native$.iQuery(`.${CSS.xVideoResolution}`, videoinfo);
        const elmposter = native$.iQuery(`.${CSS.xVideoPoster}`, videoinfo);
        const elms: Array<Array<HTMLElementX>> = [
            [elmdatetime, elmduration],
            [elmfilename],
            [elmfilesize, elmresolution, elmposter]
        ];
        if (cpath.length == 0 || info == null) {
            _MainPanel._mediaInfoError(videoinfo, anchor, elms);
            return;
        }
        const error = info.error$;
        const exists = info.fileExists$;
        const lastmodified = info.fileDate$ ?? 0;
        if (info == null || error != null || !exists) {
            
            _MainPanel._mediaInfoError(videoinfo, anchor, elms);
            return;
        }
        JsUtil.setAttribute_(videoinfo, ATTR.xTooltips, lastmodified.toString());
        const playable = info.playable$;
        if (true != playable) {
            _MainPanel._mediaInfoError(videoinfo, anchor, elms);
            return;
        }
        _MainPanel._updateVideoInfo1(videoinfo, anchor, elmfilename, elmfilesize, elmdatetime, elmresolution, elmduration, elmposter, cpath, info);
    }

    static _updateDuration(elmduration: HTMLElementX, duration: Double) {
        if (elmduration != null) {
            const sec = Math.round(duration);
            const durationstring = (sec == null || isNaN(sec) || !isFinite(sec)
                ? "??:??"
                : An.timeStringFromSeconds_(sec));
            new DomBuilderEx(elmduration).empty_().text_(durationstring);
        }
    }

    static _updateVideoInfo1(
        _videoinfo: HTMLElement,
        anchor: HTMLElementX,
        elmfilename: HTMLElementX,
        elmfilesize: HTMLElementX,
        elmdatetime: HTMLElementX,
        elmresolution: HTMLElementX,
        elmduration: HTMLElementX,
        elmposter: HTMLElementX,
        cpath: string,
        info: MediaInfo
    ): void {
        
        if (anchor != null) {
            anchor.classList.remove(CSS.xxError);
        }
        if (elmfilename != null) {
            new DomBuilderEx(elmfilename).empty_().text_(Basepath.filename_(cpath));
        }
        if (elmfilesize != null) {
            const b = new DomBuilderEx(elmfilesize).empty_();
            const size = info.fileSize$;
            if (size != null) {
                b.text_(" \u2022 " + An.filesizeUnit4_(size));
            }
        }
        if (elmdatetime != null) {
            const creationdate = info.creationDate$;
            const duration = (info.duration1_(0.0) * 1000);
            const lastmodified = info.fileDate$ ?? duration;
            const date = (creationdate != null
                ? DateTime.fromMs_(Math.max(0, creationdate - duration), true)
                : DateTime.fromMs_(Math.max(0, lastmodified - duration), false));
            const creationstring = JsUtil.datetimeStringWithXFormat_(elmdatetime, settings$.dateFormat_(), "", date);
            new DomBuilderEx(elmdatetime)
                .empty_()
                .addClass_(CSS.xDate)
                .text_(creationstring);
        }
        this._updateDuration(elmduration, info.duration$);
        if (elmresolution != null) {
            const width = info.width$;
            const height = info.height$;
            let text = "?? x ??";
            if (width != null && height != null && width > 0 && height > 0) {
                text = `${width} x ${height}`;
            }
            new DomBuilderEx(elmresolution).empty_().text_(text);
        }
        if (elmposter != null) {
            const dataurl = info.dataUrl$;
            const keys = ["max-width", "max-height"];
            if (dataurl != null) {
                const styles = native$.getInlineStyles_(elmposter, keys);
                const attrs = smap1_("src", dataurl);
                if (styles.size > 0) {
                    attrs["style"] = CSSUtil.joinStyles_(styles);
                }
                anchor?.classList.remove(CSS.xxBullet);
                const b = new DomBuilderEx(elmposter).empty_();
                b.div_().append_("img", attrs).append_("div", { "class": CSS.xPlay });
            } else {
                _MainPanel._emptyPosterElement(elmposter);
                anchor?.classList.add(CSS.xxBullet);
            }
        }
    }

    static _emptyPosterElement(elmposter: HTMLElement): void {
        const img = native$.iQuery("img", elmposter);
        if (img != null) {
            const styles = native$.getInlineStyles_(img, ["max-width", "max-height"]);
            if (styles.size > 0) {
                native$.setStyles_(elmposter, styles);
            }
        }
        new DomBuilderEx(elmposter).empty_();
    }

    stopEdit(reload: boolean, callback: Fun00X = null): void {
        
        this._onStopEdit(() => {
            
            state$ = _State.BROWSING;
            if (reload) {
                this._mainToolbar.setEnabled(false);
                const state = this.saveSession_(null);
                if (state != null) {
                    this.addIFrameReadyOneshotCallback(next => {
                        this._restoreSession(state);
                        this._mainToolbar.setEnabled(true);
                        next();
                        callback?.();
                    });
                }
                Timer.sleep00_(() => {
                    native$.reload_();
                });
            } else {
                callback?.();
            }
        });
    }

    private _restoreSession(session: JSONObjectX): void {
        if (session == null) { return; }
        const x = An.ifnull_(session[SessionParam.x], 0);
        const y = An.ifnull_(session[SessionParam.y], 0);
        const type = session[SessionParam.type];
        if (x > 0 || y > 0) {
            if (type == null) {
            } else if (SessionParam.XROOT == type || SessionParam.X_ROOT == type) {
                const root = native$.iQuery(`.${CSS.xRoot}`);
                if (root != null) {
                    
                    root.scrollLeft = x;
                    root.scrollTop = y;
                }
            }
        }
    }

    cancelEdit(): void {
        const rem = cache$.ui$.rem_();
        const buttonsize = cache$.ui$.buttonSize_();
        const width = Math.min(Math.max(rem * 12, rem * 8 + buttonsize * 3), window.innerWidth * 3 / 4);
        const d = new PromptOKFixedSize(accessories$, width, buttonsize);
        d.titleKey_(RS.Confirm);
        d.messageKey_(RS.CancelEdit);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((callback: BoolCallback) => {
            callback(true);
            host$.hideKeyboard_(() => {
                const src = this._onBeforeSaveForPause();
                if (src != null) {
                    host$.saveRecovery_(src, ret => {
                        toasters$.warn_(ret);
                        this.stopEdit(true);
                    });
                }
            });
        });
        d.showWarning_();
    }

    addIFrameReadyCallback(cb: IFrameReadyCallback): void {
        this._iframeReadyCallbacks.push(cb);
        
    }

    addIFrameReadyCallback0(cb: Fun00): void {
        this._iframeReadyCallbacks.push((next) => {
            next();
            cb();
        });
        
    }

    removeIFrameReadyCallback(cb: IFrameReadyCallback): boolean {
        const ret = An.identityRemove_(this._iframeReadyCallbacks, cb);
        
        return ret;
    }

    addIFrameReadyOneshotCallback(cb: IFrameReadyCallback): void {
        this._iframeReadyOneshotCallbacks.push(cb);
        
    }

    addIFrameReadyOneshotCallback0(cb: Fun00): void {
        this._iframeReadyOneshotCallbacks.push((next: Fun00) => {
            next();
            cb();
        });
        
    }

    /**
       * NOTE: On entry, iframe is loaded and resized, _cache and _docInfo are valid.
       * But sidepanel, toasters, ... etc. may not be created yet, _settings is not valid.
       */
    onIFrameLoad(uri: UriX): void {
        this._navigation = RecentsCmd.INFO;
        let errpath = settings$.getUrl_(Conf.errorPath$);
        this._resetIFrame();
        const iwin = native$.getIFrameWindow_();
        native$.iAddEventListener_(iwin, "dragstart", (e) => this._dragStartListener(e), true, true);
        native$.iAddEventListener_(iwin, "drag", (e) => this._dragListener(e), true, true);
        native$.iAddEventListener_(iwin, "drop", (e) => this._dropListener(e), true, true);
        const url = docInfo$?.uri$ ?? null;
        FAIL:
        {
            const fileinfo = docInfo$?.fileInfo$ ?? null;
            if (fileinfo == null || fileinfo.notexists$) {
                errpath = settings$.getUrl_(Conf.notfoundPath$);
                errpath += native$.asPathQuery_(url);
                break FAIL;
            }
            if (!fileinfo.readable$ || fileinfo.isdir$) {
                break FAIL;
            }
            if (url == null) {
                break FAIL;
            }
            let state = _State.INVALID;
            const params = url.searchParams$;
            const lcsuffix = UriUt.lcSuffix_(url);
            if (params.get(Param.view) != null) {
                if (!MimeUtil.isViewerLcSuffix_(lcsuffix)) break FAIL;
                if (MimeUtil.isTextViewerLcSuffix_(lcsuffix)) {
                    state = _State.TEXT;
                } else {
                    state = this._onIFrameMediaViewerReady(url, MimeUtil.mimeFromLcSuffix_(lcsuffix));
                }
            } else if (lcsuffix == Suffix.HTML$) {
                const iwin = native$.getIFrameWindow_();
                if (iwin == null) {
                    break FAIL;
                }
                native$.fixIFrameOnLoad_();
                state = this._onIFrameDocReady(iwin);
            }
            state$ = state;
            this._mainToolbar.onIFrameLoad(uri);
            if (state$ == _State.INVALID) {
                break FAIL;
            }
            /// and context actions like copy/paste would not work.
            
            const callbacks: IFrameReadyCallback[] = [];
            ArrayUt.addAll_(callbacks, ...this._iframeReadyCallbacks);
            ArrayUt.addAll_(callbacks, ...this._iframeReadyOneshotCallbacks);
            this._iframeReadyOneshotCallbacks.length = 0;

            /// TODO It would be better to serialize the callback execution,
            /// so that there is a way to know or ensure callbacks are all completed.
            /// Unfinished callbacks may hold up resources.
            An.iterateList_(callbacks, (cb, _index, next) => {
                Timer.sleep1_(() => {
                    cb(() => {
                        next(false);
                    });
                });
            }, () => {
            });
            return;
        }
        this._iframeReadyOneshotCallbacks.length = 0;
        _Util.browse_(An.parseUriSafe_(errpath, null), errpath);
    }

    onIFrameError(): void {
        this._iframeReadyOneshotCallbacks.length = 0;
    }

    onIFrameUnload(uri: UriX): void {
        An.ignoreException_(() => {
            
            this._showRightsidebar();
            if (state$ == _State.EDITING) {
                const cpath = uri == null ? null : An.cpathOfUri_(uri);
                if (cpath != null) {
                    this.stopEdit(false, () => {
                        host$.saveRecovery_(cpath, ret => {
                            toasters$.warn_(ret);
                            const d = _Util.promptWarning_(RS.EditAbortedTitle, MSG.string_(RS.editAbortedMessage));
                            d.zindex_(DEF.zindexPrompt);
                            d.onDismiss_(() => { });
                            d.show_();
                        });
                    });
                }
            }
            const cpath = native$.getIFrameContextPath_();
            if (cpath != null) {
                const state = this.saveSession_(null);
                host$.recentsPut_(this._navigation, cpath, state, (ret) => toasters$.warn_(ret));
            }
            this._navigation = RecentsCmd.INVALID;
        });
        while (this._iframeUnloadCallbacks.length > 0) {
            
            const cb = this._iframeUnloadCallbacks.pop()!;
            An.ignoreException_(() => {
                cb();
            });
        }
        if (this._iframeMediaViewer != null) {
            this._iframeMediaViewer.hide_();
        }
        An.ignoreException_(() => {
            this._resetIFrame();
        });
        state$ = _State.INVALID;
        this._mainToolbar.onIFrameUnload();
    }

    private _resetIFrame(): void {
        
        this._iframeUnloadCallbacks.length = 0;
        this._iframeMediaViewer = null;
        this._browsingContextmenu.resetIFrame_();
        this._videographer = null;
        sidePanel$.hideSidepanel_();
        this._hideAnnotations();
        _Util.hideContextmenus_();
    }

    onWindowSizeChanged(): void {
        this._contextmenu.destroy_();
        this._contextmenu = this._createMainContextmenu();
        this._iframeMediaViewer?.resize_();
        if (state$ == _State.EDITING || state$ == _State.BROWSING) {
            this._hideAnnotations();
        }
    }

    /// Setup iframe document for browsing.
    private _onIFrameDocReady(iwin: Window): _State {
        const idoc = iwin.document;
        if (idoc == null) {
            return _State.INVALID;
        }
        const body = idoc.body;
        if (body == null) {
            return _State.INVALID;
        }
        const state = _State.BROWSING;
        this._metainfo = new _Metainfo(native$.iGetMetainfo_());
        _Hacks.fixBody();
        gestureHandler$.push_(GestureEvent.rightOutward, _MainPanel._toggleRightSidebarHandler);
        this._addIFrameUnloadCallback(() => {
            gestureHandler$.pop_(GestureEvent.rightOutward);
            gestureHandler$.pop_(GestureEvent.rightInward);
        });
        if (docInfo$ != null) {
            const uri = docInfo$.uri$;
            if (uri != null) {
                if (uri.searchParams$.has(Param.edit) && docInfo$.fileInfo$.writable$) {
                    this.addIFrameReadyOneshotCallback(next => this.startEditCallback(next));
                }
                const json = uri.searchParams$.get(Param.session);
                const session = An.parseJSONObjectOrNull_(json);
                if (session != null) {
                    
                    this.addIFrameReadyOneshotCallback(next => {
                        this._restoreSession(session);
                        next();
                    });
                }
            }
        }

        const getlink = (target: HTMLElement, baseuri: BaseUriX) => {
            let src = target.getAttribute("src");
            if ((src == null || src != null && (src.startsWith("data:") || src.startsWith("blob:")))
                && target.parentElement?.nodeName == "A") {
                src = target.parentElement.getAttribute("href");
            }
            return (src != null && !src.startsWith("data:") && !src.startsWith("blob:"))
                ? An.parseUriSafe_(src, baseuri)
                : null;
        };
        const getimg = (target: HTMLElement, baseuri: BaseUriX) => {
            const link = getlink(target, baseuri);
            return (link != null && MimeUtil.isImageLcSuffix_(UriUt.lcSuffix_(link)))
                ? link
                : null;
        };

        const popup = (uselongpress: boolean, callback: Fun00) => {
            if (!uselongpress) {
                callback();
                return;
            }
            const timer: Timer = Timer.sleep_(750, () => {
                native$.iRemoveEventListener_(onunload);
                native$.iRemoveEventListener_(onmove);
                native$.iRemoveEventListener_(onend);
                callback();
            });
            const onunload = native$.iAddEventListener_(iwin, "unload", () => {
                timer.cancel_();
                native$.iRemoveEventListener_(onunload);
                native$.iRemoveEventListener_(onmove);
                native$.iRemoveEventListener_(onend);
            }, false, true);
            const onmove = native$.iAddEventListener_(iwin, Conf.pointermove$, () => {
                timer.cancel_();
                native$.iRemoveEventListener_(onunload);
                native$.iRemoveEventListener_(onmove);
                native$.iRemoveEventListener_(onend);
            }, false, true);
            const onend = native$.iAddEventListener_(iwin, Conf.pointerend$, () => {
                timer.cancel_();
                native$.iRemoveEventListener_(onunload);
                native$.iRemoveEventListener_(onmove);
                native$.iRemoveEventListener_(onend);
            }, false, true);
        };

        const popupviewer = (uselongpress: boolean, target: HTMLElement) => {
            const nodename = target.nodeName;
            const baseuri = native$.getIFrameUri_();
            if (baseuri != null) {
                if (nodename == "IMG" || nodename == "PICTURE") {
                    let uri = getimg(target, baseuri);
                    if (uri != null) {
                        const u = uri;
                        const t = target;
                        popup(uselongpress, () => {
                            const nodes = native$.iQueryAll_(`img[${ATTR.xAction}~='${XAction.view}'], picture[${ATTR.xAction}~='${XAction.view}']`);
                            const srcs: Uri[] = [];
                            let index = -1;
                            nodes.forEach((node, i) => {
                                const uri = getimg(node, baseuri);
                                if (uri != null && MimeUtil.isImageLcSuffix_(UriUt.lcSuffix_(uri))) srcs.push(uri);
                                if (node == t) index = i;
                            });
                            new ImageViewerDialog(accessories$, gestureHandler$, DEF.zindexPrompt, u.encoded$, srcs, index)
                                .titleKey_(RS.Image)
                                .show_();
                        });
                        return true;
                    }
                } else if (nodename == "VIDEO") {
                    const classes = Array.from(target.classList);
                    const xvideo = this._getxVideo(target, classes);
                    if (xvideo != null) {
                        this._playxvideo(xvideo, baseuri, (src, seek, callback) => {
                            popup(uselongpress, () => {
                                this._fullscreenvideoplayer(src, seek, callback);
                            });
                        });
                        return true;
                    }
                }
            }
            return false;
        };

        const copylink = (target: HTMLElement, viewing: boolean) => {
            const baseuri = native$.getIFrameUri_();
            if (baseuri == null) return;
            const link = getlink(target, baseuri);
            if (link != null) {
                const uri = link.toAbsolute_().toString();
                clipboard$.string_(uri);
                if (!viewing)
                    toasters$.info_([MSG.string_(RS.CopiedToLocalClipboard_), uri], { attop: true });
            }
            if (viewing) {
                popupviewer(viewing, target);
            }
        };

        //// Note that iframe event listeners are automatically removed by Native.dart on iframe unload.
        //// So don't need to deal with it here.
        native$.iAddEventListener_(iwin, Conf.pointerstart$, e => {
            const target = e.target as HTMLElement;
            const actions = CSSUtil.validateClassesOf(target.getAttribute(ATTR.xAction));
            const viewing = (!this.isEditing() && actions?.includes(XAction.view) == true);
            this._docTarget = target;
            const handle = () => {
                if (Conf.pointerstart$ == "touchstart") {
                    const event = e as TouchEvent;
                    const touches = event.touches.length;
                    if (touches == 1) {
                        const touch = event.touches[0];
                        this._docClickX = Math.round(touch.screenX);
                        this._docClickY = Math.round(touch.screenY);
                        searchSpotlight$.hide_();
                    } else {
                        searchSpotlight$.hide_();
                        if (touches == 2) {
                            copylink(target, false);
                        }
                        return false;
                    }
                } else {
                    const event = e as MouseEvent;
                    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (event.altKey) {
                            copylink(target, false);
                        }
                        return true;
                    }
                }
                this._clientActionHideDone();
                const button = target.getAttribute(ATTR.xButton);
                if (button != null && button.startsWith(ClientAction.hide)) {
                    this._clientActionHide(button, target);
                    return true;
                }
                if (button != null && button.startsWith(ClientAction.show)) {
                    this._clientActionShow(button, target);
                    return true;
                }
                if (("INPUT" == target.nodeName || "BUTTON" == target.nodeName)
                    && !_MainPanel._isSupportedInputType(target.getAttribute("type"))) {
                    return true;
                }
                if (viewing && popupviewer(true, target)) {
                    return Conf.pointerstart$ != "touchstart";
                }
                return false;
            };
            if (handle()) {
                this._docTarget = null;
                JsUtil.stopevent_(e);
            }
        }, true, true);
        native$.iAddEventListener_(iwin, Conf.pointerend$, e => {
            
            const target = e.target as HTMLElement;
            const doctarget = this._docTarget;
            this._docTarget = null;
            if (doctarget == null || doctarget != target) {
                JsUtil.stopevent_(e);
                return;
            }
            const isediting = this.isEditing();
            if (Conf.pointerend$ == "touchend") {
                const event = e as TouchEvent;
                const changed = event.changedTouches;
                if (changed != null) {
                    if (event.touches.length > 1) {
                        JsUtil.stopevent_(e);
                        return;
                    }
                    const touches = changed.length;
                    if (touches > 0) {
                        const touch = changed[0];
                        const x = Math.round(touch.screenX);
                        const y = Math.round(touch.screenY);
                        const dx = x - this._docClickX;
                        const dy = y - this._docClickY;
                        const distance = (dx * dx + dy * dy);
                        if (distance > 64) {
                            return;
                        }
                    }
                }
            } else {
                const event = e as MouseEvent;
                if (event.ctrlKey) {
                    JsUtil.stopevent_(e);
                    return;
                }
            }
            host$.heartbeat_();
            if (isediting) {
                this._mainToolbar.showMainbar_();
            }
            this._idocClickHandler(isediting, this._lastIFrameSelectionRange, target, e);
        }, true, true);
        native$.iAddEventListener_(body, "contextmenu", e => {
            JsUtil.stopevent_(e);
            _MainPanel._openCSS0((e as MouseEvent).shiftKey == true);
        }, true);
        return state;
    }

    static _openCSS0(shift: boolean): void {
        if (state$ != _State.BROWSING && state$ != _State.EDITING) return;
        if (docInfo$ == null || Smokescreen.liveCount() > 0) return;
        const docpath = native$.getIFrameContextPath_();
        if (docpath == null) { return; }
        const basepath = new Basepath(docpath);
        const docdir = basepath.dir$;
        const cpath = basepath.dirAndStem_() + Suffix.CSS$;
        _MainPanel._getLastWritableIFrameStylesheetContextPath(csspath => {
            if (csspath == null) {
                _MainPanel._promptCSS(docdir, cpath);
                return;
            }
            if (shift) {
                _MainPanel._openCSS1(csspath, true);
                return;
            }
            _MainPanel._promptCSS(docdir, csspath);
        });
    }

    /// Get context path for the last stylesheet that comes from a LINK element.
    /// @param cpath Context path with or without leading /.
    /// @return The context path with leading / for the last stylesheet.
    static _getLastWritableIFrameStylesheetContextPath(callback: Fun10<stringX>): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) {
            callback(null);
            return;
        }
        const sheets = Array.from(idoc.styleSheets).reverse();
        const baseuri = native$.getIFrameUri_();
        if (sheets.length == 0 || baseuri == null) {
            callback(null);
            return;
        }
        An.iterateList_(sheets, (sheet, _index, next) => {
            const href = sheet == null ? null : sheet.href;
            const csspath = An.cpathOfHref2_(baseuri, href);
            if (csspath == null) {
                next(false);
                return;
            }
            const owner = sheet.ownerNode;
            if ("LINK" != owner?.nodeName) {
                next(false);
                return;
            }
            fileinfoUt$.fileInfo_(csspath, ret => {
                if (An.hasResult_(ret)) {
                    next(false);
                    return;
                }
                const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (fileinfo != null && fileinfo.writable$) {
                    next(true);
                    callback(csspath);
                } else {
                    next(false);
                }
            });
        }, () => {
            callback(null);
        });
    }

    static _promptCSS(docdir: BasedirX, cpath: string): void {
        const d = _Util.promptFilepathKey_(RS.CSS, FilepickerKind.ANY, "", docdir, cpath);
        d.setDelegate_(FilepickerCssDelegate.singleton$);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((okcallback, cpath, fileinfo) => {
            okcallback(true);
            if (fileinfo.exists$) {
                _MainPanel._openCSS1(cpath, fileinfo.writable$);
                return;
            }
            _MainPanel._newCSS1(cpath);
        });
        d.show_();
    }

    /// @param cpath Context relative path with leading /.
    static _openCSS1(cpath: string, writable: boolean): void {
        host$.readCSS_(cpath, ret => {
            if (toasters$.warn_(ret)) return;
            const position = ret[Key.status] ?? null;
            _MainPanel._openCSS2(writable, cpath, ret[Key.result], position);
        });
    }

    static _openCSS2(editable: boolean, cpath: string, content: string, position: [Int, Int] | null): void {
        if (!_MainPanel._addStylesheetLink(cpath)) {
            toasters$.warnKey_(RS.AddStylesheetUnable);
            editable = false;
        }
        toasters$.info_(Basepath.filename_(cpath), { attop: false });
        const d = new CSSEditor(accessories$, gestureHandler$, cpath, editable, editable, content.trim(), position);
        d.zindex_(DEF.zindexPrompt);
        d.show_();
    }

    /// @param cpath Context relative path with leading /.
    static _newCSS1(cpath: string): void {
        host$.saveCSS_(cpath, "", null, ret => {
            if (toasters$.warn_(ret)) return;
            _MainPanel._openCSS2(true, cpath, "", [1, 1]);
        });
    }

    /// @param cpath Context relative path with leading /.
    /// @return true if cpath already referenced by iframe or is added.
    static _addStylesheetLink(cpath: string): boolean {
        if (native$.findIFrameStylesheet_(cpath) != null) return true;
        const baseuri = native$.getIFrameUri_();
        if (!mainPanel$.isEditing() || baseuri == null) return false;
        let path = cpath;
        const dir = An.cdirOfUri_(baseuri);
        if (PathUtil.isDocumentsSubtree(cpath) && dir != null) {
            const rpath = An.rpath2_(dir, cpath);
            if (rpath != null) { path = rpath; }
        }
        const uri = An.uriOfFilepath2_(baseuri, path);
        if (uri == null) {
            toasters$.warn_(MSG.string_(RS.InvalidURL));
            return false;
        }
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return false;
        const head = idoc.head;
        const attrs = smap_(
            ["rel", "stylesheet"],
            ["href", uri.encoded$],
            ["type", Mime.CSS$],
        );
        new DomBuilderEx(head).append_("LINK", attrs);
        return true;
    }

    static _isValidInputElement(target: NodeX): boolean {
        const elm = DomUt.asHTMLElement_(target);
        if (elm != null) {
            const name = elm.nodeName;
            if ("TEXTAREA" == name || "SELECT" == name || "OPTION" == name) return true;
            if (("INPUT" == name || "BUTTON" == name) && _MainPanel._isSupportedInputType(elm.getAttribute("type"))) return true;
        }
        return false;
    }

    static _VALID_INPUT_TYPE = new Set([
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "image",
        "reset",
        "button",
    ]);

    static _isSupportedInputType(type: stringX): boolean {
        if (type == null || type.length == 0) return true;
        type = type.trim().toLowerCase();
        return _MainPanel._VALID_INPUT_TYPE.has(type);
    }

    static _toggleRightSidebarHandler(): boolean {
        Timer.sleep1_(() => {
            if (docInfo$ == null || Smokescreen.liveCount() > 0) {
                return;
            }
            const rightsidebar = native$.iGetElementById_(ID.xRightSidebar);
            if (rightsidebar != null) {
                rightsidebar.classList.toggle(CSS.xHidetemp);
            }
        });
        return true;
    }

    private _cancelShowRightsidebar(): void {
        if (this._hideRightSidebarTimer != null) {
            this._hideRightSidebarTimer.cancel_();
            this._hideRightSidebarTimer = null;
        }
    }

    private _showRightsidebar(): void {
        this._cancelShowRightsidebar();
        native$.iGetElementById_(ID.xRightSidebar)?.classList.remove(CSS.xHidetemp);
    }

    private _idocClickHandler(
        isediting: boolean,
        iframeselectionrange: Range | null,
        target: HTMLElementX,
        e: Event,
    ): void {
        if (target == null) {
            return;
        }
        const nodetype = target.nodeType;
        const nodename = target.nodeName;
        if (nodetype != Node.ELEMENT_NODE) {
            return;
        }
        const classes = Array.from(target.classList);
        
        if (isediting && classes.includes(CSS.xPlaceholder)) {
            const baseuri = native$.getIFrameUri_();
            if (baseuri != null) {
                _MainPanel._onPlaceholder1(target, nodename, baseuri, e);
            }
            return;
        }
        if (isediting && this._idocClickEditing(target, iframeselectionrange, nodename, classes)) {
            JsUtil.stopevent_(e);
            return;
        }
        if (this._idocClickBoth(target, isediting, nodetype, nodename, classes)) {
            JsUtil.stopevent_(e);
            return;
        }
        if (this._idocClickBubbleBoth(target, isediting, nodename)) {
            JsUtil.stopevent_(e);
            return;
        }
        if (!isediting && this._idocClickBrowsing(target, iframeselectionrange, classes)) {
            JsUtil.stopevent_(e);
            return;
        }
        if (classes.includes(CSS.xBubble)) {
            this._idocClickHandler(isediting, iframeselectionrange, target.parentElement, e);
        }
    }

    private _idocClickBoth(
        target: HTMLElement,
        isediting: boolean,
        _nodetype: number,
        nodename: string,
        classes: string[],
    ): boolean {
        //// These fire on both browsing and editing mode.
        if (classes.includes(CSS.xSmokescreen)) {
            host$.hideKeyboard_(() => {
                let hiding = false;
                if (history$ != null) {
                    const parent = target.parentElement;
                    if (parent != null && parent.classList.contains(CSS.xAnnotation)) {
                        history$.startGroup_(RS.action_AnnotationHide, "");
                        hiding = true;
                    }
                }
                for (const n of native$.iQueryAll_<HTMLElement>(`div.${CSS.xSmokescreen}`, target)) {
                    native$.setDisplay_(n, null);
                }
                native$.setDisplay_(target, null);
                if (hiding) {
                    history$.endGroup_();
                }
            });
            return true;
        }
        if (classes.includes(CSS.xRightSidebarPadding)) {
            this._cancelShowRightsidebar();
            native$.iGetElementById_(ID.xRightSidebar)?.classList.add(CSS.xHidetemp);
            this._hideRightSidebarTimer = new Timer(DEFUtil.hideRightSidebarDuration$, () => {
                this._showRightsidebar();
            });
            return true;
        }
        const clientaction = _TemplateAction.parse_(target.getAttribute(ATTR.xButton));
        if (clientaction != null) {
            const range = native$.iSelectNode_(target);
            clientaction.run_(target, range, null);
            return true;
        }
        if (classes.includes(CSS.xAnnotation) && (isediting || !classes.includes(CSS.xPeek))) {
            if (_MainPanel._showAnnotation(target, isediting, nodename) != null) {
                return true;
            }
        }
        if (classes.includes(CSS.xAnnotationTarget)) {
            const parent = target.parentElement;
            if (parent != null && "DIV" == parent.nodeName) {
                const parentclasses = parent.classList;
                if (parentclasses.contains(CSS.xAnnotation) && (isediting || !parentclasses.contains(CSS.xPeek))) {
                    _MainPanel._showAnnotation0(parent);
                    return true;
                }
            }
            return false;
        }
        if (classes.includes(CSS.xSlideshow)) {
            if (AVALUE.xStop != target.getAttribute(ATTR.xInfo)) {
                this._showSlides(target);
            }
            return true;
        }
        if (classes.includes(CSS.xSlideshowImage)) {
            const node = target.parentElement;
            if (node != null) {
                const style = target.style;
                const opacity = style.opacity;
                if (An.parseDouble_(opacity, 1.0) > 0.75) {
                    node.setAttribute(ATTR.xInfo, AVALUE.xStop);
                } else if (AVALUE.xStop != node.getAttribute(ATTR.xInfo)) {
                    this._showSlides(node);
                }
            }
            return true;
        }
        const id = target.getAttribute("id");
        if (ID.xOpenRightSidepanel == id) {
            native$.setDisplayById_(ID.xRightSidepanel, "block");
            return true;
        }
        if (ID.xOpenLeftSidepanel == id) {
            native$.setDisplayById_(ID.xLeftSidepanel, "block");
            return true;
        }
        return false;
    }

    private _idocClickBrowsing(
        target: HTMLElement,
        iframeselectionrange: Range | null,
        classes: string[],
    ): boolean {
        if (classes.includes(CSS.xAlarm)) {
            sidePanel$.showEventsPanel_(() => {
            });
            return true;
        }
        if (classes.includes(CSS.xRightSidebarTab)) {
            const value = target.getAttribute(ATTR.xTemplate);
            if (value != null && value.length > 0 && value.startsWith("{")) {
                try {
                    const json = An.parseJSONObjectOrNull_(value);
                    if (json != null && (typeof (json) === "object")) {
                        this._rsbTabAction(target, () => {
                            this._browsingTemplateAction(target, json, iframeselectionrange, An.noop_);
                        });
                        return true;
                    }
                } catch (e) {
                    
                }
            }
        }
        if (this._showpdf(JsUtil.ancestorOrSelfWith_(target, (e) => e.nodeName == "A")))
            return true;
        const xaudio = this._getxAudio(target, classes);
        const baseuri = native$.getIFrameUri_();
        if (xaudio != null && baseuri != null) {
            const href = xaudio.getAttribute("src");
            if (href != null) {
                const param = An.getMediaParams_(xaudio);
                if (this._playxaudio(href, baseuri, param[XInfoKey.seek], (seek) => {
                    if (seek != null) {
                        An.setMediaParams_(xaudio, seek);
                    }
                })) return true;
            }
        }
        const xvideo = this._getxVideo(target, classes);
        if (xvideo != null && baseuri != null) {
            if (this._playxvideo(xvideo, baseuri, (src, seek, callback) => {
                this._fullscreenvideoplayer(src, seek, callback);
            })) {
                return true;
            }
        }
        const value = target.getAttribute(ATTR.xPageTemplate);
        if (value != null) {
            _MainPanel._pageTemplate(value);
            return true;
        }
        return false;
    }

    private _showpdf(target: Element | null): boolean {
        const href = target?.getAttribute("href");
        if (href != null) {
            const uri = An.parseUriSafe_(href, native$.getIFrameUri_());
            if (uri != null && uri.path$.toLowerCase().endsWith(Suffix.PDF$)) {
                uri.searchParams$.delete(Param.view);
                
                if (host$.showPdf_(uri)) {
                    return true;
                }
            }
        }
        return false;
    }

    private _playxaudio(href: stringX, baseuri: BaseUriX, seek: DoubleX, onclose: Fun10<DoubleX>): boolean {
        const cpath = An.cpathOfHref2_(baseuri, href);
        if (cpath != null && MimeUtil.isAudioLcSuffix_(Basepath.lcSuffix_(cpath))) {
            _AudioPlayerDialog.createAndShow_(accessories$, cpath, seek, true, player => {
                player?.onClose_(onclose);
            });
            return true;
        }
        return false;
    }

    private _playxvideo(xvideo: HTMLVideoElement, baseuri: Uri, callback: Fun30<string, DoubleX, Fun10<Double>>): boolean {
        const href = xvideo.getAttribute("src");
        const u = An.parseUriSafe_(href, baseuri);
        if (href != null && u != null && MimeUtil.isVideoLcSuffix_(u.lcSuffix$)) {
            const params = An.getMediaParams_(xvideo);
            callback(u.encoded$, params.seek, (seek) => {
                if (seek != null) {
                    An.setMediaParams_(xvideo, seek);
                }
            });
            return true;
        }
        return false;
    }

    private _fullscreenvideoplayer(src: string, seek: DoubleX, callback: Fun10<Double>) {
        const d = new FullscreenVideoPlayer(accessories$, src, seek ?? 0.0)
            .on_("click", () => {
                callback(d.currentTime_());
                d.destroy_();
            });
        d.show_();
    }

    private _idocClickEditing(
        target: HTMLElement,
        iframeselectionrange: Range | null,
        nodename: string,
        classes: string[],
    ): boolean {
        //// These fire only in editing mode.
        if (classes.includes(CSS.xCanvas)) {
            host$.hideKeyboard_(() => {
                native$.iClearSelection_();
                this._actionAnnotateCanvas(target, () => { });
            });
            return true;
        }
        if (classes.includes(CSS.xImageholder)) {
            _MainPanel._onImageHolder(target);
            return true;
        }
        const input = target.getAttribute(ATTR.xTemplate);
        if (input != null) {
            history$.startGroup_(RS.history_templateButtonAction, "");
            this._rsbTabAction(target, () => {
                this._templateAction(target, input, iframeselectionrange, (range) => {
                    _MainPanel.recalculateTotals_();
                    history$.endGroup_();
                    if (range == null) native$.iRemoveSelections_(); else native$.iSelectRange_(range);
                });
            });
            return true;
        }
        if (classes.includes(CSS.xCalcTotal) || classes.includes(CSS.xCalcSubtotal)) {
            _MainPanel.recalculateTotals_();
            return true;
        }
        if (classes.includes(CSS.xBullet) || classes.includes(CSS.xSymbol)) {
            host$.hideKeyboard_(() => {
                _MainPanel._actionEditSymbol(target);
            });
            return true;
        }
        if (classes.includes(CSS.xBulletText)) {
            const textnode = target.firstChild;
            if (textnode != null) {
                _MainPanel._actionEditText1(textnode, true);
            }
            return true;
        }
        if (classes.includes(CSS.xDate)) {
            host$.hideKeyboard_(() => {
                const range = native$.iSelectNode_(target);
                if (range != null) {
                    _MainPanel._actionInsertDate1(range, target);
                }
            });
            return true;
        }
        if (classes.includes(CSS.xTodoStatus)) {
            let parent: HTMLElementX = target;
            for (; (parent = parent.parentElement) != null;) {
                const parentclasses = parent.classList;
                if (parentclasses.contains(CSS.xTodoItem)) {
                    history$.group_(RS.history_templateButtonAction, CSS.xTodoDone, () => {
                        parentclasses.toggle(CSS.xTodoDone);
                        _MainPanel.recalculateTotals_();
                    });
                    break;
                }
            }
            return true;
        }
        if (classes.includes(CSS.xxStatus)) {
            let parent: HTMLElementX = target;
            for (; (parent = parent.parentElement) != null;) {
                const parentclasses = parent.classList;
                if (parentclasses.contains(CSS.xxTodo)) {
                    history$.group_(RS.history_templateButtonAction, CSS.xxDone, () => {
                        parentclasses.toggle(CSS.xxDone);
                        _MainPanel.recalculateTotals_();
                    });
                    break;
                }
            }
            return true;
        }
        const baseuri = native$.getIFrameUri_();
        if (nodename == "A") {
            if (baseuri != null) {
                _MainPanel._actionEditLink(target, false, baseuri, () => { });
            }
            return true;
        }
        if (target instanceof HTMLAudioElement && baseuri != null) {
            _MainPanel._editAudioLink(target, baseuri, (infoelm) => {
                if (infoelm != null) _MainPanel._updateAudioInfo(infoelm, An.noop_);
            });
            return true;
        }
        if ((target instanceof HTMLVideoElement) && baseuri != null) {
            _MainPanel._editVideoLink(target, baseuri, (infoelm) => {
                if (infoelm != null) _MainPanel._updateVideoInfo(infoelm, An.noop_);
            })?.show_();
            return true;
        }
        const xaudio = this._getxAudio(target, classes);
        if (xaudio != null && baseuri != null) {
            _MainPanel._editAudioholder(xaudio, baseuri, (srcuri, attrs, hrefuri) => {
                for (const [key, value] of Object.entries(attrs)) {
                    xaudio.setAttribute(key, value);
                }
                xaudio.setAttribute("src", (srcuri?.toString() ?? ""));
                xaudio.setAttribute(ATTR.xHref, (hrefuri?.toString() ?? ""));
                const infoelm = JsUtil.ancestorOrSelfWithAttr_(xaudio, ATTR.xPlaceholder, Placeholder.xpAudioinfo);
                if (infoelm != null) {
                    const audio = infoelm.querySelector(`audio.${CSS.xAudio}`);
                    if (audio != null) {
                        audio.setAttribute("src", hrefuri == null
                            ? ""
                            : An.addRemoveQueryParams_(hrefuri, null, [Param.view], baseuri)?.toString() ?? "");
                    }
                    _MainPanel._updateAudioInfo(infoelm, An.noop_);
                }
            });
            return true;
        }
        const xvideo = this._getxVideo(target, classes);
        if (xvideo != null && baseuri != null) {
            _MainPanel._editVideoholder(xvideo, baseuri, (uri) => {
                const cpath = An.cpathOfUri_(uri);
                const param = An.getMediaParams_(xvideo);
                xvideo.setAttribute(ATTR.xHref, uri.encoded$);
                host$.videoPoster_(
                    cpath,
                    (param.poster ?? 0),
                    DEF.previewPhotoSize,
                    DEF.previewPhotoSize,
                    DEF.jpegQualityThumbnail,
                    (ret) => {
                        if (!toasters$.warn_(ret)) {
                            xvideo.setAttribute("src", ret[Key.result]);
                        }
                        const infoelm = JsUtil.ancestorOrSelfWithAttr_(xvideo, ATTR.xPlaceholder, Placeholder.xpVideoinfo);
                        if (infoelm != null) _MainPanel._updateVideoInfo(infoelm, An.noop_);
                    });
            });
            return true;
        }
        //// Avoid selecting calendar cell if other action in progress, in particular when showing annotation.
        const parent = target.parentElement;
        if (parent != null) {
            const parentclasslist = parent.classList;
            if (parentclasslist.contains(CSS.xCalBody) || parentclasslist.contains(CSS.xCalHead)) {
                if (classes.includes(CSS.xGray)) {
                    Timer.sleep00_(() => {
                        native$.iClearSelection_();
                    });
                    return true;
                } else {
                    const text = JsUtil.getFirstTextnode_(target);
                    if (text != null) {
                        native$.focusIFrame_();
                        Timer.sleep00_(() => {
                            native$.iSelectNode_(text);
                        });
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private _getxAudio(target: HTMLElement, classes: string[]): HTMLAudioElement | null {
        if (target.nodeName == "AUDIO" && ArrayUt.any_(classes, c => c == CSS.xAudio))
            return target as HTMLAudioElement;
        const xaudio = CSS.xAudio + "-";
        if (ArrayUt.any_(classes, c => c.startsWith(xaudio))) {
            const ret = JsUtil.ancestorWith_(target, (e) => e.getAttribute(ATTR.xPlaceholder) == Placeholder.xpAudioinfo);
            if (ret != null)
                return DomUt.query_<HTMLAudioElement>(ret, `audio.${CSS.xAudio}`);
        }
        return null;
    }

    private _getxVideo(target: HTMLElement, classes: string[]): HTMLVideoElement | null {
        const xvideo = CSS.xVideo + "-";
        if (ArrayUt.any_(classes, c => c.startsWith(xvideo))) {
            const ret = JsUtil.ancestorWith_(target, (e) => e.getAttribute(ATTR.xPlaceholder) == Placeholder.xpVideoinfo);
            if (ret != null)
                return DomUt.query_(ret, `video.${CSS.xVideo}`);
        }
        return null;
    }

    private _rsbTabAction(target: HTMLElement, callback: Fun00): void {
        const classlist = target.classList;
        //// NOTE Browser would not perform cursor:pointer flash in edit mode,
        //// so we have to do it here.
        classlist.add(CSS.xFlashRightsidebar);
        FrameLimiter.requestAnimationFrame(10, () => {
            classlist.remove(CSS.xFlashRightsidebar);
            callback();
        });
    }

    private _idocClickBubbleBoth(parent: HTMLElement, isediting: boolean, tag: string): boolean {
        let elm: HTMLElementX = parent;
        while (_MainPanel._isBubbleTag(tag)) {
            elm = elm.parentElement;
            if (elm == null) {
                break;
            }
            tag = elm.nodeName;
            const parentclasses = elm.classList;
            if (parentclasses.contains(CSS.xAnnotation) && (isediting || !parentclasses.contains(CSS.xPeek))) {
                if (_MainPanel._showAnnotation(elm, isediting, tag) != null) {
                    return true;
                }
                break;
            }
        }
        return false;
    }

    private _onCalcCell(target: HTMLElement, pagex: number, pagey: number): void {
        const text = target.getAttribute(ATTR.AnInfo) ?? target.textContent ?? "";
        if (target.children.length == 0
        ) {
            const scrolloffsets = native$.getIFrameScroll_();
            const x = ((pagex == null || scrolloffsets == null) ? null : Math.round(pagex - scrolloffsets.x));
            const y = ((pagey == null || scrolloffsets == null) ? null : Math.round(pagey - scrolloffsets.y));
            const textnode = JsUtil.getFirstTextnode_(target);
            native$.iSelectNode_((textnode != null) ? textnode : target);
            const d = new PromptCalc(accessories$, cache$.ui$.buttonSize_());
            d.zindex_(DEF.zindexPrompt);
            d.at_(x, y);
            d.value_(text);
            d.onOK_((value: string, expr: string) => {
                if (history$ != null && value.length > 0) {
                    history$.group_(RS.history_calcTotal, value, () => {
                        JsUtil.isInput_(target) ? (target as any).value = value : target.textContent = value;
                        target.setAttribute(ATTR.AnInfo, expr);
                        _MainPanel.recalculateTotals_();
                    });
                }
            });
            d.show_();
        }
    }

    private _clientActionHide(action: string, elm: HTMLElement): void {
        this._clientActionHideShow(action, elm, CSS.xClientHide);
    }

    private _clientActionShow(action: string, elm: HTMLElement): void {
        this._clientActionHideShow(action, elm, CSS.xClientShow);
    }

    private _clientActionHideShow(action: string, elm: HTMLElement, css: string): void {
        this._clientActionHideDone();
        let marker = CSS.xHideable;
        const parts = action.split(FS);
        if (parts.length > 1) {
            const part1 = parts[1];
            if (CSSUtil.validateClass(part1)) {
                marker = part1;
            }
        }
        const parent = JsUtil.ancestorOrSelfWithClasses_(elm, [marker]);
        if (parent != null) {
            const sm = new Smokescreen(accessories$, DEF.zindexResizer, DEF.opacityTransparent);
            sm.on_(Conf.pointerstart$, e => {
                An.stopevent_(e);
                this._clientActionHideDone();
                sm.destroy_();
            });
            sm.show_(() => {
                this._clientHidden = parent;
                parent.classList.add(css);
            });
        }
    }

    private _clientActionHideDone(): void {
        if (this._clientHidden != null) {
            native$.removeAddClasses_(this._clientHidden, [CSS.xClientHide, CSS.xClientShow], null);
            this._clientHidden = null;
        }
    }

    /// Create a new page from the given template.
    /// @enter This is only called in browsing mode.
    static _pageTemplate(value: string): void {
        Timer.sleep1_(() => {
            if (!value.startsWith(FS)) {
                const info = settings$.htmlTemplatesWithAliases_().get(value);
                if (info !== undefined && info.cat$ == TemplateCat.Blog) {
                    const cpath = _Util.getBlogDayHtmlPath_(DateTime.now_());
                    fileinfoUt$.fileInfo_(cpath, ret => {
                        if (toasters$.warn_(ret)) { return; }
                        _Util.onSaveOrDiscard_(() => {
                            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
                            if (fileinfo != null && fileinfo.exists$) {
                                mainPanel$.addIFrameReadyOneshotCallback(next => mainPanel$.startEditCallback(next));
                                _Util.browseFile_(cpath);
                                return;
                            }
                            sidePanel$.hideSidepanel_();
                            _Util.newPageFromTemplate3_(cpath, value);
                        });
                    });
                } else {
                    sidePanel$.hideSidepanel_();
                    _Util.newPageFromTemplateName_(value);
                }
                return;
            }
            const cpath = Basepath.cleanFilepath_(value);
            if (!cpath.endsWith(".html")) {
                toasters$.warn_([MSG.string_(RS.ExpectingHtml), value]);
                return;
            }
            fileinfoUt$.fileInfo_(cpath, ret => {
                if (An.hasResult_(ret)) {
                    toasters$.warn_([MSG.string_(RS.InvalidPath_), value]);
                    return;
                }
                const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (fileinfo == null || fileinfo.isdir$) {
                    toasters$.warn_([MSG.string_(RS.DestinationExpectingAFile), value]);
                    return;
                }
                _Util.onSaveOrDiscard_(() => {
                    if (fileinfo.exists$) {
                        _Util.openExisting_(cpath);
                        return;
                    }
                    const d = new PageContextmenu(accessories$);
                    d.onAction_(action => {
                        d.destroy_();
                        sidePanel$.hideSidepanel_();
                        _Util.newPageFromTemplate3_(cpath, action);
                    });
                    d.onCancel_(() => {
                        d.destroy_();
                    });
                    d.show_(window.innerWidth / 2, cache$.ui$.toolbarHeight_());
                });
            });
        });
    }

    static _onImageHolder(target: HTMLElement): void {
        Timer.sleep1_(() => {
            let titlekey: string;
            let osrc: HumanLink;
            let nodename = target.nodeName;
            const baseuri = native$.getIFrameUri_();
            if (baseuri == null) { return; }
            if (nodename == "IMG") {
                osrc = HumanLink.fromHref_(JsUtil.optAttribute_(target, "src", ""));
                titlekey = RS.EditImgTitle;
                _MainPanel._onImageHolderImg(target, nodename, osrc, titlekey, baseuri);
            } else {
                const cstyles = native$.getComputedStylesOf_(target, null, [PK.BackgroundImage, PK.BackdropFilter]);
                const bgimg = cstyles.get(PK.BackgroundImage) ?? "";
                const backdropfilter = cstyles.get(PK.BackdropFilter) ?? "";
                const bgurl = CSSUtil.humanCSSUrls_(bgimg, baseuri);
                new PromptBgImg(
                    accessories$,
                    cache$.ui$.buttonSize_(),
                    baseuri,
                    [bgurl, backdropfilter],
                    null,
                    settings$.getBgImgSamples(),
                    DEF.zindexPrompt)
                    .onOK_((cssstyle) => {
                        const bgimg = cssstyle.backgroundImage;
                        const backdropfilter = cssstyle.getPropertyValue(PK.BackdropFilter);
                        history$.group_(RS.history_imageholder, native$.filenameFromCSSURL_(bgimg, baseuri), () => {
                            _JsUtil.setStyleUrlValue_(target, PK.BackgroundImage, bgimg, An.noop_);
                            native$.replaceStyle_(target, PK.BackdropFilter, backdropfilter);
                        });
                    })
                    .show_();
            }
        });
    }

    /**
       * @param osrc @notnull
       */
    static _onImageHolderImg(target: HTMLElement, nodename: string, osrc: HumanLink, titlekey: StringId, baseuri: BaseUri): void {
        let ohref = HumanLink.Empty$;
        let parent = target.parentElement;
        if (parent != null && "A" == parent.nodeName) {
            ohref = HumanLink.fromHref_(JsUtil.optAttribute_(parent, "href", ""));
        } else {
            parent = null;
        }
        const sorted = JsUtil.sortedAttributes_(target);
        const oattrs = An.attributesToStringForEdit_(sorted, " ", ["xmlns", "src"]);
        _Util.promptImageUrl2_(
            titlekey,
            DEF.zindexPrompt,
            osrc,
            oattrs,
            ohref,
            baseuri,
            Callbacks.onAnyImageFolderButton_,
            (srcuri, sanitized, createlink, linkuri) => {
                const s = An.attributesToStringForEdit_(JsUtil.sortedAttributes1_(sanitized), " ", ["xmlns", "src"]);
                _MainPanel._onImageHolderImgResult(target, nodename, srcuri, (s == oattrs ? null : sanitized), createlink, parent, linkuri);
            }
        ).show_();
    }

    static _onImageHolderImgResult(
        target: HTMLElement,
        nodename: string,
        src: UriX,
        attrs: StringMap<string> | null,
        createlink: boolean,
        parent: HTMLElementX,
        href: UriX
    ): void {
        _MainPanel._onImageHolderImgSetSrc(target, nodename, src, attrs);
        if (createlink) {
            if (parent == null) {
                parent = JsUtil.wrapNode_(target, "A");
            }
            JsUtil.setAttribute_(parent, "href", href == null ? "" : href.toString());
        } else {
            if (parent != null && !An.isBodyElement_(parent.nodeName)) {
                const grandparent = parent.parentElement;
                if (grandparent != null) {
                    new DomBuilderEx(grandparent).unwrap_(parent);
                }
            }
        }
    }

    static _onImageHolderImgSetSrc(target: HTMLElement, nodename: string, src: UriX, attrs: StringMap<string> | null): void {
        const filename = An.filenameFromUri_(src);
        if (src == null) {
            history$.group_(RS.history_imageholder, filename, () => {
                target.removeAttribute("src");
            });
            return;
        }
        const url = src.toString();
        if (nodename == "IMG") {
            history$.group_(RS.history_imageholder, filename, () => {
                if (attrs == null) {
                    target.setAttribute("src", url);
                } else {
                    attrs["src"] = url;
                    const keys = Object.keys(attrs);
                    for (const attr of Array.from(target.attributes)) {
                        if (!keys.includes(attr.name)) target.removeAttributeNode(attr);
                    }
                    for (const [k, v] of Object.entries(attrs)) {
                        target.setAttribute(k, v ?? "");
                    }
                }
            });
        } else {
            history$.group_(RS.history_imageholder, filename, () => {
                _JsUtil.setStyleUrlValue_(target, PK.BackgroundImage, CSSUtil.toCSSUrl_(url));
            });
        }
    }

    static _showEventsPanel(_target: HTMLElement): void {
        const tabid = ID.sidebarExplore;
        const tooltipsid = RS.Tooltips_EventsPanel;
        sidePanel$.showSidepanel_(tabid, false, () => {
            Timer.sleep1_(() => {
                const tabsel = `span[${ATTR.xTooltips}='${tooltipsid}']`;
                const tab = document.querySelector(`#${ID.sidepanel} div.${CSS.AnTabbar} ${tabsel}`) as HTMLElement;
                if (tab != null) {
                    tab.click();
                }
            });
        });
    }

    private static _showIncoming(dirpath: string): stringX {
        
        An.asyncWait((done) => {
            
            sidePanel$.showFilesPanel_((filespanel) => {
                filespanel?.gotoDir_(dirpath, () => {
                    done(filespanel?.currentDir$ == dirpath);
                });
            });
        }, 5000, 250, false, () => {
        });
        return null;
    }

    private static _onPlaceholder1(target: HTMLElement, nodename: string, baseuri: BaseUri, e: Event): void {
        history$.group_(RS.history_placeholder, nodename, () => {
            target.classList.remove(CSS.xPlaceholder);
            switch (nodename) {
                case "A":
                    JsUtil.stopevent_(e);
                    _MainPanel._actionEditLink(target, true, baseuri, null);
                    break;
                case "IMG":
                    JsUtil.stopevent_(e);
                    _MainPanel._actionEditImg(target, baseuri);
                    break;
                default:
                    
                    JsUtil.stopevent_(e);
                    Timer.sleep1_(() => {
                        native$.iSelectContents_(target);
                    });
            }
        });
    }

    private static _bubbletags: Set<string> = new Set(["BR", "B", "EM", "I", "IMG", "S", "SPAN", "SUB", "SUP", "U"]);

    private static _isBubbleTag(tag: string): boolean {
        return _MainPanel._bubbletags.has(tag);
    }

    /// @return The annotation if found, otherwise null.
    private static _showAnnotation(target: HTMLElement, isediting: boolean, nodename: string): HTMLElementX {
        if (target == null) {
            return null;
        }
        if (nodename == "DIV") {
            _MainPanel._showAnnotation0(target);
            return target;
        }
        if (nodename == "SPAN") {
            const parent = target.parentElement;
            if (parent != null && "DIV" == parent.nodeName) {
                const parentclasses = parent.classList;
                if (parentclasses.contains(CSS.xAnnotation) && (isediting || !parentclasses.contains(CSS.xPeek))) {
                    _MainPanel._showAnnotation0(parent);
                    return parent;
                }
            }
        }
        return null;
    }

    private _showSlides(xslideshow: HTMLElement): void {
        const ms = An.parseTime_(xslideshow.style.animationDuration, 3000);
        const images = new Array<HTMLElement>();
        for (const c of Array.from(xslideshow.children)) {
            if ("IMG" == c.nodeName) {
                images.push(c as HTMLElement);
            }
        }
        if (images.length > 0) {
            images[0].style.opacity = "1.0";
            const index: number[] = [0];
            let timer = new PeriodicTimer(ms, timer => {
                _MainPanel._showslides(timer, xslideshow, images, index);
            });
            this._addIFrameUnloadCallback(() => {
                timer.cancel_();
            });
        }
    }

    private static _showslides(timer: ITimer, target: HTMLElement, images: HTMLElement[], state: number[]): void {
        let index = state[0];
        ++index;
        state[0] = index;
        const stopping = (AVALUE.xStop == target.getAttribute(ATTR.xInfo));
        if (index < images.length && !stopping) {
            images[index].style.display = "inline";
            images[index - 1].style.display = "none";
        } else {
            timer.cancel_();
            if (stopping) {
                images[index - 1].style.opacity = "1.0";
            }
            target.removeAttribute(ATTR.xInfo);
            const style = images[0].style;
            style.opacity = "0.5";
            style.display = "inline";
            if (index > 1) {
                images[index - 1].style.display = "none";
            }
        }
    }

    private _browsingTemplateAction(_target: HTMLElement, json: SStringMap, _iframerange: RangeX, callback: Fun00): void {
        const cmd = json[TemplateMenuKey.cmd];
        if (An.isempty_(cmd)) {
            callback();
            return;
        }
        if (cmd == TemplateAction.save) {
            const prefix = json[TemplateMenuKey.path];
            this._templateActionSave(prefix, callback);
            return;
        }
        callback();
    }

    private _templateActionSave(prefix: string, callback: Fun00): void {
        function home(rpath: string): string {
            return PathUtil.getHomeDir() + rpath;
        }
        const filename = An.simpleDateTimeString_() + ".html";
        if (prefix == null) prefix = "";
        let filepath = prefix + filename;
        if (!filepath.startsWith(FS)) {
            filepath = home(filepath);
        }
        const dir = Basepath.dir_(filepath);
        if (dir == null) {
            toasters$.warnKey_(RS.InvalidPath);
            callback();
            return;
        }
        fileinfoUt$.mkDirs_(dir, ret => {
            if (toasters$.warn_(ret)) {
                filepath = home(filename);
            }
            const currentdir = _Util.getCurrentDir_();
            const d = _Util.promptFilepathKey_(RS.SaveAs, FilepickerKind.WRITE_FILE, "", currentdir, filepath);
            d.setDelegate_(FilepickerHtmlDelegate.singleton$);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((okcallback, path) => {
                okcallback(true);
                native$.fixIFrameOnSave_();
                const content = native$.serializeIFrameDocument_();
                host$.saveHtml_(path, content, ret => {
                    if (!toasters$.warn_(ret)) {
                        toasters$.ok_([RS.DocumentBrowsingSaved, path]);
                    }
                    callback();
                    Timer.sleep0_(() => {
                        _Util.browseFile_(path);
                    });
                });
            });
            d.onCancel_(callback);
            d.show_();
        });
    }

    /**
       * @param callback(JsObject range) where range is the current selected range and that the caller should leave it alone.
       * If range is null, caller may restore selection before the template action.
       * Note that callback is used to end undo groups. So it must be called, even on error.
       */
    private _templateAction(button: HTMLElement, input: string, iframerange: RangeX, callback: Fun10X<RangeX> = null): void {
        if (button.classList.contains(CSS.AnDisabled)) {
            callback?.(iframerange);
            return;
        }
        if (input.startsWith("{")) {
            this._templateMenu(button, iframerange, input, callback);
            return;
        }
        const taction = _TemplateAction.parse_(input);
        this._templateAction1(button, taction, iframerange, callback);
    }

    private _templateAction1(button: HTMLElement, taction: _IClientAction | null, iframerange: RangeX, callback: Fun10X<RangeX> = null): void {
        if (taction == null) {
            toasters$.error_(MSG.string_(RS.InvalidTemplate));
            callback?.(null);
            return;
        }
        taction.run_(button, iframerange, callback);
    }

    static getmarker_(node: HTMLElementX, markers: string[]): stringX {
        if (node != null) {
            const set = node.classList;
            for (const marker of markers) {
                if (set.contains(marker)) {
                    return marker;
                }
            }
        }
        return null;
    }

    static findMarker_(marker: string): HTMLElementX {
        const body = native$.getIFrameBody_();
        if (body == null) return null;
        if (body.classList.contains(marker)) {
            return body;
        }
        let rsb = native$.iGetElementById_(ID.xRightSidebar);
        if (rsb == null) {
            rsb = body.firstElementChild as HTMLElement;
        }
        const a = new Array<HTMLElement>();
        for (let s = rsb?.previousElementSibling; s != null; s = s.previousElementSibling) {
            a.unshift(s as HTMLElement);
        }
        for (let s = rsb?.nextElementSibling; s != null; s = s.nextElementSibling) {
            a.push(s as HTMLElement);
        }
        let node: HTMLElementX = null;
        for (const elm of a) {
            if (elm.classList.contains(marker)) {
                node = elm;
                break;
            }
            for (const e of native$.iQueryAll_(`.${marker}`, elm)) {
                if (e.parentNode != null && native$.isVisible_(e.parentNode)) {
                    node = e;
                    break;
                }
            }
        }
        return node;
    }

    /// @return The marker node.
    /// Note that callback is used to end undo groups. So it must be called, even on error.
    private _templateMenu(button: HTMLElement, iframerange: RangeX, json: string, callback: Fun10X<RangeX> = null): void {
        let cf: JSONObject;
        try {
            cf = JSON.parse(json);
        } catch (e) {
            
            toasters$.error_(MSG.string_(RS.InvalidTemplate));
            callback?.(null);
            return;
        }
        this._templateMenu1(cf, (info, action) => {
            if (info == null) {
                callback?.(null);
                return;
            }
            if (action.startsWith("{")) {
                this._templateMenu(button, iframerange, action, callback);
                return;
            }
            const t = _TemplateAction.clientActionFrom_(ClientActionInfo.of_(info));
            if (t == null) {
                callback?.(null);
                return;
            }
            this._templateAction1(button, t, iframerange, callback);
        });
    }

    private _templateMenu1(json: JSONObject, callback: Fun20<SStringMap | null, string>): void {
        host$.hideKeyboard_(() => {
            const name = json[TemplateMenuKey.lcCat];
            const menu = json[TemplateMenuKey.menu];
            if (An.isempty_(name) || menu == null) {
                callback(null, "");
                return;
            }
            let contextmenu: _TemplateContextmenu;
            const container = new DomBuilderEx(accessories$).div_().cursor_();
            try {
                contextmenu = new _TemplateContextmenu(container, name, menu as Array<Array<SStringMap>>);
            } catch (e) {
                container.remove();
                toasters$.error_(MSG.string_(RS.InvalidTemplate));
                callback(null, "");
                return;
            }
            const h = cache$.ui$.toolbarHeight_();
            contextmenu.onAction_(action => {
                contextmenu.destroy_();
                container.remove();
                native$.focusIFrameBody_();
                Timer.sleep1_(() => {
                    for (const row of menu) {
                        for (const info of row) {
                            if (info[TemplateMenuKey.action] == action) {
                                callback(info, action);
                                return;
                            }
                        }
                    }
                });
            });
            contextmenu.onCancel_(() => {
                contextmenu.destroy_();
                container.remove();
                callback(null, "");
            });
            contextmenu.show_(window.innerWidth, h * 2, false);
        });
    }

    static recalculateTotals_(): void {
        if (history$ != null && docInfo$ != null && docInfo$.getRecalc_() == true) {
            history$.group_(RS.history_calcTotal, "", () => {
                _MainPanel._recalculateTotals2();
            });
        }
    }

    private static _recalculateTotals2(): void {
        for (const total of native$.iQueryAll_(`.${CSS.xCalcTotal}`)) {
            _MainPanel._calculateTotal(total);
        }
    }

    private static _calculateTotal(etotal: HTMLElement): void {
        const context = JsUtil.ancestorOrSelfWithClass_(etotal, CSS.xCalcContext);
        if (context == null) {
            toasters$.warnKey_(RS.CalculationContextNotFound);
            return;
        }
        if (JsUtil.ancestorOrSelfWith_(context, elm => {
            return JsUtil.isElementWIthName_(elm) && elm.getAttribute("id") == ID.xRightSidebar;
        }) != null) {
            return;
        }
        const items = native$.iQueryAll_(`.${CSS.xCalcItem}`, context);
        if (items.length > 0) {
            _MainPanel._calculateItems(etotal, items);
            return;
        }
        const prices = native$.iQueryAll_(`.${CSS.xCalcPrice}`, context);
        if (prices == null) {
            return;
        }
        const len = prices.length;
        let total = 0.0;
        for (let i = 0; i < len; ++i) {
            const eprice = prices[i];
            const parent = JsUtil.ancestorOrSelfWithName_(eprice, "TR");
            if (parent == null || !native$.isVisible1_(parent)) {
                continue;
            }
            total += _MainPanel._calculateSubtotal(parent, eprice);
        }
        const value = total.toFixed(2);
        JsUtil.setValue_(etotal, value);
    }

    private static _calculateItems(etotal: HTMLElement, items: HTMLElement[]): void {
        let total = 0.0;
        for (const parent of items) {
            if (!native$.isVisible1_(parent)) {
                continue;
            }
            const eprice = native$.iQuery(`.${CSS.xCalcPrice}`, parent);
            if (eprice != null) {
                total += _MainPanel._calculateSubtotal(parent, eprice);
            }
        }
        const value = total.toFixed(2);
        JsUtil.setValue_(etotal, value);
    }

    private static _calculateSubtotal(parent: HTMLElement, eprice: HTMLElement): number {
        const equantity = native$.iQuery(`.${CSS.xCalcQuantity}`, parent);
        const esubtotal = native$.iQuery(`.${CSS.xCalcSubtotal}`, parent);
        const price = _MainPanel._calculateValue(eprice, 0.0);
        const quantity = equantity == null ? 1.0 : _MainPanel._calculateValue(equantity, 1.0);
        const subtotal = price * quantity;
        if (esubtotal != null) {
            const value = subtotal.toFixed(2);
            JsUtil.setValue_(esubtotal, value);
        }
        return subtotal;
    }

    private static readonly _xcalcerror: string[] = [CSS.xCalcError];

    private static _calculateValue(elm: HTMLElement, def: number): number {
        if (elm == null) {
            return def;
        }
        const value = An.parseDouble_(JsUtil.getCalcValue_(elm), null);
        native$.removeAddClasses_(elm, (value == null ? null : _MainPanel._xcalcerror), (value == null ? _MainPanel._xcalcerror : null));
        return value != null ? value : def;
    }

    private _onIFrameMediaViewerReady(_uri: Uri, mime: stringX): _State {
        this._iframeMediaViewer = null;
        if (mime == null) {
            return _State.INVALID;
        }
        try {
            if (mime.startsWith("image/")) {
                
                const viewer = native$.iGetElementById_(ID.xViewer);
                const content = JsUtil.asHTMLImageElement_(native$.iGetElementById_(ID.xContent));
                if (viewer == null || content == null) {
                    toasters$.warnKey_(RS.ImageNotFound);
                    return _State.INVALID;
                }
                _Hacks.fixBody();
                this._iframeMediaViewer = new IFrameImageViewer(viewer, content);
                return _State.IMAGE;
            }
            if (mime == Mime.PDF$) {
                native$.iAddEventListener_(native$.getIFrameWindow_(), Conf.pointerend$, e => {
                    const target = DomUt.asHTMLElement_(e.target);
                    if (target == null)
                        return;
                    if (this._showpdf(JsUtil.ancestorOrSelfWith_(target, (e) => e.nodeName == "A"))) {
                        JsUtil.stopevent_(e);
                    }
                }, true, true);
                return _State.PDF;
            }
            return _State.INVALID;
        } catch (e: any) {
            
            return _State.INVALID;
        }
    }

    ////////////////////////////////////////////////////////////////////////

    /**
       * @param pagex The page offset with respect to the top level document, ie. not iframe.
       * @param pagey The page offset with respect to the top level document, ie. not iframe.
       */
    private _showMainContextmenu(/* bool iscmd, */ pagex: number, pagey: number): void {
        history$.group_(RS.HistoryIgnore, "", () => { });
        this.updateContextmenuState_();
        this._contextmenu.show_(/* iscmd, */ pagex, pagey, false);
    }

    hideMainContextmenu(): void {
        if (this._contextmenu != null && this._contextmenu.isShown_()) {
            this._contextmenu.hide_();
            native$.focusIFrame_();
        }
    }

    hideMainContextmenuWithoutFocus_(): void {
        this._contextmenu?.hide_();
    }

    private _showBrowsingContextmenu(/* bool iscmd, */ pagex: number, pagey: number): void {
        history$.group_(RS.HistoryIgnore, "", () => { });
        this._browsingContextmenu.show_(/* iscmd, */ pagex, pagey, false);
    }

    hideBrowsingContextmenu(): void {
        if (this._browsingContextmenu != null && this._browsingContextmenu.isShown_()) {
            this._browsingContextmenu.hide_();
            native$.focusIFrame_();
        }
    }

    private _createImageContextmenu(): _ImageContextmenu {
        const menu = new _ImageContextmenu(accessories$, [
            [
                _ImageContextmenu._IMAGE_EXPORT,
                _ImageContextmenu._IMAGE_INFO,
            ],
            [
                _ImageContextmenu._ANNOTATE_IMAGE,
                _ImageContextmenu._IMAGE_BGCOLOR,
            ],
            [
                _ImageContextmenu._SCAN_BARCODE,
                _ImageContextmenu._SCREENSHOT,
            ],
        ]);
        menu.onAction_(action => {
            toasters$.hideAll_();
            menu.destroy_();
            native$.focusIFrame_();
            mainPanel$._imageActions(action);
        });
        menu.onCancel_(() => {
            menu.destroy_();
            native$.focusIFrame_();
        });
        menu.onContextmenu_(toasters$.onTooltipsKey_);
        return menu;
    }

    private _showImageContextmenu(/* bool iscmd, */ pagex: number, pagey: number): void {
        this._createImageContextmenu().show_(/* iscmd, */ pagex, pagey, false);
    }

    private _createCharContextmenu(): _CharContextmenu {
        const menu = new _CharContextmenu(accessories$);
        menu.onAction_(action => {
            menu.destroy_();
            native$.focusIFrame_();
            _MainPanel._charStyle1(settings$.charStylesByName_(), action);
        });
        menu.onCancel_(() => {
            menu.destroy_();
            native$.focusIFrame_();
        });
        return menu;
    }

    private _showCharContextmenu(e: MouseEvent): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null || range.collapsed) {
            toasters$.warnKey_(RS.ActionRequireANonCollapsedSelection);
            return;
        }
        const start = range.startContainer;
        const end = range.endContainer;
        if (start == null || end == null || start != end) {
            toasters$.warnKey_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
            return;
        }
        this._createCharContextmenu().show_(/* true, */ e.pageX, e.pageY);
    }

    private _createHighlightContextmenu(): _HighlightContextmenu {
        const menu = new _HighlightContextmenu(accessories$);
        menu.onAction_(action => {
            this.hideHighlightContextmenuWithoutFocus_();
            native$.focusIFrame_();
            _MainPanel._charStyle1(settings$.highlightStylesByName_(), action);
        });
        menu.onCancel_(() => native$.focusIFrame_());
        return menu;
    }

    private _showHighlightContextmenu(e: MouseEvent): void {
        if (this._highlightContextmenu == null) {
            this._highlightContextmenu = this._createHighlightContextmenu();
        }
        const range = native$.getIFrameSelectionRange_();
        if (range == null || range.collapsed) {
            toasters$.warnKey_(RS.ActionRequireANonCollapsedSelection);
            return;
        }
        const start = range.startContainer;
        const end = range.endContainer;
        if (start == null || end == null || start != end) {
            toasters$.warnKey_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
            return;
        }
        this._highlightContextmenu.show_(/* true, */ e.pageX, e.pageY);
    }

    hideHighlightContextmenuWithoutFocus_(): void {
        if (this._highlightContextmenu != null) {
            this._highlightContextmenu.hide_();
        }
    }

    private _createParaContextmenu(): _ParaContextmenu {
        const menu = new _ParaContextmenu(accessories$);
        menu.onAction_(action => {
            menu.destroy_();
            native$.focusIFrame_();
            _MainPanel._paraStyle1(settings$.paraStylesByName_(), action);
        });
        menu.onCancel_(() => {
            menu.destroy_();
            native$.focusIFrame_();
        });
        return menu;
    }

    private _showParaContextmenu(e: MouseEvent): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        const start = range.startContainer;
        const end = range.endContainer;
        if (start == null || end == null || start != end) {
            toasters$.warnKey_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
            return;
        }
        this._createParaContextmenu().show_(/* true, */ e.pageX, e.pageY);
    }

    private _createWidgetContextmenu(): _WidgetContextmenu {
        const menu = new _WidgetContextmenu(accessories$, _WidgetTemplates._INFOS);
        menu.onAction_(action => {
            menu.destroy_();
            native$.focusIFrame_();
            return _MainPanel._widgetContextAction(action);
        });
        menu.onCancel_(() => {
            menu.destroy_();
            native$.focusIFrame_();
        });
        return menu;
    }

    private _showWidgetContextmenu(e: MouseEvent): void {
        this._createWidgetContextmenu().show_(/* true, */ e.pageX, e.pageY);
    }

    toolbarActions_(e: MouseEvent, target: HTMLElement, action: string) {
        toasters$.hideAll_();
        An.stopevent_(e);
        switch (action) {
            case MainToolbarActions._HOME:
                _MainPanel._actionGoHome();
                break;
            case MainToolbarActions._EDIT_NODE:
                _MainPanel._actionEditNode();
                break;
            case MainToolbarActions._TOGGLE_LEFTSIDEPANEL:
                _MainPanel._actionToggleLeftSidepanel();
                break;
            default:
                host$.hideKeyboard_(() => {
                    switch (action) {
                        case MainToolbarActions._EDITING_MENU:
                            if (this.isEditing()) {
                                const p = An.documentOffset_(this._mainToolbar.button(MainToolbarActions._EDITING_MENU)!);
                                this._showMainContextmenu(p.x, cache$.ui$.toolbarHeight_());
                            }
                            break;
                        case MainToolbarActions._BROWSING_MENU:
                            if (!this.isEditing()) {
                                const p = An.documentOffset_(this._mainToolbar.button(MainToolbarActions._BROWSING_MENU)!);
                                this._showBrowsingContextmenu(p.x, cache$.ui$.toolbarHeight_());
                            }
                            break;
                        case MainToolbarActions._SELECT: {
                            const p = An.documentOffset_(target);
                            this._actionSelect(p.x, cache$.ui$.toolbarHeight_());
                            break;
                        }
                        case MainToolbarActions._CANCEL:
                            this.cancelEdit();
                            break;
                        case MainToolbarActions._SAVE:
                            Timer.sleep1_(() => {
                                this.saveEdit();
                            });
                            break;
                        case MainToolbarActions._BACK:
                            this._actionGoBack();
                            break;
                        case MainToolbarActions._FORWARD:
                            this._actionGoForward();
                            break;
                        case MainToolbarActions._EDIT: {
                            this._mainToolbar.setEnabled(false);
                            this.startEdit(() => {
                                this._mainToolbar.setEnabled(true);
                            }, () => {
                                this._mainToolbar.setEnabled(true);
                            });
                            break;
                        }
                        case MainToolbarActions._TOOLBAR_RECORDING:
                        case MainToolbarActions._SEARCHBAR_RECORDING:
                            this._actionStopAudioRecording();
                            break;
                        case MainToolbarActions._TOOLBAR_PLAYBACK:
                        case MainToolbarActions._SEARCHBAR_PLAYBACK:
                            this._actionShowAudioPlayer();
                            break;
                        case MainToolbarActions._IMAGE_ROTATE: {
                            if (this._iframeMediaViewer != null) {
                                (this._iframeMediaViewer as IIFrameImageViewer).rotate_();
                            }
                            break;
                        }
                        case MainToolbarActions._IMAGE_MENU: {
                            const p = An.documentOffset_(this._mainToolbar.button(MainToolbarActions._IMAGE_MENU)!);
                            this._showImageContextmenu(p.x, cache$.ui$.toolbarHeight_());
                            break;
                        }
                        default: {
                            Assert.notReach_();
                        }
                    }
                });
        }
    }

    private _imageActions(action: string): void {
        switch (action) {
            case _ImageContextmenu._IMAGE_BGCOLOR: {
                const viewer = (this._iframeMediaViewer as IIFrameImageViewer);
                Callbacks.promptColor_(cache$.ui$.buttonSize_(),
                    DEF.zindexPrompt,
                    viewer.content_().parentElement!!.style.backgroundColor,
                    ColorValue.X_WHITE)
                    .onOK_((c, format) => {
                        const formatted = ColorUtil.formatCSSString_(format, c);
                        viewer.content_().parentElement!!.style.backgroundColor = formatted;
                    }).show_();
                break;
            }
            case _ImageContextmenu._ANNOTATE_IMAGE:
                Assert.assertion_(state$ == _State.IMAGE);
                Assert.assertion_(this._iframeMediaViewer != null);
                const img = this._iframeMediaViewer!.content_() as HTMLImageElement;
                const baseuri = native$.getIFrameUri_();
                if (baseuri != null) {
                    _MainPanel.actionAnnotateImg_(img, baseuri, src => {
                        if (src != null) {
                            _Util.browse1_(src);
                        }
                    });
                }
                break;
            case _ImageContextmenu._IMAGE_EXPORT:
                if (this._iframeMediaViewer != null) {
                    (this._iframeMediaViewer as IIFrameImageViewer).export_((cpath) => {
                        _Util.browseFile_(cpath);
                    });
                }
                break;
            case _ImageContextmenu._SCAN_BARCODE:
                this._actionScanBarcode();
                break;
            case _ImageContextmenu._SCREENSHOT:
                _Util.actionScreenshot_();
                break;
            case _ImageContextmenu._IMAGE_INFO:
                const image = native$.iGetElementById_(ID.xContent);
                if (image == null) {
                    toasters$.warnKey_(RS.ImageNotFound);
                    break;
                }
                const uri = native$.getIFrameUri_();
                const cpath = uri == null ? null : An.cpathOfUri_(uri);
                if (cpath != null) {
                    Callbacks.showImageInfo_(cpath);
                }
                break;
            default:
                Assert.notReach_();
        }
    }

    private _actionScanBarcode() {
        if (this._iframeMediaViewer != null && this._iframeMediaViewer instanceof IFrameImageViewer) {
            const [r, rotation, zoom] = (this._iframeMediaViewer as IFrameImageViewer).getVisibleRegion_();
            const cpath = native$.getIFrameContextPath_();
            if (cpath != null) {
                host$.scanBarcode_(cpath, "", new CropInfo(
                    Math.round(r.x),
                    Math.round(r.y),
                    Math.round(r.w),
                    Math.round(r.h),
                    zoom,
                    rotation,
                ), (ret) => {
                    toasters$.warn_(ret);
                    const text = ret[Key.result];
                    if (text != null) {
                        clipboard$.string_(text);
                        toasters$.ok_([MSG.string_(RS.CopiedToLocalClipboard_), text], { attop: true, nowrap: true, hold: true });
                    }
                });
            }
        }
    }

    private _contextActions(action: string, target: HTMLElement, e: MouseEvent) {
        
        toasters$.hideAll_();
        switch (action) {
            case MainContextActions._PARENT_NODE:
                const p = An.documentOffset_(target);
                this._actionSelect1(p.x, p.y);
                break;
            case MainContextActions._SELECT_NEXT_SIBLING:
                this._actionSelectNextSibling();
                break;
            case MainContextActions._MOVETO_PARENT:
                this._actionMovetoParent();
                break;
            case MainContextActions._MOVETO_PREV:
                this._actionMovetoPrev();
                break;
            case MainContextActions._MOVETO_NEXT:
                this._actionMovetoNext();
                break;
            case MainContextActions._UNDO:
                this._actionUndo();
                break;
            case MainContextActions._REDO:
                this._actionRedo();
                break;
            case DEF.NOOP:
                break;
            case MainContextActions._SUBMENU_FONT:
            case MainContextActions._SUBMENU_CHAR:
            case MainContextActions._SUBMENU_PARA:
            case MainContextActions._SUBMENU_LIST:
            case MainContextActions._SUBMENU_MEDIA:
            case MainContextActions._SUBMENU_OTHERS:
                this._contextmenu.submenuActions_(target, action);
                break;
            default:
                this._contextActions1(action, e);
        }
    }

    private _contextActions1(action: string, e: MouseEvent): void {
        this.hideMainContextmenuWithoutFocus_();
        An.stopevent_(e);
        switch (action) {
            case MainContextActions._LIST_OL:
            case MainContextActions._LIST_UL:
            case MainContextActions._LIST_UL_NONE_INDENTED:
            case MainContextActions._LIST_UL_NONE:
            case MainContextActions._LIST_ITEM:
            case MainContextActions._LIST_SYMBOLS:
            case MainContextActions._LIST_DATE:
            case MainContextActions._LIST_COMPACT:
            case MainContextActions._LIST_EXPAND:
            case MainContextActions._LIST_ITEM_SYMBOL:
            case MainContextActions._LIST_ITEM_TEXT:
            case MainContextActions._LIST_ITEM_DATE:
            case MainContextActions._LIST_ITEM_TIME:
                this._listStyleActions(action);
                break;
            case MainContextActions._UNDO_HISTORY:
                _MainPanel._actionUndoHistory();
                break;
            case MainContextActions._CALCULATOR:
                _MainPanel._actionCalculator();
                break;
            case MainContextActions._SCREENSHOT:
                _Util.actionScreenshot_(native$.getIFrameDir_());
                break;
            case MainContextActions._INSERT_LINK:
                _MainPanel._actionInsertLink();
                break;
            case MainContextActions._INSERT_IMG:
                _MainPanel._actionInsertImg();
                break;
            case MainContextActions._INSERT_AUDIO:
                _MainPanel._actionInsertAudio();
                break;
            case MainContextActions._INSERT_VIDEO:
                _MainPanel._actionInsertVideo();
                break;
            case MainContextActions._PASTE_FROM_SYSTEM_CLIPBOARD:
                _MainPanel._actionPasteFromSystemClipboard();
                break;
            case MainContextActions._PARAGRAPH:
                _MainPanel._actionParagraph(e);
                break;
            case MainContextActions._INSERT_TEXT:
                _MainPanel._actionInsertText(e);
                break;
            case MainContextActions._WRAP:
                _MainPanel._actionWrap();
                break;
            case MainContextActions._INSERT_ELEMENT:
                _MainPanel._actionInsertElement();
                break;
            case MainContextActions._SPAWN_NODE:
                _MainPanel._actionSpawnNode();
                break;
            case MainContextActions._EDIT_SIZE:
                this._actionEditSize();
                break;
            case MainContextActions._EDIT_ALIGN:
                _MainPanel._actionEditAlign();
                break;
            case MainContextActions._EDIT_STYLE:
                _MainPanel._actionEditStyle();
                break;
            case MainContextActions._EDIT_STYLE_RAW:
                const target = _MainPanel._requireSingleOrCollapsedElementSelection();
                if (target != null) {
                    native$.iSelectNode_(target);
                    _MainPanel._actionEditRawStyle1(target as HTMLElement);
                }
                break;
            case MainContextActions._EDIT_NODE:
                _MainPanel._actionEditNode();
                break;
            case MainContextActions._EDIT_NODE_RAW:
                _MainPanel._actionEditNode1(true, target => {
                    const baseuri = native$.getIFrameUri_();
                    if (baseuri != null) {
                        _MainPanel._actionEditElementRaw1(target, baseuri);
                    }
                });
                break;
            case MainContextActions._ANNOTATE_IMG:
                const node = DomUt.asHTMLElement_(native$.getSingleSelectedNode_());
                if (node?.nodeName != "IMG") {
                    toasters$.warnKey_(RS.InvalidSelection);
                    break;
                }
                if (native$.hasClass_(node, CSS.xCanvas)) {
                    this._actionAnnotateCanvas(node as HTMLElement, () => { });
                } else {
                    const baseuri = native$.getIFrameUri_();
                    if (baseuri != null) {
                        _MainPanel.actionAnnotateImg_(node as HTMLImageElement, baseuri, src => {
                            if (src != null) {
                                history$.group_(RS.action_AnnotateImage, An.filenameFromUri_(src), () => {
                                    node.setAttribute("src", src.toString());
                                });
                            }
                        });
                    }
                }
                break;
            case MainContextActions._CHAR_HIDDEN:
                _MainPanel._charStyle1(settings$.charStylesByName_(), CSS.xHidden);
                native$.iClearSelection_();
                break;
            case MainContextActions._PARA_HIDDEN:
                _MainPanel._paraStyle1(settings$.paraStylesByName_(), CSS.xHidden);
                native$.iClearSelection_();
                break;
            case MainContextActions._CHAR_STYLES:
                this._showCharContextmenu(e);
                break;
            case MainContextActions._HIGHLIGHT_STYLES:
                this._showHighlightContextmenu(e);
                break;
            case MainContextActions._PARA_STYLES:
                this._showParaContextmenu(e);
                break;
            case MainContextActions._BORDER:
                _MainPanel._actionBorder();
                break;
            case MainContextActions._INSERT_CANVAS:
                this._actionInsertCanvas();
                break;
            case MainContextActions._INSERT_DATE:
                _MainPanel._actionInsertDate();
                break;
            case MainContextActions._INSERT_NAMED_ANCHOR:
                _MainPanel._actionInsertNamedAnchor();
                break;
            case MainContextActions._INSERT_CALENDAR:
                _MainPanel._actionInsertCalendar();
                break;
            case MainContextActions._INSERT_ALARM:
                _MainPanel._actionInsertAlarm();
                break;
            case MainContextActions._INSERT_SYMBOL:
                _MainPanel._actionInsertSymbol();
                break;
            case MainContextActions._INSERT_WIDGET:
                this._showWidgetContextmenu(e);
                break;
            case MainContextActions._DESTRUCT_WIDGET:
                _WidgetTemplates._actionDestructWidget();
                break;
            case MainContextActions._RECORD_AUDIO: {
                const range = _MainPanel._requireNonBodySelection();
                const baseuri = native$.getIFrameUri_();
                const basedir = baseuri == null ? null : An.cdirOfUri_(baseuri);
                if (range != null && basedir != null && baseuri != null) {
                    toasters$.error_(MSG.string_(RS.DesktopOperationRecordAudioNotAvailable));
                }
                break;
            }
            case MainContextActions._TAKE_PHOTO:
                toasters$.error_(MSG.string_(RS.DesktopOperationTakePhotoNotAvailable));
                break;
            case MainContextActions._RECORD_VIDEO: {
                const range = _MainPanel._requireNonBodySelection();
                const basedir = native$.getIFrameDir_();
                if (range != null && basedir != null) {
                    toasters$.error_(MSG.string_(RS.DesktopOperationRecordVideoNotAvailable));
                }
                break;
            }
            default:
                this._contextActions2(action);
        }
    }

    private _contextActions2(action: string): void {
        native$.focusIFrame_();
        switch (action) {
            case MainContextActions._STYLE_BOLD:
            case MainContextActions._STYLE_ITALIC:
            case MainContextActions._STYLE_UNDERLINE:
            case MainContextActions._STYLE_STRIKETHROUGH:
            case MainContextActions._STYLE_SUBSCRIPT:
            case MainContextActions._STYLE_SUPERSCRIPT:
            case MainContextActions._STYLE_FLOAT_LEFT:
            case MainContextActions._STYLE_FLOAT_RIGHT:
            case MainContextActions._STYLE_NOWRAP:
                _MainPanel._charStyle1(settings$.builtinCharStylesByName_(), action);
                break;
            case MainContextActions._STYLE_ALIGN_LEFT:
            case MainContextActions._STYLE_ALIGN_RIGHT:
            case MainContextActions._STYLE_ALIGN_CENTER:
            case MainContextActions._STYLE_ALIGN_JUSTIFY:
                _MainPanel._paraStyle1(settings$.builtinParaStylesByName_(), action);
                break;
            case MainContextActions._COPY:
                _MainPanel._actionCopy();
                break;
            case MainContextActions._CUT:
                _MainPanel._actionCut();
                break;
            case MainContextActions._PASTE_CHILD:
                _MainPanel._actionPasteChild();
                break;
            case MainContextActions._PASTE_SIBLING:
                _MainPanel._actionPasteSibling();
                break;
            case MainContextActions._TOGGLE_RIGHTSIDEBAR:
                _MainPanel._actionToggleRightSidebar();
                break;
            case MainContextActions._TO_NBSP:
                _MainPanel._actionToNbsp();
                break;
            case MainContextActions._TO_SPACE:
                _MainPanel._actionToSpace();
                break;
            case MainContextActions._UNWRAP:
                _MainPanel._actionUnwrap();
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _listStyleActions(action: string): void {
        switch (action) {
            case MainContextActions._LIST_OL:
                _MainPanel._actionList("OL");
                break;
            case MainContextActions._LIST_UL:
                _MainPanel._actionList("UL");
                break;
            case MainContextActions._LIST_UL_NONE_INDENTED:
                _MainPanel._actionList("UL", { "class": CSS.xListStyleNone });
                break;
            case MainContextActions._LIST_UL_NONE:
                _MainPanel._actionList("UL", { "class": CSS.xNone });
                break;
            case MainContextActions._LIST_SYMBOLS:
                _MainPanel._actionListSymbols();
                break;
            case MainContextActions._LIST_DATE:
                _MainPanel._actionListDate();
                break;
            case MainContextActions._LIST_ITEM:
                _MainPanel._actionListItem("UL");
                break;
            case MainContextActions._LIST_ITEM_SYMBOL:
                _MainPanel._actionListItemSymbol();
                break;
            case MainContextActions._LIST_ITEM_TEXT:
                _MainPanel._actionListItemText();
                break;
            case MainContextActions._LIST_ITEM_DATE:
                _MainPanel._actionListItemDate();
                break;
            case MainContextActions._LIST_ITEM_TIME:
                _MainPanel._actionListItemTime();
                break;
            case MainContextActions._LIST_COMPACT:
                _MainPanel._actionListCompact(true);
                break;
            case MainContextActions._LIST_EXPAND:
                _MainPanel._actionListCompact(false);
                break;
            default:
                toasters$.warn_(MSG.string1_(RS.invalidStyle_, action));
        }
    }

    ////////////////////////////////////////////////////////////////////////

    private static _actionGoHome(): void {
        Timer.sleep1_(() => {
            if (cache$.onHomeAction_()) {
                host$.autoCleanupTrash_(() => {
                    native$.reloadHome_();
                });
            } else {
                native$.browseHome_();
            }
        });
    }

    private _recentsBackForwardAction(ret: JSONObject, navigation: number, next: Fun00): void {
        if (toasters$.warn_(ret)) {
            return;
        }
        const fileinfo = FileInfo.of_(ret);
        if (fileinfo == null) {
            toasters$.warnKey_(RS.InvalidFilepath);
            return;
        }
        const path = fileinfo.name$;
        const state = fileinfo.state$;
        const lcsuffix = Basepath.lcSuffix_(path);
        if (Suffix.HTML$ != lcsuffix && !MimeUtil.isImageLcSuffix_(lcsuffix) && !MimeUtil.isTextViewerLcSuffix_(lcsuffix)) {
            host$.recentsPut_(navigation, path, state, () => {
                next();
            });
            return;
        }
        this._navigation = navigation;
        _Util.browseFile_(path, state);
    }

    private _goback1(): void {
        host$.recentsBack_((ret) => {
            this._recentsBackForwardAction(ret, RecentsCmd.BACK, () => this._goback1);
        });
    }

    private _actionGoBack(): void {
        _Util.onSaveOrDiscard_(() => {
            Timer.sleep1_(() => this._goback1());
        });
    }

    private _goforward1(): void {
        host$.recentsForward_(ret => {
            this._recentsBackForwardAction(ret, RecentsCmd.FORWARD, () => this._goforward1);
        });
    }

    private _actionGoForward(): void {
        _Util.onSaveOrDiscard_(() => {
            Timer.sleep1_(() => this._goforward1());
        });
    }

    private _actionSelect(x: number, y: number): void {
        const ancestors = native$.iGetAncestors_();
        if (ancestors == null || ancestors.length == 0) {
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        new _AncestorsContextmenu(accessories$, ancestors, true)
            .onCancel_(() => native$.focusIFrame_())
            .show_(x, y, false);
    }

    private _actionSelect1(x: number, y: number): void {
        const ancestors = native$.iGetAncestors_();
        if (ancestors == null || ancestors.length == 0) {
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        new _AncestorsContextmenu(accessories$, ancestors, false, () => this.updateContextmenuState_())
            .above_(this._contextmenu.element$)
            .show_(x, y, true);
        return;
    }

    static _actionSelectNextSiblingOK(range: RangeX, callback: Fun30<stringX, HTMLElementX, numberX>): void {
        if (range == null) {
            callback(MSG.string_(RS.InvalidSelection), null, null);
            return;
        }
        if (range.collapsed) {
            callback(null, null, null);
            return;
        }
        let container: NodeX = range.endContainer;
        let offset = range.endOffset;
        let type = container.nodeType;
        if (type == Node.TEXT_NODE) {
            offset = native$.getIndexOf_(container) + 1;
            container = container.parentElement;
        } else if (type != Node.ELEMENT_NODE) {
            callback(MSG.string_(RS.InvalidSelection), null, null);
            return;
        } else {
            const node = container.childNodes[offset];
            if (node == null) {
                callback(MSG.string_(RS.NoNextSiblingFound), null, null);
                return;
            }
            const name = node.nodeName;
            if (An.isBodyElement_(name)) {
                callback(MSG.string_(RS.NoNextSiblingFound), null, null);
                return;
            }
            offset = range.endOffset + 1;
        }
        callback(null, container as HTMLElement, offset);
    }

    private _actionSelectNextSibling(): void {
        let range = native$.getValidIFrameSelectionRange_();
        _MainPanel._actionSelectNextSiblingOK(range, (err, container, offset) => {
            if (toasters$.warn_(err)) {
                return;
            }
            if (range == null || container == null || offset == null) { return; }
            let sibling: NodeX = null;
            if (range.collapsed) {
                sibling = RangeUtil.rangeStart_(range);
                range = native$.iSelectNode_(sibling);
            } else {
                sibling = container.childNodes[offset - 1];
                range.setEnd(container, offset);
                native$.iSelectRange_(range);
            }
            this.updateContextmenuState_();
            if (sibling != null) {
                _JsUtil.toastNode_(sibling);
                
            }
        });
    }

    static _actionMovetoParent1(node: NodeX, updater: Fun00X = null): stringX {
        if (node == null || An.isBodyElement_(node.nodeName)) {
            return MSG.string_(RS.InvalidSelection);
        }
        const parent = node.parentNode;
        if (parent == null || An.isBodyElement_(parent.nodeName)) {
            return MSG.string_(RS.AlreadyAtTopLevel);
        }
        const grandparent = parent.parentElement;
        if (grandparent == null) {
            return MSG.string_(RS.AlreadyAtTopLevel);
        }
        if (!_MainPanel._canInsert1(grandparent.nodeName, node)) {
            return MSG.string_(RS.InvalidSelection);
        }
        const next = parent.nextSibling;
        history$.group_(RS.action_MoveToParent, node.nodeName, () => {
            new DomBuilderEx(grandparent).insertBefore_(next, node);
            native$.iSelectNode_(node, null, true);
            updater?.();
        });
        return null;
    }

    static _actionMovetoPrev1(node: NodeX, updater: Fun00X = null): stringX {
        if (node == null || An.isBodyElement_(node.nodeName)) {
            return MSG.string_(RS.InvalidSelection);
        }
        const prev = _MainPanel._nonEmptySibling(node, (n: Node) => { return n.previousSibling; });
        const parent = node.parentElement;
        if (parent == null) {
            return MSG.string_(RS.ThereIsNoPreviousSibling);
        }
        history$.group_(RS.action_MoveToPrev, node.nodeName, () => {
            new DomBuilderEx(parent).removeChild_(node).insertBefore_(prev, node);
            native$.iSelectNode_(node, null, true);
            updater?.();
        });
        return null;
    }

    static _actionMovetoNext1(node: NodeX, updater: Fun00X = null): stringX {
        if (node == null || An.isBodyElement_(node.nodeName)) {
            return MSG.string_(RS.InvalidSelection);
        }
        const parent = node.parentElement;
        if (parent == null) {
            return MSG.string_(RS.ThereIsNoNextSibling);
        }
        let next = _MainPanel._nonEmptySibling(node, n => { return n.nextSibling; });
        if (next == null) {
            next = parent.firstChild;
            if (next == node) {
                return null;
            }
        } else {
            next = next.nextSibling;
        }
        history$.group_(RS.action_MoveToNext, node.nodeName, () => {
            new DomBuilderEx(parent).removeChild_(node).insertBefore_(next, node);
            native$.iSelectNode_(node, null, true);
            updater?.();
        });
        return null;
    }

    private _actionMovetoParent(): void {
        const node = native$.getSingleSelectedOrCollapsedElement_();
        toasters$.warn_(_MainPanel._actionMovetoParent1(node));
        this.updateContextmenuState_();
    }

    private _actionMovetoPrev(): void {
        const range = native$.getIFrameSelectionRange_();
        let node: NodeX;
        if (range != null && range.collapsed) {
            node = JsUtil.getSplitParent_(range.startContainer);
        } else {
            node = native$.getSingleSelectedNodeOfRange_(range);
        }
        toasters$.warn_(_MainPanel._actionMovetoPrev1(node));
        this.updateContextmenuState_();
    }

    private _actionMovetoNext(): void {
        const range = native$.getIFrameSelectionRange_();
        let node: NodeX;
        if (range != null && range.collapsed) {
            node = JsUtil.getSplitParent_(range.startContainer);
        } else {
            node = native$.getSingleSelectedNodeOfRange_(range);
        }
        toasters$.warn_(_MainPanel._actionMovetoNext1(node));
        this.updateContextmenuState_();
    }

    static _actionToggleLeftSidepanel(): void {
        if (sidePanel$.isShown_()) {
            sidePanel$.hideSidepanel_();
        } else {
            sidePanel$.showSidepanel_(sidePanel$.lastTabId$, false);
        }
    }

    static _actionToggleRightSidebar(): void {
        const sidebar = native$.iGetElementById_(ID.xRightSidebar);
        if (sidebar == null) { return; }
        native$.toggleClasses_(sidebar, [CSS.xHidetemp]);
    }

    static _actionRotate(): void {
        const range = native$.getIFrameSelectionRange_();
        const node = range == null ? null : native$.getSingleSelectedNodeOfRange_(range);
        if (range == null || node == null || !_MainPanel._actionEditOpOK(node)) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return;
        }
        _MainPanel._actionRotate0(range, node as HTMLElement, null);
    }

    static _actionRotate0(_range: Range, node: HTMLElement, callback: Fun10X<HTMLElement> = null): void {
        const position = native$.getComputedStyle1_(node, null, "position");
        if (position == "absolute" || position == "fixed" || position == "relative") {
            _MainPanel._actionRotate1(node, callback);
        } else {
            _MainPanel._actionRotate90(node, callback);
        }
    }

    static _actionRotate1(node: HTMLElement, callback: Fun10X<HTMLElement> = null): void {
        const d = new CompositeDialog(accessories$, [
            new InputField("", "", "0", RS.RotationDeg, (host) => host.actionOK_()),
        ]);
        d.titleKey_(RS.Rotate);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            const xrotation = d.getValueAt_(0);
            const rotation = An.parseInt_(xrotation, null);
            if (rotation == null) {
                d.warn_(MSG.string1_(RS.InvalidValue_, xrotation));
                okcallback(false);
                return;
            }
            okcallback(true);
            history$.group_(RS.action_Rotate, node.nodeName, () => {
                const nodestyle = node.style;
                nodestyle.transform = `rotate(${rotation}deg)`;
                nodestyle.transformBox = "0 0";
                callback?.(node);
            });
        });
        d.show_();
    }

    static _actionRotate90(node: HTMLElement, callback: Fun10X<HTMLElement> = null): void {
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld("", "", "90 deg", RS.Rotation, ["0 deg", "90 deg", "180 deg", "270 deg"]),
        ]);
        d.titleKey_(RS.Rotate);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            const rotation = _Util.getRotation_(d.getValueAt_(0), 0);
            okcallback(true);
            history$.group_(RS.action_Rotate, node.nodeName, () => {
                //// which avoid extra empty spaces after rotation.
                const div = JsUtil.wrapNode_(node, "div");
                const parent = JsUtil.wrapNode_(div, "div", {
                    "class": CSS.xRotate,
                    "style": "display:inline-block;"
                });
                const nodestyle = div.style;
                nodestyle.transform = "";
                const cstyle = native$.getComputedStylesOf_(div, null, ["width", "height"]);
                const cw = cstyle.get("width")!;
                const ch = cstyle.get(PK.Height)!;
                nodestyle.width = cw;
                nodestyle.height = ch;
                if (rotation == 90 || rotation == 270) {
                    const parentstyle = parent.style;
                    parentstyle.width = ch;
                    parentstyle.height = cw;
                } else {
                    const parentstyle = parent.style;
                    parentstyle.width = cw;
                    parentstyle.height = ch;
                }
                switch (rotation) {
                    case 0:
                        nodestyle.transform = "";
                        nodestyle.transformOrigin = "";
                        break;
                    case 90:
                        nodestyle.transform = `translateX(${ch}) rotate(${rotation}deg)`;
                        nodestyle.transformOrigin = "0 0";
                        break;
                    case 180:
                        nodestyle.transform = `rotate(${rotation}deg)`;
                        nodestyle.transformOrigin = "50% 50%";
                        break;
                    case 270:
                        nodestyle.transform = `translateY(${cw}) rotate(${rotation}deg)`;
                        nodestyle.transformOrigin = "0 0";
                        break;
                }
                native$.iSelectNode_(parent);
                if (callback != null) {
                    callback(parent);
                }
            });
        });
        d.show_();
    }

    static _actionOnEnter(): boolean {
        const range = _MainPanel._requireNonBodySelection();
        if (range == null) {
            return true;
        }
        let container: NodeX = range.startContainer;
        const startoffset = range.startOffset;
        const type = container.nodeType;
        let node: NodeX = null;
        if (type == Node.TEXT_NODE) {
            node = (container as Text).splitText(startoffset);
            const parent = container.parentElement;
            if (parent != null) {
                _MainPanel._onEnter1(parent, node);
                return true;
            }
        } else if (type == Node.ELEMENT_NODE) {
            node = container.childNodes[startoffset];
            if (_MainPanel._isValidInputElement(node)) return false;
            _MainPanel._onEnter1(container as HTMLElement, node);
            return true;
        }
        return false;
    }

    static _onEnter1(container: HTMLElement, node: Node): void {
        const b = new DomBuilderEx(container).insertBefore_(node, "br");
        _MainPanel._placeholderXXX(b, node);
    }

    static _containsElement(content: Node): boolean {
        return JsUtil.find_(content, (c) => {
            if (c.nodeType == Node.ELEMENT_NODE && c.nodeName != "BR") return c;
            return null;
        }) != null;
    }

    static _actionOnBackspace(): boolean {
        const range = _MainPanel._requireNonBodySelection();
        if (range == null) { return true; }
        if (!range.collapsed) {
            const content = range.cloneContents();
            if (this._containsElement(content)) {
                toasters$.warn_(MSG.stringArray_(RS.NotDeletingNodeOnBackspace));
                return true;
            }
            history$.group_(RS.Backspace, "#range", () => {
                range.deleteContents();
            });
            return true;
        }
        const node = range.startContainer;
        if (node == null) return true;
        const type = node.nodeType;
        if (type == Node.TEXT_NODE) return this._backspace1(node, range.startOffset);
        if (type == Node.ELEMENT_NODE && range.startOffset > 0) {
            const c = node.childNodes[range.startOffset - 1];
            if (c.nodeName == "BR") {
                native$.iSelectNode_(c);
                return true;
            }
            return this._backspace1(c, null);
        }
        toasters$.warn_(MSG.string_(RS.NotDeletingNodeOnBackspace));
        native$.iClearSelection_();
        return true;
    }

    static _backspace1(node: Node, startoffset: IntX): boolean {
        const type = node.nodeType;
        if (type == Node.TEXT_NODE) {
            const text = JsUtil.nodeValue_(node) ?? "";
            const offset = (startoffset == null ? text.length : startoffset);
            if (offset == 0) {
                if (text.trim().length == 0) {
                    history$.group_(RS.Backspace, "", () => {
                        JsUtil.setTextContent_(node, "\u00a0");
                        native$.iSelectNode_(node);
                    });
                    return true;
                }
                const prev = node.previousSibling;
                if (prev != null) {
                    if (prev.nodeName == "BR") {
                        history$.group_(RS.Backspace, "BR", () => {
                            JsUtil.remove_(prev);
                        });
                        return true;
                    };
                    return this._backspace1(prev, null);
                }
            } else {
                history$.group_(RS.Backspace, text.substring(offset - 1, offset), () => {
                    const s = text.substring(0, offset - 1) + text.substring(offset);
                    if (s.length == 0) {
                        JsUtil.setTextContent_(node, "\u00a0");
                        native$.iSelectNode_(node);
                    } else {
                        JsUtil.setTextContent_(node, s);
                        native$.iSelect_(node, offset - 1, offset - 1);
                    }
                });
                return true;
            }
        }
        toasters$.warn_(MSG.string1_(RS.NotDeletingNodeOnBackspace, node.nodeName));
        native$.iClearSelection_();
        return true;
    }

    static _requireNonBodySelection(): RangeX {
        return _MainPanel._requireNonBodySelection1(native$.getIFrameSelectionRange_());
    }

    static _requireNonBodySelection1(range: RangeX): RangeX {
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return null;
        }
        if (!RangeUtil.isValidNonBodyRange_(range)) {
            toasters$.warnKey_(RS.ActionNotPermittedOnBodyElement);
            return null;
        }
        return range;
    }

    static _actionCalculator(): void {
        const d = new PromptCalc(accessories$, cache$.ui$.buttonSize_());
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((value: string) => {
            if (value.length > 0) {
                clipboard$.string_(value);
                host$.copyToClipboard_(value, An.noop_);
                toasters$.ok_([MSG.string_(RS.CopiedToLocalAndSystemClipboard_), value], { attop: true });
            }
        });
        d.show_();
    }

    static _actionCopy(): void {
        let range = _MainPanel._requireNonBodySelection();
        if (range == null) {
            return;
        }
        if (range.collapsed) {
            const node = JsUtil.getSplitParent_(range.startContainer);
            if (node == null) {
                toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
                return;
            }
            range = native$.iSelectNode_(node);
            if (range == null) {
                return;
            }
        }
        const clone = native$.cloneRange_(range);
        const context = JsUtil.getContextHtml_(range.startContainer);
        clipboard$.dom_(native$.serializeClone_(clone), context);
        _MainPanel._toastSingleNodeOrKey(range, RS.CopyOK);
    }

    static _actionCut(): void {
        let range = _MainPanel._requireNonBodySelection();
        if (range == null) {
            return;
        }
        if (range.collapsed) {
            const node = JsUtil.getSplitParent_(range.startContainer);
            if (node == null) {
                toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
                return;
            }
            range = native$.iSelectNode_(node);
        }
        if (range == null) {
            return;
        }
        const range1 = range;
        history$.group_(RS.action_Cut, "", () => {
            const clone = native$.cloneRange_(range1);
            const context = JsUtil.getContextHtml_(range1.startContainer);
            clipboard$.dom_(native$.serializeClone_(clone), context);
            _MainPanel._toastSingleNodeOrKey(range, RS.CutOK);
            range1.deleteContents();
            _MainPanel.recalculateTotals_();
        });
    }

    static _toastSingleNodeOrKey(range: RangeX, key: string): void {
        const node = native$.getSingleSelectedNodeOfRange_(range);
        if (node != null) {
            _JsUtil.toastNode_(node);
        } else {
            toasters$.infoKey_(key);
        }
    }

    static _actionPasteOK(): RangeX {
        const range = native$.getIFrameSelectionRange_();
        return _MainPanel._actionPasteOK1(range);
    }

    static _actionPasteOK1(range: RangeX): RangeX {
        if (_MainPanel._requireNonBodySelection1(range) == null) {
            return null;
        }
        if (clipboard$.isEmpty_()) {
            toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
            return null;
        }
        return range;
    }

    static _actionPasteChild(): void {
        const range = _MainPanel._actionPasteOK();
        if (range == null) {
            return;
        }
        const clone = native$.cloneClipboard_(clipboard$.get_());
        const type = clone == null ? null : clone.nodeType;
        if (clone == null || type != Node.TEXT_NODE && !(type == Node.ELEMENT_NODE && clone?.firstChild != null)) {
            toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
            return;
        }
        history$.group_(RS.action_PasteChild, "", () => {
            const type = clone.nodeType;
            if (type == Node.TEXT_NODE) {
                range.deleteContents();
                range.insertNode(clone);
            } else {
                const start = range.startContainer;
                const parentname = (start == null ? null : start.nodeName);
                if (parentname == null) {
                    toasters$.warnKey_(RS.InvalidSelection);
                    return;
                }
                const childnodes = Array.from(clone.childNodes);
                if (_MainPanel._canInsertAll(parentname, childnodes)) {
                    range.deleteContents();
                    for (let c = clone.lastChild, n; c != null; c = n) {
                        n = c.previousSibling;
                        range.insertNode(c);
                    }
                } else if (JsUtil.findChildElement_(clone, "LI") != null && _MainPanel._canInsertAll("UL", childnodes)) {
                    const parent = _MainPanel._insertnode(range, "ul");
                    if (parent != null) {
                        range.deleteContents();
                        for (let c = clone.firstChild, n; c != null; c = n) {
                            n = c.nextSibling;
                            parent.append(c);
                        }
                    }
                } else {
                    toasters$.warnKey_(RS.InvalidSelection);
                    return;
                }
                native$.iSelectRange_(range, true);
                _MainPanel.recalculateTotals_();
                //// TODO Check this normalize would interfere the selection first.
            }
        });
    }

    static _insertnode(range: Range, tag: string): HTMLElementX {
        const doc = RangeUtil.rangeOwnerDocument_(range);
        if (doc == null) { return null; }
        const ret = DomBuilderEx.offline_(doc, tag).cursor_();
        range.insertNode(ret);
        return ret;
    }

    static _canInsertAll(parent: string, childnodes: Node[]): boolean {
        const children = Html5.validChildren.get(parent) ?? null;
        for (const child of childnodes) {
            if (child.nodeType != Node.ELEMENT_NODE) { continue; }
            const name = child.nodeName;
            if (children != null && !children.includes(name)) return false;
            const parents = Html5.validParent.get(name) ?? null;
            if (parents != null && !parents.includes(parent)) return false;
        }
        return true;
    }

    static _canInsert1(parent: string, child: Node): boolean {
        if (child.nodeType != Node.ELEMENT_NODE) { return true; }
        const name = child.nodeName;
        const children = Html5.validChildren.get(parent) ?? null;
        if (children != null && !children.includes(name)) return false;
        const parents = Html5.validParent.get(name) ?? null;
        if (parents != null && !parents.includes(parent)) return false;
        return true;
    }

    static _actionPasteSibling(): void {
        let end = null;
        const range = native$.getIFrameSelectionRange_();
        if (range != null && range.collapsed) {
            end = native$.getNearestSelectedElement_();
        } else {
            const nodes = native$.getSelectedNodesOfRange_(range);
            if (nodes != null && nodes.length > 0) {
                end = nodes[nodes.length - 1];
            }
            for (; end != null && end.nodeType != Node.ELEMENT_NODE && !An.isBodyElement_(end.nodeName);) {
                end = end.parentNode;
            }
        }
        if (end == null || An.isBodyElement_(end.nodeName)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const clone = native$.cloneClipboard_(clipboard$.get_());
        const type = clone == null ? null : clone.nodeType;
        if (clone == null || type != Node.TEXT_NODE && !(type == Node.ELEMENT_NODE && clone.firstChild != null)) {
            toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
            return;
        }
        if (type == Node.ELEMENT_NODE && range != null && range.collapsed) {
            const first = (clone as HTMLElement).firstElementChild;
            if (first != null) {
                const nodename = first.nodeName;
                for (; end != null && end.nodeName != nodename;) {
                    end = end.parentNode;
                }
                if (end == null || An.isBodyElement_(end.nodeName)) {
                    toasters$.warnKey_(RS.InvalidSelection);
                    return;
                }
            }
        }
        const parent = end.parentElement;
        if (parent == null || An.isHtmlElement_(parent.nodeName)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        _MainPanel._actionPasteSibling1(parent, end, type, clone);
    }

    static _actionPasteSibling1(parent: HTMLElement, end: Node, type: number, clone: Node): number {
        let count = 1;
        history$.group_(RS.action_PasteSibling, end.nodeName, () => {
            const next = end.nextSibling;
            const b = new DomBuilderEx(parent);
            if (type == Node.TEXT_NODE) {
                b.appendNodes_(clone);
                native$.iSelectNode_(clone);
            } else {
                count = clone.childNodes.length;
                const firstchild = clone.firstChild;
                const lastchild = clone.lastChild;
                if (!_MainPanel._pasteSibling(b, parent, next, clone)) {
                    toasters$.warnKey_(RS.InvalidSelection);
                    return;
                }
                if (firstchild != null) {
                    native$.iSelectNodes_(firstchild, lastchild, true);
                }
                _MainPanel.recalculateTotals_();
            }
        });
        return count;
    }

    static _pasteSibling(b: DomBuilderEx, parent: HTMLElement, next: NodeX, clone: Node): boolean {
        const parentname = parent.nodeName;
        const childnodes = Array.from(clone.childNodes);
        const firstchild = clone.firstChild;
        if (_MainPanel._canInsertAll(parentname, childnodes)) {
            for (let c = firstchild, n; c != null; c = n) {
                n = c.nextSibling;
                b.insertBefore_(next, c);
            }
            return true;
        }
        if (JsUtil.findChildElement_(clone, "LI") != null && _MainPanel._canInsertAll("UL", childnodes)) {
            b.childBefore_(next, "ul");
            for (let c = firstchild, n; c != null; c = n) {
                n = c.nextSibling;
                b.appendNodes_(c);
            }
            return true;
        }
        return false;
    }

    private _actionUndo(): void {
        if (!history$.undo_()) {
            toasters$.warnKey_(RS.NothingToUndo);
        }
        this.updateContextmenuState_();
    }

    static _actionUndoHistory(): void {
        if (history$.isUndoEmpty_()) {
            toasters$.warnKey_(RS.NothingToUndo);
            return;
        }
        const d = new PromptUndo(accessories$, history$);
        d.titleKey_(RS.Undo);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((count) => {
            if (count == null) { return; }
            history$.undo_(count);
        });
        d.show_();
    }

    private _actionRedo(): void {
        if (!history$.redo_()) {
            toasters$.warnKey_(RS.NothingToRedo);
        }
        this.updateContextmenuState_();
    }

    static _actionWrap1(range: Range, callback: Fun10<HTMLElement>): void {
        const d = new PromptElement(accessories$);
        d.titleKey_(RS.WrapSelection);
        d.messageKey_(RS.PromptElementMessage);
        d.zindex_(DEF.zindexPrompt);
        d.tag_("DIV");
        d.onOK_((d, tag, attrs, okcallback) => {
            Sanitizers.checkTagAttrs_(tag, attrs, native$.getIFrameUri_(), (ret) => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                toasters$.warn_(ret[Key.warns]);
                const tag = ret[Key.tag];
                const attrs = (ret[Key.attrs] as SStringMap);
                history$.group_(RS.action_Wrap, tag, () => {
                    const elm = RangeUtil.wrapRange_(tag, attrs, range);
                    if (elm == null) {
                        //// FIXME Localize
                        toasters$.error_("Wrap action failed");
                        return;
                    }
                    let iswhitespace = true;
                    for (let c = elm.firstChild; c != null; c = c.nextSibling) {
                        if (!JsUtil.isWhitespaceNode_(c)) {
                            iswhitespace = false;
                            break;
                        }
                    }
                    if (iswhitespace) {
                        const b = new DomBuilderEx(elm);
                        _MainPanel._placeholder(b, null);
                    } else {
                        native$.iSelectNode_(elm);
                    }
                    _JsUtil.toastElement_(elm);
                    if (callback != null) {
                        callback(elm);
                    }
                });
            });
        });
        d.show_();
    }

    static _actionWrap(): void {
        native$.focusIFrame_();
        const range = native$.getIFrameSelectionRange_();
        if (toasters$.warn_(JsUtil.actionWrapOK_(range)) || range == null) {
            return;
        }
        _MainPanel._actionWrap1(range, An.noop_);
    }

    static _actionUnwrapOK(node: NodeX): boolean {
        return node != null
            && node.nodeType == Node.ELEMENT_NODE
            && !An.isBodyElement_(node.nodeName)
            && node.firstChild != null;
    }

    static _actionUnwrap(): void {
        const node = native$.getSingleSelectedNode_();
        const parent = node?.parentElement ?? null;
        if (!_MainPanel._actionUnwrapOK(node) || node == null || parent == null) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return;
        }
        history$.group_(RS.action_Unwrap, node.nodeName, () => {
            const b = new DomBuilderEx(parent);
            const first = node.firstChild;
            if (first != null) {
                b.moveChildrenBefore_(node, first, null);
                native$.iSelectNodes_(first, node.lastChild);
            }
            b.removeChild_(node);
        });
    }

    static _noplaceholder(elm: HTMLElement): boolean {
        return (elm.nodeName == "A" && elm.getAttribute("href") == null && elm.getAttribute("name") != null);
    }

    static _actionInsertElement(): void {
        const range = native$.getIFrameSelectionRange_();
        if (range != null && range.collapsed) {
            const d = _Util.promptInsertElement_();
            d.onChild_((tag, attrs) => {
                history$.group_(RS.action_InsertElementChild, tag, () => {
                    const b = DomBuilderEx.offline_(RangeUtil.rangeOwnerDocument_(range)!, tag, attrs);
                    const elm = b.cursor_();
                    RangeUtil.replaceRange_(range, elm);
                    if (!_MainPanel._noplaceholder(elm)) {
                        _MainPanel._placeholder(b, null);
                    }
                    _JsUtil.toastElement_(elm);
                });
            });
            d.show_();
        } else {
            const target = native$.getSingleSelectedNodeOfRange_(range);
            if (target == null) {
                toasters$.warnKey_(RS.ActionRequireASingleNodeSelection);
                return;
            }
            _MainPanel._actionInsertElement1(target, null);
        }
    }

    static _actionInsertElement1(target: Node, callback: Fun20X<HTMLElement, boolean> = null): void {
        native$.iSelectNode_(target);
        const d = _Util.promptInsertElement_();
        const name = target.nodeName;
        const isbody = An.isBodyElement_(name);
        const parent = target.parentElement;
        if (!isbody && parent != null) {
            d.onAfter_((tag, attrs) => {
                history$.group_(RS.action_InsertElementSibling, tag, () => {
                    const b = new DomBuilderEx(parent);
                    const elm = b.childBefore_(target.nextSibling, tag, attrs).cursor_();
                    native$.iRevealNode_(elm);
                    if (!_MainPanel._noplaceholder(elm)) {
                        _MainPanel._placeholder(b, null);
                    }
                    _JsUtil.toastElement_(elm);
                    callback?.(elm, true);
                });
            });
        }
        const targetelm = DomUt.asHTMLElement_(target);
        const iselement = targetelm != null && !Html5.isEmptyTag(name);
        if (iselement && targetelm != null) {
            d.onChild_((tag, attrs) => {
                history$.group_(RS.action_InsertElementChild, tag, () => {
                    const b = new DomBuilderEx(targetelm);
                    const elm = b.childBefore_(target.firstChild, tag, attrs).cursor_();
                    native$.iRevealNode_(elm);
                    if (!_MainPanel._noplaceholder(elm)) {
                        _MainPanel._placeholder(b, null);
                    }
                    _JsUtil.toastElement_(elm);
                    if (callback != null) {
                        callback(elm, false);
                    }
                });
            });
        }
        if (isbody && !iselement) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        d.show_();
    }

    static _actionInsertText1(target: Node, callback: Fun20X<Node, boolean> = null): void {
        native$.iSelectNode_(target);
        _SymbolPreferences.get_(session => {
            const elm = JsUtil.getElementSelfOrParent_(target);
            if (elm == null) {
                toasters$.warnKey_(RS.InvalidSelection);
                return;
            }
            const fontfamily = native$.getComputedStyle1_(elm, null, "font-family")!;
            const d = _Util.promptInsertText_(fontfamily, session);
            const name = target.nodeName;
            const isbody = An.isBodyElement_(name);
            const parent = target.parentElement;
            if (!isbody && parent != null) {
                d.onAfter_((_d, text, okcallback) => {
                    okcallback(true);
                    history$.group_(RS.action_InsertTextSibling, name, () => {
                        const b = new DomBuilderEx(parent);
                        const textnode = DomBuilderEx.createText_(text);
                        b.insertBefore_(target.nextSibling, textnode);
                        native$.iSelectNode_(textnode, null, true);
                        callback?.(textnode, true);
                    });
                });
            }
            const targetelm = DomUt.asHTMLElement_(target);
            const iselement = (targetelm != null && !Html5.isEmptyTag(name));
            if (iselement && targetelm != null) {
                d.onChild_((_d, text, okcallback) => {
                    okcallback(true);
                    history$.group_(RS.action_InsertTextChild, name, () => {
                        const b = new DomBuilderEx(targetelm);
                        const textnode = DomBuilderEx.createText_(text);
                        b.insertBefore_(target.firstChild, textnode);
                        native$.iSelectNode_(textnode, null, true);
                        callback?.(textnode, false);
                    });
                });
            }
            if (isbody && !iselement) {
                toasters$.warnKey_(RS.InvalidSelection);
                return;
            }
            d.show_();
        });
    }

    static _actionSpawnNode(): void {
        const range = native$.getIFrameSelectionRange_();
        let target: NodeX;
        if (range != null && range.collapsed) {
            target = RangeUtil.rangeStart_(range);
            while (target != null) {
                if (target.nodeType == Node.ELEMENT_NODE && Html5.canSplitTag(target.nodeName)) {
                    break;
                }
                target = target.parentNode;
            }
        } else {
            target = native$.getSingleSelectedNodeOfRange_(range);
        }
        const targetelm = DomUt.asHTMLElement_(target);
        if (targetelm == null) {
            toasters$.warnKey_(RS.ActionRequireASingleElementOrACollapsedSelection);
            return;
        }
        _MainPanel._spawnNode0(targetelm, node => {
            native$.focusIFrame_();
            if (node != null) {
                _MainPanel.recalculateTotals_();
                _JsUtil.toastNode_(node);
            }
        });
    }

    static _spawnNode0(target: Node, callback: Fun10<NodeX>): void {
        const parent = target.parentElement;
        const nodename = target.nodeName;
        const elm = DomUt.asHTMLElement_(target);
        if (parent == null || elm != null && An.isBodyElement_(nodename)) {
            toasters$.warnKey_(RS.ActionNotPermittedOnBodyElement);
            callback(null);
            return;
        }
        history$.group_(RS.action_Spawn, nodename, () => {
            const node = _MainPanel._spawnNode1(parent, target);
            native$.iSelectNode_(node, null, true);
            callback(node);
        });
    }

    static _spawnNode1(parent: HTMLElement, target: Node): Node {
        const clone = native$.cloneNode_(target);
        const b = new DomBuilderEx(parent);
        b.insertBefore_(target.nextSibling, clone);
        return clone;
    }

    static _actionEditOpOK(node: NodeX): boolean {
        return (node != null && node.nodeType == Node.ELEMENT_NODE && !An.isBodyElement_(node.nodeName));
    }

    static _requireSingleNonBodyElementSelection(): HTMLElementX {
        const node = native$.getSingleSelectedNode_();
        if (!_MainPanel._actionEditOpOK(node)) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return null;
        }
        return node as HTMLElement;
    }

    static _requireSingleOrCollapsedElementSelection(): HTMLElementX {
        const node = native$.getSingleSelectedOrCollapsedElement_();
        if (!_MainPanel._actionEditOpOK(node)) {
            toasters$.warnKey_(RS.ActionRequireASingleElementOrACollapsedSelection);
            return null;
        }
        return node;
    }

    static _resizeInfo(
        target: HTMLElement,
        allowresize: boolean = true,
        allowrotate: boolean = true
    ): ElementResizerInfo | null {
        const styles = native$.getComputedStylesOf_(
            target,
            null,
            [SK.Display, SK.Visibility, SK.Position, SK.Width, SK.Height, SK.Top, SK.Left]
        );
        const display = styles.get(SK.Display)!;
        const visibility = styles.get(SK.Visibility)!;
        const position = styles.get(SK.Position)!;
        if (display == SV.None || visibility == SV.Hidden) { return null; }
        const left = An.parseDoublePx_(styles.get(SK.Left), null);
        const top = An.parseDoublePx_(styles.get(SK.Top), null);
        const width = An.parseDoublePx_(styles.get(SK.Width), null);
        const height = An.parseDoublePx_(styles.get(SK.Height), null);
        const canreposition = left != null && top != null
            && (position == SV.Fixed || position == SV.Absolute || position == SV.Relative);
        const canresize = (allowresize && width != null && height != null);
        let istop = JsUtil.isBody_(target);
        if (!istop) {
            const parent = target.parentNode;
            istop = (parent == null || JsUtil.isBody_(parent));
        }
        const canrotate = allowrotate && !istop;
        return new ElementResizerInfo(target, canreposition, canresize, canrotate, position, left, top, width, height);
    }

    private _actionEditSize(): void {
        const target = _MainPanel._requireSingleNonBodyElementSelection();
        if (target == null) {
            return;
        }
        native$.iSelectNode_(target);
        this.actionEditSize0_(target as HTMLElement, null);
    }

    actionEditSize0_(target: HTMLElement, callback: Fun00X = null): void {
        const info = _MainPanel._resizeInfo(target, false, true);
        if (info == null || !(info.canReposition || info.canRotate)) {
            toasters$.warnKey_(RS.CannotRepositionResizeOrRotateElement);
            callback?.();
            return;
        }
        this.actionEditSize1_(info, callback);
    }

    actionEditSize1_(info: ElementResizerInfo, callback: Fun00X = null): void {
        if (this.isEditing()) {
            this._actionEditSizeEditing(info, callback);
        } else {
            this._actionEditSizeBrowsing(info, callback);
        }
    }

    private _actionEditSizeEditing(info: ElementResizerInfo, callback: Fun00X = null): void {
        const button = this._mainToolbar.button(MainToolbarActions._EDITING_MENU)!;
        const classes = button.classList;
        classes.remove(CSS.FaToggleDown);
        classes.add(CSS.FaArrows);
        new Smokescreen(accessories$, DEF.zindexResizer, DEF.opacityResizing).show_((sm) => {
            const startgroup = _MainPanel._startGroup(RS.action_Reposition, info.target.nodeName);
            const d = new ElementResizer(sm, info);
            d.onDone(() => {
                _MainPanel._endGroup(startgroup);
                toasters$.hideInfo_();
                classes.remove(CSS.FaArrows);
                classes.add(CSS.FaToggleDown);
                callback?.();
            });
            d.bind();
        });
    }

    private _actionEditSizeBrowsing(info: ElementResizerInfo, callback: Fun00X = null): void {
        new Smokescreen(accessories$, DEF.zindexResizer, DEF.opacityResizing).show_((sm) => {
            const d = new ElementResizer(sm, info);
            d.onDone(() => {
                toasters$.hideInfo_();
                callback?.();
            });
            d.bind();
        });
    }

    static _actionEditAlign(): void {
        const target = _MainPanel._requireSingleNonBodyElementSelection();
        if (target != null) {
            native$.iSelectNode_(target);
            _MainPanel._actionEditAlign1(target as HTMLElement);
        }
    }

    static _actionEditAlign1(target: HTMLElement, updater: Fun10X<HTMLElement> = null): void {
        const nodename = target.nodeName;
        if (!Html5.canEditTag(nodename)) {
            toasters$.warn_(MSG.string1_(RS.elementNotEditable_, nodename));
            return;
        }
        const ostyle = target.getAttribute("style");
        const current = native$.getStyleOrComputedStyle_(target, null, [
            "text-align",
            "vertical-align",
            "float",
            "clear",
        ]);
        history$.startGroup_(RS.action_EditAlign, target.nodeName);
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld(
                RS.TextAlign,
                "text-align",
                current.get("text-align")!,
                RS.TextAlign,
                PV.TextAlign
            ),
            new SelectFIeld(
                RS.VerticalAlign,
                "vertical-align",
                current.get("vertical-align")!,
                RS.VerticalAlign,
                PV.VerticalAlign
            ),
            new SelectFIeld(
                RS.Float,
                "float",
                current.get("float")!,
                RS.Float,
                PV.Float),
            new SelectFIeld(
                RS.Clear,
                "clear",
                current.get("clear")!,
                RS.Clear,
                PV.Clear)
        ]);
        d.titleKey_(RS.EditAlign);
        d.zindex_(DEF.zindexPrompt);
        d.onChange_((field, input) => {
            const key = field.spec$.key$;
            const value = (input as SelectOptions).getValue_("");
            native$.replaceStyle_(target, key, value);
        });
        d.onCancel_(() => {
            JsUtil.setAttribute0_(target, "style", ostyle);
            history$.endGroup_();
        });
        d.onOK_((d, okcallback) => {
            const values = d.getChanged_(current);
            cssParser$.sanitizeStyle_(CSSUtil.joinStylesRemovingEmptyValues_(values), native$.getIFrameUri_(), (ret) => {
                if (toasters$.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                for (const key of values.keys()) {
                    target.style.removeProperty(key);
                }
                const sanitized = ret[Key.style] as SStringMap;
                for (const [key, value] of Object.entries(sanitized)) {
                    native$.replaceStyle_(target, key, value);
                }
                updater?.(target);
                history$.endGroup_();
            });
        });
        d.show_();
    }

    static _actionEditRawStyle1(target: HTMLElement, updater: Fun00X = null): void {
        const nodename = target.nodeName;
        if (!Html5.canEditTag(nodename)) {
            toasters$.warn_(MSG.string1_(RS.elementNotEditable_, nodename));
            return;
        }
        const ostyle = target.getAttribute("style")?.trim() ?? "";
        const cpath = native$.getIFrameContextPath_();
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null || cpath == null) { return; }
        if (ostyle.length == 0) {
            this._actionEditRawStyle2(target, "", cpath, baseuri, updater);
            return;
        }
        cssParser$.sanitizeStyle_(ostyle, baseuri, (ret) => {
            toasters$.warn_(ret);
            const styles = ret[Key.style];
            if (styles == null) return;
            const content = CSSUtil.joinlnStyleList_(Object.entries(styles)).trim();
            this._actionEditRawStyle2(target, content, cpath, baseuri, updater);
        });
    }

    static _actionEditRawStyle2(target: HTMLElement, content: string, cpath: string, baseuri: BaseUri, updater: Fun00X = null): void {
        const oannotation = target.getAttribute(ATTR.xAnnotation);
        const owidth = target.style.width;
        const oheight = target.style.height;
        _Util.styleEditor_(accessories$, content, cpath, baseuri, DEF.zindexPrompt, toasters$, (ret) => {
            const value = CSSUtil.joinStyles1_(Object.entries(ret));
            const nodename = target.nodeName;
            history$.group_(RS.action_EditRawStyle, nodename, () => {
                JsUtil.setAttribute0_(target, "style", value);
                if ("IMG" == nodename && native$.hasClass_(target, CSS.xCanvas)) {
                    _MainPanel.rerenderCanvas_(target, baseuri, owidth, oheight, oannotation, false);
                }
                updater?.();
            });
        }).show_();
    }

    static _actionEditStyle(): void {
        const target = _MainPanel._requireSingleOrCollapsedElementSelection();
        if (target != null) {
            native$.iSelectNode_(target);
            _MainPanel._actionEditStyle1(target as HTMLElement);
        }
    }

    static _actionEditStyle1(target: HTMLElement, updater: Fun10X<HTMLElementX> = null): void {
        const nodename = target.nodeName;
        if (!Html5.canEditTag(nodename)) {
            toasters$.warn_(MSG.string1_(RS.elementNotEditable_, nodename));
            return;
        }
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) { return; }
        const ostyle = target.getAttribute("style");
        if (ostyle == null || ostyle.length == 0) {
            _MainPanel._actionEditStyle2(target, "", smap_(), baseuri, updater);
        } else {
            cssParser$.sanitizeStyle_(ostyle, baseuri, (ret) => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                const ostyles = (ret[Key.style] ?? smap_()) as SStringMap;
                _MainPanel._actionEditStyle2(target, ostyle, ostyles, baseuri, updater);
            });
        }
    }

    static _actionEditStyle2(
        target: HTMLElement,
        ostyle: string,
        ostyles: SStringMap,
        baseuri: BaseUri,
        updater: Fun10X<HTMLElementX> = null
    ): void {
        _JsUtil.getBgImgFromStyleAttribute_(target, baseuri, (bgurl) => {
            if (bgurl == null || "none" == bgurl) {
                bgurl = "";
            }
            const bgvalue = CSSUtil.humanCSSUrl_(bgurl);
            const style = target.style;
            const odisplay = style.display;
            const olineheight = style.lineHeight;;
            const owidth = style.width;
            const oheight = style.height;
            const omargin = style.margin;
            const opadding = style.padding;
            const widthunit = CSSUtil.cssLengthUnit_(owidth);
            const heightunit = CSSUtil.cssLengthUnit_(oheight);
            history$.startGroup_(RS.action_EditStyle, target.nodeName);
            const d = _Util.promptValues_(RS.EditStyleTitle, [
                new SelectFIeld(
                    RS.Display,
                    "display",
                    odisplay,
                    RS.Display,
                    PV.Display
                ),
                new UriField(
                    RS.BGImageURL,
                    PK.BackgroundImage,
                    bgvalue,
                    RS.BGImageURL,
                    baseuri,
                    [BUT.PathKind, BUT.Folder],
                    Callbacks.onAnyImageFolderButton_,
                ),
                new InputField(
                    RS.LineHeight,
                    "line-height",
                    olineheight,
                    RS.LineHeight,
                ),
                new InputSelectField(
                    RS.Width,
                    "width",
                    (widthunit == null ? "" : `${widthunit[0]}`),
                    RS.Width,
                    (widthunit == null ? "" : widthunit[1]),
                    CSSLengths
                ),
                new InputSelectField(
                    RS.Height,
                    "height",
                    (heightunit == null ? "" : `${heightunit[0]}`),
                    RS.Height,
                    (heightunit == null ? "" : heightunit[1]),
                    CSSLengths
                ),
                new InputField(
                    RS.Padding,
                    "padding",
                    opadding,
                    RS.Padding,
                ),
                new InputField(
                    RS.Margin,
                    "margin",
                    omargin,
                    RS.Margin,
                ),
            ]);
            d.largeWidth_();
            d.messageKey_(RS.EditSpacingMessage);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((d, okcallback) => {
                const styles = d.getChanged_(map_(
                    ["display", odisplay],
                    [PK.BackgroundImage, bgurl ?? ""],
                    ["line-height", olineheight],
                    ["width", owidth],
                    ["height", oheight],
                    ["padding", opadding],
                    ["margin", omargin],
                ));
                const value = styles.get(PK.BackgroundImage) ?? null;
                if (value == null || value.length == 0 || value == "unset" || value == "none") {
                    _MainPanel._actionEditStyle3(d, styles, baseuri, okcallback, target, ostyles, updater);
                    return;
                }
                Sanitizers.checkImageHref_(value, baseuri).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(uri => {
                    okcallback(true);
                    styles.set(PK.BackgroundImage, CSSUtil.toCSSUrl_(uri.encoded$));
                    _MainPanel._actionEditStyle3(d, styles, baseuri, okcallback, target, ostyles, updater);
                });
            });
            d.onCancel_(() => {
                JsUtil.setAttribute0_(target, "style", ostyle);
                history$.endGroup_();
            });
            d.show_();
        });
    }

    static _actionEditStyle3(
        _d: ICompositeDialog,
        styles: Map<string, string>,
        baseuri: BaseUri,
        okcallback: BoolCallback,
        target: HTMLElement,
        ostyles: SStringMap,
        updater: Fun10X<HTMLElement> = null
    ): void {
        cssParser$.sanitizeStyle_(CSSUtil.joinStylesRemovingEmptyValues_(styles), baseuri, (ret) => {
            if (toasters$.warn_(ret)) {
                okcallback(false);
                return;
            }
            okcallback(true);
            for (const key of styles.keys()) {
                ostyles[key] = "";
            }
            const decls = ret[Key.style] as SStringMap;
            for (const [key, value] of Object.entries(decls)) {
                ostyles[key] = value;
            }
            JsUtil.setAttribute0_(target, "style", CSSUtil.joinStyles1_(Object.entries(ostyles)));
            const after = native$.getStyleOrComputedStyle_(target, null, [
                PK.BackgroundImage,
            ]);
            const nodename = target.nodeName;
            const oannotation = target.getAttribute(ATTR.xAnnotation);
            const style = target.style;
            const owidth = style.width;
            const oheight = style.height;
            _MainPanel._cleanupBackgroundImageStyle(after, style);
            if ("IMG" == nodename && native$.hasClass_(target, CSS.xCanvas)) {
                _MainPanel.rerenderCanvas_(target, baseuri, owidth, oheight, oannotation, false);
            }
            if (updater != null) {
                updater(target);
            }
            history$.endGroup_();
        });
    }

    /**
       * @return A valid CSS url() value for properites like background-image.
       */
    static _cssurl(d: ICompositeDialog, value: string, baseuri: BaseUri): stringX {
        const u = d.parseUri_(value, baseuri);
        if (u != null) {
            return CSSUtil.toCSSUrl_(u.encoded$);
        }
        return null;
    }

    static _cleanupBackgroundImageStyle(after: Map<string, string>, style: CSSStyleDeclaration): void {
        const bgimg = after.get(PK.BackgroundImage);
        if (bgimg == null || bgimg.length == 0) {
            style.backgroundImage = "";
            style.backgroundPosition = "";
            for (const name of [
                PK.BackgroundAttachment,
                PK.BackgroundColor,
                PK.BackgroundSize,
                PK.BackgroundOrigin,
                PK.BackgroundClip,
                PK.BackgroundRepeat
            ]) {
                if (style.getPropertyValue(name) == "initial") {
                    style.setProperty(name, "");
                }
            }
        }
    }

    static _actionEditNode(): void {
        _MainPanel._actionEditNode1(true, target => {
            _MainPanel._actionEditElement1(target);
        });
    }

    static _actionEditNode1(focus: boolean, nodeeditor: Fun10<HTMLElement>): void {
        const textnodes = (range: Range): [NodeX, IntX, IntX] => {
            if (range.collapsed) {
                return [range.startContainer, range.startOffset, null];
            }
            const ancestor = range.commonAncestorContainer;
            if (ancestor.nodeType == Node.TEXT_NODE) {
                return [ancestor, range.startOffset, range.endOffset];
            }
            return [native$.getSingleSelectedNodeOfRange_(range), null, null];
        };
        const range = native$.getIFrameSelectionRange_();
        if (range != null) {
            const [target, start, end] = textnodes(range);
            if (target != null) {
                const type = target.nodeType;
                if (type == Node.ELEMENT_NODE && !An.isBodyElement_(target.nodeName)) {
                    nodeeditor(target as HTMLElement);
                    return;
                } else if (type == Node.TEXT_NODE) {
                    _MainPanel._actionEditText1(target, focus, start, end);
                    return;
                }
            }
        }
        toasters$.warnKey_(RS.ActionRequireASingleNodeSelection);
    }

    /**
       * @param updater(JsObject node, boolean updateparent).
       */
    static _actionEditElement1(target: HTMLElement, updater: Fun20X<HTMLElement, boolean> = null): void {
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) { return; }
        const nodename = target.nodeName;
        if ("A" == nodename) {
            _MainPanel._actionEditLink(target, false, baseuri, updater);
            return;
        } else if ("IMG" == nodename) {
            _MainPanel._actionEditImg(target, baseuri, updater);
            return;
        } else if ("AUDIO" == nodename) {
            _MainPanel._actionEditMedia(target, RS.Audio, baseuri, Callbacks.onAudioPlaybackFolderButton_, updater);
            return;
        } else if ("VIDEO" == nodename) {
            _MainPanel._actionEditMedia(target, RS.Video, baseuri, Callbacks.onVideoPlaybackFolderButton_, updater);
            return;
        } else if ("SOURCE" == nodename) {
            const tag = target.parentNode?.nodeName;
            if (tag == "AUDIO") {
                _MainPanel._actionEditMedia(target, RS.Audio, baseuri, Callbacks.onAudioPlaybackFolderButton_, updater);
            } else if (tag == "VIDEO") {
                _MainPanel._actionEditMedia(target, RS.Video, baseuri, Callbacks.onVideoPlaybackFolderButton_, updater);
            }
            return;
        } else if (!Html5.canEditTag(nodename)) {
            toasters$.warn_(MSG.string1_(RS.elementNotEditable_, nodename));
            return;
        }
        _MainPanel._actionEditElementRaw1(target, baseuri, updater);
    }

    static _actionEditElementRaw1(target: HTMLElement, baseuri: BaseUri, updater: Fun20X<HTMLElement, boolean> = null): void {
        const nodename = target.nodeName;
        const oannotation = target.getAttribute(ATTR.xAnnotation);
        const owidth = target.style.width;
        const oheight = target.style.height;
        const sorted = JsUtil.sortedAttributes_(target);
        const d = new PromptEditElement(accessories$);
        d.titleText_(nodename);
        d.zindex_(DEF.zindexPrompt);
        d.messageKey_(RS.PromptElementMessage);
        d.tag_(nodename);
        d.attributes_(An.attributesToStringForEdit_(sorted, " ", ["xmlns"]));
        d.onOK_((d, tag, attrs, okcallback) => {
            Sanitizers.checkTagAttrs_(tag, attrs, baseuri, (ret) => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                toasters$.warn_(ret[Key.warns]);
                const tag = ret[Key.tag];
                const attrs = (ret[Key.attrs] as StringMap<stringX>);
                history$.group_(RS.action_EditElement, nodename, () => {
                    let ret: HTMLElement;
                    let rerender = false;
                    if (tag == nodename) {
                        native$.removeAttributes_(target);
                        new DomBuilderEx(target).attrs_(attrs);
                        ret = target;
                    } else {
                        ret = new DomBuilderEx(target)
                            .up_()
                            .childBefore_(target, tag, attrs)
                            .moveChildren_(target.firstChild, null)
                            .push_()
                            .up_()
                            .removeChild_(target)
                            .pop_()
                            .cursor_();
                        native$.iSelectNode_(ret);
                        rerender = true;
                    }
                    if ("IMG" == tag && native$.hasClass_(ret, CSS.xCanvas)) {
                        _MainPanel.rerenderCanvas_(ret, baseuri, owidth, oheight, oannotation, rerender);
                    }
                    native$.iSelectNode_(ret);
                    updater?.(ret, false);
                });
            });
        });
        d.show_();
    }

    static _actionEditText1(
        target: Node,
        focus: boolean,
        _start: numberX = null,
        _end: numberX = null,
        callback: StringCallback | null = null
    ): void {
        const ovalue = (target.nodeValue ?? "");
        const elm = JsUtil.getElementSelfOrParent_(target);
        if (elm == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            if (focus) native$.focusIFrame_();
            return;
        }
        const fontfamily = native$.getComputedStyle1_(elm, null, "font-family");
        if (fontfamily == null) {
            return;
        }
        Callbacks.promptEditText_(ovalue, fontfamily, DEF.zindexPrompt, d => {
            d.onOK_((_d, value, offset, okcallback) => {
                okcallback(true);
                if (focus) { native$.focusIFrame_(); }
                history$.group_(RS.action_EditTextNode, An.truncate_(ovalue, DEF.historyTextLength), () => {
                    target.nodeValue = value;
                    if (offset == null || offset < 0) offset = 0;
                    if (offset >= value.length) offset = value.length;
                    native$.iSelect_(target, offset, offset);
                });
                callback?.(value);
            });
            d.onCancel_(() => {
                if (focus) native$.focusIFrame_();
            });
            d.show_();
        });
    }

    /**
       * @param updater(JsObject ret, bool refreshparent)
       * where ret is the updated A element and refreshparent is always false.
       */
    static _actionEditLink(target: HTMLElement, autofill: boolean, baseuri: BaseUri, updater: Fun20X<HTMLElement, boolean> = null): void {
        const sorted = JsUtil.sortedAttributes_(target);
        const href = HumanLink.fromHref_(sorted.get("href") ?? "");
        const text = JsUtil.trimmedTextContent_(target);
        const attrs = An.attributesToStringForEdit_(sorted, " ", ["xmlns", "href"]);
        if (_MainPanel._textchildonly(target)) {
            const d = _Util.promptLink3_(RS.EditLinkTitle, autofill, href, text, attrs, baseuri, (uri, text, attrs) => {
                history$.group_(RS.action_EditLink, An.filenameFromUri_(uri), () => {
                    if (uri == null) delete attrs["href"];
                    else attrs["href"] = uri.encoded$;
                    const ret = DomBuilderEx.offline_(target.ownerDocument, "A", attrs).text_(text).cursor_();
                    const parent = target.parentElement;
                    if (parent != null) {
                        const b = new DomBuilderEx(parent);
                        b.push_().childBefore_(target, ret);
                        b.pop_().removeChild_(target);
                        native$.iSelectNode_(ret);
                    }
                    updater?.(ret, false);
                });
            });
            d.show_();
        } else {
            const d = _Util.promptLink21_(RS.EditLinkTitle, href, attrs, baseuri, Callbacks.onLinkFolderButton_, (u, attrs) => {
                const parent = target.parentElement;
                if (u != null && parent != null) {
                    attrs["href"] = u.encoded$;
                    const ret = _MainPanel.replaceLink(parent, target, u, attrs);
                    updater?.(ret, false);
                }
            });
            d.show_();
        }
    }

    static _editAudioLink(
        target: HTMLAudioElement,
        baseuri: BaseUri,
        updater: Fun20<HTMLElementX, HTMLAudioElement>,
    ): void {
        this._actionEditMediaElement(target, RS.Audio, baseuri, Callbacks.onAudioPlaybackFolderButton_, (u, attrs) => {
            const parent = target.parentElement;
            if (u != null && parent != null) {
                attrs["src"] = u.encoded$;
                const audio = _MainPanel.replaceLink(parent, target, u, attrs);
                const audioinfo = JsUtil.ancestorOrSelfWithAttr_(parent, ATTR.xPlaceholder, Placeholder.xpAudioinfo);
                updater(audioinfo, audio);
            }
        }).show_();
    }

    static _editVideoLink(
        target: HTMLElement,
        baseuri: BaseUri,
        updater: Fun20<HTMLElementX, HTMLElement>,
    ): PromptEditMedia | null {
        return this._actionEditMediaElement(target, RS.Video, baseuri, Callbacks.onVideoPlaybackFolderButton_, (u, attrs) => {
            const parent = target.parentElement;
            if (u != null && parent != null) {
                attrs["src"] = u.encoded$;
                const video = _MainPanel.replaceLink(parent, target, u, attrs);
                const videoinfo = JsUtil.ancestorOrSelfWithAttr_(parent, ATTR.xPlaceholder, Placeholder.xpVideoinfo);
                updater(videoinfo, video);
            }
        });
    }

    static _editAudioholder(
        target: HTMLElement,
        baseuri: BaseUri,
        callback: Fun30<UriX, StringMap<string>, UriX>,
    ) {
        const osrc = HumanLink.fromHref_(target.getAttribute("src") ?? "");
        const ohref = HumanLink.fromHref_(target.getAttribute(ATTR.xHref) ?? "");
        const sorted = JsUtil.sortedAttributes_(target);
        const oattrs = An.attributesToStringForEdit_(sorted, " ", ["xmlns", "src"]);
        _Util.promptAudioUrl2_(
            RS.Audio, DEF.zindexPrompt, osrc, oattrs, ohref, baseuri, Callbacks.onAnyImageFolderButton_,
            (srcuri, sanitized, _, linkuri) => {
                callback(srcuri, sanitized, linkuri);
            },
        ).show_();
    }

    static _editVideoholder(
        target: HTMLElement,
        baseuri: BaseUri,
        callback: Fun10<Uri>,
    ) {
        const href = target.getAttribute(ATTR.xHref);
        if (href == null) return;
        let uri = HumanLink.fromHref_(href);
        new PromptEditMedia(
            accessories$,
            uri,
            null,
            baseuri,
            [
                BUT.PathKind,
                BUT.Folder,
            ],
            Callbacks.onVideoPlaybackFolderButton_,
        ).titleKey_(RS.Video
        ).zindex_(DEF.zindexPrompt
        ).onOK_((d, uri, _, okcallback) => {
            const u = uri == null ? null : _Util.getUriOfKind1_(d.getFieldAt_(0).getButton_(BUT.PathKind)!, uri);
            Sanitizers.checkRequiredUri_(u).onFail_(msgs => {
                okcallback(false);
                d.warn_(msgs);
            })?.onOK_(uri => {
                okcallback(true);
                callback(uri);
            });
        }).show_();
    }

    static replaceLink<T extends HTMLElement>(parent: HTMLElement, target: T, u: Uri, attrs: StringMap<stringX>): T {
        const ret = DomBuilderEx.offline_(target.ownerDocument, target.tagName, attrs).cursor_() as T;
        history$.group_(RS.action_EditLink, An.filenameFromUri_(u), () => {
            const b = new DomBuilderEx(parent);
            b.push_().childBefore_(target, ret);
            b.moveChildren_(target.firstChild, null);
            b.pop_().removeChild_(target);
            native$.iSelectNode_(ret);
        });
        return ret;
    }

    static _textchildonly(target: HTMLElement): boolean {
        for (let c = target.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType != Node.TEXT_NODE) {
                return false;
            }
        }
        return true;
    }

    static _actionEditImg(target: HTMLElement, baseuri: BaseUri, updater: Fun20X<HTMLElement, boolean> = null): void {
        const parent = target.parentElement;
        const src = target.getAttribute("src");
        if (parent == null) {
            toasters$.warn_(MSG.string_(RS.InvalidSelection));
            return;
        }
        if (src != null && src.startsWith("data:image/")) {
            _MainPanel._actionEditElementRaw1(target, baseuri, updater);
            return;
        }
        _MainPanel._actionEditImg2(target, RS.EditImgTitle, src, baseuri, (uri, attrs) => {
            if (uri == null) { return; }
            attrs["src"] = uri.encoded$;
            history$.group_(RS.action_EditIMG, An.filenameFromUri_(uri), () => {
                const ret = DomBuilderEx.offline_(target.ownerDocument, "IMG", attrs).cursor_();
                parent.replaceChild(ret, target);
                native$.iSelectNode_(ret);
                updater?.(ret, false);
            });
        });
    }

    static _actionEditImg2(target: HTMLElement, titlekey: StringId, src: stringX, baseuri: BaseUri, updater: UriAttrsCallback): void {
        const sorted = JsUtil.sortedAttributes_(target);
        sorted.delete("src");
        let srcuri = HumanLink.Empty$;
        if (src != null && src.length > 0) {
            srcuri = HumanLink.fromHref_(src);
        }
        const d = new PromptEditMedia(
            accessories$,
            srcuri ?? HumanLink.Empty$,
            An.attributesToStringForEdit_(sorted, " ", ["xmlns"]),
            baseuri,
            [
                BUT.PathKind,
                BUT.Folder,
            ],
            Callbacks.onAnyImageFolderButton_);
        d.titleKey_(titlekey);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, uri, attr, okcallback) => {
            const u = uri == null ? null : _Util.getUriOfKind1_(d.getFieldAt_(0).getButton_(BUT.PathKind)!, uri);
            Sanitizers.checkRequiredUri_(u).onFail_(msgs => {
                okcallback(false);
                d.warn_(msgs);
            })?.onOK_(uri => {
                Sanitizers.checkAttrs_(attr, baseuri, (ret) => {
                    if (d.warn_(ret)) {
                        okcallback(false);
                        return;
                    }
                    toasters$.warn_(ret[Key.warns]);
                    okcallback(true);
                    updater?.(uri, ret[Key.attrs]);
                });
            });
        });
        d.show_();
    }

    static _actionEditMedia(
        target: HTMLElement,
        title: string,
        baseuri: BaseUri,
        foldercallback: PromptFilepathCallback,
        updater: Fun20X<HTMLElement, boolean> = null,
    ): void {
        const parent = target.parentElement;
        if (parent == null) {
            toasters$.warn_(MSG.string_(RS.InvalidSelection));
            return;
        }
        _MainPanel._actionEditMediaElement(target, title, baseuri, foldercallback, (uri, attrs) => {
            if (uri == null) { return; }
            history$.group_(RS.action_EditIMG, An.filenameFromUri_(uri), () => {
                attrs["src"] = uri.encoded$;
                const ret = DomBuilderEx.offline_(target.ownerDocument, target.tagName, attrs).cursor_();
                parent.replaceChild(ret, target);
                native$.iSelectNode_(ret);
                updater?.(ret, false);
            });
        })?.show_();
    }

    private static _actionEditMediaElement(
        target: HTMLElement,
        title: string,
        baseuri: BaseUri,
        foldercallback: PromptFilepathCallback,
        updater: UriAttrsCallback,
    ): PromptEditMedia {
        const src = target.getAttribute("src");
        const sorted = JsUtil.sortedAttributes_(target);
        sorted.delete("src");
        const attrs = An.attributesToStringForEdit_(sorted, " ", ["xmlns"]);
        return this.promptEditMedia_(title, src, attrs, baseuri, foldercallback, updater);
    }

    static promptEditMedia_(
        titlekey: StringId,
        src: stringX,
        attrs: stringX,
        baseuri: BaseUriX,
        foldercallback: PromptFilepathCallback,
        updater: UriAttrsCallback,
    ): PromptEditMedia {
        let srcuri = HumanLink.Empty$;
        if (src != null && src.length > 0) {
            srcuri = HumanLink.fromHref_(src);
        }
        return new PromptEditMedia(accessories$, srcuri, attrs, baseuri, [BUT.PathKind, BUT.Folder], foldercallback)
            .titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt)
            .onOK_((d, uri, attrs, okcallback) => {
                const u = uri == null ? null : _Util.getUriOfKind1_(d.getFieldAt_(0).getButton_(BUT.PathKind)!, uri);
                Sanitizers.checkRequiredUri_(u).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(uri => {
                    Sanitizers.checkAttrs_(attrs, baseuri, (ret) => {
                        if (d.warn_(ret)) {
                            okcallback(false);
                            return;
                        }
                        toasters$.warn_(ret[Key.warns]);
                        okcallback(true);
                        updater?.(uri, ret[Key.attrs]);
                    });
                });
            });
    }

    static _actionInsertNode(titlekey: StringId, e: MouseEvent, callback: Fun30<Node, boolean, Range>): void {
        const range = _MainPanel._requireNonBodySelection();
        if (range == null) { return; }
        const ancestors = native$.iGetAncestors_();
        if (ancestors == null || ancestors.length == 0) {
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        new PromptAncestors(accessories$, ancestors)
            .titleKey_(titlekey)
            .zindex_(DEF.zindexPrompt)
            .onOK_((target, after) => {
                native$.focusIFrame_();
                host$.showKeyboard_();
                history$.group_(
                    titlekey,
                    MSG.string_(after ? RS.Tooltips_InsertAsNextSibling : RS.Tooltips_InsertAsFirstChild), () => {
                        callback(target, after, range);
                    });
            }).showAt_(e.x, e.y, true);
    }

    static _actionParagraph(e: MouseEvent): void {
        const doc = native$.getIFrameDocument_();
        if (doc == null) return;
        const div = DomBuilderEx.offline_(doc, "div").append_("br").cursor_();
        this._actionInsertNode(RS.Paragraph, e, (target, after, range) => {
            if (after) {
                const parent = target.parentElement;
                if (parent != null) {
                    new DomBuilderEx(parent).childBefore_(target.nextSibling, div);
                }
            } else {
                const elm = DomUt.asHTMLElement_(target);
                if (elm != null) {
                    new DomBuilder(elm).childBeforeFirst_(div);
                } else {
                    range.collapse(false);
                    range.insertNode(div);
                }
            }
            Timer.sleep0_(() => {
                native$.iSetCaretAtStart_(div.firstChild, true);
            });
        });
    }

    static _actionInsertText(e: MouseEvent): void {
        const doc = native$.getIFrameDocument_();
        if (doc == null) return;
        const text = doc.createTextNode(" " + MSG.XXX$);
        this._actionInsertNode(RS.Text, e, (target, after, range) => {
            if (after) {
                const parent = target.parentElement;
                if (parent != null) {
                    new DomBuilderEx(parent).insertBefore_(target.nextSibling, text);
                }
            } else {
                const elm = DomUt.asHTMLElement_(target);
                if (elm != null) {
                    new DomBuilder(elm).insertBefore_(elm.firstChild, text);
                } else {
                    range.collapse(false);
                    range.insertNode(text);
                }
            }
            native$.iSelect_(text, 1, text.length);
        });
    }

    static _actionCreateLinkOK(range: RangeX): stringX {
        if (range == null) {
            return MSG.string_(RS.ActionRequireAValidSelection);
        }
        const start = range.startContainer;
        const end = range.endContainer;
        if (start == null || end == null) {
            return MSG.string_(RS.InvalidSelection);
        }
        if (start != end) {
            return MSG.string_(RS.ActionRequireASelectionThatStartsAndEndsUnderTheSameParent);
        }
        if (start.nodeType == Node.ELEMENT_NODE && An.isHtmlElement_(start.nodeName)) {
            return MSG.string_(RS.ActionNotPermittedOnBodyElement);
        }
        return null;
    }

    static _actionCreateLink2(range: Range, baseuri: BaseUri): void {
        _Util.promptLink2_(RS.InsertLinkTitle, HumanLink.Empty$, "", baseuri, (u, attrs) => {
            history$.group_(RS.action_InsertLink, An.filenameFromUri_(u), () => {
                if (u == null) delete attrs["href"];
                else attrs["href"] = u.encoded$;
                const elm = RangeUtil.wrapRange_("A", attrs, range);
                Timer.sleep0_(() => {
                    native$.iSelectNode_(elm);
                });
            });
        })
            .show_();
    }

    static _actionCreateLink3(range: Range, text: string, baseuri: BaseUri): void {
        const d = _Util.promptLink3_(RS.InsertLinkTitle, false, HumanLink.Empty$, text, "", baseuri, (u, text, attrs) => {
            history$.group_(RS.action_InsertLink, An.filenameFromUri_(u), () => {
                if (u == null) delete attrs["href"];
                else attrs["href"] = u.encoded$;
                const doc = RangeUtil.rangeOwnerDocument_(range)!;
                const elm = DomBuilderEx.offline_(doc, "A", attrs).text_(text).cursor_();
                RangeUtil.replaceRange_(range, elm);
                Timer.sleep0_(() => {
                    native$.iSelectNode_(elm);
                });
            });
        });
        d.show_();
    }

    static _actionInsertLink(): void {
        const range = native$.getIFrameSelectionRange_();
        if (toasters$.warn_(_MainPanel._actionCreateLinkOK(range)) || range == null) {
            return;
        }
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) {
            return;
        }
        let text = range.collapsed ? "" : native$.getTextSelectionOfRange_(range);
        if (text != null) {
            _MainPanel._actionCreateLink3(range, text, baseuri);
        } else {
            _MainPanel._actionCreateLink2(range, baseuri);
        }
    }

    static _actionInsertNamedAnchor(): void {
        const range = native$.getIFrameSelectionRange_();
        if (toasters$.warn_(_MainPanel._actionCreateLinkOK(range)) || range == null) {
            return;
        }
        let text: string = An.simpleDateTimeString_();
        if (!range.collapsed) {
            text = RangeUtil.getText_(range)?.trim() ?? text;
        }
        const doc = range.startContainer.ownerDocument;
        if (doc == null) return;
        new PromptNamedAnchor(accessories$, text)
            .titleKey_(RS.ActionInsertNamedAnchorTitle)
            .zindex_(DEF.zindexPrompt)
            .onOK_((_, name, showicon, done) => {
                const attrs = smap1_("name", name);
                history$.group_(RS.ActionInsertNamedAnchorTitle, name, () => {
                    done(true);
                    const b = DomBuilderEx.offline_(doc, "span").push_();
                    b.child_("span", smap_(
                        ["class", CSS.xSymbol],
                        ["style", `font-family: FontAwesome;${showicon ? "" : "display:none;"}`],
                    ));
                    b.text_("\uf02b ");
                    b.peek_().text_(" ").child_("a", attrs);
                    range.collapse(false);
                    const elm = RangeUtil.insertNode_(range, b.pop_().cursor_());
                    if (elm != null) {
                        Timer.sleep0_(() => {
                            native$.iSelectNode_(elm);
                        });
                    }
                });
            }).show_();
    }

    static _actionInsertImg(): void {
        const range = _MainPanel._requireNonBodySelection();
        const baseuri = native$.getIFrameUri_();
        if (range != null && baseuri != null) {
            _MainPanel._actionInsertImg1(range, `class ${CSS.xImageholder} ${CSS.xImageDef}`, baseuri, An.noop_).show_();
        }
    }

    /**
       * @param callback(ok) ok=false if cancelled or on error.
       */
    static _actionInsertImg1(range: Range, attrs: string, baseuri: BaseUri, callback: BoolCallback): PromptInsertImg {
        return _Util.promptInsertImg1_(RS.InsertImageTitle, attrs, baseuri, Callbacks.onAnyImageFolderButton_, result => {
            if (result != null) {
                _MainPanel._createimg(range, result.caption, result);
            }
            callback(result != null);
        });
    }

    /**
       * @return The IMG element.
       * Note that there may be link or caption wrappers created around the IMG element.
       */
    static _createimg(range: Range, caption: stringX, result: PromptInsertImgResult): HTMLImageElement {
        const doc = RangeUtil.rangeOwnerDocument_(range)!;
        const img = DomBuilderEx.offline_(doc, "img", {
            "src": result.src.toString(),
        }).attrs_(result.attrs).cursor_() as HTMLImageElement;
        let elm: HTMLElement = img;
        history$.group_(RS.action_InsertImage, An.filenameFromUri_(result.src), () => {
            if (result.link != null) {
                elm = DomBuilderEx.offline_(doc, "a", {
                    "href": result.link.toString(),
                }).appendNodes_(img).cursor_();
            }
            if (caption != null && caption.length > 0) {
                const b = DomBuilderEx.offline1_(doc, "div", CSS.xVlayout)
                    .push_()
                    .div_()
                    .child_(elm)
                    .peek_()
                    .div1_(CSS.xVcaption);
                b.span_().text_(caption);
                elm = b.pop_().cursor_();
            }
            RangeUtil.replaceRange_(range, elm);
        });
        return img;
    }

    static _actionInsertAudio() {
        const range = _MainPanel._requireNonBodySelection();
        const doc = range == null ? null : RangeUtil.rangeOwnerDocument_(range);
        const baseuri = native$.getIFrameUri_();
        if (range == null || doc == null || baseuri == null) return;
        const src = "/Home/drafts/audio-" + An.simpleDateTimeString_() + MimeUtil.audioRecordingSuffix_();
        this.promptEditMedia_(RS.Audio, src, "", baseuri, Callbacks.onAudioPlaybackFolderButton_, (uri, attrs) => {
            this._createAudioElement(range, doc, uri, attrs);
        })?.show_();
    }

    static _createAudioElement(range: Range, doc: Document, uri: Uri, attrs: StringMap<string>) {
        history$.group_(RS.InsertAudioTooltips, uri.encoded$, () => {
            const b = DomBuilderEx.offline_(doc, "div", smap_(
                ["class", CSS.xWidgetAudio],
                [ATTR.xPlaceholder, Placeholder.xpAudioinfo]
            )).push_();
            WidgetUt.createXaudio_(b, uri.encoded$, attrs);
            WidgetUt._captionWithAudioInfo(b);
            range.collapse();
            const top = b.pop_().cursor_();
            RangeUtil.replaceRange_(range, top);
            mainPanel$.processPlaceholders_([top], () => {
                native$.iSetCaretAtEnd_(top, true);
            });
        });
    }

    static _actionInsertVideo() {
        const range = _MainPanel._requireNonBodySelection();
        const doc = range == null ? null : RangeUtil.rangeOwnerDocument_(range);
        const baseuri = native$.getIFrameUri_();
        if (range == null || doc == null || baseuri == null) return;
        const src = "/Home/drafts/video-" + An.simpleDateTimeString_() + MimeUtil.videoRecordingSuffix_();
        this.promptEditMedia_(RS.Video, src, "", baseuri, Callbacks.onVideoPlaybackFolderButton_, (uri, attrs) => {
            this._createVideoElement(range, doc, uri, attrs);
        })?.show_();
    }

    static _createVideoElement(range: Range, doc: Document, uri: Uri, attrs: StringMap<string>) {
        history$.group_(RS.InsertVideoTooltips, uri.encoded$, () => {
            const b = DomBuilderEx.offline_(doc, "div", smap_(
                ["class", CSS.xWidgetVideo],
                [ATTR.xPlaceholder, Placeholder.xpVideoinfo]
            )).push_();
            WidgetUt.createVideo_(b, uri.encoded$, attrs);
            WidgetUt._captionWithVideoInfo(b);
            range.collapse();
            const top = b.pop_().cursor_();
            RangeUtil.replaceRange_(range, top);
            mainPanel$.processPlaceholders_([top], () => {
                native$.iSetCaretAtEnd_(top, true);
            });
        });
    }

    static _actionPasteFromSystemClipboard() {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return false;
        }
        native$.focusIFrame_();
        history$.group_(RS.Tooltips_PasteFromSystemClipboard, "", () => {
            host$.pasteFromClipboard_(ret => {
                if (toasters$.warn_(ret)) return;
                const doc = RangeUtil.rangeOwnerDocument_(range);
                if (doc == null) return;
                const text = ret[Key.result] as stringX;
                if (text == null || text.length == 0) return;
                RangeUtil.replaceRange_(range, doc.createTextNode(text));
            });
        });
        return true;
    }

    static _actionListItem(tag: string, attrs: StringMapX<string> = null): boolean {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return false;
        }
        native$.focusIFrame_();
        history$.group_(RS.action_ListItem, tag, () => {
            const li = RangeUtil.wrapRange_("li", null, range);
            let prev: HTMLElementX = null;
            let ul: HTMLElementX = null;
            for (let p = li.parentElement; p != null; p = p.parentElement) {
                const name = p.nodeName;
                if ("UL" == name || "OL" == name) {
                    ul = p;
                    break;
                } else if ("LI" == name) {
                    prev = p;
                }
            }
            if (ul == null) {
                JsUtil.wrapNode_(li, tag, attrs);
            } else if (prev == null) {
                new DomBuilderEx(ul).appendNodes_(li);
            } else {
                new DomBuilderEx(ul).insertBefore_(prev.nextSibling, li);
            }
            _MainPanel._actionListPlaceholder(li);
        });
        return true;
    }

    static _actionListCompact(compact: boolean): boolean {
        let elm = native$.getNearestSelectedElement_();
        while (elm != null) {
            const name = elm.nodeName;
            if (name == "UL" || name == "OL") {
                const classlist = elm.classList;
                if (compact) {
                    classlist.add(CSS.xCompact);
                } else {
                    classlist.remove(CSS.xCompact);
                }
                return true;
            } else if (name == "BODY") {
                break;
            }
            elm = elm.parentElement;
        }
        toasters$.warnKey_(RS.ListElementNotFound);
        return false;
    }

    static _actionListPlaceholder(elm: HTMLElement): HTMLElement {
        const text = _MainPanel._shouldCreatePlaceholder(elm);
        if (text != null) {
            const textnode = DomBuilderEx.createText_(text);
            new DomBuilderEx(elm).appendNodes_(textnode);
            native$.iSelectNode_(textnode);
        } else {
            native$.iSetCaretAtEnd_(elm.lastChild, true);
        }
        return elm;
    }

    static _shouldCreatePlaceholder(elm: HTMLElement): stringX {
        const children = JsUtil.childNodes_(elm);
        const insertexthere = MSG.XXX$;
        if (children.length == 0) {
            return insertexthere;
        }
        const content: string[] = [];
        for (const child of children) {
            if (child.nodeType != Node.TEXT_NODE) {
                return null;
            }
            content.push(child.nodeValue ?? "");
        }
        const text = content.join().trim();
        return (text.length == 0 ? insertexthere : null);
    }

    static _actionListItemSymbol(): void {
        const range = native$.getIFrameSelectionRange_();
        const ret = _MainPanel._findEnclosingList(range);
        if (ret == null || range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const ul = ret[0];
        const li = ret[1];
        _SymbolPreferences.get_((session: _SymbolPreferences) => {
            const d = new PromptSymbol(accessories$, session);
            d.titleKey_(RS.PickSymbol);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((symbol, tooltips, styles) => {
                native$.focusIFrame_();
                history$.group_(RS.action_ListSymbol, tooltips ?? "", () => {
                    let b;
                    const elm = RangeUtil.wrapRange_("span", { "class": CSS.xListContent }, range);
                    if (ul != null) {
                        b = new DomBuilderEx(ul);
                        if (li == null) {
                            b.childBefore_(ul.firstChild, "li", {
                                "class": CSS.xList,
                            });
                        } else {
                            b.childBefore_(li.nextSibling, "li", {
                                "class": CSS.xList,
                            });
                        }
                    } else {
                        b = new DomBuilderEx(elm.parentElement!);
                        b.childBefore_(elm, "ul", { "class": CSS.xNone }).li1_(CSS.xList);
                    }
                    b.push_().span1_(CSS.xBullet).addStyles_(styles).text_(symbol + " ");
                    b.pop_().child_(elm);
                    _MainPanel._actionListPlaceholder(elm);
                });
            });
            d.onCancel_(() => native$.focusIFrame_());
            d.show_();
        });
    }

    static _actionListSymbols(): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        _SymbolPreferences.get_((session: _SymbolPreferences) => {
            const d = new PromptSymbol(accessories$, session);
            d.titleKey_(RS.PickSymbol);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((symbol, tooltips, styles) => {
                native$.focusIFrame_();
                history$.group_(RS.action_ListSymbol, tooltips ?? "", () => {
                    const elm = RangeUtil.wrapRange_("span", { "class": CSS.xListContent }, range);
                    const b = new DomBuilderEx(elm.parentElement!);
                    b.childBefore_(elm, "ul", { "class": CSS.xNone }).li1_(CSS.xList);
                    JsUtil.remove_(elm);
                    b.push_().span1_(CSS.xBullet).addStyles_(styles).text_(symbol + " ");
                    b.pop_().child_(elm);
                    _MainPanel._actionListPlaceholder(elm);
                });
            });
            d.onCancel_(() => native$.focusIFrame_());
            d.show_();
        });
    }

    static _actionListItemText(): boolean {
        const range = native$.getIFrameSelectionRange_();
        const ret = _MainPanel._findEnclosingList(range);
        if (ret == null || range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return false;
        }
        const ul = ret[0];
        const li = ret[1];
        const d = new PromptInput(accessories$, RS.TextBullet_Title, MSG.XXX$);
        d.messageKey_(RS.TextBullet_Message);
        d.onOK_((_d, label, okcallback) => {
            okcallback(true);
            native$.focusIFrame_();
            history$.group_(RS.action_ListText, label, () => {
                const elm = RangeUtil.wrapRange_("span", { "class": CSS.xListContent }, range);
                let b: DomBuilderEx;
                if (ul != null) {
                    b = new DomBuilderEx(ul);
                    if (li != null) {
                        b.childBefore_(li.nextSibling, "li", {
                            "class": CSS.xList,
                        });
                    } else {
                        b.childBefore_(null, "li", {
                            "class": CSS.xList,
                        });
                    }
                } else {
                    b = new DomBuilderEx(elm.parentElement!);
                    b.childBefore_(elm, "ul", { "class": CSS.xNone }).li1_(CSS.xList);
                }
                JsUtil.remove_(elm);
                label = replaceAll_(label, " ", "\u00a0");
                b.push_().span1_(CSS.xBulletText).text_(label + " ");
                b.pop_().child_(elm);
                _MainPanel._actionListPlaceholder(elm);
            });
        });
        d.onCancel_(() => native$.focusIFrame_());
        d.show_();
        return true;
    }

    static _actionListDate(): boolean {
        const range = native$.getValidIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return false;
        }
        const now = An.now00_();
        const d = new PromptDate(
            accessories$,
            now,
            now,
            PromptDate.ALL,
            cache$.ui$.buttonSize_());
        d.titleKey_(RS.PromptDateTimeTitle);
        d.zindex_(DEF.zindexPrompt);
        d.dateFormat_(settings$.dateFormat_());
        d.timeFormat_(settings$.timeFormat_());
        d.preferredDateFormat_(settings$.shortDateFormat_());
        d.onOK_((date: DateTime, dateformat: string, timeformat: string, formatted: string) => {
            native$.focusIFrame_();
            history$.group_(RS.action_ListDatetime, formatted, () => {
                const elm = RangeUtil.wrapRange_("span", { "class": CSS.xListContent }, range);
                const parent = elm.parentElement!;
                const b = new DomBuilderEx(parent);
                b.childBefore_(elm, "ul", { "class": CSS.xNone }).li1_(CSS.xList);
                JsUtil.remove_(elm);
                b.push_().span_(
                    ["class", `${CSS.xDate} ${CSS.xBulletDatetime}`],
                    [ATTR.xDateFormat, An.xDateFormatValue_(dateformat, timeformat, date)],
                ).text_(replaceAll_(formatted, " ", "\u00a0") + "\u00a0");
                b.pop_().child_(elm);
                _MainPanel._actionListPlaceholder(elm);
            });
        });
        d.onCancel_(() => native$.focusIFrame_());
        d.showTab_(PromptDate.DATE);
        return true;
    }

    static _actionListItemDate(): boolean {
        return _MainPanel._actionListItemDatetime(PromptDate.DATE, settings$.shortDateFormat_(), "");
    }

    static _actionListItemTime(): boolean {
        return _MainPanel._actionListItemDatetime(PromptDate.TIME, "", settings$.timeFormat_());
    }

    static _actionListItemDatetime(tab: number, preferreddateformat: string, preferredtimeformat: string): boolean {
        const range = native$.getValidIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return false;
        }
        const [ul, li] = _MainPanel._findEnclosingList(range);
        const now = An.now00_();
        new PromptDate(
            accessories$,
            now,
            now,
            PromptDate.ALL,
            cache$.ui$.buttonSize_())
            .titleKey_(RS.PromptDateTimeTitle)
            .zindex_(DEF.zindexPrompt)
            .dateFormat_(settings$.dateFormat_())
            .timeFormat_(settings$.timeFormat_())
            .preferredDateFormat_(preferreddateformat)
            .preferredTimeFormat_(preferredtimeformat)
            .onOK_((date: DateTime, dateformat: string, timeformat: string, formatted: string) => {
                native$.focusIFrame_();
                history$.group_(RS.action_ListDatetime, formatted, () => {
                    const elm = RangeUtil.wrapRange_("span", { "class": CSS.xListContent }, range);
                    let b: DomBuilderEx;
                    if (ul != null) {
                        b = new DomBuilderEx(ul);
                        if (li != null) {
                            b.childBefore_(li.nextSibling, "li", {
                                "class": CSS.xList,
                            });
                        } else {
                            b.childBefore_(null, "li", {
                                "class": CSS.xList,
                            });
                        }
                    } else {
                        b = new DomBuilderEx(elm.parentElement!);
                        b.childBefore_(elm, "ul", { "class": CSS.xNone }).li1_(CSS.xList);
                    }
                    JsUtil.remove_(elm);
                    b.push_().span_(
                        ["class", `${CSS.xDate} ${CSS.xBulletDatetime}`],
                        [ATTR.xDateFormat, An.xDateFormatValue_(dateformat, timeformat, date)],
                    ).text_(replaceAll_(formatted, " ", "\u00a0") + "\u00a0");
                    b.pop_().child_(elm);
                    _MainPanel._actionListPlaceholder(elm);
                });
            })
            .onCancel_(() => native$.focusIFrame_())
            .showTab_(tab);
        return true;
    }

    static _getStartElement(range: RangeX): HTMLElementX {
        if (range == null) { return null; }
        let ret: HTMLElementX = null;
        let start = range.startContainer;
        const startoffset = range.startOffset;
        const type = start.nodeType;
        if (type == Node.ELEMENT_NODE) {
            start = start.childNodes[startoffset];
        }
        if (start != null) {
            ret = DomUt.asHTMLElement_(start) ?? start.parentElement;
        }
        return ret;
    }

    static _findEnclosingList(range: RangeX): [ul: HTMLElementX, li: HTMLElementX] {
        let node = _MainPanel._getStartElement(range);
        if (node == null) {
            return [null, null];
        }
        let li: HTMLElementX = null;
        let ul: HTMLElementX = null;
        while (node != null) {
            const name = node.nodeName;
            if (name == "LI") {
                li = node;
            } else if (name == "UL" || name == "OL") {
                ul = node;
                break;
            } else if (name == "BODY") {
                break;
            }
            node = node.parentElement;
        }
        return [ul, li];
    }

    private _setbutton(action: string, enable: boolean): void {
        const button = this._contextmenu._buttons.get(action);
        if (button !== undefined) {
            An.enableButton_(button, enable);
        }
    }

    updateContextmenuState_(): void {
        const range0 = native$.getIFrameSelectionRange_();
        const node1 = native$.getSingleSelectedNodeOfRange_(range0);
        const start0 = (range0 == null ? null : range0.startContainer);
        const name1 = (node1 != null ? node1.nodeName : null);
        const isbody = (node1 != null && name1 != null && An.isBodyElement_(name1)
            || start0 != null && An.isHtmlElement_(start0.nodeName));
        const node1notbody = node1 != null && !isbody;
        const element1 = (node1notbody && node1 != null && node1.nodeType == Node.ELEMENT_NODE);
        const collapsed0 = (range0 != null && range0.collapsed);
        const notcollapsed0 = (range0 != null && !range0.collapsed);
        const collapsednotbody = (collapsed0 && start0 != null && !An.isHtmlElement_(start0.nodeName));
        let rowparent: NodeX = null;
        if (collapsednotbody && start0 != null) {
            rowparent = JsUtil.getSplitParent_(start0);
        }
        const parentisbody = (start0 != null && An.isBodyElement_(start0.nodeName));
        this._setbutton(MainContextActions._COPY, notcollapsed0 && !isbody || rowparent != null);
        this._setbutton(MainContextActions._CUT, notcollapsed0 && !isbody || rowparent != null);
        const pasteok = (range0 != null && !isbody && !clipboard$.isEmpty_());
        this._setbutton(MainContextActions._PASTE_CHILD, pasteok);
        this._setbutton(MainContextActions._PASTE_SIBLING, pasteok);
        const hashistory = !history$.isUndoEmpty_();
        const hasredo = !history$.isRedoEmpty_();
        this._setbutton(MainContextActions._UNDO, hashistory);
        this._setbutton(MainContextActions._UNDO_HISTORY, hashistory);
        this._setbutton(MainContextActions._REDO, hasredo);
        this._setbutton(MainContextActions._PARENT_NODE, range0 != null && !isbody);
        _MainPanel._actionSelectNextSiblingOK(range0, (err) => {
            this._setbutton(MainContextActions._SELECT_NEXT_SIBLING, err == null);
        });
        this._setbutton(MainContextActions._WRAP, JsUtil.actionWrapOK_(range0) == null);
        this._setbutton(MainContextActions._INSERT_ELEMENT, node1 != null || collapsednotbody);
        this._setbutton(MainContextActions._PARAGRAPH, node1notbody || collapsednotbody);
        this._setbutton(MainContextActions._INSERT_TEXT, (node1notbody || collapsednotbody && !parentisbody));
        this._setbutton(MainContextActions._UNWRAP, element1 && node1 != null && node1.firstChild != null);
        this._setbutton(MainContextActions._SPAWN_NODE, rowparent != null || element1);
        this._setbutton(MainContextActions._EDIT_STYLE, collapsednotbody || element1);
        this._setbutton(MainContextActions._EDIT_STYLE_RAW, collapsednotbody || element1);
        this._setbutton(MainContextActions._EDIT_NODE, collapsednotbody || node1notbody);
        this._setbutton(MainContextActions._EDIT_NODE_RAW, collapsednotbody || node1notbody);
        this._setbutton(MainContextActions._EDIT_ALIGN, element1);
        this._setbutton(MainContextActions._BORDER, element1);
        this._setbutton(MainContextActions._EDIT_SIZE, element1);
        this._setbutton(MainContextActions._MOVETO_PARENT, node1notbody && !parentisbody);
        this._setbutton(MainContextActions._MOVETO_PREV,
            (rowparent != null && _MainPanel._hasNonEmptySibling(rowparent)
                || node1notbody && node1 != null && _MainPanel._hasNonEmptySibling(node1)));
        this._setbutton(MainContextActions._MOVETO_NEXT,
            (rowparent != null && _MainPanel._hasNonEmptySibling(rowparent)
                || node1notbody && node1 != null && _MainPanel._hasNonEmptySibling(node1)));
        const insertok = (range0 != null && !isbody);
        this._setbutton(MainContextActions._INSERT_IMG, insertok);
        this._setbutton(MainContextActions._INSERT_AUDIO, insertok);
        this._setbutton(MainContextActions._INSERT_VIDEO, insertok);
        this._setbutton(MainContextActions._INSERT_CANVAS, insertok);
        this._setbutton(MainContextActions._INSERT_SYMBOL, insertok);
        this._setbutton(MainContextActions._INSERT_DATE, insertok);
        this._setbutton(MainContextActions._INSERT_CALENDAR, insertok);
        this._setbutton(MainContextActions._INSERT_ALARM, insertok);
        this._setbutton(MainContextActions._LIST_SYMBOLS, insertok);
        this._setbutton(MainContextActions._LIST_ITEM_SYMBOL, insertok);
        this._setbutton(MainContextActions._LIST_DATE, insertok);
        this._setbutton(MainContextActions._LIST_ITEM_DATE, insertok);
        this._setbutton(MainContextActions._INSERT_WIDGET, insertok);
        this._setbutton(MainContextActions._DESTRUCT_WIDGET, element1);
        this._setbutton(MainContextActions._INSERT_LINK, _MainPanel._actionCreateLinkOK(range0) == null);
        this._setbutton(MainContextActions._TAKE_PHOTO, false);
        this._setbutton(MainContextActions._RECORD_VIDEO, false);
        this._setbutton(MainContextActions._RECORD_AUDIO, false);
        if (("IMG" == name1 || "CANVAS" == name1)) {
            this._setbutton(MainContextActions._ANNOTATE_IMG, true);
            An.show_(this._contextmenu._buttons.get(MainContextActions._ANNOTATE_IMG)!);
            An.hide_(this._contextmenu._buttons.get(MainContextActions._INSERT_CANVAS)!);
        } else {
            An.show_(this._contextmenu._buttons.get(MainContextActions._INSERT_CANVAS)!);
            An.hide_(this._contextmenu._buttons.get(MainContextActions._ANNOTATE_IMG)!);
        }
        const buttons = this._contextmenu._menubarButtons;
        let activemenu: stringX = null;
        for (const name of buttons.keys()) {
            if (buttons.get(name)!.classList.contains(CSS.AnSelected)) {
                activemenu = name;
                break;
            }
        }
        if (range0 == null) {
            if (activemenu != null) {
                this._contextmenu.hideSubmenu_(activemenu);
            }
            for (const button of buttons.values()) {
                An.enableButton_(button, false);
            }
            return;
        }
        const font = MainContextActions._SUBMENU_FONT;
        const char = MainContextActions._SUBMENU_CHAR;
        const para = MainContextActions._SUBMENU_PARA;
        const list = MainContextActions._SUBMENU_LIST;
        const media = MainContextActions._SUBMENU_MEDIA;
        const others = MainContextActions._SUBMENU_OTHERS;
        An.enableButton_(buttons.get(font)!, notcollapsed0 && !isbody);
        An.enableButton_(buttons.get(char)!, notcollapsed0 && !isbody);
        An.enableButton_(buttons.get(para)!, element1);
        An.enableButton_(buttons.get(list)!, !isbody);
        An.enableButton_(buttons.get(media)!, !isbody);
        An.enableButton_(buttons.get(others)!, true);
        if (isbody) {
            if (activemenu != null && activemenu != others) {
                this._contextmenu.hideSubmenu_(activemenu);
                activemenu = null;
            }
            if (activemenu == null) {
                this._contextmenu.showSubmenu_(others);
                activemenu = others;
            }
            return;
        }
        if (range0 == null || collapsed0) {
            if (activemenu == null || activemenu == char || activemenu == font || activemenu == para) {
                if (activemenu != null) {
                    this._contextmenu.hideSubmenu_(activemenu);
                }
                this._contextmenu.showSubmenu_(list);
            }
            return;
        }
        if (activemenu == null) {
            this._contextmenu.showSubmenu_(element1 ? para : char);
            return;
        }
        if (activemenu == para && !element1) {
            this._contextmenu.hideSubmenu_(activemenu);
            this._contextmenu.showSubmenu_(char);
            activemenu = char;
            return;
        }
        if (activemenu == font) {
            this._contextmenu.updateFontSubmenuState(range0);
        }
    }

    static _nonEmptySibling(node: Node, sibling: Fun11<Node, NodeX>): NodeX {
        let n: NodeX = sibling(node);
        for (; n != null; n = sibling(n)) {
            if (!JsUtil.isEmptyTextNode_(n)) {
                return n;
            }
        }
        return null;
    }

    static _hasNonEmptySibling(node: Node): boolean {
        const parent = node.parentNode;
        if (parent != null) {
            for (let n = parent.firstChild; n != null; n = n.nextSibling) {
                if (n != node && !JsUtil.isEmptyTextNode_(n)) {
                    return true;
                }
            }
        }
        return false;
    }

    static _revealHierarchy(node: Node): void {
        const parents = new Array<HTMLElement>();
        for (let parent = node.parentElement; parent != null && "BODY" != parent.nodeName; parent = parent.parentElement) {
            parents.unshift(parent);
        }
        const panels = Array.from(native$.iQueryAll_<HTMLElement>(`#${ID.xRightSidepanel}, #${ID.xLeftSidepanel}`));
        for (const panel of panels) {
            if (parents.includes(panel)) {
                continue;
            }
            native$.setDisplay_(panel, "none");
        }
        const list = Array.from(native$.iQueryAll_<HTMLElement>(`div.${CSS.xAnnotation} > div.${CSS.xSmokescreen}`));
        for (const sm of list) {
            if (!parents.includes(sm)) {
                _MainPanel._hideAnnotation1(sm);
            }
        }
        for (const n of parents) {
            const id = n.getAttribute("id");
            if (n != null && (ID.xRightSidepanel == id || ID.xLeftSidepanel == id)) {
                native$.setDisplay_(n, "block");
            } else {
                const classlist = n.classList;
                if (classlist.contains(CSS.xAnnotationContent)) {
                    const grandparent = n.parentElement?.parentElement;
                    if (grandparent != null && native$.hasClass_(grandparent, CSS.xAnnotation)) {
                        if (_MainPanel._showAnnotation1(grandparent)) {
                            break;
                        }
                    }
                }
            }
        }
    }

    static _isTesting(): boolean {
        return false;
    }

    static _paraStyle1(infos: Map<string, StyleInfo>, style: string): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const labelkey = RS.action_ParaStyle;
        const node = native$.getSingleSelectedNodeOfRange_(range);
        if (node != null) {
            //// Apply builtinParaStyles to any element.
            //// Otherwise, only apply to DIV or P.
            const name = node.nodeName;
            if ("DIV" == name || "P" == name ||
                node.nodeType == Node.ELEMENT_NODE && settings$.builtinParaStylesByName_().get(style) !== undefined) {
                _MainPanel._toggleStyle1(labelkey, infos, style, node as HTMLElement);
                native$.iSelectNode_(node);
                native$.focusIFrame_();
                return;
            }
        }
        history$.group_(labelkey, style, () => {
            const ret = RangeUtil.wrapRange_("div", null, range);
            if (ret != null) {
                _MainPanel._toggleStyle(infos, style, ret);
                const collapsed = range.collapsed;
                if (collapsed) {
                    _MainPanel._placeholderXXX(new DomBuilderEx(ret), null);
                } else {
                    native$.iSelectNode_(ret);
                }
                native$.focusIFrame_();
            }
        });
    }

    static _toggleStyle1(labelkey: StringId, infos: Map<string, StyleInfo>, style: string, node: HTMLElement): void {
        history$.group_(labelkey, style, () => {
            _MainPanel._toggleStyle(infos, style, node);
        });
    }

    /// Remove styles in the same group and add the given style if it does not exists before the removal.
    static _toggleStyle(infos: Map<string, StyleInfo>, style: string, node: HTMLElement): void {
        if (style == null) { return; }
        if (style.length == 0 || style == CSS.xNone) {
            _MainPanel._removeAllStyles(node, infos);
            return;
        }
        const styleinfo = infos.get(style);
        const group = styleinfo === undefined ? null : styleinfo.group$;
        if (group == null || group.length == 0 || node.classList.contains(style)) {
            //// If there are no group information, or the style already exists, simply toggle the style.
            node.classList.toggle(style);
            return;
        }
        const removes = sarray_();
        const adds = [style];
        //// Remove styles of same group and add the style.
        _MainPanel._removeStylesInGroup(removes, group, infos);
        native$.removeAddClasses_(node, removes, adds);
    }

    static _removeAllStyles(node: HTMLElement, infos: Map<string, StyleInfo>): void {
        //// Remove all styles.
        const removes: string[] = [];
        _MainPanel._removeStyles(removes, infos);
        native$.removeAddClasses_(node, removes, null);
    }

    static _removeStyles(removes: string[], infos: Map<string, StyleInfo>): void {
        for (const info of infos.values()) {
            const name = info.name$;
            if (name.length > 0) {
                removes.push(name);
            }
        }
    }

    static _removeStylesInGroup(removes: string[], group: string, infos: Map<string, StyleInfo>): void {
        for (const info of infos.values()) {
            if (info.group$ == group) {
                const name = info.name$;
                if (name.length > 0) {
                    removes.push(name);
                }
            }
        }
    }

    /**
       * @param styles _settings.charStylesByName or _settings.highlightStylesByName.
       */
    static _charStyle1(infos: Map<string, StyleInfo>, style: string): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const labelkey = RS.action_CharStyle;
        const node = native$.getSingleSelectedNodeOfRange_(range);
        if (node != null && node.nodeType == Node.ELEMENT_NODE) {
            _MainPanel._toggleStyle1(labelkey, infos, style, node as HTMLElement);
            native$.iSelectNode_(node);
            return;
        }
        history$.group_(labelkey, style, () => {
            const ret = RangeUtil.wrapRange_("span", null, range);
            if (ret != null) {
                _MainPanel._toggleStyle(infos, style, ret);
                native$.iSelectNode_(ret);
            }
        });
    }

    static _widgetContextAction(name: string): void {
        if (!state$.isEditing_()) {
            toasters$.warnKey_(RS.NotEditing);
            return;
        }
        _WidgetTemplates.create(name);
    }

    static _actionBorder(): void {
        const node = native$.getSingleSelectedNode_();
        if (node == null || node.nodeType != Node.ELEMENT_NODE) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return;
        }
        _MainPanel._actionBorder1(node as HTMLElement, null);
    }

    static _actionBorder1(node: HTMLElement, callback: Fun10X<HTMLElement>): void {
        const border = (function () {
            const computed = PromptBorders.getBorderStyles_(node);
            return PromptBorders.normalizeBorderStyles_((name) => computed.get(name) ?? "");
        })();
        new PromptBorders(
            accessories$,
            cache$.ui$.buttonSize_(),
            border)
            .titleKey_(RS.Borders)
            .zindex_(DEF.zindexPrompt)
            .onOK_((_d, styles, okcallback) => {
                okcallback(true);
                history$.group_(RS.ActionAddBorderTitle, node.nodeName, () => {
                    node.style.border = "";
                    node.style.borderRadius = "";
                    node.style.boxShadow = "";
                    const inherited = function () {
                        const computed = PromptBorders.getBorderStyles_(node);
                        return PromptBorders.normalizeBorderStyles_((name) => computed.get(name) ?? "");
                    }();
                    native$.setStyles_(node, PromptBorders.reduceBorderStyles_(styles, inherited));
                    callback?.(node);
                });
            })
            .onCancel_(() => {
                callback?.(node);
                history$.endGroup_();
            })
            .show_();
    }

    static _placeholder(b: DomBuilderEx, before: NodeX): DomBuilderEx {
        const e = b.cursor_();
        const name = e.nodeName;
        if (Html5.isEmptyTag(name)) {
            native$.iSetCaretAtEnd_(e, true);
        } else {
            const br = b.push_().childBefore_(before, "br").cursor_();
            native$.iSetCaretAtEnd_(br, true);
            b.pop_();
        }
        return b;
    }

    static _placeholderXXX(b: DomBuilderEx, before: NodeX): DomBuilderEx {
        const textnode = DomBuilderEx.createText_(MSG.XXX$);
        b.insertBefore_(before, textnode);
        native$.iSelectNode_(textnode);
        return b;
    }

    static _actionInsertDate(): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            return;
        }
        const node1 = native$.getSingleSelectedNodeOfRange_(range);
        _MainPanel._actionInsertDate1(range, node1);
    }

    static _actionInsertDate1(range: Range, node1: NodeX): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) { return; }
        const elm1 = DomUt.asHTMLElement_(node1);
        const replace = elm1 != null && native$.hasClass_(elm1, CSS.xDate);
        const now = An.now00_();
        const tabs = PromptDate.ALL;
        let tab = PromptDate.DATE;
        let dateformat = settings$.dateFormat_();
        let timeformat = settings$.timeFormat_();
        let targetdate = null;
        let preferreddateformat = "auto";
        let preferedtimeformat = "";
        if (replace && elm1 != null) {
            const formats = An.splitDatetimeXFormat_(elm1.getAttribute(ATTR.xDateFormat));
            if (formats.length >= 2) {
                preferreddateformat = DateFormat.validate_(formats[0], dateformat);
                preferedtimeformat = TimeFormat.validate_(formats[1], timeformat);
                if (preferreddateformat.length == 0 && preferedtimeformat.length > 0) {
                    tab = PromptDate.TIME;
                }
            }
            if (formats.length >= 3) {
                const ms = An.parseInt_(formats[2], null);
                if (ms != null) {
                    targetdate = An.now01_(DateTime.fromMs_(ms));
                }
            }
        }
        if (targetdate == null) {
            targetdate = now;
        }
        new PromptDate(
            accessories$,
            now,
            targetdate,
            tabs,
            cache$.ui$.buttonSize_())
            .titleKey_(RS.PromptDateTimeTitle)
            .zindex_(DEF.zindexPrompt)
            .dateFormat_(dateformat)
            .timeFormat_(timeformat)
            .preferredDateFormat_(preferreddateformat)
            .preferredTimeFormat_(preferedtimeformat)
            .onOK_((date: DateTime, dateformat: string, timeformat: string, formatted: string) => {
                native$.focusIFrame_();
                history$.group_(RS.action_InsertDate, formatted, () => {
                    const attrs = smap1_(ATTR.xDateFormat, An.xDateFormatValue_(dateformat, timeformat, date));
                    if (replace
                        /* These should already been checked at replace, but here for the compiler. */
                        && elm1 != null) {
                        An.replaceDatetimeString_(elm1, formatted);
                        new DomBuilderEx(elm1).attrs_(attrs);
                    } else {
                        attrs["class"] = CSS.xDate;
                        if (elm1 != null && elm1.classList.contains(CSS.xBulletDatetime)) {
                            formatted = replaceAll_(formatted, " ", "\u00a0");
                        }
                        const node = DomBuilderEx.offline_(idoc, "span", attrs).text_(formatted).cursor_();
                        if (node1 != null) {
                            new DomBuilderEx(node1.parentElement!).replaceChild_(node1, node);
                        } else {
                            RangeUtil.replaceRange_(range, node);
                        }
                        node1 = DomBuilderEx.createText_("\u00a0");
                        new DomBuilderEx(node).up_().insertBefore_(node.nextSibling, node1);
                    }
                    native$.iSetCaretAtEnd_(node1, true);
                });
            })
            .onCancel_(() => {
                native$.focusIFrame_();
                native$.iSetCaretAtEnd_(node1, true);
            })
            .showTab_(tab);
    }

    static _actionList(tag: string, attrs: StringMapX<string> = null): boolean {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return false;
        }
        history$.group_(RS.action_List, tag, () => {
            native$.focusIFrame_();
            const li = RangeUtil.wrapRange_("li", null, range);
            if (tag != null) {
                JsUtil.wrapNode_(li, tag, attrs);
            }
            _MainPanel._actionListPlaceholder(li);
        });
        return true;
    }

    static _actionToNbsp(): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        if (range.collapsed) {
            history$.group_(RS.action_ToNbsp, "", () => {
                const textnode = RangeUtil.insertText_(range, "\u00a0");
                native$.iSelectNode_(textnode);
            });
            return;
        }
        history$.group_(RS.action_ToNbsp, "", () => {
            const fragment = RangeUtil.extractContents_(range);
            JsUtil.transverse_(fragment, node => {
                if (node.nodeType == Node.TEXT_NODE) {
                    const value = JsUtil.nodeValue_(node);
                    if (value != null) {
                        node.nodeValue = replaceAll_(value, " ", "\u00a0");
                    }
                }
                return node.nextSibling;
            });
            RangeUtil.insertNode_(range, fragment);
            native$.iSelectRange_(range);
        });
    }

    static _actionToSpace(): void {
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        if (range.collapsed) {
            history$.group_(RS.action_ToSpace, "", () => {
                const textnode = RangeUtil.insertText_(range, " ");
                native$.iSelectNode_(textnode);
            });
            return;
        }
        history$.group_(RS.action_ToSpace, "", () => {
            const fragment = RangeUtil.extractContents_(range);
            JsUtil.transverse_(fragment, node => {
                if (node.nodeType == Node.TEXT_NODE) {
                    const value = JsUtil.nodeValue_(node);
                    if (value != null) {
                        node.nodeValue = replaceAll_(value, "\u00a0", " ");
                    }
                }
                return node.nextSibling;
            });
            RangeUtil.insertNode_(range, fragment);
            native$.iSelectRange_(range);
        });
    }

    static _actionInsertCalendar(): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        const range = native$.getIFrameSelectionRange_();
        if (range == null) {
            toasters$.warn_(MSG.string_(RS.ActionRequireAValidSelection));
            return;
        }
        const d = new PromptCalendar(
            accessories$,
            cache$.ui$.buttonSize_());
        d.titleKey_(RS.InsertCalendarTitle);
        d.zindex_(DEF.zindexPrompt);
        d.dateFormat_(settings$.monthFormat_());
        d.onOK_((date: DateTime, width: string, height: string, datestring: string) => {
            native$.focusIFrame_();
            if (datestring == null) {
                datestring = settings$.monthString_(date);
            }
            history$.group_(RS.action_InsertCalendar, datestring, () => {
                const node = _MainPanel._createCalendar(idoc, date, "#444", width, height, datestring);
                RangeUtil.replaceRange_(range, node);
            });
        });
        d.onCancel_(() => native$.focusIFrame_());
        d.show_();
    }

    static _createCalendar(
        idoc: Document,
        date: DateTime,
        color: stringX,
        width: string,
        height: string,
        datestring: string
    ): HTMLElement {
        const node = _MainPanel._createCalendarBody(idoc, date, width, height);
        const attrs = smap_(
            ["class", CSS.xCalendar],
            [ATTR.xTooltips, An.simpleDateString_(date)],
        );
        const spanattrs = smap_<string>(
        );
        if (color != null) {
            spanattrs["style"] = `color:${color};`;
        }
        return DomBuilderEx.offline_(idoc, "div", attrs)
            .push_()
            .div_({
                "class": CSS.xCalHead,
            })
            .span_(spanattrs)
            .text_(datestring)
            .peek_()
            .child_(node)
            .pop_()
            .cursor_();
    }

    private static _createCalendarBody(idoc: Document, date: DateTime, width: string, height: string): HTMLElement {
        let start = date.subtract_(DateTime.DAY * (date.day$ - 1));
        start = (start.weekday$ == 7 ? start : start.subtract_(DateTime.DAY * (start.weekday$)));
        const month = date.month$;
        const aday = DateTime.DAY;
        const style = An.ifempty_(width, "", `width:${width};`) +
            An.ifempty_(height, "", `height:${height};`);
        const b = DomBuilderEx.offline_(idoc, "div", {
            "class": CSS.xCalBody,
            "style": style,
        }).push_();
        for (let r = 0; r < 6; ++r) {
            for (let c = 0; c < 7; ++c) {
                let classes = sarray_();
                const weekday = start.weekday$;
                if (start.month$ == month) {
                    if (weekday == 0 || weekday == 6) {
                        classes.push(CSS.xDateHoliday);
                    }
                } else {
                    classes.push(CSS.xGray);
                }
                b.peek_().div_().addClasses_(classes).text_(`${start.day$}`).cursor_();
                start = start.add_(aday);
            }
        }
        return b.peek_().cursor_();
    }

    static _actionEditSymbol(target: HTMLElement): void {
        if (native$.hasAnyClass_(target, [CSS.xxSymbol, CSS.xxBullet])) {
            toasters$.warnKey_(RS.CannotReplaceReservedSymbol);
            return;
        }
        _SymbolPreferences.get_((session: _SymbolPreferences) => {
            const d = new PromptSymbol(accessories$, session);
            d.titleKey_(RS.ReplaceSymbolTitle);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((symbol, tooltips, styles) => {
                native$.focusIFrame_();
                history$.group_(RS.action_InsertSymbol, tooltips ?? "", () => {
                    _MainPanel._actionEditSymbol1(target, symbol, tooltips, styles);
                });
            });
            d.onCancel_(() => {
                native$.focusIFrame_();
                native$.iSetCaretAtEnd_(target, true);
            });
            d.show_();
        });
    }

    static _actionEditSymbol1(target: HTMLElement, symbol: string, _tooltips: stringX, styles: StringMap<stringX>): void {
        ///#BEGIN
        ///#NOTE As of xwalk-15, using :before cause cursor stay at before the symbol
        /// instead of after, as with the other symbols. Use the font-family and text node
        /// in all cases for consistency.
        ///#END
        const family = styles["font-family"];
        target.style.fontFamily = family ?? "";
        target.textContent = symbol;
        native$.iSetCaretAtEnd_(target, true);
    }

    static _actionInsertSymbol(): void {
        const range = _MainPanel._requireNonBodySelection();
        if (range == null) { return; }
        _SymbolPreferences.get_((session: _SymbolPreferences) => {
            const d = new PromptSymbol(accessories$, session);
            d.titleKey_(RS.InsertSymbolTitle);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((symbol, tooltips, styles) => {
                native$.focusIFrame_();
                history$.group_(RS.action_InsertSymbol, tooltips ?? "", () => {
                    _MainPanel._actionInsertSymbol1(range, symbol, styles);
                });
            });
            d.onCancel_(() => {
                native$.focusIFrame_();
            });
            d.show_();
        });
    }

    static _actionInsertSymbol1(range: Range, symbol: string, styles: StringMap<stringX>): void {
        const family = styles["font-family"];
        const b = DomBuilderEx.offline_(RangeUtil.rangeOwnerDocument_(range)!, "span", {
            "class": CSS.xSymbol,
            "style": `font-family: ${family};`,
        });
        const elm = b.text_(symbol).cursor_();
        RangeUtil.replaceRange_(range, elm);
        const textnode = b.textSiblingAfter_(" ");
        native$.iSetCaretAtEnd_(textnode, true);
    }

    static _actionInsertAlarm(): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        const range = _MainPanel._requireNonBodySelection();
        if (range == null) return;
        _ClientActionPostAlarm.post_(range, (found) => {
            if (found) return;
            const ancestor = range.commonAncestorContainer;
            let text = "";
            if (ancestor.nodeType == Node.TEXT_NODE) {
                const start = range.startOffset;
                const end = range.endOffset;
                text = ancestor.nodeValue!.substring(start, end);
            } else if (!range.collapsed) {
                text = JsUtil.textContent_(RangeUtil.cloneContents_(range));
            }
            const now = An.now00_();
            const id = _AlarmUtil.createId_();
            const uri = native$.getIFrameUri_();
            const href = (uri == null ? "" : `${uri.encodedPath$}#${id}`);
            const d = _EventsPanelBase._promptNewEvent(EventInfo.create_(
                id, now.millisecondsSinceEpoch$, text, "", href
            ), (event) => {
                native$.focusIFrame_();
                host$.postEvent_(event, ret => {
                    toasters$.warn_(ret);
                    const div = _MainPanel._createAlarm(idoc, id, event);
                    RangeUtil.insertNode_(range, div);
                    host$.getPendingAlarmCount_(ret => {
                        if (toasters$.warn_(ret)) { return; }
                        const count = ret[Key.result];
                        toasters$.info_(`${MSG.string_(RS.AlarmsPending_)}${count}`, { attop: false });
                        sidePanel$.showEventsPanel_((eventspanel) => eventspanel?.selectAndReveal_(id));
                    });
                });
            });
            d.onCancel_(() => native$.focusIFrame_());
            d.show_();
        });
    }

    private static _createAlarm(idoc: Document, id: string, event: JSONObject): HTMLElement {
        const alarm = new EventInfo(event);
        const xxx = MSG.XXX$;
        const date = DateTime.fromMs_(alarm.ms$);
        const desc = alarm.desc$;
        const div = _TodoWidget.createTodo_(idoc, "", (b) => {
            b.code_(
                ["class", `${CSS.xDate}`],
                [ATTR.xDateFormat, `${settings$.shortDateFormat_()};;${date.millisecondsSinceEpoch$}`],
                [ATTR.xRole, EventKey.Ms],
            ).text_(settings$.shortDateString_(date));
        }, (b) => {
            b.span_(
                ["class", CSS.xWidgetTodoSubject],
                [ATTR.xRole, EventKey.Description],
            ).text_(desc);
        }, (b) => {
            b.indent_(
                b.push_().li1_(CSS.xList).indent_(
                    b.push_().span_(
                        ["class", `${CSS.xBulletFa} fa-bell-o`],
                    ),
                    b.pop_().span_(
                        ["class", CSS.xListContent],
                        [ATTR.xRole, EventKey.Repeat],
                    ).text_(alarm.repeat$)),
                b.pop_().li1_(CSS.xList).indent_(
                    b.push_().span_(
                        ["class", CSS.xBullet],
                        ["style", "font-family: FontAwesome"]
                    ).text_(" "),
                    b.pop_().span1_(CSS.xListContent, CSS.xPlaceholder).text_(xxx)));
        });
        new DomBuilderEx(div).attrs_(smap_(
            ["name", id],
            [ATTR.xInfo, JSON.stringify(alarm.filterx_())],
        ));
        return div;
    }

    static _isSymbol(node: NodeX): boolean {
        return (node != null
            && node.nodeType == Node.ELEMENT_NODE
            && (native$.hasAnyClass_(node as HTMLElement, [CSS.xSymbol, CSS.xBullet])));
    }

    private _actionShowAudioPlayer(): void {
        if (_AudioPlayerDialog.singleton$ != null) {
            _AudioPlayerDialog.singleton$.show_();
            return;
        }
        this._mainToolbar.updateAudioStatus_();
    }

    static _createAudioInfo(range: Range, filepath: string, baseuri: BaseUri, attrs: SStringMap): [HTMLElement, HTMLElement] {
        const doc = RangeUtil.rangeOwnerDocument_(range)!;
        if (!An.isempty_(filepath)) {
            const href = An.uriOfFilepath2_(baseuri, filepath);
            attrs["href"] = href + `?${Param.view}`;
        } else {
            attrs["href"] = "";
        }
        attrs["class"] = `${CSS.xAudio} ${CSS.xxError}`;
        return history$.group_(RS.action_InsertAudio, Basepath.filename_(filepath), () => {
            const b = DomBuilderEx.offline_(doc, "div", smap_(
                ["class", CSS.xAudioinfo],
                [ATTR.xPlaceholder, Placeholder.xpAudioinfo],
            ));
            const audioinfo = b.cursor_();
            const anchor = b.push_().a_(attrs).cursor_();
            b.peek_().div_().indent_(
                b.push_().div_().indent_(
                    b.push_().div_().indent_(
                        b.push_().span1_(CSS.xAudioDatetime).text_("??:??"),
                        b.peek_().text_(" \u2022 ").span1_(CSS.xAudioDuration).text_("??:??"),
                        b.pop_().text_(" \u2022 ").span1_(CSS.xAudioRate).text_("??"),
                    ),
                    b.pop_().div_().indent_(
                        b.push_().span1_(CSS.xAudioFilename).text_("??"),
                        b.pop_().append1_("span", CSS.xAudioFilesize),
                    )
                ),
                b.pop_().div_()
                    .span_({
                        "class": CSS.xBullet,
                    })
                    .text_("\uf1db")
                    .up_()
                    .text_(MSG.string_(RS.Description))
            );
            RangeUtil.replaceRange_(range, b.pop_().cursor_());
            return [audioinfo, anchor];
        });
    }

    static _createVideoInfo(range: Range, cpath: string, poster: number, attrs: SStringMap): [HTMLElement, HTMLElement] {
        const doc = RangeUtil.rangeOwnerDocument_(range)!;
        attrs["href"] = An.isempty_(cpath)
            ? ""
            : An.uriFromSafe_(null, cpath.split(FS), `?${Param.view}&${Param.poster}=${poster}`)?.toString() ?? "";
        attrs["class"] = `${CSS.xVideo} ${CSS.xVideoPoster} ${CSS.xxError}`;
        const b = DomBuilderEx.offline_(doc, "div", smap_(
            ["class", CSS.xVideoinfo],
            [ATTR.xPlaceholder, Placeholder.xpVideoinfo],
        ));
        const videoinfo = b.cursor_();
        const anchor = b.push_().a_(attrs).cursor_();
        b.peek_().div_().indent_(
            b.push_().div_().indent_(
                b.push_().div_().indent_(
                    b.push_().span1_(CSS.xVideoDatetime).text_("??:??"),
                    b.peek_().text_(" \u2022 ").span1_(CSS.xVideoDuration).text_("??:??"),
                    b.pop_().text_(" \u2022 ").span1_(CSS.xVideoResolution).text_("??"),
                ),
                b.pop_().div_().indent_(
                    b.push_().span1_(CSS.xVideoFilename).text_("??"),
                    b.pop_().append1_("span", CSS.xVideoFilesize),
                )
            ),
            b.pop_().div_()
                .span_({
                    "class": CSS.xBullet,
                })
                .text_("\uf1db")
                .up_()
                .text_(MSG.string_(RS.Description))
        );
        history$.group_(RS.InsertVideoTooltips, Basepath.filename_(cpath), () => {
            RangeUtil.replaceRange_(range, b.pop_().cursor_());
        });
        return [videoinfo, anchor];
    }

    photoResult(_json: stringX): stringX { return null; }
    videoRecordingResult(_json: stringX): stringX { return null; }

    private _actionStopAudioRecording(): void {
        host$.stopAudioRecording_(ret => {
            if (!toasters$.warn_(ret)) {
                this._mainToolbar.updateAudioStatus_();
            }
        });
    }

    private _actionAnnotateCanvas(node: HTMLElement, updater: BoolCallback): void {
        const annotation = node.getAttribute(ATTR.xAnnotation);
        if (annotation == null) {
            this._actionAnnotateCanvas0(node, updater);
            return;
        }
        try {
            const history = ScribblerHistory.fromJson_(JSON.parse(annotation));
            const width = history.getWidth_();
            const height = history.getHeight_();
            const bound = native$.getBoundingClientRect_(node);
            const nodestyle = node.style;
            const w = nodestyle.width;
            const h = nodestyle.height;
            
            let tnwidth = null;
            let tnheight = null;
            if (w != null && w.length > 0 && "auto" != w) {
                tnwidth = Math.round(bound.width);
            }
            if (h != null && h.length > 0 && "auto" != h) {
                tnheight = Math.round(bound.height);
            }
            this.actionAnnotateCanvas1_(node, width, height, tnwidth, tnheight, history.getBGColor_(), history.history_(), updater);
        } catch (e) {
            
            toasters$.warnKey_(RS.ErrorDecodingAnnotation);
            if (updater != null) {
                updater(false);
            }
            return;
        }
    }

    private _actionAnnotateCanvasImage(node: HTMLElement, basedir: BasedirX, updater: BoolCallback): void {
        const d = new PromptImageFilepath(accessories$, HumanFilepath.Empty$, basedir,
            RS.PlaceholderRequiredFilepath, Callbacks.onReadImageFolderButton_);
        d.titleKey_(RS.PickImage);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, cpath, okcallback) => {
            Sanitizers.checkRequiredImageFilepath_(cpath).onFail_(msgs => {
                okcallback(false);
                d.warn_(msgs);
            })?.onOK_(cpath => {
                host$.localImageInfo_(cpath, false, ret => {
                    if (d.warn_(ret[Key.errors])) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    const imageinfo = MediaInfo.of_(ret[Key.result]);
                    if (imageinfo != null) {
                        Timer.sleep0_(() => {
                            this._actionAnnotateCanvasImage1(node, cpath, imageinfo, updater);
                        });
                    }
                });
            });
        });
        d.onCancel_(() => {
            updater(false);
        });
        d.show_();
    }

    private _actionAnnotateCanvasImage1(node: HTMLElement, cpath: string, imageinfo: MediaInfo, updater: BoolCallback): void {
        
        const iwidth = imageinfo.width$;
        const iheight = imageinfo.height$;
        const winwidth = window.innerWidth;
        const margins = ImageAnnotator.PADDING * 2 + 2 /* borders */ + 4;
        const width = An.multipleOf_(16, winwidth - margins);
        const height = An.multipleOf_(16, window.innerHeight - cache$.ui$.toolbarHeight_() - margins);
        let dim = MediaUtil.fit_(iwidth, iheight, width, height);
        dim = MediaUtil.limitImageArea_(dim.x, dim.y);
        const msg = MSG.string1_(RS.OriginalSize, `: ${iwidth}x${iheight}`);
        const d = _Util.promptCanvasDimension_(msg, dim.x, dim.y,
            (width, height, tnwidth, tnheight, bgcolor) => {
                const history: ScribblerCmd[] = [
                    new ScribblerCmd(ScribblerAction.IMAGE, new ScribblerSetting({
                        x_stroke: false,
                        x_fill: false,
                        x_rotation: 0,
                        x_data: An.ensureLeadingSlash_(cpath),
                    }), [0, 0, width, height])
                ];
                this.actionAnnotateCanvas1_(node, width, height, tnwidth, tnheight, bgcolor, history, updater);
            });
        d.onCancel_(() => {
            updater?.(false);
        });
        d.show_();
    }

    private _actionAnnotateCanvas0(node: HTMLElement, updater: BoolCallback): void {
        const winwidth = window.innerWidth;
        const margins = ImageAnnotator.PADDING * 2 + 2 /* borders */ + 4 + 6 /* arbitrary extra. */;
        const width = An.multipleOf_(16, winwidth - margins);
        const height = An.multipleOf_(16, window.innerHeight - cache$.ui$.toolbarHeight_() - margins - 20 /* x-canvas paddings */);
        const dim = MediaUtil.limitImageArea_(width, height);
        this.actionAnnotateCanvas1_(node, dim.x, dim.y, null, null, null, null, updater);
    }

    actionAnnotateCanvas1_(
        node: HTMLElement,
        width: number,
        height: number,
        tnwidth: numberX,
        tnheight: numberX,
        bgcolor: ColorValue | null,
        history: ScribblerCmd[] | null,
        updater: BoolCallback
    ): void {
        gestureHandler$.pause_();
        Timer.sleep0_(() => {
            this._actionAnnotationCanvasX(node, width, height, tnwidth, tnheight, bgcolor, history, (ret: boolean) => {
                gestureHandler$.resume_();
                updater(ret);
            });
        });
    }

    private _actionAnnotationCanvasX(
        node: HTMLElement,
        width: number,
        height: number,
        tnwidth: numberX,
        tnheight: numberX,
        bgcolor: ColorValue | null,
        history: ScribblerCmd[] | null,
        updater: BoolCallback
    ): void {
        if (MediaUtil.isInvalidDimension_(width, height)) {
            toasters$.warnKey_(RS.InvalidDimensionAbort);
            updater?.(false);
            return;
        }
        const handler = new ScribblerHandler();
        const d = new ImageAnnotator(
            accessories$,
            gestureHandler$,
            cache$.ui$.buttonSize_(),
            width,
            height,
            handler);
        d.bgColor_(bgcolor);
        d.history_(history);
        d.zindex_(DEF.zindexImageAnnotator);
        d.titleKey_(RS.EditDrawingTitle);
        d.path_(native$.getIFrameContextPath_());
        d.onPromptColor_(Callbacks.promptColor_);
        d.onEditText_(Callbacks.promptEditText_);
        d.onOK_((canvas: HTMLCanvasElement, history: ScribblerHistory, callback: BoolCallback) => {
            history$.group_(RS.action_AnnotateCanvas, "", () => {
                const w = canvas.width;
                const h = canvas.height;
                const json = JSON.stringify(history.toJson_(w, h));
                JsUtil.setAttribute_(node, ATTR.xAnnotation, json);
                if (tnwidth != null || tnheight != null) {
                    const styles = ssmap_();
                    if (tnwidth != null) {
                        styles.width = `${tnwidth}px`;
                    }
                    if (tnheight != null) {
                        styles.height = `${tnheight}px`;
                    }
                    new DomBuilderEx(node).addStyles_(styles);
                }
                const dim = MediaUtil.optionalDimension0_(tnwidth, tnheight, w, h);
                if ((tnwidth == null && tnheight == null) || (dim.x == w && dim.y == h)) {
                    const dataurl = _MainPanel._todataurl(history, canvas);
                    _MainPanel._annotationCanvas2(node, dataurl, updater, callback);
                } else {
                    const baseuri = native$.getIFrameUri_();
                    if (baseuri != null) {
                        _MainPanel._renderAnnotation2(baseuri, width, height, dim.x, dim.y, history, (dataurl) => {
                            _MainPanel._annotationCanvas2(node, dataurl, updater, callback);
                        });
                    }
                }
            });
        });
        d.onCancel_(() => {
            updater?.(false);
        });
        d.show_();
    }

    private static _annotationCanvas2(node: HTMLElement, dataurl: string, updater: BoolCallback, callback: BoolCallback): void {
        node.setAttribute("src", dataurl);
        updater?.(true);
        callback(true);
    }

    static actionAnnotateImg_(img: HTMLImageElement, baseuri: BaseUri, updater: UriXCallback): void {
        gestureHandler$.pause_();
        _MainPanel._actionAnnotateImgX(img, baseuri, ret => {
            gestureHandler$.resume_();
            updater(ret);
        });
    }

    /**
       * @param updater(src) where src is null if cancelled or on error.
       * Otherwise, src is the updated image uri.
       */
    private static _actionAnnotateImgX(img: HTMLImageElement, baseuri: BaseUri, updater: UriXCallback): void {
        const src = img.src;
        const ouri = An.parseUriAndWarn_(src, baseuri, toasters$);
        const ocpath = ouri == null ? null : ouri.toAbsolute_().path$;
        if (ocpath == null || ouri == null) { return; }
        const iwidth = img.naturalWidth;
        const iheight = img.naturalHeight;
        const handler = new ScribblerHandler();
        const d = new ImageAnnotator(
            accessories$,
            gestureHandler$,
            cache$.ui$.buttonSize_(),
            iwidth,
            iheight,
            handler);
        d.zindex_(DEF.zindexImageAnnotator);
        d.bgImage_(canvas => {
            native$.iDrawImage_(canvas, img);
        });
        d.onPromptColor_(Callbacks.promptColor_);
        d.onEditText_(Callbacks.promptEditText_);
        d.path_(ocpath);
        d.onOK_((canvas, _history, annotatorCallback) => {
            const basedir = An.cdirOfUri_(baseuri);
            const d = new PromptImageFilepath(accessories$, new HumanFilepath(ocpath), basedir, RS.PlaceholderRequiredFilepath,
                Callbacks.onWriteImageFolderButton_);
            d.titleKey_(RS.SaveAs);
            d.messageKey_(RS.PromptCopyOverwrite1);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((d, cpath, okcallback) => {
                Sanitizers.checkRequiredImageFilepath_(cpath).onFail_(msgs => {
                    okcallback(false);
                    d.warn_(msgs);
                })?.onOK_(cpath => {
                    fileinfoUt$.checkFileWritable2_(cpath, (msg: TestResult) => {
                        d.warn_(msg);
                        okcallback(false);
                    }, fileinfo => {
                        if (fileinfo.exists$) {
                            DialogUt.confirmOverwriting_(cpath, (yes: boolean) => {
                                if (!yes) {
                                    okcallback(false);
                                    return;
                                };
                                _MainPanel._actionAnnotateImg2(ouri, cpath, canvas, src => {
                                    okcallback(src != null);
                                    if (src != null) {
                                        annotatorCallback(true);
                                        updater(src);
                                    }
                                });
                            });
                        } else {
                            _MainPanel._actionAnnotateImg2(ouri, cpath, canvas, src => {
                                okcallback(src != null);
                                if (src != null) {
                                    annotatorCallback(true);
                                    updater(src);
                                }
                            });
                        }
                    });
                });
            });
            d.onCancel_(() => {
                annotatorCallback(false);
                updater(null);
            });
            d.show_();
        });
        d.onCancel_(() => {
            updater(null);
        });
        d.show_();
    }

    private static _actionAnnotateImg2(uri: Uri, cpath: string, canvas: HTMLCanvasElement, callback: UriXCallback): void {
        let quality = 100;
        const mime = MimeUtil.imageMimeFromPath_(cpath);
        switch (mime) {
            case Mime.JPEG$, Mime.WEBP$:
                quality = DEF.jpegQuality;
                break;
            case Mime.PNG$:
                break;
            default:
                toasters$.warn_(MSG.string1_(RS.UnsupportedOutputFormat_, mime ?? ""));
                callback(null);
                return;
        }
        const data = canvas.toDataURL(mime, quality / 100.0);
        host$.saveBase64Image_(cpath, data, ret => {
            if (toasters$.warn_(ret)) {
                callback(null);
                return;
            }
            const q = Uri.asMap_(uri.searchParams$);
            q.set(Param.t, An.msString_());
            q.set(Param.view, "");
            const src = An.uriFromSafe_(null, cpath.split(FS), q, uri.hash$);
            callback(src);
        });
    }

    static rerenderCanvas_(ret: HTMLElement, baseuri: BaseUri, owidth: string, oheight: string, oannotation: stringX, force: boolean): void {
        const annotation = ret.getAttribute(ATTR.xAnnotation);
        const width = ret.style.width;
        const height = ret.style.height;
        
        force = force || (annotation != oannotation) || (width != owidth) || (height != oheight);
        if (force && annotation != null && annotation.length > 2) {
            let w = null;
            let h = null;
            if (!An.isempty_(width) || !An.isempty_(height)) {
                const bound = native$.getBoundingClientRect_(ret);
                if (bound != null) {
                    w = Math.round(bound.width);
                    h = Math.round(bound.height);
                }
            }
            _MainPanel._renderAnnotation1(ret, baseuri, w, h, annotation);
        }
    }

    private static _renderAnnotation1(ret: HTMLElement, baseuri: BaseUri, outwidth: numberX, outheight: numberX, annotation: string): void {
        try {
            const json = JSON.parse(annotation);
            const history = ScribblerHistory.fromJson_(json);
            const width = history.getWidth_();
            const height = history.getHeight_();
            if (outwidth == null) {
                outwidth = width;
            }
            if (outheight == null) {
                outheight = height;
            }
            _MainPanel._renderAnnotation2(baseuri, width, height, outwidth, outheight, history, (dataurl: string) => {
                ret.setAttribute("src", dataurl);
            });
        } catch (e) {
            
        }
    }

    private static _renderAnnotation2(
        baseuri: BaseUri,
        width: number,
        height: number,
        outwidth: number,
        outheight: number,
        history: ScribblerHistory,
        callback: StringCallback
    ): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        const c = idoc.createElement("canvas") as HTMLCanvasElement;
        c.width = outwidth;
        c.height = outheight;
        const context = c.getContext("2d")!;
        if (outwidth != width || outheight != height) {
            context.scale(outwidth / width, outheight / height);
        }
        history.exec_(context, new ScribblerHandler(), errors => {
            if (errors != null && errors.length > 0) {
                const msgs = [MSG.string_(RS.ErrorLoading)];
                for (const error of errors) {
                    if (error.startsWith("#")) {
                        msgs.push(error);
                    } else {
                        const msg = An.cpathOfHref2_(baseuri, error) ?? MSG.string_(RS.ParameterMissingURI);
                        msgs.push(msg);
                    }
                }
                toasters$.warn_(msgs);
            }
            callback(_MainPanel._todataurl(history, c));
        });
    }

    private static _todataurl(history: ScribblerHistory, c: HTMLCanvasElement): string {
        const bgcolor = history.getBGColor_();
        if (bgcolor.a$ <= 0.99) {
            return c.toDataURL("image/png");
        }
        return c.toDataURL("image/jpeg", DEF.jpegQuality);
    }

    private _actionInsertCanvas(): void {
        Timer.sleep0_(() => this._actionInsertCanvas1());
    }

    private _actionInsertCanvas1(): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        const range = native$.getIFrameSelectionRange_();
        if (range == null) { return; }
        const dim = DialogUt.defaultCanvasDimension_(cache$.ui$.toolbarHeight_());
        const msg = MSG.format1_(RS.PromptCanvasMessage, `${DEF.maxOutputImageArea / 1024 / 1024}M`);
        const d = _Util.promptCanvasDimension_(msg, dim.x, dim.y, (width, height, tnwidth, tnheight, bgcolor) => {
            const attrs = smap_(
                ["class", CSS.xCanvas],
                [ATTR.xAnnotation, `{${ScribblerHistory.WIDTH}:${width},${ScribblerHistory.HEIGHT}:${height}`],
            );
            const node = DomBuilderEx.offline_(idoc, "img", attrs).cursor_();
            this.actionAnnotateCanvas1_(node, width, height, tnwidth, tnheight, bgcolor, null, (ok: boolean) => {
                if (ok) {
                    range.insertNode(node);
                }
            });
        });
        d.show_();
    }

    static createPhoto_(range: Range, uri: Uri, attrs: StringMap<stringX>): void {
        //// If need to change size constraint, specify max-width and/or max-height to keep aspect ratio.
        const doc = RangeUtil.rangeOwnerDocument_(range)!;
        history$.group_(RS.TakePhotoTitle, An.filenameFromUri_(uri), () => {
            const elm = DomBuilderEx.offline_(doc, "a", {
                "href": uri.encoded$,
            }).append_("img", attrs).cursor_();
            RangeUtil.replaceRange_(range, elm);
        });
    }

}

////////////////////////////////////////////////////////////////////////

class _PlaceholderDateFormatter {
    dateformat: string;
    timeformat: string;
    datestring: stringX = null;

    constructor(
        elm: HTMLElement,
        holder: string,
        readonly now: DateTime = DateTime.now_()
    ) {
        const formats = An.splitDatetimeXFormat_(elm.getAttribute(ATTR.xDateFormat));
        if (formats.length >= 2) {
            this.dateformat = DateFormat.validate_(formats[0], settings$.dateFormat_());
            this.timeformat = TimeFormat.validate_(formats[1], settings$.timeFormat_());
            this.datestring = An.datetimeString_(this.dateformat, this.timeformat, this.now);
            return;
        }
        this.dateformat = settings$.dateFormat_();
        this.timeformat = settings$.timeFormat_();
        switch (holder) {
            case Placeholder.xpDatetime:
                this.datestring = settings$.datetimeString_(this.now);
                break;
            case Placeholder.xpDatetimeShort:
            case Placeholder.xpShortDatetime:
                this.datestring = settings$.shortDatetimeString_(this.now);
                this.dateformat = settings$.shortDateFormat_();
                break;
            case Placeholder.xpDate:
                this.datestring = settings$.dateString_(this.now);
                this.timeformat = "";
                break;
            case Placeholder.xpDateAuto:
                this.datestring = An.autoDateString_(this.now, this.now);
                this.dateformat = "auto";
                this.timeformat = "";
                break;
            case Placeholder.xpDateShort:
            case Placeholder.xpShortDate:
                this.datestring = settings$.shortDateString_(this.now);
                this.dateformat = settings$.shortDateFormat_();
                this.timeformat = "";
                break;
            case Placeholder.xpTime:
            case Placeholder.xpTimeShort:
            case Placeholder.xpShortTime:
                this.datestring = settings$.timeString_(this.now);
                this.dateformat = "";
                break;
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _TemplateContextmenu extends _ContextmenuBase {
    static readonly symbolOf: SStringMap = {
        "widget,form,row,1": CSS.FaEllipsisH,
        "widget,form,col,1": CSS.FaEllipsisV,
        "widget,form,head,1": CSS.FaHeader,
        "widget,form,label,1": CSS.FaTumblr,
        "widget,form,input,1": CSS.FaPencil,
        "widget,form,input-with-borer,1": CSS.FaEdit,
        "widget,form,textarea,1": CSS.FaTerminal,
        "widget,form,textarea-with-border,1": CSS.FaStickyNoteO,
        "widget,form,checkbox,1": CSS.FaCheckSquareO,
        "widget,form,radio-group,1": CSS.FaListUl,
        "widget,form,radio-button,1": CSS.FaCircleO,
        "widget,form,save-button,1": CSS.FaSave,
        "widget,media-wall,section,1": CSS.FaBars,
        "widget,media-wall,text,1": CSS.FaTumblr,
        "widget,media-wall,image,1": CSS.FaFileImageO,
        "widget,media-wall,audio-file,1": CSS.FaFileAudioO,
        "widget,media-wall,video-file,1": CSS.FaFileVideoO,
        "widget,media-wall,photo,1": `${CSS.FaCamera} ${CSS.AnDisabled}`,
        "widget,media-wall,audio-recording,1": `${CSS.FaMicrophone} ${CSS.AnDisabled}`,
        "widget,media-wall,video-recording,1": `${CSS.FaVideoCamera} ${CSS.AnDisabled}`,
        "widget,media-sticker,section,1": CSS.FaBars,
        "widget,media-sticker,text,1": CSS.FaTumblr,
        "widget,media-sticker,image,1": CSS.FaFileImageO,
        "widget,media-sticker,audio-file,1": CSS.FaFileAudioO,
        "widget,media-sticker,video-file,1": CSS.FaFileVideoO,
        "widget,media-sticker,photo,1": `${CSS.FaCamera} ${CSS.AnDisabled}`,
        "widget,media-sticker,audio-recording,1": `${CSS.FaMicrophone} ${CSS.AnDisabled}`,
        "widget,media-sticker,video-recording,1": `${CSS.FaVideoCamera} ${CSS.AnDisabled}`,
    };

    constructor(container: HTMLElement, name: string, infos: Array<Array<SStringMap>>) {
        super(_TemplateContextmenu.createContextmenu(container));
        this._create(container, name, infos);
    }

    static createContextmenu(container: HTMLElement) {
        return DomBuilderEx.offline_(container.ownerDocument, "div", {
            "class": CSS.AnContextmenu,
            "style": "display: none; visibility: hidden;",
            "name": NAME.contextmenuTemplate,
        }).cursor_();
    }

    private _create(container: HTMLElement, name: string, infos: Array<Array<SStringMap>>): void {
        if (An.isempty_(name) || infos == null) return;
        const b = new DomBuilderEx(this._contextmenu).table_({
            "class": `${CSS.AnContextmenu} ${CSS.AnTemplateMenu}`,
        }).push_();
        for (const row of infos) {
            _TemplateContextmenu._createbuttons(b, name, row);
        }
        container.append(this._contextmenu);
        super.setupHandlers_(this._contextmenu, `td.${CSS.AnContextButton}`);
    }

    static _createbuttons(b: DomBuilderEx, name: string, infos: Array<SStringMap>): void {
        const classesOf = (action: string, info: SStringMap) => {
            const c = this.symbolOf[ClientActionInfo.actionOf_(action)];
            if (c != null) return `${CSS.AnContextButton} ${CSS.Fa} ${c}`;
            const classes = An.famap_(info[TemplateMenuKey.classes]);
            if (classes != null) {
                return `${CSS.AnContextButton} ${CSS.Fa} ${classes}`;
            } else {
                return CSS.AnContextButton;
            }
        };
        b.peek_().tr_().push_();
        for (const info of infos) {
            const action = info[TemplateMenuKey.action];
            if (action == null || action.length == 0 || DEF.NOOP == action) {
                ContextmenuBase.createNoop_(b);
                continue;
            }
            const bg = info[TemplateMenuKey.background];
            const bgsize = info[TemplateMenuKey.backgroundSize];
            let bgimage = info[TemplateMenuKey.backgroundImage];
            let classes = classesOf(action, info);
            const label = info[TemplateMenuKey.label];
            const attrs = smap_(
                ["class", classes],
                [ATTR.AnAction, action],
            );
            let style = "";
            if (bg != null) {
                const c = ColorUtil.getColorValue_(bg);
                if (c != null) {
                    style += `background-color:${c.toCSSString_()};`;
                }
            }
            if (bgimage != null) {
                if (bgimage.startsWith("./")) {
                    bgimage = `/assets/templates/${name}/${bgimage}`;
                }
                const path = Basepath.cleanFilepath_(bgimage);
                if (path != null /* && path.startsWith(PATH._assets_) */
                    && PathUtil.isValidFilepath(path)
                    && An.parseUriSafe_(path, null) != null) {
                    style += `background-image:url(\"${path}\");`;
                }
            }
            if (bgsize == "cover" || bgsize == "contain") {
                style += `background-size:${bgsize};`;
            }
            if (style.length > 0) {
                attrs["style"] = style;
            }
            b.peek_().td_(attrs).text_(label == null ? "\u00a0" : label).cursor_();
        }
        b.pop_();
    }

    hide_(): void {
        super.destroy_();
    }
}

////////////////////////////////////////////////////////////////////////

class ImageViewerBase {
    private static readonly _FIT = 0;
    private static readonly _MINOR = 1;
    private static readonly _ORIGINAL = 2;
    static readonly MIN_ZOOM = 0.03125;
    static readonly MAX_ZOOM = 4.0;
    static readonly MAX_AREA = DEF.maxOutputImageArea;
    protected _center: Point<number> | null = null;
    protected _rotation: number = 0;
    protected _marginx: number = 10;
    protected _marginy: number = 20;
    protected _limiter: IRateLimiter = new FrameLimiter(2);
    protected _overlay: HTMLElement;
    protected _zoom: Double = 0.0;
    protected _zoomState;
    #shown = false;

    constructor(
        protected _viewport: HTMLElement,
        protected _content: HTMLElement,
        protected _image: HTMLImageElement,
        private _createpinchzoom: Fun10<Fun21<Point<number> | null, number, number>>,
    ) {
        this._zoomState = this._fitinit(_image);
        this._overlay = new DomBuilderEx(_image).siblingAfter_("div", smap_(
            ["style", "position:absolute;top:0;left:0;pointer-events:none;"],
        )).cursor_();
        An.showHidden_(this._viewport);
        An.showHidden_(this._image);
        this.setupEventHandlers_(this._viewport);
    }

    zoom_(): number {
        return this._zoom;
    }

    rotate_(): void {
        toasters$.info_(`${MSG.string_(RS.Rotation)}: ${this._rotation}`, { attop: false });
        this.onresize_(this._center?.x, this._center?.y, this._zoom, (this._rotation + 90) % 360);
    }

    show_(): void {
        if (!this.#shown) {
            JsUtil.showVisible_(this._viewport, "block");
            JsUtil.showVisible_(this._image, "block");
            this.#shown = true;
        }
    }

    destroy_(): void {
        if (this.#shown) {
            JsUtil.hide_(this._image);
            this.#shown = false;
        }
        this._viewport.remove();
    }

    setupEventHandlers_(target: HTMLElement | Document) {
        const image = this._image;
        target.addEventListener("click", (event) => {
            const e = event as MouseEvent;
            if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return;
            JsUtil.stopevent_(e);
            const iwidth = image.naturalWidth;
            const iheight = image.naturalHeight;
            const winwidth = cache$.ui$.iwinWidth_();
            const winheight = cache$.ui$.iwinHeight_();
            const width = winwidth - this._marginx * 2;
            /* 4px mysterious at bottom of iframe body. */
            const height = winheight - this._marginy * 2 - 4;
            const swap = this._swapDimension();
            const outwidth = (swap ? iheight : iwidth);
            const outheight = (swap ? iwidth : iheight);
            const fitz = Math.min(4.0, MediaUtil.zoomOf_(MediaUtil.fit_(outwidth, outheight, width, height), outwidth, outheight));
            const fitm = Math.min(4.0, Math.max(width / outwidth, height / outheight));
            let zoom: Double;
            if (this._zoomState == ImageViewerBase._FIT) {
                this._zoomState = ImageViewerBase._MINOR;
                zoom = fitm;
            } else if (this._zoomState == ImageViewerBase._MINOR) {
                this._zoomState = ImageViewerBase._ORIGINAL;
                zoom = 1.0;
            } else {
                this._zoomState = ImageViewerBase._FIT;
                zoom = fitz;
            }
            const [cx, cy] = this._findcenterfromclick(e.pageX, e.pageY);
            this.onresize_(cx, cy, zoom, this._rotation);
        });
        this._createpinchzoom((center, delta) => {
            if (center != null) {
                const contentbound = JsUtil.getBoundingClientRect_(this._image);
                this._center = new Point(center.x - contentbound.x, center.y - contentbound.y);
                return delta;
            }
            if (this._center != null) {
                let z = this._zoom;
                while (delta <= -DEF.zoomDelta) {
                    z = z * (1.0 - DEF.zoomScale);
                    delta += DEF.zoomDelta;
                }
                while (delta >= DEF.zoomDelta) {
                    z = z * (1.0 + DEF.zoomScale);
                    delta -= DEF.zoomDelta;
                }
                z = An.clamp_(ImageViewerBase.MIN_ZOOM, ImageViewerBase.MAX_ZOOM, z);
                if (z != this._zoom) {
                    this.onresize_(this._center.x, this._center.y, z, this._rotation);
                }
            }
            return delta;
        });
    }

    resize_() {
        this.onresize_(this._center?.x, this._center?.y, this._zoom, this._rotation);
    }

    resize1_() {
        this._limiter.cancel_();
        this._onresize1((this._center?.x ?? null), (this._center?.y ?? null), this._zoom, this._rotation);
    }

    onresize_(cx: numberXX, cy: numberXX, zoom: number, rotation: number) {
        this._limiter.queue_(() => {
            this._onresize1(cx ?? null, cy ?? null, zoom, rotation);
        });
    }

    protected _onresize1(cx: numberX, cy: numberX, zoom: number, rotation: number) {
        
        if (this._viewport == null || this._content == null || this._image == null) {
            return;
        }
        if (!this.#shown) {
            An.showHidden_(this._viewport);
            An.showHidden_(this._image);
        }
        const naturalwidth = this._image.naturalWidth;
        const naturalheight = this._image.naturalHeight;
        if (naturalwidth == 0 || naturalheight == 0) {
            
            return;
        }
        const winwidth = cache$.ui$.iwinWidth_();
        const winheight = cache$.ui$.iwinHeight_();
        
        this._rotation = rotation;
        let rotated = (rotation == 90 || rotation == 270);
        let outwidth = rotated ? naturalheight : naturalwidth;
        let outheight = rotated ? naturalwidth : naturalheight;
        const width = winwidth - this._marginx * 2;
        /* 4px mysterious at bottom of iframe body. */
        const height = winheight - this._marginy * 2 - 4;
        const fitz = MediaUtil.zoomOf_(MediaUtil.fit_(outwidth, outheight, width, height), outwidth, outheight);
        const fitm = Math.min(4.0, Math.max(width / outwidth, height / outheight));
        if (zoom == 0) zoom = (this._zoomState == ImageViewerBase._FIT ? fitz
            : this._zoomState == ImageViewerBase._MINOR ? fitm
                : 1.0);
        if (zoom == fitz) {
            cx = null;
            cy = null;
        }
        zoom = An.clamp_(ImageViewerBase.MIN_ZOOM, ImageViewerBase.MAX_ZOOM, zoom);
        const maxz = MediaUtil.zoomOf_(
            MediaUtil.limitImageArea_(zoom * outwidth, zoom * outheight, ImageViewerBase.MAX_AREA),
            outwidth, outheight);
        if (zoom > maxz) zoom = maxz;
        this._zoom = zoom;
        let w = Math.round(zoom * outwidth);
        let h = Math.round(zoom * outheight);
        const oleft = Math.max(this._marginx, (winwidth - w) / 2);
        const top = this._marginy;
        const [dx, dy, sx, sy, left] = this._findcenter(w, h, cx, cy, winwidth, winheight, oleft);
        /* 4px mysterious at bottom of iframe body. */
        native$.setStyles_(this._content, map_(
            ["width", `${w + left * 2}px`],
            ["height", `${h + top * 2 /* + this._margin HACK: for some reason need some extra margin */}px`],
        ));
        this._resizeContent(rotated, left, top, w, h);
        this._viewport.scrollLeft = sx;
        this._viewport.scrollTop = sy;
        this._center = new Point(dx, dy);
        
    }

    public getVisibleRegion_(): [MutRect, Int, Double] {
        const z = this._zoom ?? 1.0;
        const winwidth = cache$.ui$.iwinWidth_();
        const winheight = cache$.ui$.iwinHeight_();
        let w = winwidth;
        let h = winheight;
        const x = this._viewport.scrollLeft - this._marginx;
        const y = this._viewport.scrollTop - this._marginy;
        return [
            new MutRect(
                Math.max(0, Math.round(x)),
                Math.max(0, Math.round(y)),
                Math.max(0, Math.round(w)),
                Math.max(0, Math.round(h))),
            this._rotation,
            z,
        ];
    }

    private _findcenter(
        w: Int,
        h: Int,
        centerx: numberX,
        centery: numberX,
        winwidth: Int,
        winheight: Int,
        oleft: number,
    ): [dx: Int, dy: Int, sx: Int, sy: Int, left: Int] {
        const scrollx = this._viewport.scrollLeft;
        const scrolly = this._viewport.scrollTop;
        const left = Math.max(this._marginx, Math.round((winwidth - w) / 2));
        const bound = JsUtil.getBoundingClientRect_(this._image);
        const cx = centerx ?? (bound.w / 2) - oleft;
        const cy = centery ?? (bound.h / 2) - this._marginy;
        const dx = w * cx / bound.w;
        const dy = h * cy / bound.h;
        const sx = Math.round(scrollx + (left + dx - oleft - cx));
        const sy = Math.round(Math.min(h - winheight + this._marginy, scrolly + (dy - cy)));
        
        
        return [dx, dy, sx, sy, left];
    }

    private _findcenterfromclick(x: number, y: number): [x: number, y: number] {
        const contentbound = JsUtil.getBoundingClientRect_(this._image);
        const cx = x - contentbound.x;
        const cy = y - contentbound.y;
        
        return [cx, cy];
    }

    protected _resizeContent(rotate: boolean, left: number, top: number, width: number, height: number): void {
        const ww = (rotate ? height : width);
        const hh = (rotate ? width : height);
        native$.setStyles_(this._image, map_(
            ["width", `${ww}px`],
            ["height", `${hh}px`],
            ["top", "0"],
            ["left", "0"],
            ["clip", `rect(0, ${ww}px, ${hh}px, 0)`],
        ));
        native$.setStyles_(this._overlay, map_(
            ["width", `${width}px`],
            ["height", `${height}px`],
        ));
        const style = this._image.style;
        switch (this._rotation) {
            case 0:
                style.transform = "";
                style.transformOrigin = "";
                break;
            case 90:
                style.transform = `translateX(${width}px) rotate(${this._rotation}deg)`;
                style.transformOrigin = "0 0";
                break;
            case 180:
                style.transform = `rotate(${this._rotation}deg)`;
                style.transformOrigin = "50% 50%";
                break;
            case 270:
                style.transform = `translateY(${height}px) rotate(${this._rotation}deg)`;
                style.transformOrigin = "0 0";
                break;
            default:
                throw Assert.notReach_(`${this._rotation}`);
        }
        native$.setStyles_(this._image.parentElement!, map_(
            ["position", "absolute"],
            ["left", `${left}px`],
            ["top", `${top}px`],
            ["width", `${width}px`],
            ["height", `${height}px`],
            ["box-shadow", DEF.themeBoxShadow],
        ));
    }

    image_(): HTMLImageElement {
        return this._image;
    }

    onclick_(callback: IFrameEventCallback): void {
        native$.iAddEventListener_(this._image, "click", (e) => callback(e), false);
    }

    filter_(name: string, value: string, toggle: boolean): string {
        const style = this._overlay.style;
        const ovalue = style.getPropertyValue(PK.BackdropFilter);
        const filter = CSSUtil.updateFilter_(ovalue, name, value, toggle);
        style.setProperty(PK.BackdropFilter, filter);
        return filter;
    }

    export_(uri: UriX, callback: Fun10<string>): void {
        const basedir = native$.getIFrameDir_();
        if (uri == null) {
            uri = An.parseUriSafe_(this._image.src, native$.getIFrameUri_());
        }
        if (basedir == null || uri == null) {
            toasters$.warn_(MSG.string_(RS.InvalidPath));
            return;
        }
        const fromcpath = uri.toAbsolute_().path$;
        _Util.promptRect_(fromcpath, DEF.zindexPrompt, (rect) => {
            
            host$.localImageThumbnail_(fromcpath, DEF.previewPhotoSize, DEF.jpegQuality, new CropInfo(
                rect.x,
                rect.y,
                rect.w,
                rect.h,
                1.0,
                0,
            ), ret => {
                if (toasters$.warn_(ret)) return;
                const dataurl = ret[Key.result];
                this._export1(fromcpath, basedir, dataurl, rect.x, rect.y, rect.w, rect.h, callback);
            });
        });
    }

    private _export1(
        fromcpath: string,
        basedir: string,
        dataurl: string,
        x: number, y: number, w: number, h: number,
        callback: Fun10<string>) {
        _Util.promptOutputImage1_(
            (() => fromcpath),
            basedir,
            fromcpath,
            w,
            h,
            DEF.zindexPrompt,
            dataurl,
            MediaUtil.optionalDimension_,
            (outputinfo) => {
                host$.writeImage_(fromcpath, outputinfo, new CropInfo(
                    Math.round(x),
                    Math.round(y),
                    Math.round(w),
                    Math.round(h),
                    1.0,
                    0,
                ), ret => {
                    if (toasters$.warn_(ret)) {
                        return;
                    }
                    toasters$.ok_(MSG.actionOK_(RS.Export), { attop: true });
                    callback(outputinfo.cpath);
                });
            }, (d) => {
                d.show_();
            });
    }

    move_(zindex: Int, callback: Fun00): void {
        const basedir = native$.getIFrameDir_();
        const uri = An.parseUriSafe_(this._image.src, native$.getIFrameUri_());
        if (basedir == null || uri == null) {
            toasters$.warn_(MSG.string_(RS.InvalidPath));
            return;
        }
        const fromcpath = uri.toAbsolute_().path$;
        Callbacks.onMoveImageFolderButton_(fromcpath, basedir, zindex, (cpath) => {
            fileinfoUt$.copy_(true, true, true, cpath, fromcpath, null, (ret) => {
                toasters$.warn_(ret);
                callback();
            });
        });
    }

    protected _isLandscape(): boolean {
        switch (this._rotation) {
            case 0:
            case 180:
                return this._image.naturalWidth > this._image.naturalHeight;
            case 90:
            case 270:
                return this._image.naturalHeight > this._image.naturalWidth;
            default:
                throw Assert.notReach_(`${this._rotation}`);
        }
    }

    protected _swapDimension(): boolean {
        switch (this._rotation) {
            case 0:
            case 180:
                return false;
            case 90:
            case 270:
                return true;
            default:
                throw Assert.notReach_(`${this._rotation}`);
        }
    }

    private _fitinit(image: HTMLImageElement): Int {
        const winwidth = cache$.ui$.iwinWidth_();
        const winheight = cache$.ui$.iwinHeight_();
        const width = winwidth - this._marginx * 2;
        const height = winheight - this._marginy * 2 - 4;
        return (image.naturalWidth > width && image.naturalHeight > height)
            ? ImageViewerBase._MINOR
            : ImageViewerBase._ORIGINAL;
    }
}

class IFrameImageViewer implements IIFrameImageViewer {
    private _imageviewer: ImageViewerBase;
    constructor(viewer: HTMLElement, image: HTMLImageElement /* , zoom: numberX */) {
        this._imageviewer = new ImageViewerBase(viewer.parentElement!, viewer, image /*, zoom */, (handler) => {
            new PinchZoomListener(image.ownerDocument, Conf.useTouch$, handler);
        });
        this._imageviewer.resize_();
        this._imageviewer.show_();
    }
    content_(): HTMLElement {
        return this._imageviewer.image_();
    }
    filter_(name: string, value: string, toggle: boolean): string {
        return this._imageviewer.filter_(name, value, toggle);
    }
    resize_(): void {
        this._imageviewer.resize_();
    }
    rotate_(): void {
        this._imageviewer.rotate_();
    }
    export_(callback: Fun10<string>): void {
        this._imageviewer.export_(native$.getIFrameUri_(), callback);
    }
    show_(): void {
        this._imageviewer.show_();
    }
    hide_(): void {
        this._imageviewer.destroy_();
    }
    onclick_(_callback: IFrameEventCallback): void {
    }
    onPause_(): void { }
    onResume_(): void { }
    getVisibleRegion_(): [MutRect, Int, Double] {
        return this._imageviewer.getVisibleRegion_();
    }

}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class FullscreenVideoPlayer extends Smokescreen {

    private _clone: HTMLVideoElement | null = null;

    constructor(container: HTMLElement, private _src: string, private _currentTime: number) {
        super(container, DEF.zindexMax, DEF.opacityOpaque);
        this.bgcolor_(ColorValue.X_BLACK);
    }

    show_(callback: SmokescreenCallback | null = null): this {
        super.show_((sm) => {
            const elm = sm?.element_();
            if (elm == null) { return; }
            const src = this._src;
            if (src == null) { return; }
            elm.style.opacity = "1.0";
            elm.style.visibility = "hidden";
            const clone = new DomBuilderEx(elm).child1_("div", CSS.AnFullscreenFlexCenter).child_("video", {
                "class": `${CSS.AnFullscreenPlayer} ${CSS.xVideo}`,
                "src": src,
                "controls": "true",
                "preload": "metadata"
            }).cursor_() as HTMLVideoElement;
            this._clone = clone;
            clone.currentTime = this._currentTime;
            clone.addEventListener("loadedmetadata", () => {
                requestAnimationFrame(() => {
                    elm.style.visibility = "visible";
                    clone.play();
                });
            });
            callback?.(this);
        });
        return this;
    }

    currentTime_(): Double {
        return this._clone?.currentTime ?? 0;
    }

    hide_(): boolean {
        this._clone = null;
        this.destroy_();
        return true;
    }

    destroy_(): void {
        this._clone?.pause();
        super.destroy_();
    }
}

////////////////////////////////////////////////////////////////////////

class AudioPlayerInfo {
    constructor(
        readonly cpath: string,
        readonly uri: Uri,
        readonly seek: DoubleX = null,
    ) { }
}

class _AudioPlayerDialog extends DialogBase implements IFrameMediaViewer {

    static singleton$: _AudioPlayerDialog | null = null;
    private _index = 0;
    private _body!: HTMLElement;
    private _select!: SelectOptions;
    private _audio: HTMLAudioElement | null = null;
    private _timer: Timer | null = null;
    private _onClose: Fun10X<DoubleX> = null;

    private static _createAndShow(
        container: HTMLElement,
        infos: AudioPlayerInfo[],
        autoplay: boolean = true,
        callback: Fun10X<_AudioPlayerDialog> = null,
    ) {
        if (_AudioPlayerDialog.singleton$ != null) {
            _AudioPlayerDialog.singleton$.close_();
        }
        const player = new _AudioPlayerDialog(container, infos, autoplay);
        _AudioPlayerDialog.singleton$ = player;
        player.titleKey_(RS.Audio).zindex_(DEF.zindexPrompt).show_();
        callback?.(player);
    }

    static createAndShowAll_(
        container: HTMLElement,
        infos: AudioPlayerInfo[],
        autoplay: boolean = true,
        callback: Fun10X<_AudioPlayerDialog> = null,
    ): void {
        const requests = infos.map((info) => json_(
            [Key.path, info.cpath],
            [Key.time, 0],
        ));
        host$.audioInfos_(requests, (ret) => {
            const filtered = infos.filter((info) => {
                const json = ret[Key.result]?.[info.cpath];
                const mediainfo = MediaInfo.of_(json);
                return mediainfo != null && mediainfo.fileExists$ && mediainfo.error$ == null;
            });
            this._createAndShow(container, filtered, autoplay, callback);
        });
    }

    static createAndShow_(
        container: HTMLElement,
        cpath: string,
        seek: DoubleX = null,
        autoplay: boolean = true,
        callback: Fun10X<_AudioPlayerDialog | null> = null): void {
        host$.audioInfos_([json_(
            [Key.path, cpath],
            [Key.time, 0],
        )], (ret) => {
            const json = ret[Key.result]?.[cpath];
            const mediainfo = MediaInfo.of_(json);
            const uri = An.uriFromSafe_(null, cpath);
            if (uri == null || !(mediainfo != null && mediainfo.fileExists$ && mediainfo.error$ == null)) {
                callback?.(null);
                return;
            }
            this._createAndShow(container, [new AudioPlayerInfo(cpath, uri, seek)], autoplay, callback);
        });
    }

    private constructor(
        container: HTMLElement,
        private _infos: AudioPlayerInfo[],
        private _autoplay: boolean) {
        super(container);
        super.init_(this.create_(container));
        this.maxWidthMultipler_(DEF.dialogMaxWidthXLarge);
    }

    content_(): HTMLElement {
        return this.element_();
    }

    resize_(): void {
    }

    onclick_(_callback: IFrameEventCallback): void {
    }

    onPause_(): void {
    }

    onResume_(): void {
    }

    onClose_(callback: Fun10<DoubleX>): this {
        this._onClose = callback;
        return this;
    }

    protected create_(container: HTMLElement) {
        const buttons = this._infos.length > 1
            ? BUT.infos_(BUT.PrevMedia, BUT.NextMedia, BUT.Hide, BUT.Cancel)
            : BUT.infos_(BUT.Hide, BUT.Cancel);
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            buttons,
            (action) => this._toolbarActions(action),
        );
    }

    private _createContent(content: HTMLElement) {
        const cpaths = this._infos.map(info => info.cpath);
        const b = new DomBuilderEx(content).empty_();
        this._body = b.child_("div", {
            "class": CSS.AnFlexCenter,
            "style": "flex-flow:column;padding-top:15px;",
        }).push_().child_("div", {
            "style": "width:-webkit-fill-available;"
        }).cursor_();
        this._select = new SelectOptions(accessories$, b.peek_().child_("div", {
            "style": "display:flex;justify-content:end;margin-top:5px;width:-webkit-fill-available;"
        }).child_("div", {
            "class": `${CSS.AnSmall}`,
            "style": "text-align:end;font-weight:bold;white-space:nowrap;padding:10px;"
        }).cursor_()).setOptions_(cpaths).alignEnd_().onChange_((cpath) => {
            this._audio?.pause();
            this._index = cpaths.indexOf(cpath);
            this._audio = this._createAudio(this._infos[this._index]);
            this._audio?.play();
        });
        b.pop_();
        this._audio = this._createAudio(this._infos[this._index]);
    }

    private _createAudio(info: AudioPlayerInfo | null | undefined): HTMLAudioElement | null {
        const b = new DomBuilderEx(this._body).empty_();
        if (info == null) return null;
        const audio = b.child_("audio", {
            "class": `${CSS.xAudio}`,
            "src": info.uri.encoded$,
            "controls": "true",
            "preload": "medadata",
            "style": "width:-webkit-fill-available;",
        }).cursor_() as HTMLVideoElement;
        if (info.seek != null) audio.currentTime = info.seek;
        audio.onpause = () => {
            this._updateToolbarState();
        };
        audio.onplay = () => {
            this._updateToolbarState();
        };
        audio.onended = () => {
            const saved = audio.src;
            audio.src = "";
            this._cancelTimer();
            this._timer = Timer.sleep_(2000, () => {
                audio.src = saved;
                this._playNext();
            });
        };
        return audio;
    }

    getAudioStatus_(callback: JSONCallback) {
        const info = this._infos[this._index];
        const audio = this._audio;
        if (info == null || audio == null) {
            callback(smap_());
            return;
        }
        callback(smap_(
            [Key.recorder, smap1_(Key.status, false)],
            [Key.player, json_(
                [Key.status, true],
                [Key.path, info.cpath],
                [Key.isplaying, audio.paused == false],
            )],
        ));
    }

    saveSession_(): JSONObject {
        return smap_(
            [SessionParam.x, this._audio?.currentTime ?? 0],
            [SessionParam.y, this._audio?.duration ?? 0],
        );
    }

    show_(): this {
        if (this._shown) return this;
        super.show_();
        if (this._autoplay && this._audio?.paused == true) {
            this._autoplay = false;
            this._audio?.play();
        }
        this._updateToolbarState();
        mainPanel$._mainToolbar.updateAudioStatus_();
        return this;
    }

    hide_() {
        super.hide_();
    }

    close_() {
        this._cancelTimer();
        this._audio?.pause();
        this._onClose?.(this._audio?.currentTime ?? null);
        super.close_();
        _AudioPlayerDialog.singleton$ = null;
        mainPanel$._mainToolbar.updateAudioStatus_();
    }

    private _togglePlay() {
        With.notnull_(this._toolbar?.buttonIfExists_(BUT.PauseMedia), (button) => {
            const playing = An.classlist_(button).contains_(CSS.FaPause);
            if (playing) this._audio?.pause();
            else this._audio?.play();
        });
    }

    private _cancelTimer() {
        this._timer?.cancel_();
        this._timer = null;
    }

    private _playPrev() {
        this._cancelTimer();
        if (this._index > 0) {
            this._audio = this._createAudio(this._infos[--this._index]);
            this._audio?.play();
            this._select.setSelectedIndex_(this._index);
        }
    }

    private _playNext() {
        this._cancelTimer();
        if (this._index < this._infos.length - 1) {
            this._audio = this._createAudio(this._infos[++this._index]);
            this._audio?.play();
            this._select.setSelectedIndex_(this._index);
        }
    }

    private _updateToolbarState() {
        With.notnull_(this._toolbar?.buttonIfExists_(BUT.PauseMedia), (button) => {
            const classlist = An.classlist_(button);
            if (this._audio?.paused == true) {
                classlist.remove_(CSS.FaPause).add_(CSS.FaPlay);
            } else {
                classlist.removeAll_(CSS.FaPlay).add_(CSS.FaPause);
            }
        });
        With.notnull_(this._toolbar?.buttonIfExists_(BUT.PrevMedia), (button) => {
            An.enableButton_(button, this._index > 0);
        });
        With.notnull_(this._toolbar?.buttonIfExists_(BUT.NextMedia), (button) => {
            An.enableButton_(button, this._index < this._infos.length - 1);
        });
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.PrevMedia:
                this._playPrev();
                break;
            case BUT.NextMedia:
                this._playNext();
                break;
            case BUT.PauseMedia:
                this._togglePlay();
                break;
            case BUT.Hide:
                this.hide_();
                break;
            case BUT.Cancel:
                this.close_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

///#BEGIN TODO
///class _VideoViewer extends _ViewerBase implements IFrameMediaViewer {
///  _VideoViewer(JsObject content, bool fit, bool autoplay) : super(content, fit) {
/// 
/// 
/// 
/// 
///    onresize(fit);
///    if (autoplay || JsUtil.hasAttribute(_content, "autoplay")) {
///      play();
///    }
///    show();
///  }
///  void play() {
///    _content.play();
///  }
///  void pause() {
///    _content.pause();
///  }
///  void onresize([bool fit]) {
///    if (fit != null) {
///      _fit = fit;
///    } else {
///      fit = _fit;
///    }
///    int iwidth = _content.videoWidth;
///    int iheight = _content.videoHeight;
///    if (iwidth == 0 && iheight == 0) {
/// 
///      
///      return;
///    }
///    _resize(iwidth, iheight);
///  }
///  void rotate() {
///    toasters$.warn(MSG.string_(R.AssertUnsupportedOperation));
///  }
///}
///#END TODO

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

const mainPanel$ = new _MainPanel(document.body);

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

/**
 * Panels that need to be refresh on document changes.
 */
interface _IDocumentPanel {
    refresh(): void;
}

abstract class DocumentPanelBase extends UIPanelBase implements _IDocumentPanel {
    abstract refresh(): void;
}

type _OutlineTarget1Callback = (treenode: OutlineTreenode, target: Node) => void;

class _OutlineTreeListener implements ITreeListener {
    _panel: _DocumentOutlinePanel;
    _baseuri = native$.getIFrameUri_();

    constructor(panel: _DocumentOutlinePanel) {
        this._panel = panel;
    }

    onDblClick_(treenode: OutlineTreenode): void {
        if (this.ondblclick1(treenode)) {
            const range = native$.getIFrameSelectionRange_();
            const target = _OutlineUtil.getTarget_(treenode);
            if (range != null && target != null) { RangeUtil.setEndAfter_(range, target); }
            if (range != null) { native$.iSelectRange_(range); }
        }
    }

    ondblclick1(treenode: OutlineTreenode): boolean {
        const tree = treenode.tree_();
        const sel = tree.getSelection_();
        if (sel.length != 0) {
            const start = ArrayUt.first_(sel) ?? null;
            const end = ArrayUt.last_(sel)?.nextSibling_() ?? null;
            let n: OutlineTreenode | null = start;
            for (; n != null && n !== end; n = n.nextSibling_()) {
                if (n === treenode) {
                    for (let m = n.nextSibling_(); m != null && m !== end; m = m.nextSibling_()) {
                        tree.deselect_(m, true);
                    }
                    return true;
                }
            }
            for (let n1 = end; n1 != null; n1 = n1.nextSibling_()) {
                if (treenode === n1) {
                    for (let m1 = end; m1 != null && m1 !== n1; m1 = m1.nextSibling_()) {
                        tree.select_(m1, true);
                    }
                    tree.select_(n1, true);
                    return true;
                }
            }
        }
        return false;
    }

    onExpand_(treenode: OutlineTreenode): void {
        if (!treenode.isPopulated_() && this._baseuri != null) {
            const targetpath = treenode.getTargetPath_();
            if (targetpath != null) {
                const target = native$.getIFrameNodeByPath_(targetpath);
                if (target != null) {
                    this._panel.populateOutlineChildren_(treenode, target, this._baseuri);
                }
            }
        }
    }

    onSelectionChanged_(treenode: OutlineTreenode, isselected: boolean): void {
        if (isselected) {
            const targetpath = treenode.getTargetPath_();
            if (targetpath != null) {
                native$.iSelectNodeByPath_(targetpath, true, true);
            }
        } else {
            native$.iClearSelection_();
        }
    }
}

class _OutlineUtil {
    static getTarget_(treenode: OutlineTreenode): NodeX {
        const targetpath = treenode.getTargetPath_();
        return targetpath == null ? null : native$.getIFrameNodeByPath_(targetpath);
    }

    static getTag_(treenode: OutlineTreenode): stringX {
        if (treenode == null) return null;
        return _OutlineUtil.getTag1_(treenode.content_());
    }

    static getTag1_(content: HTMLElementX): stringX {
        if (content == null) return null;
        const child = content.firstChild;
        if (child == null) return null;
        return child.textContent?.trim() ?? "";
    }

    static getOlAttr_(treenode: OutlineTreenode): HTMLElementX {
        if (treenode == null) return null;
        return _OutlineUtil.getOlAttr1_(treenode.content_());
    }

    static getOlAttr1_(content: HTMLElementX): HTMLElementX {
        if (content == null) return null;
        const children = content.children;
        for (const child of Array.from(children)) {
            if (child.classList.contains(CSS.AnAtt)) {
                return child as HTMLElement;
            }
        }
        return null;
    }

    static getNodeInfo_(node: Node, baseuri: BaseUri): string {
        let nodeinfo = native$.getNodeInfo_(node);
        if (node.nodeType == Node.ELEMENT_NODE) {
            let style = CSSUtil.humanCSSUrls_((node as HTMLElement).getAttribute("style") ?? "", baseuri);
            if (style.length != 0) {
                if (style.length > DEF.maxNodeInfoLen) {
                    style = An.truncate_(style + "...", DEF.maxNodeInfoLen);
                }
                nodeinfo += ` style (${style})`;
            }
        }
        return nodeinfo;
    }
}

class _DocumentOutlinePanel extends DocumentPanelBase {
    static readonly _COPY: string = MainContextActions._COPY;
    static readonly _CUT: string = MainContextActions._CUT;
    static readonly _DELETE: string = MainContextActions._DELETE;
    static readonly _DESTRUCT_WIDGET: string = MainContextActions._DESTRUCT_WIDGET;
    static readonly _EDIT_ELEMENT: string = MainContextActions._EDIT_NODE;
    static readonly _EDIT_RAW_STYLE: string = MainContextActions._EDIT_STYLE_RAW;
    static readonly _HIDDEN = "H";
    static readonly _INSERT_ELEMENT: string = MainContextActions._INSERT_ELEMENT;
    static readonly _INSERT_TEXT: string = MainContextActions._INSERT_TEXT;
    static readonly _INSERT_WIDGET: string = MainContextActions._INSERT_WIDGET;
    static readonly _LINEBREAK: string = MainContextActions._LINEBREAK;
    static readonly _MOVETO_NEXT: string = MainContextActions._MOVETO_NEXT;
    static readonly _MOVETO_PARENT: string = MainContextActions._MOVETO_PARENT;
    static readonly _MOVETO_PREV: string = MainContextActions._MOVETO_PREV;
    static readonly _PARAGRAPH: string = MainContextActions._PARAGRAPH;
    static readonly _PASTE_CHILD: string = MainContextActions._PASTE_CHILD;
    static readonly _PASTE_SIBLING: string = MainContextActions._PASTE_SIBLING;

    static readonly _SPAWN_NODE: string = MainContextActions._SPAWN_NODE;
    static readonly _INITIAL_SELECTION = "T";
    static readonly _UNDO: string = MainContextActions._UNDO;
    static readonly _UNWRAP: string = MainContextActions._UNWRAP;
    static readonly _WHITESPACE = "W";
    static readonly _WRAP: string = MainContextActions._WRAP;

    static _getNodeType(treenode: OutlineTreenode): numberX {
        const content = treenode.content_();
        if (content == null) return null;
        return (content.classList.contains(CSS.AnTxt) ? Node.TEXT_NODE : Node.ELEMENT_NODE);
    }

    static _getNodeName(treenode: OutlineTreenode): stringX {
        const child = treenode.content_()?.firstChild ?? null;
        if (child == null) return null;
        if (child.nodeType == Node.ELEMENT_NODE) {
            return child.textContent?.trim() ?? null;
        } else {
            return "#text";
        }
    }

    _container: HTMLElement;
    _toolbar: Toolbar;
    _searchbar: Toolbar;
    _content: HTMLElement;
    _contextmenu: Contextmenu;
    _searchbox: HTMLTextAreaElement;
    _smokescreen: Smokescreen | null = null;
    _treeListener: ITreeListener | null = null;
    _tree: OutlineTree | null = null;
    _targetPath: number[] | null = null;
    _targetTreenode: OutlineTreenode | null = null;
    _matcher: OutlineSearchMatcher | null = null;
    _showWhitespaces: boolean = false;
    _shown: boolean = false;

    constructor(container: HTMLElement) {
        super();
        this._container = container;
        this._treeListener = new _OutlineTreeListener(this);
        const b = new DomBuilderEx(container).push_();
        this._toolbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.CollapseAll,
            BUT.ExpandAll,
            BUT.ExtendSelection,
            BUT.Contextmenu,
        ));
        this._toolbar.onAction_((action, e) => this._toolbarActions(action, e));
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._searchbar = new Toolbar(b.cursor_(), [
            INPUT.info_(INPUT.SearchBox),
            BUT.info_(BUT.NextMatch),
            BUT.info_(BUT.PrevMatch),
            BUT.info_(BUT.Contextmenu),
        ]);
        this._searchbar.onAction_((action, e) => this._searchbarActions(action, e));
        this._searchbar.onTooltips_(toasters$.onTooltipsKey_);
        b.pop_().div1_(CSS.AnContentPanel);
        this._content = b.div1_(CSS.AnContentViewport).cursor_();
        this._contextmenu = this._createContextmenu();
        this._searchbox = this._searchbar.querySelector_(Conf.input$)! as AnInputElement;
        this._searchbar.hide_();
        An.onFocus_(this._searchbox, () => {
            
            Timer.sleep0_(() => {
                An.select_(this._searchbox);
            });
            if (this._matcher != null) {
                this._matcher.resetAnchor_();
            }
        });
        An.onKeypress_(this._searchbox, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this._actionNextMatch();
            }
        });
        An.onInput_(this._searchbox, () => {
            const backward = An.isButtonOff_(this._searchbar.button_(BUT.NextMatch));
            this._actionIncrementalSearch(false, true, backward);
        });
        An.onKeypress_(this.element_(), (e) => {
            if (e.ctrlKey && (e.key == "f" || e.key == "F")) {
                An.stopevent_(e);
                if (e.shiftKey) this._showMainbar();
                else this._showSearchbar();
            }
        });
    }

    private _createContextmenu(): Contextmenu {
        const d = new Contextmenu(
            accessories$,
            DEF.zindexContextmenu,
            [
                [
                    _MainContextmenu._info(_DocumentOutlinePanel._COPY),
                    _MainContextmenu._info(_DocumentOutlinePanel._CUT),
                    _MainContextmenu._info(_DocumentOutlinePanel._PASTE_CHILD),
                    _MainContextmenu._info(_DocumentOutlinePanel._PASTE_SIBLING),
                    _MainContextmenu._info(_DocumentOutlinePanel._UNDO),
                ],
                [
                    _MainContextmenu._info(_DocumentOutlinePanel._MOVETO_PARENT),
                    _MainContextmenu._info(_DocumentOutlinePanel._MOVETO_PREV),
                    _MainContextmenu._info(_DocumentOutlinePanel._MOVETO_NEXT),
                    _MainContextmenu._info(_DocumentOutlinePanel._EDIT_ELEMENT),
                    _MainContextmenu._info(_DocumentOutlinePanel._EDIT_RAW_STYLE),
                ],
                [
                    _MainContextmenu._info(_DocumentOutlinePanel._LINEBREAK),
                    _MainContextmenu._info(_DocumentOutlinePanel._INSERT_TEXT),
                    _MainContextmenu._info(_DocumentOutlinePanel._INSERT_ELEMENT),
                    _MainContextmenu._info(_DocumentOutlinePanel._UNWRAP),
                    _MainContextmenu._info(_DocumentOutlinePanel._WRAP),
                ],
                [
                    _MainContextmenu._info(_DocumentOutlinePanel._PARAGRAPH),
                    _MainContextmenu._info(_DocumentOutlinePanel._DELETE),
                    _MainContextmenu._info(_DocumentOutlinePanel._SPAWN_NODE),
                    _MainContextmenu._info(_DocumentOutlinePanel._DESTRUCT_WIDGET),
                    _MainContextmenu._info(_DocumentOutlinePanel._INSERT_WIDGET),
                ],
                [
                    smap_(
                        [ATTR.AnAction, _DocumentOutlinePanel._INITIAL_SELECTION],
                        ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaFlag}`],
                        [ATTR.xTooltips, RS.Tooltips_ShowInitialSelection],
                    ),
                    smap_(
                        [ATTR.AnAction, _DocumentOutlinePanel._HIDDEN],
                        ["class", `${CSS.Fa} ${CSS.FaEyeSlash}`],
                        [ATTR.xTooltips, RS.Tooltips_ToggleHidden],
                    ),
                    smap_(
                        [ATTR.AnAction, _DocumentOutlinePanel._WHITESPACE],
                        ["class", `${CSS.Fa} ${CSS.FaCircleThin}`],
                        [ATTR.xTooltips, RS.Tooltips_ShowWhitespaceNodes],
                    ),
                    BUT.info_(BUT.IgnoreCase),
                    BUT.info_(BUT.Searchbar),
                ],
            ]);
        d.onAction_((action, e, elm) => this._contextActions(action, e, elm));
        d.onDrag_(Contextmenu.contextmenuDragOK_);
        d.onShow_(() => this._updateContextmenuState());
        d.onTooltips_(toasters$.onTooltipsKey_);
        return d;
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            host$.hideKeyboard_(() => {
                const timer = new StepTimer();
                timer.debug_("# OutlinePanel.show(): start");
                An.showHidden_(this._container);
                this.refresh();
                An.showVisible_(this._container);
                timer.debug_("# OutlinePanel.show(): end");
            });
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            const timer = new StepTimer();
            timer.debug_("# OutlinePanel.hide(): start");
            this._matcher = null;
            this.hideContextmenu_();
            An.hide_(this._container);
            new DomBuilderEx(this._content).empty_();
            if (this._tree != null) {
                this._tree.destroy_();
                this._tree = null;
            }
            this._targetPath = null;
            this._targetTreenode = null;
            timer.debug_("# OutlinePanel.hide(): end");
        }
    }

    /**
     * Refresh the whole outline tree with BODY as root.
     */
    refresh(): void {
        this._matcher = null;
        const timer = new StepTimer();
        timer.debug_("# OutlinePanel.refresh(): start");
        new DomBuilderEx(this._content).empty_();
        if (!(docInfo$?.isHtml$ ?? false)) {
            if (this._tree != null) {
                this._tree.destroy_();
                this._tree = null;
            }
            this._enableToolbar(false);
            timer.debug_("# OutlinePanel.refresh(): end");
            return;
        }
        this._tree = this._populateOutlineTree();
        if (this._treeListener != null) {
            this._tree.addListener_(this._treeListener);
        }
        const width = Math.round(this._content.getBoundingClientRect().width);
        this._tree.setWidth_(width);
        this._enableToolbar(true);
        timer.debug_("# OutlinePanel.refresh(): end");
    }

    showContextmenu_(e: MouseEvent): void {
        this._contextmenu.show_(e);
    }

    hideContextmenu_(): void {
        
        this._contextmenu.hide_();
    }

    onWindowSizeChanged_(): void {
        
        this._contextmenu.destroy_();
        this._contextmenu = this._createContextmenu();
    }

    resizeContent_(containerheight: number): void {
        
        const h = containerheight - cache$.ui$.toolbarHeight_() - DEF.sidepanelMarginBottom /* margin-bottom */;
        this._content.style.height = `${h}px`;
        if (this._shown && this._tree != null) {
            const width = Math.round(this._content.getBoundingClientRect().width);
            this._tree.setWidth_(width);
        }
    }

    ////////////////////////////////////////////////////////////////////////

    private _actionIncrementalSearch(reset: boolean = false, matchself: boolean = false, backward: boolean = false): void {
        toasters$.hideWarn_();
        if (this._tree == null) {
            return;
        }
        for (let c = this._tree.root_().firstChild_(); c != null; c = c.nextSibling_()) {
            c.expandAll_();
        }
        if (this._matcher == null) {
            this._matcher = new OutlineSearchMatcher(this._tree);
        }
        const searchtext = this._searchbox.value;
        const ignorecase = An.isButtonOn_(this._contextmenu.button_(BUT.IgnoreCase));
        if (reset) {
            this._matcher.resetAnchor_();
        }
        if (!this._matcher.incrementalSearch_(searchtext, ignorecase, matchself, backward)) {
            toasters$.warnKey_(RS.NoMatchFound, { attop: false });
        }
    }

    ////////////////////////////////////////////////////////////////////////

    private _refresh1(parent: OutlineTreenode, parenttarget: Node): void {
        const baseuri = native$.getIFrameUri_();
        if (parent != null && baseuri != null) {
            this._matcher = null;
            parent.removeDescendants_();
            this.populateOutlineChildren_(parent, parenttarget, baseuri);
            parent.revealExpand_();
        }
    }

    private _refreshParent1(first: OutlineTreenode, target: Node, offset: number): void {
        const treeparent = first.parent_();
        if (this._tree == null || treeparent == null || target.parentNode == null) { return; }
        const index = treeparent.indexOf_(first);
        this._tree.deselectAll_();
        this._refresh1(treeparent, target.parentNode);
        treeparent.expand_();
        const treenode = treeparent.get_(index + offset);
        if (treenode != null) {
            treenode.reveal_();
            treenode.expand_();
            treenode.select_(true);
        }
    }

    private _refreshParent(first: OutlineTreenode, targetparent: Node, offset: number, count: number): void {
        const treeparent = first.parent_();
        if (this._tree == null || treeparent == null) { return; }
        this._tree.deselectAll_();
        if (count <= 0) {
            this._refresh1(treeparent, targetparent);
            return;
        }
        const index = treeparent.indexOf_(first);
        this._refresh1(treeparent, targetparent);
        treeparent.expand_();
        let treenode: OutlineTreenode | null = treeparent.get_(index + offset);
        while (--count >= 0 && treenode != null) {
            treenode.select_(true);
            treenode = treenode.nextSibling_();
        }
    }

    private _populateOutlineTree(): OutlineTree {
        const timer = new StepTimer();
        timer.debug_("# populateOutlineTree: start");
        const treeelm = DomBuilderEx.offline1_(this._content.ownerDocument, "div", CSS.AnViewportContent).cursor_();
        const tree = new OutlineTree(treeelm, cache$.ui$.buttonSize_() / 4);
        const root = tree.root_();
        const body = native$.getIFrameBody_();
        const baseuri = native$.getIFrameUri_();
        if (body != null && baseuri != null) {
            this._targetPath = native$.getIFrameSelectionPath_();
            if (this._targetPath != null && this._targetPath.length > 0) {
                root.expand_();
                this._targetTreenode = this._populateOutlinePath(root, body, baseuri, this._targetPath, 0);
            } else {
                this.populateOutlineChildren_(root, body, baseuri);
                root.expand_();
            }
            timer.debug_("# populateOutlineRoot: populate");
            this._content.append(treeelm);
            if (this._targetTreenode != null && this._targetPath != null) {
                native$.iSelectNodeByPath_(this._targetPath, true);
                this._targetTreenode.revealSelect_();
                this._targetTreenode.scrollIntoView_();
            }
            timer.debug_("# populateOutlineRoot: append");
        }
        timer.debug_("# populateOutlineTree: done");
        return tree;
    }

    populateOutlineChildren_(treeparent: OutlineTreenode, node: Node, baseuri: BaseUri): void {
        let targetindex = -1;
        for (let child = node.firstChild; child != null; child = child.nextSibling) {
            ++targetindex;
            const type = child.nodeType;
            const nodeinfo = _OutlineUtil.getNodeInfo_(child, baseuri);
            let iswhitespaces = false;
            if (type == Node.TEXT_NODE) {
                iswhitespaces = An.isWhitespaces_(nodeinfo);
                if (!this._showWhitespaces && iswhitespaces) {
                    continue;
                }
            } else if (type == Node.ELEMENT_NODE) { } else {
                continue;
            }
            const ret = _DocumentOutlinePanel._createOutlineItem(
                treeparent.append_(),
                this._showWhitespaces,
                iswhitespaces,
                child,
                type,
                nodeinfo);
            ret.setData_(targetindex);
        }
        treeparent.setPopulated_(true);
    }

    private _populateOutlinePath(
        treenode: OutlineTreenode,
        target: Node,
        baseuri: BaseUri,
        targetpath: number[],
        level: number
    ): OutlineTreenode | null {
        const index = targetpath[level];
        if (!treenode.isPopulated_()) {
            this.populateOutlineChildren_(treenode, target, baseuri);
        }
        treenode.expand_();
        let child = null;
        let prev = null;
        for (child = treenode.firstChild_(); child != null; child = child.nextSibling_()) {
            if (child.getData_() == index) {
                break;
            }
            prev = child;
        }
        if (child == null) {
            if (level == targetpath.length - 1) {
                return prev;
            }
            throw Assert.notReach_(`level=${level}, index=${index}`);
        }
        if (++level < targetpath.length) {
            return this._populateOutlinePath(child, target.childNodes[index], baseuri, targetpath, level);
        }
        return child;
    }

    static _createOutlineItem(
        ret: OutlineTreenode,
        showwhitespaces: boolean,
        iswhitespaces: boolean,
        target: Node,
        type: number,
        text: string
    ): OutlineTreenode {
        const content = ret.content_();
        if (content == null) { return ret; }
        if (type == Node.ELEMENT_NODE) {
            const b = new DomBuilderEx(content);
            const name = target.nodeName;
            b.push_().span1_(CSS.AnTag).text_(name).pop_();
            if (!An.isBodyElement_(name)) {
                if (text.length > 0) {
                    b.text_("\u00a0").span1_(CSS.AnAtt).text_(text);
                }
            }
        } else if (type == Node.TEXT_NODE) {
            if (iswhitespaces) {
                ret.element_().classList.add(CSS.AnWsp);
            }
            new DomBuilderEx(content, { "class": CSS.AnTxt }).text_(text);
        } else {
            throw MSG.string_(RS.AssertNotReach);
        }
        if (showwhitespaces) {
            ret.setKind_(target.hasChildNodes() ? OutlineTreenode.COLLAPSED : OutlineTreenode.LEAF);
        } else {
            ret.setKind_(JsUtil.isEmptyNode_(target) ? OutlineTreenode.LEAF : OutlineTreenode.COLLAPSED);
        }
        return ret;
    }

    validOutlineSelection(sel: ArrayX<OutlineTreenode>): ArrayX<OutlineTreenode> {
        if (sel == null || sel.length == 0) {
            return null;
        }
        if (state$ != _State.EDITING) {
            return null;
        }
        return sel;
    }

    private _validOutlineSelectionOrWarn(sel: ArrayX<OutlineTreenode>): OutlineTreenode[] | null {
        const ret = this.validOutlineSelection(sel);
        if (ret == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
        }
        return ret;
    }

    private _outlineSelected1(sel: ArrayX<OutlineTreenode>): OutlineTreenode | null {
        const ret = this.validOutlineSelection(sel);
        if (ret != null && ret.length == 1) {
            return ret[0];
        }
        return null;
    }

    private _outlineSelectedLast(sel: ArrayX<OutlineTreenode>): OutlineTreenode | null {
        const ret = this.validOutlineSelection(sel);
        if (ret != null && ret.length > 0) {
            return ret[ret.length - 1];
        }
        return null;
    }

    /**
         * @param callback(Treenode treenode, JsObject target)
         * Callback to be called if there is a single treenode selection with a valid target.
         */
    private _outlineTarget1(sel: ArrayX<OutlineTreenode>, callback: _OutlineTarget1Callback): void {
        const first = this._outlineSelected1(sel);
        if (first == null) {
            toasters$.warnKey_(RS.ActionRequireASingleNodeSelection);
            return;
        }
        const target = _OutlineUtil.getTarget_(first);
        if (target == null) {
            
            return;
        }
        callback(first, target);
    }

    private _outlineTargetLast(sel: ArrayX<OutlineTreenode>, callback: _OutlineTarget1Callback): void {
        const selected = this._outlineSelectedLast(sel);
        if (selected == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        const target = _OutlineUtil.getTarget_(selected);
        if (target == null) {
            
            return;
        }
        callback(selected, target);
    }

    ////////////////////////////////////////////////////////////////////////

    static readonly _ACTIONS: string[] = [
        _DocumentOutlinePanel._COPY,
        _DocumentOutlinePanel._CUT,
        _DocumentOutlinePanel._DELETE,
        _DocumentOutlinePanel._DESTRUCT_WIDGET,
        _DocumentOutlinePanel._EDIT_ELEMENT,
        _DocumentOutlinePanel._EDIT_RAW_STYLE,
        _DocumentOutlinePanel._HIDDEN,
        _DocumentOutlinePanel._INSERT_ELEMENT,
        _DocumentOutlinePanel._INSERT_TEXT,
        _DocumentOutlinePanel._INSERT_WIDGET,
        _DocumentOutlinePanel._LINEBREAK,
        _DocumentOutlinePanel._MOVETO_NEXT,
        _DocumentOutlinePanel._MOVETO_PARENT,
        _DocumentOutlinePanel._MOVETO_PREV,
        _DocumentOutlinePanel._PARAGRAPH,
        _DocumentOutlinePanel._PASTE_CHILD,
        _DocumentOutlinePanel._PASTE_SIBLING,
        _DocumentOutlinePanel._SPAWN_NODE,
        _DocumentOutlinePanel._UNDO,
        _DocumentOutlinePanel._UNWRAP,
        _DocumentOutlinePanel._WRAP,
    ];

    private _updateContextmenuState(): void {
        const classlist = this._contextmenu.button_(_DocumentOutlinePanel._WHITESPACE).classList;
        if (this._showWhitespaces) {
            classlist.remove(CSS.AnToggleOff);
        } else {
            classlist.add(CSS.AnToggleOff);
        }
        An.enableButton_(this._contextmenu.button_(_DocumentOutlinePanel._INITIAL_SELECTION), this._targetTreenode != null);
        const classes = this._contextmenu.button_(BUT.Searchbar).classList;
        const showingtoolbar = this._toolbar.isShown_();
        classes.remove(showingtoolbar ? CSS.FaEllipsisH : CSS.FaSearch);
        classes.add(showingtoolbar ? CSS.FaSearch : CSS.FaEllipsisH);
        const editing = (state$ == _State.EDITING);
        if (!editing) {
            for (const action of _DocumentOutlinePanel._ACTIONS) {
                if (action == _DocumentOutlinePanel._COPY) {
                    let yes = false;
                    const sel = this._tree?.getSelection_() ?? [];
                    if (sel.length > 0) {
                        const treenode = sel[0];
                        const nodename = _DocumentOutlinePanel._getNodeName(treenode);
                        yes = "BODY" != nodename;
                    }
                    An.enableButton_(this._contextmenu.button_(action), yes);
                    continue;
                }
                An.enableButton_(this._contextmenu.button_(action), false);
            }
        } else {
            const sel = this._tree?.getSelection_() ?? [];
            if (sel.length == 0) {
                for (const action of _DocumentOutlinePanel._ACTIONS) {
                    if (action == _DocumentOutlinePanel._UNDO) {
                        this._contextmenu.enableButton_(_DocumentOutlinePanel._UNDO, !history$.isUndoEmpty_());
                        continue;
                    }
                    An.enableButton_(this._contextmenu.button_(action), false);
                }
                return;
            }
            const treenode = sel[0];
            const parent = treenode.parent_();
            const type = _DocumentOutlinePanel._getNodeType(treenode);
            const nodename = _DocumentOutlinePanel._getNodeName(treenode);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._UNDO, !history$.isUndoEmpty_());
            const notbody = ("BODY" != nodename);
            const iselm = (type == Node.ELEMENT_NODE);
            const emptytag = nodename == null || Html5.isEmptyTag(nodename);
            const clipempty = clipboard$.isEmpty_();
            const notbody1 = (notbody && sel.length == 1);
            const notbody1elm = (notbody1 && iselm);
            this._contextmenu.enableButtons_([
                _DocumentOutlinePanel._COPY,
                _DocumentOutlinePanel._CUT,
                _DocumentOutlinePanel._DELETE,
                _DocumentOutlinePanel._WRAP,
                _DocumentOutlinePanel._INSERT_WIDGET,
                _DocumentOutlinePanel._HIDDEN],
                notbody);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._PASTE_SIBLING, !clipempty && notbody);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._PASTE_CHILD, !clipempty && sel.length == 1 && iselm && !emptytag);
            this._contextmenu.enableButtons_([
                _DocumentOutlinePanel._INSERT_ELEMENT,
                _DocumentOutlinePanel._INSERT_TEXT,
                _DocumentOutlinePanel._LINEBREAK,
                _DocumentOutlinePanel._PARAGRAPH],
                notbody1);
            this._contextmenu.enableButton_(
                _DocumentOutlinePanel._MOVETO_PARENT,
                notbody1 && parent != null && !parent.isRoot_() && "BODY" != _DocumentOutlinePanel._getNodeName(parent));
            const canmove = notbody1 && parent != null && parent.childCount_() > 1;
            this._contextmenu.enableButton_(_DocumentOutlinePanel._MOVETO_PREV, canmove);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._MOVETO_NEXT, canmove);
            this._contextmenu.enableButtons_([
                _DocumentOutlinePanel._SPAWN_NODE,
                _DocumentOutlinePanel._EDIT_RAW_STYLE,
                _DocumentOutlinePanel._DESTRUCT_WIDGET,
            ], notbody1elm);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._EDIT_ELEMENT, notbody1elm || type == Node.TEXT_NODE);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._SPAWN_NODE, notbody1elm);
            this._contextmenu.enableButton_(_DocumentOutlinePanel._UNWRAP, notbody1elm && !emptytag);
        }
    }

    ////////////////////////////////////////////////////////////////////////

    private _contextActions(action: string, e: MouseEvent, elm: HTMLElement) {
        const sel = this._tree == null ? null : this._tree.getSelection_();
        switch (action) {
            case _DocumentOutlinePanel._COPY:
                this._actionCopy(sel);
                break;
            case _DocumentOutlinePanel._CUT:
                this._actionCut(sel);
                break;
            case _DocumentOutlinePanel._DELETE:
                this._actionDelete(sel);
                break;
            case _DocumentOutlinePanel._PASTE_SIBLING:
                this._actionPasteSibling(sel);
                break;
            case _DocumentOutlinePanel._PASTE_CHILD:
                this._actionPasteChild(sel);
                break;
            case _DocumentOutlinePanel._UNDO:
                this._actionUndo();
                break;
            case _DocumentOutlinePanel._LINEBREAK:
                this._actionLInebreak(sel);
                break;
            case _DocumentOutlinePanel._PARAGRAPH:
                this._actionParagraphBreak(sel, e);
                break;
            case _DocumentOutlinePanel._INSERT_ELEMENT:
                this._actionInsertElement(sel);
                break;
            case _DocumentOutlinePanel._INSERT_TEXT:
                this._actionInsertText(sel);
                break;
            case _DocumentOutlinePanel._HIDDEN:
                this._actionToggleHidden(sel);
                break;
            case _DocumentOutlinePanel._WRAP:
                this._actionWrap(sel);
                break;
            case _DocumentOutlinePanel._UNWRAP:
                this._actionUnwrap(sel);
                break;
            case _DocumentOutlinePanel._INSERT_WIDGET:
                this._actionInsertWidget(sel, e);
                break;
            case _DocumentOutlinePanel._DESTRUCT_WIDGET:
                this._actionDestroyWidget(sel);
                break;
            case _DocumentOutlinePanel._SPAWN_NODE:
                this._actionSpawnNode(sel);
                break;
            case _DocumentOutlinePanel._MOVETO_PARENT:
                this._actionMovetoParent(sel);
                this._updateContextmenuState();
                return;
            case _DocumentOutlinePanel._MOVETO_PREV:
                this._actionMovetoPrev(sel);
                this._updateContextmenuState();
                return;
            case _DocumentOutlinePanel._MOVETO_NEXT:
                this._actionMovetoNext(sel);
                this._updateContextmenuState();
                return;
            case _DocumentOutlinePanel._EDIT_RAW_STYLE:
                this._actionEditStyle(sel);
                break;
            case _DocumentOutlinePanel._EDIT_ELEMENT:
                this._actionEditNode(sel);
                break;
            case _DocumentOutlinePanel._INITIAL_SELECTION:
                if (this._targetTreenode != null) {
                    this._targetTreenode.revealSelect_();
                    this._targetTreenode.scrollIntoView_();
                } else {
                    toasters$.warnKey_(RS.ThereIsNoInitialDocumentSelection);
                }
                break;
            case _DocumentOutlinePanel._WHITESPACE:
                this._showWhitespaces = !this._showWhitespaces;
                _Util.toastOnOffButton_(MSG.string_(RS.Tooltips_ShowWhitespaceNodes), this._showWhitespaces);
                this.refresh();
                break;
            case BUT.IgnoreCase:
                _Util.toggleIgnorecase_(this._contextmenu.button_(BUT.IgnoreCase));
                break;
            case BUT.Searchbar: {
                const classlist = An.classlist_(elm);
                if (classlist.contains_(CSS.FaSearch)) {
                    this._showSearchbar();
                } else {
                    this._showMainbar();
                }
                classlist.toggleAll_(CSS.FaSearch, CSS.FaEllipsisH);
                break;
            }
            case DEF.NOOP:
                return;
            default:
                
        }
        this.hideContextmenu_();
    }

    private _showSearchbar() {
        this._toolbar.hide_();
        this._searchbar.show_();
        Timer.sleep00_(() => {
            this._searchbox.focus();
            host$.showKeyboard_();
        });
    }

    private _showMainbar() {
        this._searchbar.hide_();
        this._toolbar.show_();
    }

    private _actionUndo(): void {
        if (!history$.undo_()) {
            toasters$.warnKey_(RS.NothingToUndo);
        }
        this.refresh();
    }

    private _actionSpawnNode(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._spawnNode0(target, () => {
                this._refreshParent1(first, target, 1);
            });
        });
    }

    private _actionMovetoParent(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._actionMovetoParent1(target, () => {
                const parent = first.parent_();
                if (parent == null) { return; }
                this._refreshParent1(parent, target, 1);
            });
        });
    }

    private _actionMovetoPrev(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._actionMovetoPrev1(target, () => {
                const treeparent = first.parent_();
                if (treeparent == null) { return; }
                const index = treeparent.indexOf_(first);
                this._refreshParent1(first, target, (index == 0 ? treeparent.childCount_() - 1 : -1));
            });
        });
    }

    private _actionMovetoNext(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._actionMovetoNext1(target, () => {
                const treeparent = first.parent_();
                if (treeparent == null) { return; }
                const index = treeparent.indexOf_(first);
                this._refreshParent1(first, target, (index == (treeparent.childCount_() - 1) ? -index : 1));
            });
        });
    }

    private _actionEditStyle(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            const type = target.nodeType;
            if (type == Node.ELEMENT_NODE) {
                _MainPanel._actionEditRawStyle1(target as HTMLElement, () => {
                    this._refreshParent1(first, target, 0);
                });
            } else {
                toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            }
        });
    }

    private _actionEditNode(sel: ArrayX<OutlineTreenode>): void {
        const jointext = () => {
            if (sel == null || sel.length <= 1) return sel;
            const first = ArrayUt.first_(sel);
            const parent = first?.parent_();
            if (first == null || parent == null) return sel;
            let text = "";
            let a = new Array<Node>();
            for (const treenode of sel) {
                const node = _OutlineUtil.getTarget_(treenode);
                if (node == null || node.nodeType != Node.TEXT_NODE) return sel;
                text += node.nodeValue ?? "";
                a.push(node);
            }
            const firsttarget = _OutlineUtil.getTarget_(first);
            const texttarget = firsttarget?.ownerDocument?.createTextNode(text);
            const parenttarget = _OutlineUtil.getTarget_(parent) as HTMLElementX;
            if (firsttarget == null || texttarget == null || parenttarget == null) return sel;
            history$.group_(RS.action_EditTextNode, An.truncate_(text, DEF.historyTextLength), () => {
                const b = new DomBuilderEx(parenttarget);
                b.insertBefore_(firsttarget, texttarget);
                for (const node of a) {
                    b.removeChild_(node);
                }
                native$.iSelectNode_(texttarget);
            });
            this._refresh1(parent, parenttarget);
            for (let c = parent.firstChild_(); c != null; c = c.nextSibling_()) {
                if (_OutlineUtil.getTarget_(c) == texttarget) {
                    c.select_(false);
                    break;
                }
            }
            return this._tree?.getSelection_() ?? null;
        };
        this._outlineTarget1(jointext(), (first: OutlineTreenode, target: Node) => {
            const baseuri = native$.getIFrameUri_();
            if (baseuri == null) { return; }
            const type = target.nodeType;
            if (type == Node.ELEMENT_NODE) {
                _MainPanel._actionEditElementRaw1(target as HTMLElement, baseuri, (ret, updateparent) => {
                    if (updateparent) {
                        const parent = first.parent_();
                        if (parent != null) {
                            this._refreshParent1(parent, ret, 0);
                        }
                    } else {
                        this._refreshParent1(first, ret, 0);
                    }
                });
            } else if (type == Node.TEXT_NODE) {
                _MainPanel._actionEditText1(target, false, null, null, (value: string) => {
                    const content = first.content_();
                    if (content != null) {
                        content.textContent = An.truncate_(value, _DEF.OutlineTextLen);
                    }
                });
            } else {
                toasters$.warnKey_(RS.InvalidSelection);
            }
        });
    }

    private _actionUnwrap(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            const elm = DomUt.asHTMLElement_(target);
            if (elm == null) {
                toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
                return;
            }
            const baseuri = native$.getIFrameUri_();
            if (baseuri == null) { return; }
            if (!first.isPopulated_()) {
                this.populateOutlineChildren_(first, elm, baseuri);
            }
            history$.group_(RS.action_Unwrap, (elm.nodeName ?? ""), () => {
                const parent = elm.parentElement;
                const firstchild = elm.firstChild;
                if (parent == null || firstchild == null) { return; }
                const lastchild = elm.lastChild;
                const count = first.childCount_();
                const t = new DomBuilderEx(elm);
                const p = new DomBuilderEx(parent);
                let c: NodeX = firstchild;
                while (c != null) {
                    const n: NodeX = c.nextSibling;
                    t.removeChild_(c);
                    p.insertBefore_(elm, c);
                    c = n;
                }
                p.removeChild_(elm);
                native$.iSelectNodes_(firstchild, lastchild, true, true);
                this._refreshParent(first, parent, 0, count);
            });
        });
    }

    private _actionWrap(sel: ArrayX<OutlineTreenode>): boolean {
        const selection = this._validOutlineSelectionOrWarn(sel);
        if (selection == null || selection.length == 0) {
            return false;
        }
        const firstnode = selection[0];
        const firsttarget = _OutlineUtil.getTarget_(firstnode);
        if (firsttarget == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return false;
        }
        const nodename = firsttarget.nodeName;
        if (An.isBodyElement_(nodename)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return false;
        }
        const d = new PromptElement(accessories$);
        d.titleKey_(RS.WrapSelection);
        d.messageKey_(RS.PromptElementMessage);
        d.zindex_(DEF.zindexPrompt);
        d.tag_("DIV");
        d.onOK_((d, tag, attrs, okcallback) => {
            Sanitizers.checkTagAttrs_(tag, attrs, native$.getIFrameUri_(), (ret) => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                toasters$.warn_(ret[Key.warns]);
                const tag = ret[Key.tag];
                const attrs = (ret[Key.attrs] as StringMap<stringX>);
                history$.group_(RS.action_Wrap, tag, () => {
                    const parent = firsttarget.parentElement;
                    const lastnode = ArrayUt.last_(selection);
                    const treeparent = firstnode.parent_();
                    if (parent == null || treeparent == null || lastnode === undefined) { return; }
                    const target = _OutlineUtil.getTarget_(lastnode);
                    if (target == null) { return; }
                    const index = treeparent.indexOf_(firstnode);
                    const lasttarget = target.nextSibling;
                    const b = new DomBuilderEx(parent).childBefore_(firsttarget, tag, attrs);
                    b.moveChildren_(firsttarget, lasttarget);
                    native$.iSelectNodes_(firsttarget, lasttarget, true, true);
                    this._tree?.deselectAll_();
                    this._refresh1(treeparent, parent);
                    treeparent.get_(index);
                    treeparent.select_(true);
                    treeparent.expand_();
                });
            });
        });
        d.show_();
        return true;
    }

    private _actionInsertWidget(sel: ArrayX<OutlineTreenode>, e: MouseEvent): void {
        const selection = this._validOutlineSelectionOrWarn(sel);
        if (selection == null || selection.length == 0) {
            return;
        }
        const menu = new _WidgetContextmenu(accessories$, _WidgetTemplates._INFOS);
        menu.onAction_(action => {
            menu.destroy_();
            _MainPanel._widgetContextAction(action);
        });
        menu.onCancel_(() => {
            menu.destroy_();
        });
        menu.show_(e.pageX, e.pageY);
    }

    private _actionDestroyWidget(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTarget1(sel, (_first: OutlineTreenode, target: Node) => {
            if (target.nodeType != Node.ELEMENT_NODE) {
                toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
                return;
            }
            if (_WidgetTemplates._actionDestructWidget()) {
                sidePanel$.hideSidepanel_();
            }
        });
    }

    private _actionToggleHidden(sel: OutlineTreenode[] | null): void {
        const selection = this._validOutlineSelectionOrWarn(sel);
        if (selection == null || selection.length == 0) {
            return;
        }
        const firstnode = selection[0];
        const firsttarget = _OutlineUtil.getTarget_(firstnode);
        if (firsttarget == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const nodename = firsttarget.nodeName;
        if (An.isBodyElement_(nodename)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        history$.group_(RS.action_ToggleVisibility, nodename, () => {
            if (selection.length == 1 && firsttarget.nodeType == Node.ELEMENT_NODE) {
                native$.toggleClasses_(firsttarget as HTMLElement, [CSS.xHidden]);
                this._refreshParent1(firstnode, firsttarget, 0);
                return;
            }
            const parent = firsttarget.parentElement;
            const lastnode = ArrayUt.last_(selection);
            const treeparent = firstnode.parent_();
            if (treeparent == null || parent == null || lastnode === undefined) { return; }
            const target = _OutlineUtil.getTarget_(lastnode);
            if (target == null) { return; }
            const index = treeparent.indexOf_(firstnode);
            const lasttarget = target.nextSibling;
            const b = new DomBuilderEx(parent).childBefore_(firsttarget, "div", { "class": CSS.xHidden });
            b.moveChildren_(firsttarget, lasttarget);
            this._tree?.deselectAll_();
            this._refresh1(treeparent, parent);
            treeparent.get_(index);
            treeparent.select_(true);
            treeparent.expand_();
        });
    }

    private _actionInsertElement(sel: OutlineTreenode[] | null): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._actionInsertElement1(target, (_node: HTMLElement, after: boolean) => {
                this._tree?.deselectAll_();
                if (after) {
                    this._refreshParent1(first, target, 1);
                } else {
                    this._refresh1(first, target);
                    first.firstChild_();
                    first.select_(true);
                    first.reveal_();
                    first.expand_();
                }
            });
        });
    }

    private _actionInsertText(sel: OutlineTreenode[] | null): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            _MainPanel._actionInsertText1(target, (_node: Node, after: boolean) => {
                this._refreshParent1(first, target, after ? 1 : 0);
            });
        });
    }

    private _actionParagraphBreak(sel: OutlineTreenode[] | null, e: MouseEvent): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            const d = new _ParaContextmenu(accessories$);
            d.onAction_(style => {
                d.hide_();
                const attrs: StringMap<stringX> = (style == CSS.xNone) ? {} : { "class": style };
                history$.group_(RS.action_InsertParagraph, style, () => {
                    const parent = target.parentElement;
                    if (parent == null) { return; }
                    new DomBuilderEx(parent).childBefore_(target.nextSibling, "div", attrs).br_();
                    this._refreshParent1(first, target, 1);
                });
            });
            d.show_(/* true, */ e.pageX, e.pageY);
        });
    }

    private _actionLInebreak(sel: OutlineTreenode[] | null): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            history$.group_(RS.action_InsertLinebreak, "", () => {
                const parent = target.parentElement;
                if (parent == null) { return; }
                new DomBuilderEx(parent).childBefore_(target.nextSibling, "br");
                this._refreshParent1(first, target, 1);
            });
        });
    }

    private _actionPasteChild(sel: OutlineTreenode[] | null): void {
        this._outlineTarget1(sel, (first: OutlineTreenode, target: Node) => {
            const elm = DomUt.asHTMLElement_(target);
            if (elm == null) {
                toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
                return;
            }
            const clone = native$.cloneClipboard_(clipboard$.get_());
            const type = clone == null ? null : clone.nodeType;
            if (type == null
                || type != Node.TEXT_NODE && !(type == Node.ELEMENT_NODE && clone != null && clone.firstChild != null)
                || clone == null) {
                toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
                return;
            }
            const b = new DomBuilderEx(elm);
            const next = elm.firstChild;
            let count = 1;
            history$.group_(RS.action_Paste, "", () => {
                if (type == Node.TEXT_NODE) {
                    b.insertBefore_(next, clone);
                    native$.iSelectNode_(clone);
                } else {
                    count = clone.childNodes.length;
                    const firstchild = clone.firstChild;
                    const lastchild = clone.lastChild;
                    if (!_MainPanel._pasteSibling(b, elm, next, clone)) {
                        toasters$.warnKey_(RS.InvalidSelection);
                        return;
                    }
                    if (firstchild != null) {
                        native$.iSelectNodes_(firstchild, lastchild);
                    }
                }
                this._tree?.deselectAll_();
                this._refresh1(first, elm);
                let node = first.firstChild_();
                while (--count >= 0 && node != null) {
                    node.select_(true);
                    node = node.nextSibling_();
                }
            });
        });
    }

    private _actionPasteSibling(sel: ArrayX<OutlineTreenode>): void {
        this._outlineTargetLast(sel, (selected: OutlineTreenode, target: Node) => {
            const parent = target.parentElement;
            const clone = native$.cloneClipboard_(clipboard$.get_());
            const type = clone == null ? null : clone.nodeType;
            if (type == null
                || type != Node.TEXT_NODE && !(type == Node.ELEMENT_NODE && clone != null && clone.firstChild != null)
                || clone == null
                || parent == null) {
                toasters$.warnKey_(RS.ClipboardIsEmptyOrInvalid);
                return;
            }
            const count = _MainPanel._actionPasteSibling1(parent, target, type, clone);
            this._refreshParent(selected, parent, 1, count);
        });
    }

    private _actionCopy(sel: OutlineTreenode[] | null): boolean {
        if (sel == null || sel.length == 0) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return false;
        }
        const nodes = new Array<Node>();
        for (const e of sel) {
            const target = _OutlineUtil.getTarget_(e);
            if (target == null) {
                toasters$.error_(MSG.string_(RS.TargetNodeNotExists));
                return false;
            }
            nodes.push(target);
        }
        const fragment = native$.iCreateDocumentFragment_(nodes);
        if (fragment != null) {
            const data = native$.serializeClone_(fragment);
            const parent = nodes[0].parentNode;
            const context = parent == null ? "" : JsUtil.getContextHtml_(parent);
            clipboard$.dom_(data, context);
        }
        return true;
    }

    private _actionCut(sel: OutlineTreenode[] | null): boolean {
        const ret = this._actionDelete(sel);
        if (ret == null) { return false; }
        const parent = ret[0];
        const nodes = ret[1];
        const fragment = native$.iCreateDocumentFragment_(nodes);
        if (fragment == null || parent == null) { return false; }
        const data = native$.serializeClone_(fragment);
        const context = JsUtil.getContextHtml_(parent);
        clipboard$.dom_(data, context);
        return true;
    }

    private _actionDelete(sel: OutlineTreenode[] | null): [HTMLElementX, Node[]] | null {
        const selection = this._validOutlineSelectionOrWarn(sel);
        if (selection == null || selection.length == 0) { return null; }
        const treenode0 = selection[0];
        const treeparent0 = treenode0.parent_();
        const target0 = _OutlineUtil.getTarget_(treenode0);
        const parent = target0?.parentElement ?? null;
        if (treeparent0 == null || target0 == null || parent == null) {
            
            return null;
        }
        const nodes = new Array<Node>();
        for (const treenode of selection) {
            if (treenode == null) {
                
                return null;
            }
            const target = _OutlineUtil.getTarget_(treenode);
            if (target == null) {
                
                return null;
            }
            nodes.push(target);
            Assert.assertionKey_(target.parentNode == parent, RS.AssertMultiSelectionMustBeUnderTheSameParent);
            Assert.assertionKey_(treenode.parent_() == treeparent0, RS.AssertMultiSelectionMustBeUnderTheSameParent);
        }
        const b = new DomBuilderEx(parent);
        history$.group_(RS.action_Cut, "", () => {
            for (const target of nodes) {
                b.removeChild_(target);
            }
        });
        while (selection.length > 0) {
            selection.pop()!.remove_();
        }
        this._refresh1(treeparent0, parent);
        return [parent, nodes];
    }

    ////////////////////////////////////////////////////////////////////////

    private _toolbarActions(action: string, e: MouseEvent) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.CollapseAll:
                this._actionCollapseAll();
                break;
            case BUT.ExpandAll:
                this._actionExpandAll();
                break;
            case BUT.ExtendSelection:
                this._actionExtend();
                break;
            case BUT.Contextmenu:
                this.showContextmenu_(e);
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _searchbarActions(action: string, e: MouseEvent) {
        switch (action) {
            case BUT.Contextmenu:
                this.showContextmenu_(e);
                break;
            case BUT.NextMatch:
                this._actionNextMatch();
                break;
            case BUT.PrevMatch:
                this._searchbar.button_(BUT.NextMatch).classList.add(CSS.AnToggleOff);
                this._searchbar.button_(BUT.PrevMatch).classList.remove(CSS.AnToggleOff);
                this._actionIncrementalSearch(false, false, true);
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _actionNextMatch = () => {
        this._searchbar.button_(BUT.NextMatch).classList.remove(CSS.AnToggleOff);
        this._searchbar.button_(BUT.PrevMatch).classList.add(CSS.AnToggleOff);
        this._actionIncrementalSearch();
    };

    private _actionExtend(): void {
        if (this._tree == null) { return; }
        const sel = this._tree.getSelection_();
        if (sel.length == 0) {
            this._tree.root_().firstChild_()?.select_(true);
            return;
        }
        const treenode = ArrayUt.last_(sel);
        const next = treenode?.nextSibling_() ?? null;
        if (next == null) {
            toasters$.infoKey_(RS.NoMoreChild);
            return;
        }
        next.select_(true);
        const range = native$.getIFrameSelectionRange_();
        if (range != null) {
            const target = _OutlineUtil.getTarget_(next);
            if (target != null) { range.setEndAfter(target); }
            native$.iSelectRange_(range);
        }
    }

    private _actionExpandAll(): void {
        if (this._tree == null) { return; }
        const timer = new StepTimer();
        const sel = this._tree.getSelection_();
        if (sel.length == 0) {
            for (let c = this._tree.root_().firstChild_(); c != null; c = c.nextSibling_()) {
                c.expandAll_();
            }
        } else {
            for (const node of sel) {
                node.expandAll_();
            }
        }
        timer.debug_("# actionExpandAll()");
    }

    private _actionCollapseAll(): void {
        if (this._tree == null) { return; }
        const timer = new StepTimer();
        const sel = this._tree.getSelection_();
        if (sel.length == 0) {
            for (let c = this._tree.root_().firstChild_(); c != null; c = c.nextSibling_()) {
                c.collapseAll_();
            }
        } else {
            for (const node of sel) {
                node.collapseAll_();
            }
        }
        timer.debug_("# actionCollapsedAll()");
    }

    ////////////////////////////////////////////////////////////////////////

    private _enableToolbar(enable: boolean): void {
        if (enable) {
            this._searchbar.hide_();
            this._toolbar.show_();
            this._matcher = null;
        } else {
            this._searchbar.hide_();
            this._toolbar.showHidden_();
            this._matcher = null;
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _DocumentLinksPanel extends DocumentPanelBase {
    static readonly _ADD = "a";
    static readonly _REMOVE = "R";
    private _toolbar: Toolbar;
    private _filterbar: Toolbar;
    private _content: HTMLElement;
    private _filterbox: HTMLTextAreaElement;
    private _linkInfos: JSONObjectX = null;
    private _linkStatus: StringMap<stringX> | null = null;
    private _showBrokenOnly: boolean = false;
    private _selected: HTMLElementX = null;
    private _rateLimiter = new FireLimiter(DEFUtil.filterDelay$);

    constructor(private _container: HTMLElement) {
        super();
        const b = new DomBuilderEx(_container).push_();
        this._toolbar = new Toolbar(b.cursor_(), [
            BUT.info_(BUT.FixBrokenLinks),
            BUT.info_(BUT.OpenStylesheet),
            BUT.info_(BUT.EditLink),
            smap_(
                [ATTR.AnAction, _DocumentLinksPanel._ADD],
                ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaPlus}`],
                [ATTR.xTooltips, RS.Tooltips_AddLink],
            ),
            smap_(
                [ATTR.AnAction, _DocumentLinksPanel._REMOVE],
                ["class", `${CSS.AnButton} ${CSS.Fa} ${CSS.FaMinus}`],
                [ATTR.xTooltips, RS.Tooltips_RemoveLink],
            ),
            BUT.info_(BUT.ShowBrokenOnly),
            BUT.info_(BUT.Toolbar),
        ]);
        this._toolbar.onAction_(action => this._toolbarActions(action));
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        An.hide_(this._toolbar.button_(BUT.OpenStylesheet));
        this._filterbar = new Toolbar(b.cursor_(), [
            INPUT.info_(INPUT.FilterBox),
            BUT.info_(BUT.ClearSearchText),
            BUT.info_(BUT.Toolbar1),
        ]);
        this._content = b.peek_().div1_(CSS.AnContentViewport).cursor_();
        this._filterbar.onAction_(action => this._toolbarActions(action));
        this._filterbar.onTooltips_(toasters$.onTooltipsKey_);
        this._filterbox = this._filterbar.querySelector_(Conf.input$) as AnInputElement;
        An.onInputFocusSelect_(this._filterbox);
        An.onKeypress_(this._filterbox, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this._filter();
            }
        });
        An.onInput_(this._filterbox, () => {
            this._rateLimiter.queue_(() => {
                this._filter();
            });
        });
        An.onKeypress_(this.element_(), (e) => {
            if (e.ctrlKey && (e.key == "f" || e.key == "F")) {
                An.stopevent_(e);
                if (e.shiftKey) this._showMainbar();
                else this._showFilterbar();
            }
        });
        this._enableToolbar(true);
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            host$.hideKeyboard_(() => {
                const timer = new StepTimer();
                timer.debug_("# DocumentLinksPanel.show(): start");
                An.showHidden_(this._container);
                this.resizeContent_(window.innerHeight - cache$.ui$.toolbarHeight_());
                this.refresh();
                An.setVisible_(this._container);
                timer.debug_("# DocumentLinksPanel.show(): end");
            });
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            
            this.hideContextmenu_();
            An.hide_(this._container);
            new DomBuilderEx(this._content).empty_();
        }
    }

    refresh(select: OutlineTreenode | null = null): void {
        const timer = new StepTimer();
        timer.debug_("# DocumentLinksPanel.refresh(): start");
        this._selected = null;
        if (!(docInfo$ != null && docInfo$.isHtml$)) {
            this._disablePanel();
            return;
        }
        this._linkInfos = native$.getIFrameLinks_();
        const infos = An.parseJSONObjectOrNull_(native$.stringify_(this._linkInfos));
        if (infos == null) {
            this._disablePanel();
            return;
        }
        const baseurl = infos[Key.baseurl];
        const links = infos[Key.links] as JSONObject;
        const params = smap_(
            [Key.baseurl, baseurl],
            [Key.links, links],
        );
        host$.linkInfos_(params, ret => {
            timer.debug_("# DocumentLinksPanel.refresh(): linkinfos done");
            const errors = ret[Key.errors];
            if (errors != null) {
                this._disablePanel();
                toasters$.warn_(errors);
                return;
            }
            this._linkStatus = (ret[Key.result] as SStringMap);
            this._populate(timer);
            this._enableToolbar(true);
            this._updateToolbarState();
            if (select != null) {
            }
            timer.debug_("# DocumentLinksPanel.refresh(): end");
        });
    }

    private _disablePanel(): void {
        new DomBuilderEx(this._content).empty_();
        this._enableToolbar(false);
    }

    protected _updateToolbarState(): void {
        const elm = this._editok(false);
        const [linkinfo, ishead] = this._getlinkinfoOf(elm);
        const removeok = (elm != null);
        const addok = (this._selected == null && mainPanel$.isEditing() || elm != null && linkinfo != null && ishead);
        this._toolbar.enableButton_(BUT.EditLink, elm != null);
        this._toolbar.enableButton_(_DocumentLinksPanel._REMOVE, removeok);
        this._toolbar.enableButton_(_DocumentLinksPanel._ADD, addok);
        const butopen = this._toolbar.button_(BUT.OpenStylesheet);
        const butfix = this._toolbar.button_(BUT.FixBrokenLinks);
        if (elm == null && mainPanel$.isEditing()) {
            An.hide_(butopen);
            An.show_(butfix);
            this._toolbar.enableButton_(BUT.FixBrokenLinks, this._hasBrokenLinks());
        } else {
            An.hide_(butfix);
            An.show_(butopen);
            this._toolbar.enableButton_(BUT.OpenStylesheet, this._openStylesheetOK(linkinfo, ishead));
        }
    }

    private _hasBrokenLinks(): boolean {
        if (this._linkInfos != null && this._linkStatus != null) {
            function hasbroken(infos: JSONArrayX, linkstatus: JSONObject): boolean {
                if (infos != null) {
                    for (const linkinfo of infos) {
                        if (isbroken(linkinfo, linkstatus)) return true;
                    }
                }
                return false;
            }
            function isbroken(linkinfo: JSONObject, linkstatus: JSONObject): boolean {
                const href = linkinfo[LinkInfoKey.value];
                if (href == null) return false;
                const status = linkstatus[href];
                return !(status == null || status == LinkInfoStatus.EXISTS);
            }
            return hasbroken(this._linkInfos[LinkInfoKey.HEAD], this._linkStatus) ||
                hasbroken(this._linkInfos[LinkInfoKey.BODY], this._linkStatus);
        }
        return false;
    }

    resizeContent_(containerheight: number): void {
        
        if (this._shown) {
            const h = containerheight - cache$.ui$.toolbarHeight_() - DEF.sidepanelMarginBottom /* margin-bottom */;
            const width = Math.round(this._container
                .getBoundingClientRect()
                .width);
            this._content.style.height = `${h}px`;
            this._content.style.minWidth = `${width}px`;
        }
    }

    private _enableToolbar(enable: boolean): void {
        if (enable) {
            this._filterbar.hide_();
            this._toolbar.show_();
        } else {
            this._filterbar.hide_();
            this._toolbar.showHidden_();
        }
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.Toolbar:
                this._showFilterbar();
                break;
            case BUT.Toolbar1:
                this._showMainbar();
                break;
            case BUT.ShowBrokenOnly:
                this._showBrokenOnly = An.toggleOnOffButton_(this._toolbar.button_(BUT.ShowBrokenOnly));
                this.refresh();
                break;
            case BUT.EditLink:
                this._actionEditLink();
                break;
            case BUT.OpenStylesheet:
                this._actionOpenStylesheet();
                break;
            case BUT.FixBrokenLinks:
                this._actionFixBrokenLinks();
                break;
            case BUT.ClearSearchText:
                this._filterbox.value = "";
                this._filter();
                break;
            case _DocumentLinksPanel._ADD:
                this._actionAdd();
                break;
            case _DocumentLinksPanel._REMOVE:
                this._actionRemove();
                break;
            case BUT.EditLink:
                this._actionEditLink();
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _showFilterbar() {
        this._toolbar.hide_();
        this._filterbar.show_();
        Timer.sleep00_(() => {
            this._filterbox.focus();
            An.select_(this._filterbox);
            host$.showKeyboard_();
        });
    }

    private _showMainbar() {
        this._filterbar.hide_();
        this._toolbar.show_();
    }

    showContextmenu_(): void {
    }

    hideContextmenu_(): void { }

    onWindowSizeChanged_(): void { }

    private _actionEditLink(): void {
        const elm = this._editok();
        const baseuri = native$.getIFrameUri_();
        const [linkinfo, ishead] = this._getlinkinfoOf(elm);
        if (elm == null || baseuri == null || linkinfo == null) return;
        const name: string = linkinfo[LinkInfoKey.name$];
        const value: string = linkinfo[LinkInfoKey.value];
        if (name == null || value == null) {
            toasters$.warnKey_(RS.SelectedNodeIsNotEditable);
            return;
        }
        const tag: string = linkinfo[LinkInfoKey.tag];
        const targetpath: number[] = linkinfo[LinkInfoKey.targetpath];
        const target = DomUt.asHTMLElement_(targetpath == null ? null : native$.getIFrameNodeByPath_(targetpath, ishead));
        if (target == null) {
            toasters$.warnKey_(RS.TargetNodeNotExists);
            return;
        }
        if (ishead) {
            this._editlink(tag, name, HumanLink.fromHref_(value), baseuri, (uri) => {
                linkinfo[LinkInfoKey.value] = (uri == null ? "" : uri.encoded$);
                this._actionEditLink1(
                    elm,
                    target,
                    name,
                    uri,
                    baseuri);
            });
            return;
        }
        switch (name) {
            case "name": {
                _Util.promptName_(RS.Name, null, "", value, (name) => {
                    JsUtil.setAttribute_(target, "name", name);
                    linkinfo[LinkInfoKey.value] = name;
                    this._updateNameValue(elm, LinkInfoStatus.EXISTS, "name", name);
                }).show_();
                break;
            }
            case "src":
            case "href": {
                const isimg = tag == "IMG" && name == "src";
                this._edithref(HumanLink.fromHref_(value), baseuri, isimg, (uri) => {
                    linkinfo[LinkInfoKey.value] = (uri == null ? "" : uri.encoded$);
                    this._actionEditLink1(
                        elm,
                        target,
                        name,
                        uri,
                        baseuri);
                });
                break;
            }
            default:
                toasters$.error_(MSG.string_(RS.InvalidSelection) + ": " + name);
        }
    }

    private _edithref(value: HumanLink, baseuri: Uri, isimg: boolean, callback: Fun10<UriX>) {
        _Util.promptLink_(RS.EditLinkTitle, "", value, baseuri, RS.URL).onOK_((d, href, okcallback) => {
            Sanitizers.checkOptionalHref_(href, baseuri).onFail_((msgs) => {
                d.warn_(msgs);
                okcallback(false);
            })?.onOK_((uri) => {
                if (uri == null) {
                    okcallback(true);
                    callback(null);
                    return;
                }
                if (isimg && Sanitizers.checkIsImageUri_(uri).onFail_(msg => {
                    d.warn_(msg);
                    okcallback(false);
                }) == null) return;
                okcallback(true);
                callback(uri);
            });
        }).show_();
    }

    private _editlink(tag: string, name: string, value: HumanLink, baseuri: Uri, callback: Fun10<UriX>) {
        _Util.promptCssOutputUrl_(
            RS.EditLinkTitle,
            MSG.format2_(RS.editLinkMessage, tag ?? "", name),
            value,
            FilepickerKind.EXISTING_FILE,
            baseuri,
            RS.URL,
        ).onOK_((d, href, okcallback) => {
            Sanitizers.checkOptionalHref_(href, baseuri)?.onFail_(msgs => {
                d.warn_(msgs);
                okcallback(false);
            })?.onOK_((uri) => {
                if (uri == null) {
                    okcallback(true);
                    callback(null);
                    return;
                }
                const cpath = An.cpathOfUri_(uri);
                if (cpath == null || !this._addcssok(cpath)) {
                    d.warn_(MSG.string1_(RS.DestinationNotValid_, cpath));
                    okcallback(false);
                    return;
                }
                Sanitizers.checkIsSameSuffix_(uri, ".css").onFail_(msg => {
                    d.warn_(msg);
                    okcallback(false);
                })?.onOK_((uri) => {
                    okcallback(true);
                    callback(uri);
                });
            });
        }).show_();
    }

    private _actionEditLink1(
        elm: HTMLElement,
        target: HTMLElement,
        name: string,
        uri: UriX,
        baseuri: BaseUri,
    ): void {
        if (uri == null) {
            target.removeAttribute(name);
            this.refresh();
            return;
        }
        const href = uri.encoded$;
        host$.linkInfo_(baseuri.toString(), href, (ret) => {
            const status: string = toasters$.warn_(ret) ? LinkInfoStatus.INVALID : ret[Key.linkinfo];
            if (this._linkStatus != null) {
                this._linkStatus[href] = status;
            }
            target.setAttribute(name, href);
            this._updateNameValue(elm, status, name, HumanLink.fromUri_(uri).humanHref$);
        });
    }

    private _actionAdd(): void {
        let elm: HTMLElementX = null;
        if (this._selected != null || !mainPanel$.isEditing()) {
            elm = this._editok();
            const [linkinfo, ishead] = this._getlinkinfoOf(elm);
            if (elm == null || linkinfo == null || !ishead) {
                toasters$.warnKey_(RS.ActionNotPermitted);
                return;
            }
        }
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) return;
        let cpath = native$.getIFrameContextPath_();
        let href: HumanLink;
        if (cpath == null /* || !PathUtil.isDocumentsSubtree(cpath) */) {
            href = HumanLink.fromFilepath_(PathUtil.getHomeDir() + "XXX.css");
        } else {
            href = HumanLink.fromHref_(Basepath.stem_(cpath) + ".css");
        }
        _Util.promptCssOutputUrl_(
            RS.AddStylesheetTitle,
            MSG.string_(RS.AddStylesheetMessage),
            href,
            FilepickerKind.ANY_FILE,
            baseuri,
            RS.PlaceholderRequiredUrl,
        ).onOK_((d, href, okcallback) => {
            Sanitizers.checkRequiredHref_(href, baseuri).onFail_(msgs => {
                okcallback(false);
                d.warn_(msgs);
            })?.onOK_(uri => {
                const lcsuffix = UriUt.lcSuffix_(uri);
                if (Suffix.CSS$ != lcsuffix) {
                    d.warn_(MSG.string1_(RS.ExpectingCSSExt_, lcsuffix));
                    okcallback(false);
                    return;
                }
                const cpath = An.cpathOfUri_(uri);
                if (cpath == null || !this._addcssok(cpath)) {
                    d.warn_([MSG.string_(RS.DestinationNotValid_), cpath]);
                    okcallback(false);
                    return;
                }
                okcallback(true);
                this._actionAddStylesheet(elm, uri.encoded$, cpath);
            });
        }).show_();
    }

    private _addcssok(cpath: string): boolean {
        cpath = An.apath_(cpath);
        return (PathUtil.isDocumentsSubtree(cpath)
            || PathUtil.isBackupsSubtree(cpath)
            || cpath.startsWith(PATH._assetsTemplates_)
            || cpath.startsWith(PATH._assetsManual_)
            || cpath.startsWith(PATH._assetsClient)
            || cpath.startsWith(PATH._assetsCore)
        );
    }

    private _isClientCss(cpath: string): boolean {
        cpath = An.apath_(cpath);
        return cpath.startsWith(PATH._assetsClient);
    }

    private _actionAddStylesheet(elm: HTMLElementX, href: string, cpath: string): void {
        new FilepickerHandler().fileInfo_(cpath, ret => {
            const info = FileInfo.of_(ret[Key.fileinfo]);
            if (toasters$.warn_(ret) || info == null) return;
            if (info.exists$) {
                this._actionAddStylesheet1(
                    elm,
                    "stylesheet",
                    Mime.CSS$,
                    href,
                    cpath,
                );
                return;
            }
            host$.saveCSS_(cpath, "", null, ret => {
                if (toasters$.warn_(ret)) return;
                Timer.sleep0_(() => {
                    this._actionAddStylesheet1(
                        elm,
                        "stylesheet",
                        Mime.CSS$,
                        href,
                        cpath,
                    );
                });
            });
        });
    }

    private _actionAddStylesheet1(
        elm: HTMLElementX,
        rel: string,
        type: string,
        href: string,
        _cpath: string,
    ): void {
        
        const attrs: SStringMap = {
            "rel": rel,
            "href": href,
        };
        if (type != null) {
            attrs["type"] = type;
        }
        if (elm == null) {
            const idoc = native$.getIFrameDocument_();
            if (idoc != null) {
                const head = idoc.head;
                new DomBuilderEx(head).childBefore_(head.firstChild, "LINK", attrs);
            }
        } else {
            const [linkinfo] = this._getlinkinfoOf(elm);
            const targetpath = linkinfo?.[LinkInfoKey.targetpath];
            const t = DomUt.asHTMLElement_(targetpath == null ? null : native$.getIFrameNodeByPath_(targetpath, true));
            if (t == null) {
                toasters$.warnKey_(RS.TargetNodeNotExists);
                return;
            }
            new DomBuilderEx(t).siblingAfter_("LINK", attrs);
        }
        this.refresh();
    }

    private _actionRemove(): void {
        const elm = this._editok();
        const baseuri = native$.getIFrameUri_();
        const [linkinfo, ishead] = this._getlinkinfoOf(elm);
        if (elm == null || linkinfo == null || baseuri == null) return;
        const targetpath = linkinfo[LinkInfoKey.targetpath];
        const node = DomUt.asHTMLElement_(targetpath == null ? null : native$.getIFrameNodeByPath_(targetpath, ishead));
        if (node == null) {
            toasters$.warnKey_(RS.TargetNodeNotExists);
            return;
        }
        if (ishead && node.nodeName == "LINK") {
            const href = node.getAttribute("href");
            if (href != null) {
                let msg: string[];
                const rel = node.getAttribute("rel");
                if (rel == "stylesheet") {
                    const cpath = An.cpathOfHref2_(baseuri, href);
                    if (cpath == null) {
                        msg = [MSG.string_(RS.ConfirmUnlinkStylesheet), href];
                    } else {
                        const isdef = this._isClientCss(cpath);
                        msg = [MSG.string_(isdef ? RS.ConfirmUnlinkDefaultStylesheet : RS.ConfirmUnlinkStylesheet)];
                        msg.push(cpath);
                    }
                } else if (rel == "next") {
                    msg = [MSG.string_(RS.ConfirmDeletingNextPageLink), href];
                } else if (rel == "prev") {
                    msg = [MSG.string_(RS.ConfirmDeletingPrevPageLink), href];
                } else {
                    msg = [href];
                }
                DialogUt.confirm_(accessories$, msg, (yes: boolean) => {
                    if (!yes) return;
                    this._actionRemove1(node);
                }).zindex_(DEF.zindexConfirm).showWarning_();
                return;
            }
        }
        const tag = linkinfo[LinkInfoKey.tag];
        _Util.confirmSmall_(MSG.format1_(RS.confirmDeletingElement, tag ?? ""), DEF.zindexConfirm, yes => {
            if (!yes) return;
            this._actionRemove1(node);
        });
    }

    private _actionRemove1(target: HTMLElement): void {
        JsUtil.remove_(target);
        this.refresh();
    }

    private _editok(warn: boolean = true): HTMLElementX {
        if (this._selected != null && mainPanel$.isEditing()) return this._selected;
        if (warn) toasters$.warnKey_(RS.ActionNotPermitted);
        return null;
    }

    static _openCSS(cpath: string, writable: boolean): void {
        sidePanel$.hideSidepanel_();
        host$.readCSS_(cpath, ret => {
            if (toasters$.warn_(ret)) return;
            const content: string = ret[Key.result];
            const position = ret[Key.status] ?? null;
            const d = new CSSEditor(accessories$, gestureHandler$, cpath, writable, writable, content.trim(), position);
            d.zindex_(DEF.zindexPrompt);
            d.show_();
        });
    }

    private _openStylesheetOK(linkinfo: JSONObjectX, ishead: boolean): boolean {
        if (linkinfo == null) return false;
        return ishead
            && linkinfo[LinkInfoKey.tag] == "LINK"
            && linkinfo[LinkInfoKey.name$] == "href"
            && Basepath.lcSuffix_(linkinfo[LinkInfoKey.value] ?? "") == ".css";
    }

    private _select(elm: HTMLElement, targetpath: Int[] | null) {
        if (!elm.classList.toggle(CSS.AnSelected)) {
            this._selected = null;
            return;
        }
        this._unselect();
        this._selected = elm;
        if (targetpath != null) {
            native$.iSelectNodeByPath_(targetpath, true, true);
        }
    }

    private _unselect() {
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelected);
            this._selected = null;
        }
    }

    private _actionFixBrokenLinks(): void {
        const cpath = native$.getIFrameContextPath_();
        if (cpath == null)
            return;
        const basepath = new Basepath(cpath);
        const docdir = basepath.dir$;
        if (docdir == null)
            return;
        _Util.promptFilepathKey_(RS.FromDir, FilepickerKind.ANY_DIR, "", docdir, docdir + FS)
            .onOK_((okcallback, fromdir) => {
                okcallback(true);
                this._actionFixBrokenLinks1(cpath, docdir, fromdir);
            })
            .onCancel_(() => this._actionFixBrokenLinks1(cpath, docdir, null))
            .zindex_(DEF.zindexPrompt)
            .setDelegate_(FilepickerDirDelegate.singleton$)
            .show_();
        toasters$.infoKey_(RS.ActionFixBrokenLinksKnownGoodDir);
    }

    private _actionFixBrokenLinks1(cpath: string, docdir: string, fromdir: stringX): void {
        host$.requestFixBrokenLinks_(cpath, fromdir, (ret) => {
            if (toasters$.warn_(ret))
                return;
            const tofix = ret[Key.result] as JSONObject;
            if (Object.keys(tofix).length == 0) {
                toasters$.warnKey_(RS.ActionFixBrokenLinksNothingToFix);
                return;
            }
            new PromptFixBrokenLinks(accessories$, docdir, tofix)
                .titleKey_(RS.ActionFixBrokenLinksTitle)
                .onOK_(selected => {
                    const spinner = new Spinner(this._container);
                    spinner.show_(() => {
                        Timer.sleep0_(() => {
                            host$.confirmFixBrokenLinks_(cpath, selected, (ret) => {
                                spinner.destroy_();
                                if (toasters$.warn_(ret))
                                    return;
                                mainPanel$.stopEdit(false, () => {
                                    host$.saveRecovery_(cpath, ret => {
                                        toasters$.warn_(ret);
                                        sidePanel$.hideSidepanel_(_DEF.SidebarTop, () => {
                                            const state = mainPanel$.saveSession_(null);
                                            _Util.browseFile_(cpath, state, true);
                                        });
                                    });
                                });
                            });
                        });
                    });
                })
                .onCancel_(() => {
                    toasters$.warnKey_(RS.ActionFixBrokenLinksCancelled);
                })
                .zindex_(DEF.zindexPrompt)
                .show_();
        });
    }

    private _actionOpenStylesheet(): void {
        const div = this._selected;
        if (div == null) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return;
        }
        const baseuri = native$.getIFrameUri_();
        const [linkinfo, ishead] = this._getlinkinfoOf(div);
        if (baseuri == null || linkinfo == null || !this._openStylesheetOK(linkinfo, ishead)) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        const href = linkinfo[LinkInfoKey.value];
        const cpath = An.cpathOfHref2_(baseuri, href);
        if (cpath == null || href == null) {
            toasters$.warnKey_(RS.InvalidSelection);
            return;
        }
        fileinfoUt$.fileInfo_(cpath, ret => {
            if (toasters$.warn_(ret)) return;
            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
            if (fileinfo == null || !fileinfo.exists$) {
                toasters$.warnKey_(RS.FileNotFound);
                return;
            }
            _DocumentLinksPanel._openCSS(cpath, fileinfo.writable$);
        });
    }

    private _filter(): void {
        this._populate(new StepTimer());
    }

    private _populate(timer: StepTimer): void {
        timer.debug_("# DocumentLinksPanel.refresh(): populate start");
        new DomBuilderEx(this._content).empty_();
        const linkinfos = this._linkInfos;
        const linkstatus = this._linkStatus;
        if (linkinfos == null || linkstatus == null /*  || baseuri == null */) { return; }
        this._populateOutlineTree(linkinfos, linkstatus);
        timer.debug_("# DocumentLinksPanel.refresh(): populate end");
    }

    private _populateOutlineTree(linkinfos: JSONObject, linkstatus: StringMap<stringX>) {
        const b = DomBuilderEx.offline1_(this.element_().ownerDocument, "div", CSS.AnViewportContent).push_();
        const top = b.cursor_();
        b.div1_(CSS.AnTextList, CSS.AnZebra).push_();
        const head = linkinfos[LinkInfoKey.HEAD];
        this._populateOutlineSection(b, head, linkstatus, true);
        const body = linkinfos[LinkInfoKey.BODY];
        this._populateOutlineSection(b, body, linkstatus, false);
        new DomBuilderEx(this._content).empty_().appendNodes_(top);
        An.onClickMatching_(top, `.${CSS.AnTextList}>div`, (elm, e) => {
            An.stopevent_(e);
            const [linkinfo] = this._getlinkinfoOf(elm);
            const targetpath = linkinfo?.[LinkInfoKey.targetpath];
            if (targetpath == null || !(targetpath instanceof Array)) {
                native$.iClearSelection_();
                this._unselect();
            } else {
                this._select(elm, targetpath);
            }
            this._updateToolbarState();
        });
    }

    private _populateOutlineSection(
        b: DomBuilderEx,
        linkinfos: JSONObject[] | null,
        linkstatus: StringMap<stringX>,
        ishead: boolean,
    ): void {
        b.peek_().div2_(ATTR.AnInfo, JSON.stringify([true, -1])).span1_(CSS.AnSec).text_(ishead ? "HEAD" : "BODY");
        const searchtext = this._filterbox.value.trim().toLowerCase();
        linkinfos?.forEach((linkinfo, index) => {
            const link = linkinfo[LinkInfoKey.value];
            const status = linkstatus[link];
            if (this._showBrokenOnly && (status == null || status == LinkInfoStatus.EXISTS)) return;
            if (searchtext.length > 0 && !link.toLowerCase().includes(searchtext)) return;
            this._populateOutlineItem(b, ishead, index, linkinfo, status);
        });
    }

    private _populateOutlineItem(b: DomBuilderEx, ishead: boolean, index: Int, linkinfo: JSONObject, status: stringX): void {
        if (linkinfo == null) {
            b.peek_().div_().span1_(CSS.AnErr).text_("Error");
            return;
        }
        const tag = linkinfo[LinkInfoKey.tag];
        const rel = linkinfo[LinkInfoKey.rel];
        if (tag == "LINK" && (rel == null || rel.toLowerCase() != "stylesheet")) return;
        b.peek_().div2_(ATTR.AnInfo, JSON.stringify([ishead, index])).indent_(
            b.push_().span1_(CSS.AnTag).text_(tag),
            ((rel != null) ? b.peek_().text_("\u00a0").span1_(CSS.AnTxt).text_(rel) : b),
            b.pop_().text_("\u00a0").span1_(CSS.AnAtt)
        );
        const name = linkinfo[LinkInfoKey.name$];
        const value = linkinfo[LinkInfoKey.value];
        this._createlink(b, status, name, value);
    }

    private _updateNameValue(elm: HTMLElement, status: stringX, name: string, value: string): void {
        const att = DomUt.query_(elm, `span.${CSS.AnAtt}`);
        if (att == null) return;
        const b = new DomBuilderEx(att).empty_();
        this._createlink(b, status, name, value);
    }

    private _createlink(b: DomBuilderEx, status: stringX, name: string, value: string): void {
        let classes = CSS.AnLnk;
        let label = value;
        if (name == "name") {
        } else if (value.startsWith("data:")) {
            label = An.truncate_(value, DEF.maxNodeInfoLen);
        } else {
            label = HumanLink.fromHref_(value).humanHref$;
            if (LinkInfoStatus.NOTEXISTS == status) {
                classes += " " + CSS.AnNot;
            } else if (LinkInfoStatus.EXISTS != status) {
                classes += " " + CSS.AnErr;
            }
        }
        this._createlink1(b, classes, name, label);
    }

    private _createlink1(b: DomBuilderEx, classes: string, name: string, label: string): void {
        b.text_(` ${name} (`).span2_("class", classes).text_(label).up_().text_(")");
    }

    private _getlinkinfoOf(elm: HTMLElementX): [JSONObjectX, boolean] {
        const info: [boolean, Int] = elm == null ? null : An.parseJSONOrNull_(elm.getAttribute(ATTR.AnInfo));
        return info == null ? [null, false] : [this._getlinkinfo(info[0], info[1]), info[0]];
    }

    private _getlinkinfo(ishead: boolean, index: Int): JSONObjectX {
        const infos: JSONObjectX = this._linkInfos?.[ishead ? LinkInfoKey.HEAD : LinkInfoKey.BODY] ?? null;
        return infos == null || index < 0 ? null : infos[index];
    }
}

//////////////////////////////////////////////////////////////////////////

class _DocumentStylesPanel extends DocumentPanelBase {
    private _content: HTMLElement;
    private _filterbox: HTMLTextAreaElement;
    private _target: HTMLElementX = null;
    private _contextmenu: Contextmenu | null = null;
    private _toolbar: Toolbar;
    private _rateLimiter = new FireLimiter(DEFUtil.filterDelay$);
    private _selected: HTMLElementX = null;

    constructor(private _container: HTMLElement) {
        super();
        this._toolbar = new Toolbar(_container, [
            INPUT.info_(INPUT.FilterBox),
            BUT.info_(BUT.ClearSearchText),
            BUT.info_(BUT.RulesetEdit),
        ]);
        this._toolbar.onAction_(action => this._toolbarActions(action));
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._toolbar.enableButton_(BUT.RulesetEdit, false);
        this._content = new DomBuilderEx(_container).div1_(CSS.AnContentViewport).cursor_();
        this._filterbox = this._toolbar.querySelector_(Conf.input$) as AnInputElement;
        An.onInputFocusSelect_(this._filterbox);
        An.onInputEnterKey_(this._filterbox, () => {
            this._actionFilter();
        });
        An.onInput_(this._filterbox, () => {
            this._rateLimiter.queue_(() => {
                if (this._target != null) {
                    const timer = new StepTimer();
                    this._populate(timer, this._target);
                }
            });
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            const timer = new StepTimer();
            timer.debug_("# DocumentStylesPanel.show(): start");
            this._shown = true;
            An.showHidden_(this._container);
            this.resizeContent_(window.innerHeight - cache$.ui$.toolbarHeight_());
            this.refresh();
            An.setVisible_(this._container);
            timer.debug_("# DocumentStylesPanel.show(): end");
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            
            this.hideContextmenu_();
            An.hide_(this._container);
            new DomBuilderEx(this._content).empty_();
        }
    }

    showContextmenu_(e: MouseEvent): void {
        if (this._contextmenu != null) {
            this._contextmenu.show_(e);
        }
    }

    hideContextmenu_(): void {
        if (this._contextmenu != null) {
            this._contextmenu.hide_();
        }
    }

    onWindowSizeChanged_(): void { }

    refresh(): void {
        const timer = new StepTimer();
        timer.debug_("# DocumentStylesPanel.refresh(): start");
        this._selected = null;
        if (!(docInfo$ != null && docInfo$.isHtml$)) {
            this._disablePanel();
            return;
        }
        const elm = native$.getNearestSelectedElement_();
        if (elm == null) {
            this._disablePanel();
            return;
        }
        this._populate(timer, elm as HTMLElement);
        timer.debug_("# DocumentStylesPanel.refresh(): end");
    }

    private _disablePanel(): void {
        new DomBuilderEx(this._content).empty_();
        this._toolbar.showHidden_();
    }

    resizeContent_(containerheight: number): void {
        
        if (this._shown) {
            const h = containerheight - cache$.ui$.toolbarHeight_() - DEF.sidepanelMarginBottom /* margin-bottom */;
            this._content.style.height = `${h}px`;
        }
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.ClearSearchText: {
                this._filterbox.value = "";
                if (this._target != null) {
                    this._populate(new StepTimer(), this._target);
                }
                break;
            }
            case BUT.RulesetEdit: {
                if (this._selected != null) this._edit(this._selected);
                break;
            }
            default:
                throw Assert.notReach_(action);
        }
    }

    private _actionFilter() {
        if (this._target != null) {
            this._populate(new StepTimer(), this._target);
        }
    }

    private _populate(timer: StepTimer, elm: HTMLElement): void {
        timer.debug_("# DocumentStylesPanel.refresh(): populate start");
        const baseuri = native$.getIFrameUri_();
        if (elm == null || baseuri == null) {
            this._disablePanel();
            return;
        };
        const styles = native$.getComputedStyles_(elm);
        const style = elm.getAttribute(ATTR.style);
        if (style == null || style.length == 0) {
            this._populate1(timer, elm, styles, {}, baseuri);
        } else {
            cssParser$.sanitizeStyle_(style, baseuri, (ret) => {
                const istyles = ret[Key.style] as SStringMap;
                this._populate1(timer, elm, styles, istyles, baseuri);
            });
        }
    }

    private _populate1(timer: StepTimer, elm: HTMLElement, styles: CSSStyleDeclaration, istyles: SStringMap, baseuri: BaseUri): void {
        this._populateOutlineTree(elm, styles, istyles, baseuri);
        this._updateToolbarState();
        this._toolbar.show_();
        timer.debug_("# DocumentStylesPanel.refresh(): populate end");
    }

    private _populateOutlineTree(target: HTMLElement, styles: CSSStyleDeclaration, istyles: SStringMap, baseuri: BaseUri) {
        this._target = target;
        const builder = new DomBuilderEx(this._content).empty_();
        const name = target.nodeName;
        if (An.isBodyElement_(name)) return;
        const b = DomBuilderEx.offline1_(target.ownerDocument, "div", CSS.AnViewportContent).push_();
        const top = b.cursor_();
        b.div1_(CSS.AnTextList, CSS.AnZebra).push_().cursor_();
        const nodeinfo = _OutlineUtil.getNodeInfo_(target, baseuri);
        b.peek_().div_().push_().span1_(CSS.AnSec).text_(name).pop_();
        if (nodeinfo.length > 0) {
            b.span1_(CSS.AnAtt);
            b.text_("\u00a0");
            b.text_(nodeinfo);
        }
        this._populateStyles(b, this._filterbox.value, styles, istyles, baseuri);
        builder.appendNodes_(top);
        An.onClickMatching_(top, `div.${CSS.AnTextList}>div`, (elm, e) => {
            An.stopevent_(e);
            const name = elm.getAttribute(ATTR.AnInfo);
            if (name == null) {
                this._unselect();
            } else {
                this._select(elm);
            }
            this._updateToolbarState();
        });
    }

    private _select(elm: HTMLElement) {
        if (!elm.classList.toggle(CSS.AnSelected)) {
            this._selected = null;
            return;
        }
        this._unselect();
        this._selected = elm;
    }

    private _unselect(): boolean {
        if (this._selected != null) {
            this._selected.classList.remove(CSS.AnSelected);
            this._selected = null;
            return true;
        }
        return false;
    }

    private _populateStyles(b: DomBuilderEx, filtertext: string, styles: CSSStyleDeclaration, istyles: SStringMap, baseuri: BaseUri): void {
        filtertext = filtertext.trim().toLowerCase();
        const hasfilter = filtertext.length != 0;
        const prefixed = new Set<string>();
        const keys = new Set<string>();
        for (let i = 0, len = styles.length; i < len; ++i) {
            const name = styles[i];
            if (name.startsWith("-")) {
                prefixed.add(name);
            } else {
                keys.add(name);
            }
        }
        for (const key of keys) {
            prefixed.delete(DEF.webkitPrefix + key);
        }
        const codepoints = hasfilter ? Ut.codepoints_(filtertext) : [];
        for (const set of [keys, prefixed]) {
            for (const name of set) {
                let value = styles.getPropertyValue(name);
                if (value == null) {
                    
                    continue;
                }
                const istyle = istyles[name];
                if (istyle && istyle.length > 0) value = istyle;
                value = CSSUtil.humanCSSUrls_(value, baseuri);
                if (hasfilter && !(An.fuzzyMatch1_(codepoints, name.toLowerCase())
                    || An.fuzzyMatch1_(codepoints, value.toLowerCase())
                )) continue;
                b.peek_().div2_(ATTR.AnInfo, name)
                    .span1_(CSS.AnTag)
                    .text_(name)
                    .up_()
                    .text_("\u00a0:\u00a0")
                    .child1_((istyle ? "b" : "span"), CSS.AnAtt)
                    .text_(value);
            }
        }
    }

    private _edit(elm: HTMLElement): void {
        if (!mainPanel$.isEditing() || this._target == null) return;
        const baseuri = native$.getIFrameUri_();
        const name = elm.querySelector(`.${CSS.AnTag}`)?.textContent?.trim();
        const value = elm.querySelector(`.${CSS.AnAtt}`)?.textContent?.trim();
        if (name == null || value == null || baseuri == null) return;
        const nodename = this._target.nodeName;
        if (!Html5.canEditTag(nodename)) {
            toasters$.warn_(MSG.string1_(RS.elementNotEditable_, nodename));
            return;
        }
        this._editStyleProperty(name, value, baseuri, () => {
            if (this._target != null) {
                const timer = new StepTimer();
                this._populate(timer, this._target);
            }
        });
    }

    private _editStyleProperty(name: string, value: string, baseuri: BaseUri, callback: Fun00): void {
        if (this._target == null) { return; }
        const cpath = native$.getIFrameContextPath_();
        if (baseuri == null || cpath == null) { return; }
        const nodename = this._target.nodeName;
        const oannotation = this._target.getAttribute(ATTR.xAnnotation);
        const owidth = this._target.style.width;
        const oheight = this._target.style.height;
        value = CSSUtil.escCSSValue_(name, value);
        _Util.styleEditor_(accessories$, `${name}: ${value}`, cpath, baseuri, DEF.zindexPrompt, toasters$, (ret) => {
            const value = ret[name] ?? "";
            history$.group_(RS.action_EditStyle, name, () => {
                if (this._target == null) { return; }
                native$.replaceStyle_(this._target, name, value);
                if ("IMG" == nodename && native$.hasClass_(this._target, CSS.xCanvas)) {
                    _MainPanel.rerenderCanvas_(this._target, baseuri, owidth, oheight, oannotation, false);
                }
            });
            callback();
        }).onCancel_(callback).show_();
    }

    private _updateToolbarState(): void {
        const editok = mainPanel$.isEditing() && this._selected != null;
        this._toolbar.enableButton_(BUT.RulesetEdit, editok);
    }
}

////////////////////////////////////////////////////////////////////////

class _DocumentPanel extends TabPanel implements IUIPanel {
    private _shown = false;
    constructor(container: HTMLElement) {
        super(container);
        this._container = container;
        An.onContextmenu_(this._container, e => {
            An.stopevent_(e);
        });
        const tab = this.addTab(RS.Tooltips_DocumentOutline, `${CSS.Fa} ${CSS.FaThList}`, (e) => {
            return new _DocumentOutlinePanel(e);
        });
        this.addTab(RS.Tooltips_DocumentLinks, `${CSS.Fa} ${CSS.FaLink}`, (e) => {
            return new _DocumentLinksPanel(e);
        });
        this.addTab(RS.Tooltips_DocumentStyles, `${CSS.Fa} ${CSS.FaStrikethrough}`, (e) => {
            return new _DocumentStylesPanel(e);
        });
        this.onTooltips(toasters$.onTooltipsKey_);
        this.activeTab(tab);
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            An.showHidden_(this._container);
            this.resizeContent_(window.innerHeight);
            this.selectTab(this.activeTab());
            An.setVisible_(this._container);
        }
    }

    refresh(): void {
        const panel = this.activePanel();
        if (panel != null && (panel instanceof DocumentPanelBase)) {
            panel.refresh();
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            An.hide_(this._container);
            const active = this.activePanel();
            if (active != null) {
                active.hide_();
            }
        }
    }

    destroy(): void {
        new DomBuilderEx(this._container).empty_();
    }

    showContextmenu_(): void { }

    hideContextmenu_(): void {
        
        const panel = this.activePanel();
        if (panel != null) {
            panel.hideContextmenu_();
        }
    }

    onWindowSizeChanged_(): void {
        super.onWindowSizeChanged();
    }

    resizeContent_(containerheight: number): void {
        
        super.resizeContent1(containerheight, cache$.ui$.toolbarHeight_());
    }
}

////////////////////////////////////////////////////////////////////////

type _FilesFinderCallback = (matcher: _FilesFinder) => void;

class _FilesFinder {
    _searchResult: string[] = [];
    _index: number = 0;

    constructor(
        private _fromDir: string,
        private _searchText: string,
    ) { }

    find_(cb: _FilesFinderCallback): void {
        host$.findFiles_(this._fromDir, this._searchText, ret => {
            if (toasters$.warn_(ret)) {
                this._searchResult = [];
                this._index = -1;
                return;
            }
            this._searchResult = (ret[Key.result] as Array<string>);
            this._index = -1;
            cb(this);
        });
    }

    searchText_(): string {
        return this._searchText;
    }

    hasNext_(): boolean {
        return this._index + 1 >= 0 && this._index + 1 < this._searchResult.length;
    }

    hasPrev_(): boolean {
        return this._index > 0 && this._index <= this._searchResult.length;
    }

    next_(): stringX {
        if (this.hasNext_()) {
            return this._searchResult[++this._index];
        }
        return null;
    }

    prev_(): stringX {
        if (this.hasPrev_()) {
            return this._searchResult[--this._index];
        }
        return null;
    }

    index_(): number {
        return this._index;
    }

    resultCount_(): number {
        return this._searchResult.length;
    }

    reset_(): void {
        this._index = 0;
    }
}

////////////////////////////////////////////////////////////////////////

class _FilesPanel extends FilepickerBase implements IUIPanel {
    #toolbar!: Toolbar;
    #searchbar!: Toolbar;
    #searchbox!: HTMLTextAreaElement;
    #finder: _FilesFinder | null = null;
    #shown = false;

    constructor(private _top: HTMLElement) {
        super(accessories$, FilepickerKind.ANY, "", fileinfoUt$);
        this._create();
        this.onPaste(Callbacks.pasteFromClipboard_);
        this.onCopy(Callbacks.copyToClipboard_);
    }

    private _create(): void {
        const timer = new StepTimer();
        timer.debug_("# ExploreFilesPanel.create(): start");
        const b = new DomBuilderEx(this.element_()).push_();
        this.#toolbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.Backward,
            BUT.Forward,
            BUT.CurrentDocument,
            BUT.Clear,
            BUT.Searchbar,
            BUT.Contextmenu,
        ));
        this.#toolbar.onAction_((action, e) => this._toolbarActions(action, e));
        this.#toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this.#searchbar = new Toolbar(b.cursor_(), [
            INPUT.searchbox(RS.Tooltips_SearchFilename, "1"),
            BUT.info_(BUT.NextMatch),
            BUT.info_(BUT.PrevMatch),
            BUT.info_(BUT.Toolbar),
            BUT.info_(BUT.Contextmenu),
        ]);
        this.#searchbar.onAction_((action, e) => this._toolbarActions(action, e));
        this.#searchbar.onTooltips_(toasters$.onTooltipsKey_);
        b.peek_().div1_(CSS.AnContentPanel).cursor_();
        b.div_({
            "class": CSS.AnFilesPanel,
        }).push_();
        this._createFilepicker(b);
        this.#searchbox = this.#searchbar.querySelector_(Conf.input$) as AnInputElement;
        this.#searchbar.hide_();
        this.#searchbox;
        An.onFocus_(this.#searchbox, () => {
            Timer.sleep0_(() => {
                this.#finder = null;
                this._updateSearchbarState();
            });
        });
        An.onKeypress_(this.#searchbox, (e) => {
            if (e.key == "Enter") {
                this._actionFind();
                An.stopevent_(e);
            }
        });
        An.onInput_(this.#searchbox, () => {
            this.#finder = null;
            this._updateSearchbarState();
        });
        An.onKeypress_(this.element_(), (e) => {
            if (e.ctrlKey && (e.key == "f" || e.key == "F")) {
                An.stopevent_(e);
                if (e.shiftKey) this._showMainbar();
                else this._showSearchbar();
            }
        });
        this.element_().addEventListener("contextmenu", e => {
            An.stopevent_(e);
        });
        this.setupEventHandlers();
        timer.debug_("# ExploreFilesPanel.create(): end");
    }

    private _createFilepicker(b: DomBuilderEx): void {
        const filename = b.peek_().child_(Conf.input$, INPUT.info_(INPUT.Filename)).cursor_() as AnInputElement;
        b.peek_().div_({
            "class": CSS.AnDirpath,
            "style": "padding-left:0;",
        }).push_();
        const rootbutton = b.div_(
            ["class", `${CSS.AnFlexButton} ${CSS.AnLink} ${CSS.Fa} ${CSS.FaBookmarkO}`],
            ["style", "align-self: baseline; line-height: normal; padding-left: 10px;"],
            [ATTR.xTooltips, RS.Tooltips_RootFolder],
        ).cursor_();
        const upbutton = b.peek_().div_(
            ["class", `${CSS.AnFlexButton} ${CSS.AnLink} ${CSS.Fa} ${CSS.FaAngleDoubleUp}`],
            ["style", "align-self: baseline; line-height: normal; margin-left: -5px; margin-right: 10px;"],
            [ATTR.xTooltips, RS.ActionGotoParentDirTooltips],
        ).cursor_();
        const dirpath = b.pop_().div1_(CSS.AnDirpathDir).cursor_();
        const dirtree = b.peek_().div1_(CSS.AnDirtree).cursor_();
        this.populateFilepicker_(rootbutton, upbutton, filename, null, dirpath, dirtree);
    }

    element_(): HTMLElement {
        return this._top;
    }

    ////////////////////////////////////////////////////////////////////////

    toClipboard_(path: string): void {
        clipboard$.string_(path);
        host$.copyToClipboard_(path, An.noop_);
    }

    /**
       * @param now Now in ms since epoch.
       * @param ms Last modified date in ms since epoch.
       */
    fileDateString_(lastyear: DateTime, yesterday: DateTime, now: DateTime, ms: number): string {
        return An.autoFileDatetimeString2_(lastyear, yesterday, now, DateTime.fromMs_(ms)) + "\u00a0";
    }

    updateContextmenuState_(): void {
        super.updateContextmenuState_();
    }

    updateContextmenuStateWithFilename(parentinfo: FileInfo, dirinfo: FileInfo, fileinfo: FileInfo, dir: string): void {
        With.optional_(this.contextmenu$, menu => {
            const canwrite = dirinfo != null && dirinfo.writable$;
            const lcsuffix = fileinfo == null ? "" : Basepath.lcSuffix_(fileinfo.name$);
            const isbackup = MimeUtil.isBackupLcSuffix_(lcsuffix);
            const isconvertablebackup = (lcsuffix == Suffix.ZIP$ || lcsuffix == Suffix.BACKUP$ || lcsuffix == Suffix.IBACKUP$);
            const isroot = (dir == FS || dir == "");
            menu.enableButtons_([
                BUT.Nobackup,
                BUT.GenerateBarcode,
                BUT.TakePhoto,
                BUT.RecordAudio,
                BUT.RecordVideo,
            ], canwrite);
            const canbackup = !isroot;
            menu.showButton_(BUT.ImageConversion, !isconvertablebackup, true);
            menu.showButton_(BUT.BackupConversion, isconvertablebackup, isconvertablebackup);
            menu.enableButton_(BUT.Recover, (this.rootInfo_()?.supportHistory$ ?? false) && (canwrite || isroot));
            menu.enableButtons_([BUT.Fsck, BUT.Info, BUT.ShredFile, BUT.GenerateGallery], !isroot);
            menu.enableButton_(BUT.BackupVerify, isbackup);
            menu.enableButton_(BUT.BackupRestore, isbackup || MimeUtil.isBackupKeyLcSuffix_(lcsuffix));
            menu.enableButtons_([BUT.BackupAction, BUT.Zip], canbackup);
            super.updateContextmenuStateWithFilename(parentinfo, dirinfo, fileinfo, dir);
        });
    }

    updateContextmenuStateWithoutFilename(parentinfo: FileInfo | null, dirinfo: FileInfo | null, dir: string): void {
        With.optional_(this.contextmenu$, menu => {
            const canwrite = dirinfo != null && dirinfo.writable$;
            menu.enableButtons_([
                BUT.Nobackup,
                BUT.GenerateBarcode,
                BUT.TakePhoto,
                BUT.RecordAudio,
                BUT.RecordVideo,
            ], canwrite);
            const isroot = (dir == FS || dir == "");
            const canbackup = !isroot;
            menu.enableButton_(BUT.BackupAction, canbackup);
            menu.enableButton_(BUT.Zip, canbackup);
            menu.enableButton_(BUT.Recover, (this.rootInfo_()?.supportHistory$ ?? false) && (canwrite || isroot));
            menu.enableButtons_([BUT.Fsck, BUT.Info, BUT.ShredFile, BUT.GenerateGallery], !isroot);
            menu.enableButton_(BUT.BackupVerify, canbackup);
            menu.showButton_(BUT.ImageConversion, true, !isroot);
            menu.showButton_(BUT.BackupConversion, false, false);
            menu.enableButtons_([
                BUT.BackupRestore,
            ], false);
            super.updateContextmenuStateWithoutFilename(parentinfo, dirinfo, dir);
        });
    }

    createContextmenu_(): Contextmenu {
        const d = new Contextmenu(
            accessories$,
            DEF.zindexContextmenu,
            [
                BUT.infos_(
                    BUT.Info,
                    BUT.CopyFile,
                    BUT.CutFile,
                    BUT.PasteFile,
                    BUT.CloneFile,
                ),
                BUT.infos_(
                    BUT.DeleteFile,
                    BUT.ShredFile,
                    BUT.DeleteEmptyDirs,
                    BUT.Mkdir,
                    BUT.RenameFile,
                ),
                BUT.infos_(
                    BUT.Nobackup,
                    BUT.Zip,
                    BUT.BackupVerify,
                    BUT.BackupRestore,
                    BUT.BackupAction,
                ),
                BUT.infos_(
                    BUT.PickImage,
                    BUT.PlayAll,
                    BUT.ImageConversion,
                    BUT.BackupConversion,
                    BUT.GenerateBarcode,
                    BUT.GenerateGallery,
                ),
                BUT.infos_(
                    BUT.Screenshot,
                    BUT.TakePhoto,
                    BUT.RecordVideo,
                    BUT.RecordAudio,
                    BUT.OpenDocument,
                ),
                BUT.infos_(
                    BUT.Noop,
                    BUT.Noop,
                    BUT.Fsck,
                    BUT.RebuildXrefs,
                    BUT.Recover,
                ),
            ]);
        d.onAction_((action, e, target) => this._contextActions(action, e, target));
        d.onDrag_(Contextmenu.contextmenuDragOK_);
        d.onShow_(() => this.updateContextmenuState_());
        d.onTooltips_(toasters$.onTooltipsKey_);
        return d;
    }

    /// @param name A filename.
    onFileInfo_(filename: string): void {
        const cpath = this.currentPath_(filename);
        const lcsuffix = Basepath.lcSuffixOfFilename_(filename);
        if (MimeUtil.isAudioLcSuffix_(lcsuffix)) {
            _AudioPlayerDialog.createAndShow_(accessories$, cpath);
            return;
        }
        if (MimeUtil.isVideoLcSuffix_(lcsuffix)) {
            host$.playVideo_(cpath, false, 0, (ret) => {
                toasters$.warn_(ret);
            });
            return;
        }
        if (lcsuffix == Suffix.CSS$) {
            this._handler.dirAndFileInfo_(cpath, (msg) => {
                toasters$.warn_(msg);
            }, (dirinfo, fileinfo) => {
                if (fileinfo.isdir$) {
                    toasters$.warn_(MSG.string_(RS.DestinationExpectingAFile));
                    return;
                }
                _FilesPanel._openCSS(cpath, dirinfo.writable$ && fileinfo.writableFileOrNotExists$);
            });
            return;
        }
        if (lcsuffix == Suffix.ZIP$) {
            _Util.promptFilepathKey_(
                RS.DestinationDir,
                FilepickerKind.WRITE_DIR,
                "",
                this.currentDir$,
                Basepath.joinPath_(this.currentDir$, filename))
                .setDelegate_(FilepickerDirDelegate.singleton$)
                .zindex_(DEF.zindexPrompt)
                .onOK_((okcallback, dstdir) => {
                    okcallback(true);
                    host$.unzip_(cpath, dstdir, "", (ret) => {
                        toasters$.warnErrorsOrResult_(ret, null, true);
                        this.refresh_(ret);
                    });
                })
                .show_();
            return;
        }
        if (MimeUtil.isBackupLcSuffix_(lcsuffix)) {
            const writable = this.currentDirInfo_()?.writable$ == true;
            const dstdir = writable ? this.currentDir$ : PATH.Home;
            host$.actionRestore_(settings$.dateFormat_(), cpath, dstdir, (ret) => {
                this.refresh_(ret);
            });
            return;
        }
        if (MimeUtil.isBackupKeyLcSuffix_(lcsuffix) && !MimeUtil.isImageLcSuffix_(lcsuffix)) {
            _Util.importBackupKey_(cpath, Basepath.stem_(filename));
            return;
        }
        _Util.onSaveOrDiscard_(() => {
            sidePanel$.hideSidepanel_();
            _Util.browseFile_(cpath);
        });
    }

    renameDir_(frompath: string): void {
        const oname = Basepath.filename_(frompath);
        const d = this.promptDirname(RS.RenameTitle, MSG.string_(RS.RenameMessage), oname, true)
            .onOK_((d, toname, fixxrefs, okcallback) => {
                toname = toname.trim();
                if (d.warn_(FilepickerBase._renameDirValidator(toname, oname))) {
                    okcallback(false);
                    return;
                }
                okcallback(true);
                this.rename1_(frompath, toname, fixxrefs);
            });
        d.zindex_(DEF.zindexPrompt);
        d.show_();
    }

    renameFile_(frompath: string): void {
        const opath = new Basepath(frompath);
        this.promptRename1_(
            RS.RenameTitle,
            MSG.string_(RS.RenameMessage),
            opath.dir$,
            opath.filename$,
            (name, callback) => {
                this._renameFileValidator(name, opath, callback);
            },
            (toname, fixxrefs) => {
                //// If confirmed overwriting, delete the file first, before rename.
                const info = this.dirtreeFind_(toname);
                if (info != null && info.exists$ && !info.isdir$) {
                    const newpath = Basepath.joinPath_(Basepath.dir_(frompath) ?? "", toname);
                    this._handler.delete_(newpath, ret => {
                        if (toasters$.warn_(ret)) {
                            //// Delete failed.
                            return;
                        }
                        this.rename1_(frompath, toname, fixxrefs);
                    });
                } else {
                    this.rename1_(frompath, toname, fixxrefs);
                }
            }).show_();
    }

    rename1_(frompath: string, toname: string, fixxrefs: boolean): void {
        this._handler.rename_(frompath, toname, fixxrefs, ret => {
            if (toasters$.warn_(ret)) {
                return;
            }
            this.refresh_(ret);
        });
    }

    pasteFile1_(
        cut: boolean,
        preservetimestamp: boolean,
        msg: stringX,
        dstdir: string,
        dstfilename: string,
        srcpath: string,
        callback: JSONCallback
    ): void {
        this.promptRename1_(RS.PromptPasteTitle, msg, dstdir, dstfilename, (name, callback) => {
            this._pasteFileValidator(name, dstdir, srcpath, callback);
        }, (toname, fixxrefs) => {
            const topath = (dstdir == null ? toname : Basepath.joinPath_(dstdir, toname));
            this._handler.copy_(cut, preservetimestamp, fixxrefs, topath, srcpath, null, callback);
        }).show_();
    }

    private promptRename1_(
        titlekey: StringId,
        msg: stringX,
        odir: BasedirX,
        ofilename: string,
        validator: StringValidator,
        callback: Fun20<string, boolean>
    ): PromptRename {
        return _Util.promptBasename_(titlekey, msg, odir, ofilename, true)
            .onOK_((d, name, fixxrefs, okcallback) => {
                validator(name, (errors: TestResult, sanitized: string) => {
                    if (d.warn_(errors)) {
                        okcallback(false);
                        return;
                    }
                    okcallback(true);
                    callback(sanitized, fixxrefs);
                });
            });
    }

    updateToolbarState_(dirtree: FileInfo[] | null): void {
        if (dirtree == null) {
            return;
        }
        this.#toolbar.enableButton_(BUT.Forward, this._history.canForward_());
        this.#toolbar.enableButton_(BUT.Backward, this._history.canBackward_());
    }

    ////////////////////////////////////////////////////////////////////////

    onWindowSizeChanged_(): void {
        this.recreateContextmenu_();
    }

    show_(): void {
        if (!this.#shown) {
            this.#shown = true;
            
            if (this.dirtreePanel$ == null) {
                this._create();
            }
            this._showPanel();
            let path = (this.currentDirInfo_() == null
                ? native$.getIFrameContextPath_()
                : this.currentPath_(this.getFilename_()));
            if (path == null) {
                path = "";
            }
            this._handler.listDir_(path, ret => {
                if (toasters$.warn_(ret)) {
                    this._handler.listDir_("", ret => {
                        ret[Key.filename] = Basepath.filename_(path ?? "");
                        this.refresh_(ret);
                    });
                    return;
                }
                this.refresh_(ret);
            });
        }
    }

    hide_(): void {
        if (this.#shown) {
            this.#shown = false;
            
            this._hidePanel();
        }
    }

    resizeContent_(_containerheight: number): void {
        if (this.#shown) {
            const dirtreetop = An.documentOffset_(this.dirtreePanel$).y;
            const winheight = window.innerHeight;
            const treeheight = winheight -
                dirtreetop -
                12
                -
                DEF.sidepanelMarginBottom /* margin-bottom */
                ;
            const style = this.dirtreePanel$.style;
            style.height = `${treeheight}px`;
            style.maxHeight = `${treeheight}px`;
        }
    }

    private _toolbarActions(action: string, e: MouseEvent) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.Searchbar:
                this._showSearchbar();
                break;
            case BUT.Toolbar:
                this._showMainbar();
                break;
            case BUT.Clear:
                this.setFilename_("");
                this.deselect_();
                break;
            case BUT.Backward:
                this._actionBackward();
                break;
            case BUT.Forward:
                this._actionForward();
                break;
            case BUT.CurrentDocument:
                this._actionCurrent();
                break;
            case BUT.PickImage:
                this._actionPickImage(sidePanel$.sidepanel$);
                break;
            case BUT.Contextmenu:
                Timer.sleep1_(() => {
                    this.showContextmenu_(e);
                });
                break;
            case BUT.NextMatch:
                if (this.#finder == null) {
                    this._actionFind();
                } else {
                    const next = this.#finder.next_();
                    if (next != null) {
                        this._handler.listDir_(next, ret => {
                            this.refresh_(ret);
                        });
                        const index = this.#finder.index_();
                        const count = this.#finder.resultCount_();
                        toasters$.info_(`${index + 1}/${count}`, { attop: true });
                    } else {
                        toasters$.warnKey_(RS.NoMoreMatches);
                        this.#finder.reset_();
                    }
                }
                this._updateSearchbarState();
                break;
            case BUT.PrevMatch:
                if (this.#finder == null) {
                    this._actionFind();
                } else {
                    const prev = this.#finder.prev_();
                    if (prev != null) {
                        this._handler.listDir_(prev, ret => {
                            this.refresh_(ret);
                        });
                        const index = this.#finder.index_();
                        const count = this.#finder.resultCount_();
                        toasters$.info_(`${index + 1}/${count}`, { attop: true });
                    } else {
                        toasters$.warnKey_(RS.NoMoreMatches);
                        this.#finder.reset_();
                    }
                }
                this._updateSearchbarState();
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _actionRecover() {
        let filename = this.filenameInput$.value.trim();
        if (filename.length == 0) {
            this._actionRecover1(this.currentDir$ + FS);
            return;
        }
        this._handler.fileInfo1_(toasters$, this.currentPath_(filename), (fileinfo) => {
            if (fileinfo.isdir$) {
                this._actionRecover1(this.currentPath_(filename) + FS);
            } else {
                this._actionRecover1(this.currentPath_(filename));
            }
        });
    }

    private _actionRecover1(cpath: string) {
        new HistoryFilepicker(
            accessories$,
            cpath,
            fileinfoUt$,
            historyFileinfoUt$,
            settings$.dateFormat_(),
        )
            .zindex_(DEF.zindexPrompt)
            .onOK_((cpath) => {
                this._handler.listDir_(cpath, (ret) => {
                    this.refresh_(ret);
                });
            })
            .onCancel_(() => {
                this.refreshCurrentDir_();
            })
            .show_();
    }

    private _actionFsck() {
        let filename = this.filenameInput$.value.trim();
        host$.actionFsck_(this.currentPath_(filename), (ret) => {
            const [files, dirs] = ret[Key.result] ?? [0, 0];
            const errors: string[] = ret[Key.errors] ?? [];
            const failcount = errors.length;
            if (errors.length > 10) errors.length = 10;
            if (failcount > 0) toasters$.warn_([MSG.format3_(RS.FilesFsckResult, `${files}`, `${dirs}`, `${failcount}`), ...errors], { hold: true });
            else toasters$.ok_(MSG.format3_(RS.FilesFsckResult, `${files}`, `${dirs}`, "0"), { hold: true });
        });
    }

    private _actionRebuildXrefs() {
        let filename = this.filenameInput$.value.trim();
        host$.actionRebuildXrefs_(this.currentPath_(filename), (ret) => {
            const oks = ret[Key.result];
            const errors: string[] = ret[Key.errors] ?? [];
            const failcount = errors.length;
            if (errors.length > 10) {
                errors.length = 10;
                errors.push("...");
            }
            if (failcount > 0) toasters$.warn_([MSG.format2_(RS.XrefsRebuildResult, `${oks}`, `${failcount}`), ...errors], { hold: true });
            else toasters$.ok_(MSG.format2_(RS.XrefsRebuildResult, `${oks}`, '0'));
        });
    }

    private _actionPlayAll() {
        const dirtree = this._dirtree;
        if (dirtree == null) return;
        const infos = new Array<AudioPlayerInfo>();
        dirtree.filter(info => {
            const lcsuffix = Basepath.lcSuffixOfFilename_(info.name$);
            return MimeUtil.isAudioLcSuffix_(lcsuffix);
        }).forEach(info => {
            const cpath = this.currentPath_(info.name$);
            const uri = An.uriFromSafe_(null, cpath);
            if (uri != null) infos.push(new AudioPlayerInfo(cpath, uri, 0));
        });
        if (infos.length == 0) {
            toasters$.warnKey_(RS.NoSuitableMediaFileFound);
            return;
        }
        _AudioPlayerDialog.createAndShowAll_(accessories$, infos, true);
    }

    private _actionOpenDocument(e: MouseEvent): void {
        const filename = this.filenameInput$.value.trim();
        let cpath = this.currentDir$;
        if (filename.length > 0) {
            cpath = this.currentPath_(filename);
        }
        const dir = Basepath.dir_(cpath);
        if (dir == null) {
            toasters$.warnKey_(RS.InvalidPath);
            return;
        }
        this._handler.fileInfo_(cpath, ret => {
            if (toasters$.warn_(ret)) {
                return;
            }
            const fileinfo = FileInfo.of_(ret[Key.fileinfo]);
            if (fileinfo == null) { return; }
            if (fileinfo.isdir$) {
                if (!fileinfo.writable$) {
                    toasters$.warn_(MSG.string1_(RS.DestinationNotWritable_, cpath));
                    return;
                }
                _Util.onSaveOrDiscard_(() => {
                    _FilesPanel._newpage1(e, true, cpath);
                });
                return;
            }
            const lcsuffix = Basepath.lcSuffix_(cpath);
            const ishtml = (lcsuffix == Suffix.HTML$);
            const iscss = (lcsuffix == Suffix.CSS$);
            const writable = fileinfo.writable$;
            if (fileinfo.exists$) {
                _Util.onSaveOrDiscard_(() => {
                    if (iscss) {
                        _FilesPanel._openCSS(cpath, writable);
                    } else {
                        _FilesPanel._openpage1(cpath, ishtml && writable);
                    }
                });
                return;
            }
            this._handler.fileInfo_(dir, ret => {
                if (toasters$.warn_(ret)) {
                    return;
                }
                const dirinfo = FileInfo.of_(ret[Key.fileinfo]);
                if (dirinfo == null || dirinfo.notexists$ || !dirinfo.writable$) {
                    toasters$.warn_(MSG.string1_(RS.DestinationNotWritable_, dir));
                    return;
                }
                _Util.onSaveOrDiscard_(() => {
                    if (iscss) {
                        _FilesPanel._newCSS(cpath, true);
                    } else {
                        if (!ishtml) {
                            cpath = cpath + ".html";
                        }
                        _FilesPanel._newpage1(e, false, cpath);
                    }
                });
            });
        });
    }

    private _actionNobackup(): void {
        host$.toggleNobackup_(this.currentDir$, ret => {
            if (!toasters$.warn_(ret)) {
                _Util.toastOnOffButton_(MSG.string_(RS.Backup), !ret[Key.status]);
                this.refresh_(ret);
            }
        });
    }

    private _actionCurrent(): void {
        const path = native$.getIFrameContextPath_();
        if (path == null) {
            toasters$.warnKey_(RS.InvalidDocument);
        } else {
            this._handler.listDir_(path, (ret) => this.refresh_(ret));
        }
    }

    private _actionFind(): void {
        const text = this.#searchbox.value;
        if (text.length == 0) {
            this.#finder = null;
            this._actionCurrent();
            return;
        }
        this.#finder = new _FilesFinder(this.currentDir$, text);
        this.#finder.find_((finder: _FilesFinder) => {
            this.#searchbox.blur();
            host$.hideKeyboard_(() => {
                const count = finder.resultCount_();
                //// FIXME
                toasters$.info_(count > 1 ? `${count} matches` : `${count} match`, { attop: true });
                const next = finder.next_();
                if (next != null) {
                    this._handler.listDir_(next, ret => {
                        this._updateSearchbarState();
                        this.refresh_(ret);
                    });
                }
            });
        });
    }

    private static _openpage1(filepath: string, editable: boolean): void {
        sidePanel$.hideSidepanel_();
        if (editable) {
            mainPanel$.addIFrameReadyOneshotCallback(next => mainPanel$.startEditCallback(next));
        }
        _Util.browseFile_(filepath);
    }

    private static _newpage1(e: MouseEvent, isdir: boolean, cpath: string): void {
        const d = new PageContextmenu(accessories$);
        d.onAction_(lccat => {
            d.destroy_();
            _FilesPanel._newpage2(lccat, isdir, cpath);
        });
        d.onCancel_(() => {
            d.destroy_();
        });
        d.show_(/* true, */ e.pageX, e.pageY);
    }

    private static _newpage2(name: string, isdir: boolean, filepath: string): void {
        if (!isdir) {
            _FilesPanel._newpage3(name, filepath);
            return;
        }
        const info = settings$.htmlTemplatesWithAliases_().get(name);
        const filename = info === undefined ? null : _Util.defaultNewPageFilename_(info);
        if (filename == null) {
            toasters$.warn_(MSG.string_(RS.InvalidTemplate) + ": " + name);
            return;
        }
        _Util.newPageFromTemplate1_(Basepath.joinPath_(filepath, filename), name);
    }

    private static _newpage3(name: string, filepath: string): void {
        sidePanel$.hideSidepanel_();
        if (!filepath.endsWith(".html")) {
            filepath = filepath + ".html";
        }
        host$.addPage_(filepath, name, ret => {
            if (toasters$.error_(ret)) {
                return;
            }
            mainPanel$.addIFrameReadyOneshotCallback(next => mainPanel$.startEditCallback(next));
            _Util.browseFile_(filepath);
        });
    }

    private static _openCSS(cpath: string, writable: boolean): void {
        sidePanel$.hideSidepanel_();
        host$.readCSS_(cpath, ret => {
            if (toasters$.warn_(ret)) return;
            const content: string = ret[Key.result];
            const position: [Int, Int] | null = ret[Key.status] ?? null;
            const d = new CSSEditor(accessories$, gestureHandler$, cpath, writable, false, content.trim(), position);
            d.zindex_(DEF.zindexPrompt);
            d.show_();
        });
    }

    private static _newCSS(cpath: string, writable: boolean): void {
        sidePanel$.hideSidepanel_();
        host$.saveCSS_(cpath, "", null, ret => {
            if (toasters$.error_(ret)) {
                return;
            }
            _FilesPanel._openCSS(cpath, writable);
        });
    }

    private _contextActions(action: string, e: MouseEvent, _target: HTMLElement) {
        toasters$.hideAll_();
        switch (action) {
            default:
                this.hideContextmenu_();
                switch (action) {
                    case BUT.Info:
                        this.actionShowFileInfo_();
                        break;
                    case BUT.CopyFile:
                        this._actionCopy();
                        break;
                    case BUT.CutFile:
                        this._actionCutFile();
                        break;
                    case BUT.PasteFile:
                        this._actionPaste(false);
                        break;
                    case BUT.CloneFile:
                        this._actionPaste(true);
                        break;
                    case BUT.DeleteFile:
                        this._actionDelete();
                        break;
                    case BUT.ShredFile:
                        this._actionShred();
                        break;
                    case BUT.Mkdir:
                        this._actionMkdir(sidePanel$.sidepanel$);
                        break;
                    case BUT.RenameFile:
                        this._actionRename();
                        break;
                    case BUT.DeleteEmptyDirs:
                        this._actionDeleteEmptyDirs();
                        break;
                    case BUT.Nobackup:
                        this._actionNobackup();
                        break;
                    case BUT.Recover:
                        this._actionRecover();
                        break;
                    case BUT.RebuildXrefs:
                        this._actionRebuildXrefs();
                        break;
                    case BUT.Fsck:
                        this._actionFsck();
                        break;
                    case BUT.PlayAll:
                        this._actionPlayAll();
                        break;
                    case BUT.TakePhoto:
                        toasters$.error_(MSG.string_(RS.DesktopOperationTakePhotoNotAvailable));
                        break;
                    case BUT.RecordVideo:
                        toasters$.error_(MSG.string_(RS.DesktopOperationRecordVideoNotAvailable));
                        break;
                    case BUT.RecordAudio:
                        toasters$.error_(MSG.string_(RS.DesktopOperationRecordAudioNotAvailable));
                        break;
                    case BUT.OpenDocument:
                        this._actionOpenDocument(e);
                        break;
                    case BUT.GenerateBarcode:
                        this._actionGenerateBarcode(() => this.refreshCurrentDir_());
                        break;
                    case BUT.GenerateGallery:
                        this._actionGenerateGallery(e, () => this.refreshCurrentDir_());
                        break;
                    case BUT.Screenshot: {
                        const info = this.currentDirInfo_();
                        _Util.actionScreenshot_((info == null || !info.writable$)
                            ? PATH._HomeDrafts : this.currentDir$);
                        break;
                    }
                    case BUT.PickImage:
                        this._actionPickImage(sidePanel$.sidepanel$);
                        break;
                    case BUT.ImageConversion:
                        this._actionImageConversion();
                        break;
                    case BUT.BackupConversion: {
                        const srcpath = new Basepath(this.currentPath_(this.getFilename_()));
                        this._actionBackupConversion(srcpath);
                        break;
                    }
                    case BUT.BackupAction: {
                        const srcdir = this.currentDir$;
                        const dstdir = this._parentDirInfo();
                        const dir = (dstdir?.writable$ == true) ? (Basepath.dir_(this.currentDir$) ?? PATH._internal) : PATH._internal;
                        const filepath = Basepath.joinPath_(dir, Basepath.stem_(srcdir) + Suffix.BACKUP$);
                        host$.actionBackup_(settings$.dateFormat_(), filepath, this.currentDir$, () => {
                            this.refreshCurrentDir_();
                        });
                        break;
                    }
                    case BUT.Zip:
                        this._actionZip(this.currentDir$, DEF.zindexPrompt);
                        break;
                    case BUT.BackupRestore: {
                        const cpath = this.currentPath_(this.getFilename_());
                        const basepath = new Basepath(cpath);
                        if (MimeUtil.isBackupKeyLcSuffix_(basepath.lcSuffix$)) {
                            _Util.importBackupKey_(cpath, basepath.stem$);
                        } else {
                            const writable = this.currentDirInfo_()?.writable$ == true;
                            const dstdir = writable ? this.currentDir$ : PATH.Home;
                            host$.actionRestore_(settings$.dateFormat_(), cpath, dstdir, (ret) => {
                                this.refresh_(ret);
                            });
                        }
                        break;
                    }
                    case BUT.BackupVerify: {
                        const filename = this.getFilename_();
                        const cpath = this.currentPath_(filename);
                        host$.actionBackupVerify_(cpath, (ret) => {
                            let warns = ret[Key.warns] as string[];
                            const haswarns = warns.length > 0;
                            toasters$.warnErrorsOrResult_(ret, null, haswarns);
                            if (haswarns) toasters$.warn_(warns, { attop: true, hold: haswarns });
                        });
                        break;
                    }
                    case DEF.NOOP:
                        break;
                    default:
                        throw Assert.notReach_(action);
                }
        }
    }

    private _showSearchbar() {
        this.#toolbar.hide_();
        this.#searchbar.show_();
        this._updateSearchbarState();
        Timer.sleep00_(() => {
            this.#searchbox.focus();
            host$.showKeyboard_();
        });
    }

    private _showMainbar() {
        this.#searchbox.blur();
        this.#searchbar.hide_();
        this.#toolbar.show_();
        this.updateToolbarState_(this._dirtree);
    }

    private _updateSearchbarState(): void {
        const classes = An.classlist_(this.#searchbar.button_(BUT.NextMatch));
        const isnext = classes.contains_(CSS.FaArrowCircleDown);
        if (this.#finder == null && isnext || this.#finder != null && !isnext) {
            classes.toggleAll_(CSS.FaArrowCircleDown, CSS.FaSearch);
        }
        this.#searchbar.enableButton_(
            BUT.NextMatch, (this.#finder != null && this.#finder.hasNext_()
                || this.#finder == null && this.#searchbox.value.length > 0)
        );
        this.#searchbar.enableButton_(BUT.PrevMatch, (this.#finder != null && this.#finder.hasPrev_()));
    }

    private _actionGenerateBarcode(callback: Fun00) {
        const d = new PromptBarcode(accessories$,
            new Basepath(An.ensureTrailingSlash_(this.currentDir$) + "barcode-" + An.simpleDateTimeString_() + ".png"));
        d
            .titleKey_(RS.BarcodeGenerateTitle)
            .zindex_(DEF.zindexPrompt)
            .onOK_((filename, type, scale, text) => {
                host$.generateBarcode_(type, scale, text, (ret) => {
                    if (toasters$.warn_(ret)) return;
                    const dataurl = ret[Key.result];
                    this._showDataurl(d.element_(), RS.Confirm, dataurl, (ok) => {
                        if (!ok) return;
                        host$.saveBase64Image_(this.currentPath_(filename), dataurl, (ret) => {
                            if (!toasters$.warn_(ret)) toasters$.ok_([MSG.string_(RS.CommandOKSeeOutputAt_), filename], { nowrap: true });
                            callback();
                        });
                    });
                });
            })
            .show_();
    }

    private _showDataurl(element: HTMLElement, titlekey: string, dataurl: string, callback: Fun10<boolean>) {
        new ImageViewerDialog(accessories$, gestureHandler$, An.above_(element), dataurl)
            .titleKey_(titlekey)
            .showOnlyButtons([BUT.OK, BUT.Cancel])
            .onCancel_(() => callback(false))
            .onOK_(() => callback(true))
            .show_();
    }

    private _actionGenerateGallery(e: MouseEvent, callback: Fun00): void {
        _Util.onSaveOrDiscard_(() => {
            const d = new GalleryContextmenu(accessories$);
            d.onAction_((name) => {
                d.destroy_();
                const tinfo = settings$.htmlTemplatesWithAliases_().get(name);
                if (tinfo != undefined) {
                    new _GalleryGenerator(
                        tinfo,
                        d.options_(),
                        this.currentDir$,
                        this._handler
                    ).run_();
                }
                callback();
            });
            d.onCancel_(() => {
                d.destroy_();
            });
            d.show_(/* true, */ e.pageX, e.pageY);
        });
    }

    private _promptOutputZipFile(srcdirpath: string, zindex: Int, callback: Fun20<string, FileInfo>): void {
        const basepath = new Basepath(srcdirpath);
        Filepicker.withTitleKey_(
            accessories$,
            RS.DestinationDir,
            FilepickerKind.WRITE_FILE,
            null,
            "",
            (basepath.dir$ ?? PATH._Internal_),
            basepath.filename$ + ".zip",
            fileinfoUt$)
            .zindex_(zindex)
            .dateFormat_(settings$.dateFormat_())
            .setDelegate_(OutputZipFileDelegate.singleton$)
            .onOK_((okcallback, cpath, fileinfo) => {
                okcallback(true);
                callback(cpath, fileinfo);
            })
            .show_();
    }

    private _actionZip(srcdirpath: string, zindex: Int) {
        this._promptOutputZipFile(srcdirpath, zindex, (zipfilepath) => {
            host$.zip_(zipfilepath, srcdirpath, (ret) => {
                if (toasters$.warn_(ret, { hold: true })) return;
                this.refresh_(ret);
            });
        });
    }

    private _actionBackupConversion(srcpath: Basepath) {
        const dstpath = srcpath.changeSuffix_((srcpath.lcSuffix$ == Suffix.ZIP$) ? Suffix.BACKUP$ : Suffix.ZIP$).path$;
        host$.getBackupKeyAliases_((ret) => {
            if (toasters$.warn_(ret)) return;
            const aliases = ret[Key.result];
            new PromptBackupConversion(accessories$, settings$.dateFormat_(), dstpath, srcpath, aliases, (ret) => {
                this.refresh_(ret);
            }).show_();
        });
    }

    private _actionImageConversion(): void {
        const infos = this._dirtree?.filter((info) => {
            if (info.isdir$) return false;
            const lcsuffix = Basepath.lcSuffixOfFilename_(info.name$);
            return MimeUtil.isImageLcSuffix_(lcsuffix)
                || MimeUtil.supportPdfConversion$ && lcsuffix == Suffix.PDF$;
        });
        if (infos == null || infos.length == 0) {
            toasters$.warnKey_(RS.NoImageFound);
            return;
        }
        const filename = this.getFilename_();
        const basedir = native$.getIFrameDir_() ?? FS;
        const cpath = this.currentPath_(filename);
        const convert1 = (width: Int, height: Int, dataurl: stringX) => {
            _Util.promptOutputImage0_(((defformat) => {
                const lcsuffix = Basepath.lcSuffix_(filename);
                const format = (lcsuffix != defformat ? defformat
                    : (lcsuffix != MimeUtil.defaultWritableImageFormat$) ? MimeUtil.defaultWritableImageFormat$
                        : Suffix.JPG$);
                return this.currentPath_(`output${format}`);
            }), basedir, cpath, width, height, DEF.zindexPrompt + DEF.zindexAbove10, dataurl, (w, h) => {
                let x = (w.length == 0 ? 0 : An.parseInt_(w, -1));
                let y = (h.length == 0 ? 0 : An.parseInt_(h, -1));
                if (x < 0 || y < 0) {
                    return null;
                }
                return new Point(x!!, y!!);
            }, (outputinfo) => {
                this._checkOverwrite(outputinfo.cpath, infos, (converting, overwriting, notconverting) => {
                    new PromptImageConversion(accessories$, filename, converting, overwriting, notconverting)
                        .zindex_(DEF.zindexPrompt)
                        .onOK_((names, cut) => {
                            if (names.length == 0) {
                                toasters$.warnKey_(RS.NoImageFound);
                                return;
                            }
                            host$.imageConversion_(this.currentDir$, names, outputinfo, cut, (ret) => {
                                if (toasters$.warn_(ret, { hold: true })) return;
                                const warns: Array<string> = [];
                                const okslen: string[] = ret[Key.result].length ?? 0;
                                const fails: JSONObject = ret[Key.fails] ?? json_();
                                const failmsgs: string[] = Object.values(fails);
                                const failslen = failmsgs.length;
                                const msg = (failslen == 0)
                                    ? MSG.format1_(RS.Result1, `${okslen}`)
                                    : MSG.format2_(RS.Result2, `${okslen}`, `${failslen}`);
                                if (failslen == 0) toasters$.ok_(msg);
                                else warns.push(msg);
                                warns.push(...An.resultListOfKey_(ret, Key.warns));
                                warns.push(...failmsgs);
                                if (warns.length > 0) toasters$.warn_(warns, { attop: true, hold: true });
                                this.refresh_(ret);
                            });
                        }).show_();
                });
            }, (d) => {
                d.show_();
            });
        };
        if (filename.length > 0) {
            const cpath = this.currentPath_(filename);
            host$.localImageThumbnail_(cpath, DEF.previewPhotoSize, DEF.jpegQuality, null, ret => {
                if (toasters$.warn_(ret)) return;
                host$.localImageInfo_(cpath, true, (ret) => {
                    if (toasters$.warn_(ret)) return;
                    const imageinfo = MediaInfo.of_(ret[Key.result]);
                    const dataurl = imageinfo?.tnDataUrl$;
                    if (imageinfo == null || dataurl == null) return;
                    convert1(imageinfo.width$, imageinfo.height$, dataurl);
                });
            });
        } else {
            convert1(0, 0, null);
        }
    }

    private _checkOverwrite(outpath: string, infos: FileInfo[], callback: Fun30<FileInfo[], FileInfo[], Map<string, string[]>>) {
        const basepath = new Basepath(outpath);
        const dir = basepath.dir$;
        if (dir == null) {
            toasters$.warnKey_(RS.InvalidPath);
            return;
        }
        const dstnames = infos.map((info) => Basepath.changeSuffix_(info.name$, basepath.suffix$));
        fileinfoUt$.checkDirWritable2_(dir, (ret) => {
            toasters$.warn_(ret);
        }, () => {
            fileinfoUt$.fileInfos_(dir, dstnames, (ret) => {
                if (toasters$.warn_(ret)) return;
                const result = ret[Key.result] as JSONObject;
                const converting = new Array<FileInfo>();
                const overwriting = new Array<FileInfo>();
                const notconverting = new Array<string>();
                dstnames.forEach((name, index) => {
                    const info = infos[index];
                    const fileinfo = FileInfo.of_(result[name]);
                    if (fileinfo == null || fileinfo.notexists$) {
                        converting.push(info);
                    } else if (fileinfo.isfile$) {
                        overwriting.push(info);
                    } else {
                        notconverting.push(info.name$);
                    }
                });
                const map = new Map<string, string[]>();
                if (notconverting.length > 0) {
                    map.set(MSG.string_(RS.DestinationNotValid_), notconverting);
                }
                callback(converting, overwriting, map);
            });
        });
    }

    private _showPanel(): void {
        An.showHidden_(this.element_());
        this._setDirtreeHeight();
        An.setVisible_(this.element_());
    }

    private _hidePanel(): void {
        this.hideContextmenu_();
        An.hide_(this.element_());
    }

    private _setDirtreeHeight(): void {
        const dirtreetop = An.documentOffset_(this.dirtreePanel$).y;
        const winheight = window.innerHeight;
        const treeheight = winheight -
            dirtreetop -
            DEF.sidepanelMarginBottom /* margin-bottom */;
        const style = this.dirtreePanel$.style;
        style.height = `${treeheight}px`;
        style.maxHeight = `${treeheight}px`;
    }

}

class _GallerySectionInfo {
    constructor(public section$: HTMLElement, public parent$: HTMLElement, public items$: Map<string, HTMLElement>) {
    }
}

abstract class _GalleryGeneratorBase {
    protected static XXX = MSG.XXX$;
    protected sections$ = sarray_();
    protected cpaths$ = sarray_();
    protected descending$: boolean;
    protected result$: Map<string, Map<string, JSONObject>>;
    constructor(
        protected readonly idoc$: Document,
        protected readonly baseuri$: BaseUriX,
        protected readonly info$: JSONObject,
        protected readonly options$: GalleryOptions,
    ) {
        this.descending$ = this.info$[Key.backward];
        this.result$ = this._sortedResult(this.info$[Key.result]);
        for (const [name, items] of this.result$.entries()) {
            this.sections$.push(name);
            this.cpaths$.push(...items.keys());
        }
    }

    protected _imageInfo(b: DomBuilderEx, item: JSONObject) {
        const filestat = FileStat.of_(item[Key.filestat]);
        const date = filestat?.date$ ?? null;
        b.push_();
        if (date != null) {
            const elm = b.span_().cursor_();
            An.setDatetime(elm, new _PlaceholderDateFormatter(
                elm, Placeholder.xpDatetime, DateTime.fromMs_(date)));
            b.peek_().span_().text_("\u00a0");
        }
        b.pop_();
    }

    protected _updateFailed(): boolean {
        toasters$.warnKey_(RS.GalleryUpdateFailed);
        return false;
    }

    protected _getSectionName(section: HTMLElement): stringX {
        return section.getAttribute(ATTR.xInfo) ?? null;
    }

    protected _sorted1<T>(map: JSONObject, mapper: Fun11<JSONObject, T>): Map<string, T> {
        const ret = map_<string, T>();
        const keys = Object.keys(map).sort();
        if (this.descending$) keys.reverse();
        for (const key of keys) {
            ret.set(key, mapper(map[key]));
        }
        return ret;
    }

    protected _sortedResult(map: JSONObject): Map<string, Map<string, JSONObject>> {
        return this._sorted1(map, (o) => {
            return this._sorted1(o, (oo) => oo);
        });
    }

    protected _sortedKeys(map: Map<string, any>): string[] {
        const ret = Array.from<string>(map.keys()).sort();
        if (this.descending$) ret.reverse();
        return ret;
    }

    protected _getExistingTreeSections(
        autogen: HTMLElement,
        sectionselector: string,
        itemselector: string,
        items: string[],
    ): Map<string, _GallerySectionInfo> {
        const ret = map_<string, _GallerySectionInfo>();
        for (const sectionelm of DomUt.queryAll_(autogen, sectionselector)) {
            const name = this._getSectionName(sectionelm);
            if (name == null) continue;
            const section = map_<string, HTMLElement>();
            for (const item of DomUt.queryAll_(sectionelm, itemselector)) {
                const a = item.querySelector("a[href]");
                const href = a?.getAttribute("href");
                const uri = An.parseUriSafe_(href, this.baseuri$);
                if (uri == null) {
                    item.remove();
                    continue;
                }
                const cpath = Basepath.trimLeading_(uri.toAbsolute_().path$);
                if (!items.includes(cpath)) {
                    item.remove();
                    continue;
                }
                section.set(cpath, item);
            }
            ret.set(name, new _GallerySectionInfo(
                sectionelm,
                sectionelm,
                map_(...this._sortedKeys(section).map<[string, HTMLElement]>((k) => [k, section.get(k)!!]))));
        }
        return map_(...this._sortedKeys(ret).map<[string, _GallerySectionInfo]>((k) => [k, ret.get(k)!!]));
    }

    protected _getExistingLinearSections(
        sectionclass: string,
        itemselector: string,
        aselector: string,
        sectionselm: HTMLElement,
    ): [Map<string, HTMLElement>, Map<string, HTMLElement>] {
        const sections = map_<string, HTMLElement>();
        const items = map_<string, HTMLElement>();
        const array = DomUt.queryAll_(sectionselm, itemselector);
        for (const item of array) {
            if (item.classList.contains(sectionclass)) {
                const name = this._getSectionName(item);
                if (name != null) sections.set(name, item);
                continue;
            }
            const a = item.querySelector(aselector);
            const href = a?.getAttribute("href");
            const uri = An.parseUriSafe_(href, this.baseuri$);
            if (uri == null) continue;
            const cpath = Basepath.trimLeading_(uri.toAbsolute_().path$);
            items.set(cpath, item);
        }
        return [sections, items];
    }

    protected _labelOf(name: string, baseuri: BaseUriX): string {
        if (name.length > 0) return name;
        if ((this.options$.options$.singlesection$ || this.result$.size == 1) && baseuri != null) {
            const basepath = new Basepath(baseuri.path$);
            return An.labelFromBasepath_(basepath);
        }
        return ".";
    }

    static _createIFrame(
        baseuri: BaseUriX,
        templatehtmlpath: string,
        templatecontent: string,
        content: string,
        callback: Fun20<HTMLIFrameElement | null, boolean>
    ) {
        if (An.isempty_(content)) {
            this._createIFrame1(templatecontent, (iframe) => {
                callback(iframe, true);
            });
            return;
        }
        this._createIFrame1(content, (iframe) => {
            const idoc = iframe?.contentDocument;
            if (idoc != null) {
                const templatecss = new Basepath(templatehtmlpath).changeSuffix_(Suffix.CSS$).path$;
                for (const stylesheet of Array.from(idoc.styleSheets)) {
                    const href = stylesheet.href;
                    const apath = An.parseUriSafe_(href, baseuri)?.toAbsolute_().path$;
                    if (apath == templatecss) {
                        callback(iframe, false);
                        return;
                    }
                }
            }
            if (iframe != null) iframe.remove();
            this._createIFrame1(templatecontent, (iframe) => {
                callback(iframe, true);
            });
        });
    }

    static _createIFrame1(content: stringX, callback: Fun10<HTMLIFrameElement | null>) {
        if (content == null || content.length == 0) {
            callback(null);
            return;
        }
        for (const e of Array.from(accessories$.querySelectorAll("iframe"))) e.remove();
        const iframe = new DomBuilder(accessories$).iframe_({
            "style": "display:none;visibility:hidden",
        }).cursor_() as HTMLIFrameElement;
        iframe.addEventListener("error", () => {
            iframe.remove();
            callback(null);
        });
        iframe.addEventListener("load", () => {
            callback(iframe);
        });
        iframe.srcdoc = content;
    }
}

class _HomeGalleryGenerator extends _GalleryGeneratorBase {
    constructor(
        idoc: Document,
        baseuri: BaseUriX,
        info: JSONObject,
        options: GalleryOptions,
        readonly created$: boolean,
    ) {
        super(idoc, baseuri, info, options);
    }

    run_(): boolean {
        const sectionselm = this._getSectionsElement();
        if (sectionselm == null) return this._updateFailed();
        const existings = this._getExistingTreeSections(sectionselm, `div.${XX.xxSection}`, `ul.${XX.xxTocs} > li`, this.cpaths$);
        const existingitems = map_<string, HTMLElement>();
        for (const info of existings.values()) {
            for (const [cpath, item] of info.items$.entries()) {
                existingitems.set(cpath, item);
            }
            const parent = DomUt.query_(info.section$, `ul.${XX.xxTocs}`);
            if (parent == null) return this._updateFailed();
            info.parent$ = parent;
        }
        const b = new DomBuilderEx(sectionselm).empty_().push_();
        for (const [name, items] of this.result$.entries()) {
            const createSection = (name: string): _GallerySectionInfo => {
                b.peek_().child_("div", smap_(
                    ["class", XX.xxSection],
                    [ATTR.xInfo, name],
                ));
                const section = b.cursor_();
                const parent = b.push_().div1_(XX.xxHeader).text_(this._labelOf(name, this.baseuri$))
                    .pop_().ul1_(XX.xxTocs)
                    .cursor_();
                return new _GallerySectionInfo(section, parent, map_());
            };
            const createExistingSection = (name: string) => {
                const info = existings.get(name);
                if (info != undefined) {
                    b.peek_().appendNodes_(info.section$);
                    new DomBuilderEx(info.parent$).empty_();
                }
                return info;
            };
            let existingsection = createExistingSection(name) ?? createSection(name);
            for (const [cpath, item] of items.entries()) {
                const existingitem = existingitems.get(cpath);
                if (existingitem != undefined) {
                    existingsection.parent$.appendChild(existingitem);
                    continue;
                }
                const classes = Basepath.lcSuffix_(cpath) == Suffix.HTML$ ? XX.xxToc2 : XX.xxToc3;
                new DomBuilderEx(existingsection.parent$).child1_("li", classes)
                    .push_().span1_(XX.xxBullet)
                    .pop_().span_().ahref1_(item[Key.url], CSS.xPlaceholder).text_(item[Key.text]);
            }
        }
        return true;
    }

    private _getSectionsElement(): HTMLElementX {
        const right = DomUt.query_(this.idoc$, `div.${CSS.xRoot} div.${XX.xxRight}`);
        if (right == null) return null;
        let autogen = right?.querySelector<HTMLElement>(`div.${XX.xxSections}[${ATTR.xRole}~='${ROLE.Generated}']`);
        if (autogen != null) return autogen;
        let first: HTMLElementX = right.querySelector(`div.${XX.xxSections}`);
        let parent: HTMLElementX = null;
        if (first != null) {
            if (this.created$) {
                Role.addRole(first, ROLE.Generated);
                return first as HTMLElement;
            }
            parent = first?.parentElement ?? null;
        } else {
            first = DomUt.query_(this.idoc$, `div.${XX.xxContent}`);
            if (first != null) {
                parent = first.parentElement;
                first = first.nextElementSibling as HTMLElement;
            } else {
                parent = right.firstElementChild as HTMLElement;
                first = (parent?.firstElementChild as HTMLElement) ?? null;
            }
        }
        if (parent == null) return null;
        return new DomBuilderEx(parent).childBefore_(first, "div", smap_(
            ["class", XX.xxSections],
            [ATTR.xRole, ROLE.Generated],
        )).cursor_();
    }
}

class _MediaStickerGalleryGenerator extends _GalleryGeneratorBase {
    constructor(
        idoc: Document,
        baseuri: BaseUriX,
        info: JSONObject,
        options: GalleryOptions,
        readonly created$: boolean,
    ) {
        super(idoc, baseuri, info, options);
    }

    run_(): boolean {
        const createSection = (name: string): HTMLElement => {
            const section = b.peek_().child_("div", smap_(
                ["class", `${XX.xxComment} ${CSS.xSticker} ${CSS.xStickOnDocument} ${CSS.xDraggable} ${CSS.xZMiddle} ${XX.xxStyle00}`],
                [ATTR.xInfo, name],
            )).cursor_();
            b.push_().div1_(CSS.xSubject).indent_(
                b.push_().span_(
                    ["class", `${CSS.xFloatRightClearNone}  ${CSS.xShowInEdit} fa fa-arrows`],
                    [ATTR.xButton, "m/"],
                ),
                b.peek_().span_(
                    ["class", `${CSS.xFloatRightClearNone}  ${CSS.xShowInEdit} fa fa-retweet`],
                    [ATTR.xButton, `c/${CSS.xZBottom} ${CSS.xZLower} ${CSS.xZMiddle} ${CSS.xZUpper} ${CSS.xZTop}/${XX.xxPhoto}`],
                ),
                b.pop_().span_().text_(this._labelOf(name, this.baseuri$)));
            b.pop_().div_().div1_(XX.xxCaption).span_().text_(XXX);
            return section;
        };
        const sectionselm = this._getSectionsElement();
        if (sectionselm == null) return this._updateFailed();
        const [existingsections, existingitems] = this._getExistingLinearSections(
            XX.xxComment,
            `div.${CSS.xSticker}`,
            `div.${CSS.xPhoto} > a[href]`,
            sectionselm);
        const seens = sarray_();
        const b = new DomBuilderEx(sectionselm).empty_().push_();
        for (const [name, items] of this.result$.entries()) {
            const createExistingSection = (name: string): HTMLElement | undefined => {
                const section = existingsections.get(name);
                if (section !== undefined) {
                    existingsections.delete(name);
                    b.peek_().append_(section);
                }
                return section;
            };
            createExistingSection(name) ?? createSection(name);
            for (const [cpath, item] of items.entries()) {
                seens.push(cpath);
                const existingitem = existingitems.get(cpath);
                if (existingitem != null) {
                    existingitems.delete(cpath);
                    b.peek_().append_(existingitem);
                } else {
                    const basepath = new Basepath(cpath);
                    const kind = WidgetUt.kindFromLcSuffix_(basepath.lcSuffix$);
                    if (kind == null) continue;
                    const li = _ClientActionWidget._createMediaStickerWidget(sectionselm.ownerDocument, kind, basepath.filename$, item);
                    if (li == null) continue;
                    b.peek_().appendNodes_(li);
                }
            }
        }
        return true;
    }

    private _getSectionsElement(): HTMLElementX {
        let generated = DomUt.query_(this.idoc$, `div.${XX.xxTop}[${ATTR.xRole}~='${ROLE.Generated}']`);
        if (generated != null) return generated;
        let top = DomUt.query_(this.idoc$, `div.${XX.xxTop}`);
        if (top != null) {
            Role.addRole(top, ROLE.Generated);
            return top;
        }
        return null;
    }
}

class _MediaWallGalleryGenerator extends _GalleryGeneratorBase {
    constructor(
        idoc: Document,
        baseuri: BaseUriX,
        info: JSONObject,
        options: GalleryOptions,
        readonly created$: boolean,
    ) {
        super(idoc, baseuri, info, options);
    }

    run_(): boolean {
        const sectionselm = this._getSectionsElement();
        if (sectionselm == null) return this._updateFailed();
        const existings = this._getExistingTreeSections(sectionselm, `div.${XX.xxSection}`, `ul.${XX.xxMedias} > li`, this.cpaths$);
        const existingitems = map_<string, HTMLElement>();
        for (const info of existings.values()) {
            for (const [cpath, item] of info.items$.entries()) {
                existingitems.set(cpath, item);
            }
            const parent = DomUt.query_(info.section$, `ul.${XX.xxMedias}`);
            if (parent == null) return this._updateFailed();
            info.parent$ = parent;
        }
        const b = new DomBuilderEx(sectionselm).empty_().push_();
        for (const [name, items] of this.result$.entries()) {
            const createSection = (name: string): _GallerySectionInfo => {
                b.peek_().child_("div", smap_(
                    ["class", XX.xxSection],
                    [ATTR.xInfo, name],
                )).push_()
                    .div1_(XX.xxHeader)
                    .div1_(XX.xxSubject)
                    .text_(this._labelOf(name, this.baseuri$))
                    .peek_().ul1_(XX.xxMedias);
                const photos = b.cursor_();
                const section = b.pop_().cursor_();
                return new _GallerySectionInfo(section, photos, map_());
            };
            const createExistingSection = (name: string) => {
                const info = existings.get(name);
                if (info !== undefined) {
                    b.peek_().appendNodes_(info.section$);
                    new DomBuilderEx(info.parent$).empty_();
                }
                return info;
            };
            const createItem = (cpath: string, item: JSONObject) => {
                const basepath = new Basepath(cpath);
                const kind = WidgetUt.kindFromLcSuffix_(basepath.lcSuffix$);
                if (kind == null) return;
                return _ClientActionWidget._createMediaWallWidget(existingsection.parent$.ownerDocument, kind, basepath.filename$, item);
            };
            let existingsection = createExistingSection(name) ?? createSection(name);
            for (const [cpath, item] of items.entries()) {
                const existingitem = existingitems.get(cpath);
                if (existingitem != undefined) {
                    existingsection.parent$.appendChild(existingitem);
                    continue;
                }
                const li = createItem(cpath, item);
                if (li != null) existingsection.parent$.appendChild(li);
            }
        }
        return true;
    }

    private _getSectionsElement(): HTMLElementX {
        let autogen = DomUt.query_(this.idoc$, `div.${XX.xxBody}[${ATTR.xRole}~='${ROLE.Generated}']`);
        if (autogen != null) return autogen;
        let top = DomUt.query_(this.idoc$, `div.${XX.xxBody}`);
        if (top != null) {
            Role.addRole(top, ROLE.Generated);
            return top;
        }
        return null;
    }
}

class GalleryGeneratorOptions {
    constructor(
        readonly descending$: boolean,
        readonly singlesection$: boolean,
        readonly largeThumbnails$: boolean,
        readonly scrollableThumbnails$: boolean,
        readonly preserve$: boolean,
    ) { }
    toJSONArray_(): JSONArray {
        return [
            this.descending$,
            this.singlesection$,
            this.largeThumbnails$,
            this.scrollableThumbnails$,
            this.preserve$,
        ];
    }
}

class GalleryOptions {
    constructor(
        readonly options$: GalleryGeneratorOptions,
        readonly recursive$: boolean,
        readonly recursive1$: boolean,
    ) { }
}

class _GalleryGenerator {
    constructor(
        readonly tinfo$: TemplateInfo,
        readonly options$: GalleryOptions,
        readonly currentDir$: string,
        readonly handler$: IFileinfoUtil,
    ) { }

    run_(): void {
        if (this.options$.recursive$) {
            this.handler$.listRecursive_(json1_(Key.path, this.currentDir$), ret => {
                if (toasters$.warn_(ret)) return;
                const dirtree: StrFileInfo[] = ret[Key.dirtree] ?? [];
                const rpathinfos = Array<StrFileInfo>();
                for (const [rpath, info] of dirtree) {
                    const fileinfo = FileInfo.of_(info);
                    if (fileinfo == null) continue;
                    if (!fileinfo.isfile$) continue;
                    rpathinfos.push([rpath, fileinfo]);
                }
                if (rpathinfos.length == 0) {
                    toasters$.warn_(MSG.string_(RS.NoSuitableMediaFileFound));
                    return;
                }
                this._generateGallery3(rpathinfos);
            });
        } else if (this.options$.recursive1$) {
            this.handler$.listRecursive_(json_(
                [Key.path, this.currentDir$],
                [Key.level, 1],
            ), ret => {
                if (toasters$.warn_(ret)) return;
                const dirtree: StrFileInfo[] = ret[Key.dirtree] ?? [];
                const rpathinfos = Array<StrFileInfo>();
                for (const [rpath, info] of dirtree) {
                    const fileinfo = FileInfo.of_(info);
                    if (fileinfo == null) continue;
                    if (!fileinfo.isfile$) continue;
                    rpathinfos.push([rpath, fileinfo]);
                }
                if (rpathinfos.length == 0) {
                    toasters$.warn_(MSG.string_(RS.NoSuitableMediaFileFound));
                    return;
                }
                this._generateGallery3(rpathinfos);
            });
        } else {
            this.handler$.listDir_(this.currentDir$, ret => {
                if (toasters$.warn_(ret)) return;
                const dirtree = FileInfo.arrayOf_(ret[Key.dirtree]) ?? [];
                if (dirtree.length == 0) {
                    toasters$.warn_(MSG.string_(RS.NoSuitableMediaFileFound));
                    return;
                }
                const rpathinfos = Array<StrFileInfo>();
                for (const fileinfo of dirtree) {
                    if (!fileinfo.isfile$) continue;
                    rpathinfos.push([fileinfo.name$, fileinfo]);
                }
                this._generateGallery3(rpathinfos);
            });
        }
    }

    private _generateGallery3(fileinfos: StrFileInfo[]): void {
        const filter = this._getTemplateFilter(this.tinfo$);
        if (filter == null) return;
        const [selected1, notselected] = filter(fileinfos);
        if (selected1.length + notselected.length == 0) {
            toasters$.warn_(MSG.string_(RS.NoSuitableMediaFileFound));
            return;
        }
        let selected = selected1;
        if (this.options$.recursive1$ && this.tinfo$.name$ == TemplateName.homeSimpler) {
            selected = selected1.filter((sinfo) => {
                if (sinfo[1].name$ == "index.html") return true;
                notselected.push(sinfo);
                return false;
            });
        }
        if (this.options$.options$.descending$) {
            selected.reverse();
            notselected.reverse();
        }
        const d = new PromptFilelist(accessories$, smap_(
            [Key.copying, smap_(...selected.map<[string, CopyInfo]>(([rpath, info]) => [rpath, [false, false, info.size$, info.date$]]))],
            [Key.overwriting, smap_(...notselected.map<[string, CopyInfo]>(([rpath, info]) => [rpath, [false, false, info.size$, info.date$]]))],
        ));
        d.titleKey_(RS.PickFiles);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((rpaths: string[]) => {
            const path = Basepath.joinPath_(this.currentDir$, "index.html");
            const d = _Util.promptFilepath_(this.tinfo$.cat$, FilepickerKind.WRITE_FILE, "", this.currentDir$, path);
            d.setDelegate_(FilepickerHtmlDelegate.singleton$);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((okcallback, path) => {
                okcallback(true);
                sidePanel$.hideSidepanel_();
                this._generateGallery4(path, rpaths);
            });
            d.show_();
        });
        d.show_();
    }

    private _generateGallery4(path: string, rpaths: string[]): void {
        if (rpaths.length == 0) {
            toasters$.warn_(MSG.string_(RS.NoSuitableMediaFileFound));
            return;
        }
        const templatehtml = _Util.getTemplateHtmlFromInfo_(this.tinfo$);
        if (templatehtml == null) return;
        if (!path.endsWith(Suffix.HTML$)) {
            path = path + Suffix.HTML$;
        }
        host$.generateGallery_(path, templatehtml, this.options$, this.currentDir$, rpaths, (ret) => {
            if (toasters$.error_(ret, { hold: true })) return;
            const baseuri = An.parseUriSafe_(path, null);
            const templatecontent = ret[Key.template];
            const content = ret[Key.text];
            _GalleryGeneratorBase._createIFrame(baseuri, templatehtml, templatecontent, content, (iframe, created) => {
                const idoc = iframe?.contentDocument;
                if (idoc == null || iframe == null) return;
                try {
                    const name = ret[Key.type];
                    let ok = true;
                    switch (name) {
                        case TemplateName.homeSimpler: {
                            ok = new _HomeGalleryGenerator(idoc, baseuri, ret, this.options$, created).run_();
                            break;
                        }
                        case TemplateName.mediaSticker: {
                            ok = new _MediaStickerGalleryGenerator(idoc, baseuri, ret, this.options$, created).run_();
                            break;
                        }
                        case TemplateName.mediaWall: {
                            ok = new _MediaWallGalleryGenerator(idoc, baseuri, ret, this.options$, created).run_();
                            break;
                        }
                        default:
                    }
                    if (ok) {
                        if (name == TemplateName.homeSimpler) {
                            const bars = native$._iQuerySelectorAll<HTMLElement>(`div.${XX.xxVerticalToolbar}`, idoc);
                            for (const bar of bars) {
                                An.hide_(bar);
                            }
                        }
                        const content = native$.serializeDocument_(idoc);
                        host$.saveHtml_(path, content, () => {
                            mainPanel$.addIFrameReadyOneshotCallback(next => {
                                mainPanel$.startEditCallback(() => {
                                    _MainPanel._processPlaceholdersAudioInfos(
                                        native$.iQueryAll_<HTMLElement>(`[${ATTR.xPlaceholder}='${Placeholder.xpAudioinfo}']`), () => {
                                            _MainPanel._processPlaceholdersVideoInfos(
                                                native$.iQueryAll_<HTMLElement>(`[${ATTR.xPlaceholder}='${Placeholder.xpVideoinfo}']`), () => {
                                                    next();
                                                });
                                        });
                                });
                            });
                            _Util.browseFile_(path);
                        });
                    }
                } finally {
                    iframe.remove;
                }
            });
        });
    }

    private audioFileFilter(fileinfos: StrFileInfo[]): [StrFileInfo[], StrFileInfo[]] {
        const selected = Array<StrFileInfo>();
        for (const sinfo of fileinfos) {
            const lcsuffix = Basepath.lcSuffix_(sinfo[1].name$);
            if (MimeUtil.isAudioLcSuffix_(lcsuffix) || MimeUtil.isVideoLcSuffix_(lcsuffix)) {
                selected.push(sinfo);
            }
        }
        return [selected, []];
    }

    private htmlFileFilter(fileinfos: StrFileInfo[]): [StrFileInfo[], StrFileInfo[]] {
        const selected = Array<StrFileInfo>();
        const notselected = Array<StrFileInfo>();
        for (const sinfo of fileinfos) {
            const lcsuffix = Basepath.lcSuffix_(sinfo[1].name$);
            if (lcsuffix == Suffix.HTML$) {
                selected.push(sinfo);
            } else if (MimeUtil.isViewerLcSuffix_(lcsuffix)) {
                notselected.push(sinfo);
            }
        }
        return [selected, notselected];
    }

    private mediaFileFilter(fileinfos: StrFileInfo[]): [StrFileInfo[], StrFileInfo[]] {
        const selected = Array<StrFileInfo>();
        for (const sinfo of fileinfos) {
            if (MimeUtil.isMediaLcSuffix_(Basepath.lcSuffix_(sinfo[1].name$))) selected.push(sinfo);
        }
        return [selected, []];
    }

    private photoFileFilter(fileinfos: StrFileInfo[]): [StrFileInfo[], StrFileInfo[]] {
        const selected = Array<StrFileInfo>();
        for (const sinfo of fileinfos) {
            if (MimeUtil.isImageLcSuffix_(Basepath.lcSuffix_(sinfo[1].name$))) {
                selected.push(sinfo);
            }
        }
        return [selected, []];
    }

    private _getTemplateFilter(info: TemplateInfo): Fun11X<StrFileInfo[], [StrFileInfo[], StrFileInfo[]]> {
        switch (info.name$) {
            case TemplateName.audioV2:
                return this.audioFileFilter;
            case TemplateName.homeSimpler:
                return this.htmlFileFilter;
            case TemplateName.photoSticker1:
            case TemplateName.photoWall:
                return this.photoFileFilter;
            case TemplateName.mediaSticker:
            case TemplateName.mediaWall:
                return this.mediaFileFilter;
            default:
                return null;
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _CalendarPanel extends UIPanelBase {
    _toolbar: Toolbar;
    _content!: HTMLElement;
    _selectedDate!: DateTime;
    _startDate!: DateTime;
    _dateContainer!: HTMLElement;
    _inputYear!: HTMLTextAreaElement;
    _inputMonth!: HTMLTextAreaElement;
    _buttonPrevYear!: HTMLElement;
    _buttonNextYear!: HTMLElement;
    _buttonPrevMonth!: HTMLElement;
    _buttonNextMonth!: HTMLElement;
    _eventsPanel!: _CalendarEventsPanel;
    _selectedCell: HTMLElementX = null;
    _blogRegex = RegExp("^.*/(\\d\\d\\d\\d)/(\\d\\d)/(\\d\\d)(/\\d\\d)?\\.html$");

    constructor(private _top: HTMLElement) {
        super();
        const b = new DomBuilderEx(_top).push_();
        this._toolbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.PrevBlog,
            BUT.NextBlog,
            BUT.OpenDocument,
            BUT.Today,
        ));
        this._toolbar.onAction_(action => this._toolbarActions(action));
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._createContent(b);
    }

    private _createContent(b: DomBuilderEx): void {
        const now = An.now00_();
        this._selectedDate = now;
        const buttonsize = cache$.ui$.buttonSize_();
        const x6 = buttonsize * 6;
        this._content = b.peek_().div1_(CSS.AnContentViewport).cursor_();
        this._createCalendar(b.cursor_(), x6);
        this._createAlarms(b.cursor_(), this._selectedDate);
        An.onContextmenuMatching_(this._dateContainer, "div", (_target, e) => {
            An.stopevent_(e);
        });
        An.onEventMatching_(this._dateContainer, Conf.pointerstart$, "div", (elm, e) => {
            An.stopevent_(e);
            if (elm.classList.contains(CSS.AnDateSelected)) {
                this._open(false);
            } else {
                this._onSelectDate(elm);
            }
        });
        An.onInputFocusSelectIgnoreEnterKey_(this._inputYear);
        An.onChange_(this._inputYear, e => {
            An.stopevent_(e);
            const year = this._selectedDate.year$;
            const y = An.parseInt_(this._inputYear.value, year);
            this._inputYear.value = `${year}`;
            if (y != year) {
                this.refresh_(DateTime.local_(
                    y,
                    this._selectedDate.month$,
                    this._selectedDate.day$,
                    this._selectedDate.hour$,
                    this._selectedDate.minute$,
                    this._selectedDate.second$));
            }
        });
        An.onInputFocusSelectIgnoreEnterKey_(this._inputMonth);
        An.onChange_(this._inputMonth, e => {
            An.stopevent_(e);
            const month = this._selectedDate.month$;
            const m = An.parseInt_(this._inputMonth.value, month);
            this._inputMonth.value = `${month}`;
            if (m != month) {
                this.refresh_(
                    DateTime.local_(
                        this._selectedDate.year$,
                        m,
                        this._selectedDate.day$,
                        this._selectedDate.hour$,
                        this._selectedDate.minute$,
                        this._selectedDate.second$));
            }
        });
        An.onClick_(this._buttonNextYear, e => {
            An.stopevent_(e);
            this.refresh_(DateTime.local_(
                this._selectedDate.year$ + 1,
                this._selectedDate.month$,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonPrevYear, e => {
            An.stopevent_(e);
            this.refresh_(DateTime.local_(
                this._selectedDate.year$ - 1,
                this._selectedDate.month$,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonNextMonth, e => {
            An.stopevent_(e);
            this.refresh_(DateTime.local_(
                this._selectedDate.year$,
                this._selectedDate.month$ + 1,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        An.onClick_(this._buttonPrevMonth, e => {
            An.stopevent_(e);
            this.refresh_(DateTime.local_(
                this._selectedDate.year$,
                this._selectedDate.month$ - 1,
                this._selectedDate.day$,
                this._selectedDate.hour$,
                this._selectedDate.minute$,
                this._selectedDate.second$));
        });
        this.refresh_(this._selectedDate);
    }

    private _createCalendar(top: HTMLElement, x6: number): void {
        const b = new DomBuilderEx(top);
        b.div_({
            "class": CSS.AnFlexCenter,
        }).div_({
            "style": `padding:5px;border-bottom:${DEF.themeBorder};`,
        });
        b.push_();
        b.div_({
            "class": CSS.AnFlex,
            "style": "padding-top: 5px; padding-bottom:5px; "
        });
        b.push_();
        this._buttonPrevYear = b.div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronLeft).cursor_();
        this._inputYear = b.peek_().child_(Conf.input$, {
            "class": CSS.AnPromptInput,
            "style": "text-align:center;",
            "rows": "1",
        }).cursor_() as AnInputElement;
        this._buttonNextYear = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronRight).cursor_();
        this._buttonPrevMonth = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronLeft).cursor_();
        this._inputMonth = b.peek_().child_(Conf.input$, {
            "class": CSS.AnPromptInput,
            "style": "text-align:center;",
            "rows": "1",
        }).cursor_() as AnInputElement;
        this._buttonNextMonth = b.peek_().div1_(CSS.AnFlexButton, CSS.Fa, CSS.FaChevronRight).cursor_();
        b.pop_();
        b.peek_().div1_(CSS.AnCalHead);
        b.push_();
        for (const d of MSG.stringArray_(RS.Weekdays)) {
            b.peek_().div_().text_(d);
        }
        b.pop_();
        this._dateContainer = b.peek_().div_({
            "class": CSS.AnCalBody,
            "style": `flex-flow: row wrap; height: ${x6}px; padding-bottom: 4px;`,
        }).cursor_();
    }

    private _createAlarms(top: HTMLElement, date: DateTime): void {
        this._eventsPanel = new _CalendarEventsPanel(top, this, date);
    }

    private _onSelectDate(elm: HTMLElement): boolean {
        if (elm.classList.contains(CSS.AnGray)) {
            return false;
        }
        const index = An.parseInt_(elm.getAttribute(ATTR.AnInfo), -1);
        if (index >= 0 && elm != this._selectedCell) {
            if (this._selectedCell != null) {
                this._selectedCell.classList.remove(CSS.AnDateSelected);
            }
            this._selectedCell = elm;
            this._selectedCell.classList.add(CSS.AnDateSelected);
            this._selectedDate = this._startDate.add_(DateTime.DAY * index);
            this._inputYear.value = `${this._selectedDate.year$}`;
            this._inputMonth.value = `${this._selectedDate.month$}`;
            this._updateToolbarState();
            this._eventsPanel.setDate1(this._selectedDate);
            return true;
        }
        return false;
    }

    element_(): HTMLElement {
        return this._top;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this._setContentHeight();
            this.refresh_(this._selectedDate);
            gestureHandler$.push_(GestureEvent.leftInward, this._flingHandler);
            gestureHandler$.push_(GestureEvent.leftOutward, this._flingHandler);
            An.show_(this._top);
        }
    }

    hide_(): void {
        if (this._shown) {
            gestureHandler$.pop_(GestureEvent.leftInward);
            gestureHandler$.pop_(GestureEvent.leftOutward);
            this._shown = false;
            An.hide_(this._top);
        }
    }

    private _setContentHeight(): void {
        this.resizeContent_(window.innerHeight - cache$.ui$.toolbarHeight_());
    }

    resizeContent_(containerheight: number): void {
        if (this._shown) {
            const h = containerheight - cache$.ui$.toolbarHeight_() - DEF.sidepanelMarginBottom /* margin-bottom */;
            const style = this._content.style;
            style.height = `${h}px`;
            style.maxHeight = `${h}px`;
        }
    }

    private _flingHandler(event: string): boolean {
        Timer.sleep1_(() => {
            switch (event) {
                case GestureEvent.leftOutward:
                    this.refresh_(DateTime.local_(
                        this._selectedDate.year$,
                        this._selectedDate.month$ + 1,
                        this._selectedDate.day$,
                        this._selectedDate.hour$,
                        this._selectedDate.minute$,
                        this._selectedDate.second$));
                    break;
                case GestureEvent.leftInward:
                    this.refresh_(DateTime.local_(
                        this._selectedDate.year$,
                        this._selectedDate.month$ - 1,
                        this._selectedDate.day$,
                        this._selectedDate.hour$,
                        this._selectedDate.minute$,
                        this._selectedDate.second$));
                    break;
            }
        });
        return true;
    }

    onRefreshEvents_(): void {
        if (!this._shown) { return; }
        this.refresh_(this._selectedDate);
    }

    refresh_(
        date: DateTime
    ): void {
        host$.getEvents_(false, false, ret => {
            toasters$.warn_(ret);
            const alarms = (ret[Key.result] as JSONObject);
            this._refreshCalendar(date, alarms);
            this._eventsPanel.setDate(date, alarms);
        });
    }

    private _refreshCalendar(date: DateTime, alarms: JSONObject): void {
        this._selectedDate = date;
        this._inputYear.value = this._selectedDate.year$.toString();
        this._inputMonth.value = this._selectedDate.month$.toString();
        let d = this._selectedDate.subtract_(DateTime.DAY * (this._selectedDate.day$ - 1));
        d = (d.weekday$ == 7 ? d : d.subtract_(DateTime.DAY * d.weekday$));
        this._startDate = d;
        this.populate_(this._dateContainer, this._selectedDate, this._startDate, alarms);
    }

    refreshCalendar1_(alarms: JSONObject): void {
        this.populate_(this._dateContainer, this._selectedDate, this._startDate, alarms);
    }

    populate_(container: HTMLElement, selecteddate: DateTime, fromdate: DateTime, alarms: JSONObject): void {
        const today = An.simpleDateString_();
        const selected = selecteddate == null ? null : An.simpleDateString_(selecteddate);
        const month = selecteddate.month$;
        const pendingevents = new Array<DateTime>();
        const offevents = new Array<DateTime>();
        const doneevents = new Array<DateTime>();
        if (alarms != null) {
            const fromms = DateTime.local_(fromdate.year$, fromdate.month$, fromdate.day$).millisecondsSinceEpoch$;
            const toms = fromms + 42 * DateTime.DAY;
            const values = Object.values(alarms) as Array<JSONObject>;
            for (const event of values) {
                const info = EventInfo.of_(event);
                if (info == null)
                    continue;
                const ms = info.ms$;
                const inrange = (ms >= fromms && ms < toms);
                if (!inrange)
                    continue;
                const datetime = DateTime.fromMs_(ms);
                if (info.done$ == true) {
                    doneevents.push(datetime);
                } else if (info.pending$ == true) {
                    pendingevents.push(datetime);
                } else {
                    offevents.push(datetime);
                }
            }
        }
        host$.listBlogs_(selecteddate.year$, selecteddate.month$, (ret) => {
            let fileinfos = new StringMap<any>();
            //// Ignore errors, eg. in case directory not exists,
            if (!An.hasResult_(ret)) {
                fileinfos = ret[Key.result];
            }
            const aday = DateTime.DAY;
            let selectedCell = null;
            const b = new DomBuilderEx(container).empty_().push_();
            for (let r = 0; r < 6; ++r) {
                for (let c = 0; c < 7; ++c) {
                    const index = r * 7 + c;
                    const classes = sarray_();
                    classes.push(CSS.AnFlexRowNoWrap);
                    const weekday = fromdate.weekday$;
                    let hashtml = false;
                    if (fromdate.month$ == month) {
                        const day = An.to02d_(fromdate.day$);
                        hashtml = fileinfos[`${day}/${day}.html`] || fileinfos[`${day}.html`];
                        if (weekday == 0 || weekday == 6) {
                            classes.push(CSS.AnDateHoliday);
                        }
                    } else {
                        classes.push(CSS.AnGray);
                    }
                    if (hashtml) {
                        classes.push(CSS.AnIndicatorBlog);
                    }
                    const day = An.simpleDateString_(fromdate);
                    if (day == today) {
                        ArrayUt.delete_(classes, CSS.AnDateHoliday);
                        classes.push(CSS.AnBold);
                    }
                    if (day == selected) {
                        classes.push(CSS.AnDateSelected);
                    }
                    DONE:
                    {
                        for (const alarm of pendingevents) {
                            if (An.isSameDay_(fromdate, alarm)) {
                                classes.push(CSS.AnIndicatorTopRight, CSS.AnIndicatorAlarm);
                                break DONE;
                            }
                        }
                        for (const event of offevents) {
                            if (An.isSameDay_(fromdate, event)) {
                                classes.push(CSS.AnIndicatorTopRight, CSS.AnIndicatorEvent);
                                break;
                            }
                        }
                        for (const event of doneevents) {
                            if (An.isSameDay_(fromdate, event)) {
                                classes.push(CSS.AnIndicatorTopRight, CSS.AnIndicatorDone);
                                break;
                            }
                        }
                    }
                    const attrs = smap1_(
                        ATTR.AnInfo, index.toString(),
                    );
                    if (classes.length > 0) {
                        attrs["class"] = classes.join(" ");
                    }
                    const elm = b.peek_().div_(attrs).text_(fromdate.day$.toString()).cursor_();
                    if (day == selected) {
                        selectedCell = elm;
                    }
                    fromdate = fromdate.add_(aday);
                }
            }
            this._selectedCell = selectedCell;
            this._updateToolbarState();
        });
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.PrevBlog:
                this._findBlog(false, this._selectedDate);
                break;
            case BUT.NextBlog:
                this._findBlog(true, this._selectedDate);
                break;
            case BUT.Today:
                this.refresh_(An.now00_());
                break;
            case BUT.OpenDocument:
                this._open(true);
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _updateToolbarState(): void { }

    private _findBlog(next: boolean, selected: DateTime) {
        host$.findBlog_(selected.year$, selected.month$, selected.day$, next, (ret) => {
            if (toasters$.warn_(ret)) return;
            const cpath = ret[Key.result] as string;
            if (cpath != null) {
                const match = this._blogRegex.exec(cpath);
                if (match != null) {
                    const year = An.parseInt_(match[1], null);
                    const month = An.parseInt_(match[2], null);
                    const day = An.parseInt_(match[3], null);
                    if (year != null && month != null && day != null) {
                        const now = DateTime.now_();
                        this.refresh_(DateTime.local_(year, month, day, now.hour$, now.minute$, 0));
                    }
                }
            }
        });
    }

    private _open(create: boolean): void {
        const dir = _Util.getBlogMonthPath_(this._selectedDate);
        const day = An.to02d_(this._selectedDate.day$);
        const daydayhtml = `${day}/${day}.html`;
        const dayhtml = `${day}.html`;
        fileinfoUt$.fileInfos_(dir, [daydayhtml, dayhtml], ret => {
            if (toasters$.warn_(ret)) return;
            const infos: StringMap<any> = ret[Key.result];
            let cpath = `${dir}/${daydayhtml}`;
            let fileinfo = FileInfo.of_(infos[daydayhtml]);
            let exists = (fileinfo?.exists$ == true);
            if (!exists) {
                fileinfo = FileInfo.of_(infos[dayhtml]);
                exists = (fileinfo?.exists$ == true);
                if (exists) {
                    cpath = `${dir}/${dayhtml}`;
                }
            }
            if (exists || create) {
                _Util.onSaveOrDiscard_(() => {
                    this._open1(create, exists, cpath);
                });
            }
        });
    }

    private _open1(create: boolean, exists: boolean, cpath: string): void {
        if (exists) {
            sidePanel$.hideSidepanel_();
            _Util.browseFile_(cpath);
            return;
        }
        if (!create) {
            return;
        }
        sidePanel$.hideSidepanel_();
        host$.addPage_(cpath, TemplateCat.Blog.toLowerCase(), ret => {
            if (toasters$.error_(ret)) {
                return;
            }
            mainPanel$.addIFrameReadyOneshotCallback(next => {
                Timer.sleep0_(() => {
                    mainPanel$.startEdit(() => {
                        const title = native$.iQuery(`div.${CSS.xxTitle}`);
                        if (title != null) {
                            title.textContent = settings$.shortDateString_(this._selectedDate);
                        }
                        next();
                    }, () => {
                        next();
                    });
                });
            });
            _Util.browseFile_(cpath);
        });
    }
}

////////////////////////////////////////////////////////////////////////

abstract class _EventsPanelBase extends UIPanelBase {
    static readonly _FA_SELECTED = CSS.AnSelectedHighlight;
    static readonly ColorDisabled = "#bbb";
    static readonly _REPEATS: Map<string, string> = map_(
        [EventRepeat.Off, MSG.string_(RS.RepeatOffMarker)],
        [EventRepeat.Once, MSG.string_(RS.RepeatOnceMarker)],
        [EventRepeat.Daily, MSG.string_(RS.RepeatDailyMarker)],
        [EventRepeat.Workdays, MSG.string_(RS.RepeatWorkdaysMarker)],
        [EventRepeat.Weekly, MSG.string_(RS.RepeatWeeklyMarker)],
        [EventRepeat.Monthly, MSG.string_(RS.RepeatMonthlyMarker)],
        [EventRepeat.Yearly, MSG.string_(RS.RepeatYearlyMarker)],
    );
    _toolbar: Toolbar;
    _content: HTMLElement;
    _eventsPanel: HTMLElement;
    _sorted: JSONObject[] = [];
    _selected: HTMLElementX = null;
    _excludeDone: boolean = false;
    _shown: boolean = false;
    _populated = false;

    protected abstract _createEventsToolbars(b: DomBuilderEx): Toolbar;

    protected abstract _refreshAndReportPending(refresh: boolean, callback: Fun00X): void;

    protected abstract _addEvent(): void;

    protected abstract _includes(alarm: JSONObject): boolean;

    constructor(private _container: HTMLElement) {
        super();
        const b = new DomBuilderEx(this._container).push_();
        this._toolbar = this._createEventsToolbars(b);
        this._content = b.div1_(CSS.AnContentViewport).push_().cursor_();
        this._eventsPanel = b.peek_().div_({
            "style": "padding: 0;",
        }).cursor_();
        An.onContextmenu_(this._content, e => {
            An.stopevent_(e);
        });
        this._eventsPanel.addEventListener("click", (e) => {
            An.stopevent_(e);
            e.stopImmediatePropagation();
            if (With.optionalOrFalse_(DomUt.matchingTarget_(e, `.${CSS.AnFile}`), target => {
                toasters$.hideModal_();
                const url = target.getAttribute(ATTR.xTooltips);
                if (url == null || url.length == 0) {
                    toasters$.warnKey_(RS.PleaseSelectAFileToOpen);
                } else {
                    this._openurl(url);
                }
            })) return;
            if (With.optional_(DomUt.matchingTarget_(e,
                `span.${CSS.FaCheckSquare}, span.${CSS.FaSquareO}, span.${CSS.FaBellO}, span.${CSS.FaBell}`), target => {
                    this._toggleDone(target, () => {
                        this._refreshAndReportPending(true, null);
                    });
                    return true;
                })) return;
            if (With.optional_(DomUt.matchingTarget_(e, `div.${CSS.AnEventsPanel} > div`), td => {
                toasters$.hideModal_();
                this._select(td);
                this._updateToolbarState();
            })) return;
            this._deselect();
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    private _deselect() {
        if (this._selected != null) {
            this._selected.classList.remove(_EventsPanelBase._FA_SELECTED);
            this._selected = null;
            this._updateToolbarState();
        }
    }

    private _select(td: HTMLElement): void {
        const classes = td.classList;
        if (classes.contains(_EventsPanelBase._FA_SELECTED)) {
            classes.remove(_EventsPanelBase._FA_SELECTED);
            this._selected = null;
        } else {
            if (this._selected != null) {
                this._selected.classList.remove(_EventsPanelBase._FA_SELECTED);
            }
            classes.add(_EventsPanelBase._FA_SELECTED);
            this._selected = td;
        }
        this._updateToolbarState();
    }

    selectAndReveal_(id: string, callback: Fun00X = null) {
        if (!this._populated) {
            Timer.sleep_(250, () => {
                this.selectAndReveal_(id, callback);
            });
            return;
        }
        const index = this._sorted.findIndex((a) => id == a[EventKey.Id]);
        if (index >= 0) {
            const parent = DomUt.query_(this._eventsPanel, `div.${CSS.AnEventsPanel}`);
            if (parent != null) {
                const elm = parent.children.item(index);
                if (elm) {
                    this._select(elm as HTMLElement);
                    (elm as any).scrollIntoViewIfNeeded(true);
                }
            }
        }
        callback?.();
    }

    private _getAlarm(elm: HTMLElementX): JSONObjectX {
        const id = elm?.getAttribute(ATTR.AnInfo);
        if (elm == null || id == null) { return null; }
        const index = this._sorted.findIndex(a => id == a[EventKey.Id]);
        return (index >= 0) ? this._sorted[index] : null;
    }

    private _setContentHeight(): void {
        const viewport = this._eventsPanel.parentElement;
        if (viewport == null) { return; }
        const top = An.documentOffset_(viewport).y;
        const h = window.innerHeight - top - DEF.sidepanelMarginBottom /* margin-bottom */;
        const style = viewport.style;
        style.height = `${h}px`;
        style.maxHeight = `${h}px`;
    }

    resizeContent_(_containerheight: number): void {
        this._setContentHeight();
    }

    protected _refresh(ret: JSONObject): void {
        this._sorted = new Array<JSONObject>();
        this._selected = null;
        new DomBuilderEx(this._eventsPanel).empty_();
        this._refresh1(ret);
        this._updateToolbarState();
    }

    private _refresh1(ret: JSONObject) {
        if (ret == null) return;
        if (toasters$.warn_(ret)) return;
        const events = (ret[Key.result] as JSONObject);
        this._refresh2(this._eventsPanel, events);
    }

    protected _refresh2(panel: HTMLElement, events: JSONObject) {
        if (events == null) return;
        const sorted = Array.from(Object.values(events));
        sorted.sort((a: JSONObject, b: JSONObject) => {
            const ams = a[EventKey.Ms];
            const bms = b[EventKey.Ms];
            return (ams > bms) ? 1 : (bms > ams) ? -1 : 0;
        });
        const b = DomBuilderEx.offline_(document, "div", {
            "class": `${CSS.AnEventsPanel} ${CSS.AnZebra}`,
        }).push_();
        const now = An.now00_();
        const tomorrow = now.add_(DateTime.DAY);
        const nextdate = this._nextTrigger(sorted, tomorrow);
        for (const alarm of sorted) {
            if (!this._includes(alarm)) {
                continue;
            }
            this._sorted.push(alarm);
            this._populate1(b, now, tomorrow, nextdate, alarm);
        }
        if (this._sorted.length > 0) new DomBuilderEx(panel).empty_().appendNodes_(b.pop_().cursor_());
    }

    private _days(date: DateTime, now: DateTime): Int {
        return Math.round(Math.abs(date.millisecondsSinceEpoch$ - now.millisecondsSinceEpoch$) / DateTime.DAY);
    }

    private _datestring(date: DateTime, now: DateTime, istoday: boolean, istomorrow: boolean): string {
        const days = this._days(date, now);
        if (istoday) return MSG.string_(RS.Today) + "\u00a0" + settings$.timeString_(date);
        if (istomorrow) return MSG.string_(RS.Tomorrow) + "\u00a0" + settings$.timeString_(date);
        if (days <= 30) {
            return (date.year$ == now.year$)
                ? settings$.shortDatetimeString_(date)
                : settings$.datetimeString_(date);
        }
        return (date.year$ == now.year$)
            ? settings$.shortDateString_(date)
            : settings$.dateString_(date);
    }

    private _populate1(b: DomBuilderEx, now: DateTime, tomorrow: DateTime, nextdate: DateTime | null, alarm: JSONObject): void {
        const info = new EventInfo(alarm);
        const id = info.id$;
        const ms = info.ms$;
        const repeat = info.repeat$;
        const href = info.url$;
        const desc = info.desc$;
        const color = info.color$;
        const isprivate = info.private$;
        const donems = info.doneMs$;
        const donedesc = info.doneDesc$;
        const alarmoff = (repeat == EventRepeat.Off);
        const done = info.done$;
        const pending = info.pending$;
        const shouldpost = !done && !pending && !alarmoff && this._shouldPostAlarm(alarm, now);
        const date = DateTime.fromMs_(ms);
        const istoday = An.isSameDay_(now, date);
        const istomorrow = An.isSameDay_(tomorrow, date);
        const nexttrigger = nextdate != null && An.isSameDay_(nextdate, date);
        const uri = An.parseUriSafe_(href, null);
        const filepath = (uri == null ? "" : uri.path$);
        const emptyfilepath = An.isempty_(filepath);
        const exists = !emptyfilepath && info.exists$;
        const datestring = this._datestring(date, now, istoday, istomorrow);
        const att = {
            "class": (done ? ` ${CSS.AnEventsDone}`
                : istoday ? ` ${CSS.AnEventsToday}`
                    : nexttrigger ? ` ${CSS.AnEventsTomorrow}` : ` ${CSS.AnEventsPending}`),
        };
        const status = done ? CSS.FaCheckSquare : pending ? CSS.FaBellO : shouldpost ? CSS.FaBell : CSS.FaSquareO;
        const fulldesc = done
            ? `[${An.simpleDateString_(DateTime.fromMs_(donems ?? 0))}: ${donedesc}] ${desc}`
            : desc;
        const text = !An.isempty_(fulldesc)
            ? fulldesc
            : !emptyfilepath ? Basepath.stem_(filepath) : "\u00a0";
        const attrs = smap1_("class", CSS.AnEventsItem);
        attrs[ATTR.AnInfo] = id;
        if (!An.isempty_(color)) {
            const c = ColorUtil.getColorValue_(color);
            if (c != null) attrs["style"] = `background-color:${c.toCSSString_()};`;
        }
        b.peek_().div_(attrs).indent_(
            b.push_().div_(att).indent_(
                b.push_().span1_(CSS.AnBulletLeft, CSS.Fa, status, CSS.AnLink),
                b.peek_().span1_(CSS.AnEventsDate).text_(datestring),
                b.peek_().span1_(CSS.AnEventsRepeat).text_(`\u00a0\u00a0${_EventsPanelBase._REPEATS.get(repeat) ?? ""}`),
                b.peek_().span1_(CSS.AnBullet, CSS.AnSmall, CSS.Fa, isprivate ? CSS.FaLock : ""),
                b.pop_()
            ),
            b.pop_().div_(att).push_().span1_(CSS.AnBulletLeft)
        );
        if (!exists) {
            b.peek_().span_({
                "class": emptyfilepath ? CSS.AnEventsDesc : `${CSS.AnEventsDesc} ${CSS.AnNot}`,
            }).text_(text);
        } else {
            b.peek_().ahref_(href,
                ["class", `${CSS.AnEventsDesc} ${CSS.AnFile}`],
                [ATTR.xTooltips, href],
            ).text_(text);
        }
        b.pop_();
    }

    private _nextTrigger(sorted: JSONObject[], t: DateTime): DateTime | null {
        const tomorrow = DateTime.local_(t.year$, t.month$, t.day$).millisecondsSinceEpoch$;
        for (const alarm of sorted) {
            if (true == alarm[EventKey.Done]) {
                continue;
            }
            const ms = alarm[EventKey.Ms];
            if (ms < tomorrow) {
                continue;
            }
            return DateTime.fromMs_(ms);
        }
        return null;
    }

    private _shouldPostAlarm(alarm: JSONObject, now: DateTime): boolean {
        if (EventRepeat.Once == alarm[EventKey.Repeat]) {
            const ms = alarm[EventKey.Ms];
            const lastms = alarm[EventKey.Lastms];
            const min = now.millisecondsSinceEpoch$ + DEF.alarmMargin;
            if ((lastms != null && ms <= lastms) || ms <= min) {
                return false;
            }
        }
        return true;
    }

    show_(): void {
        if (this._shown) return;
        this._shown = true;
        An.showHidden_(this._container);
        this._setContentHeight();
        this._refreshAndReportPending(true, () => {
            An.setVisible_(this._container);
        });
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            this._populated = false;
            An.hide_(this._container);
            this._sorted = [];
            this._selected = null;
            new DomBuilderEx(this._eventsPanel).empty_();
        }
    }

    private _getSelectedAlarm(): EventInfo | null {
        return EventInfo.of_(this._getAlarm(this._selected));
    }

    private _toggleDone(span: HTMLElement, callback: Fun00): void {
        const td = span.parentElement?.parentElement ?? null;
        const event = this._getAlarm(td);
        if (event == null) {
            
            return;
        }
        const done = !(true == event[EventKey.Done]);
        if (done) {
            event[EventKey.Done] = true;
            event[EventKey.DoneMs] = DateTime.ms_();
            const eventinfo = EventInfo.of_(event);
            if (eventinfo != null) this.promptAlarm_(eventinfo, callback);
        } else {
            event[EventKey.Done] = false;
            delete event[EventKey.DoneMs];
            host$.postEvent_(event, ret => {
                toasters$.warn_(ret);
                callback();
            });
        }
    }

    protected _updateToolbarState(): void {
        const hasselection = (this._selected != null);
        this._toolbar.enableButtons_([BUT.Remove, BUT.EditEvent], hasselection);
    }

    protected _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.CreateEvent:
                this._addEvent();
                break;
            case BUT.EditEvent:
                this._editEvent();
                break;
            case BUT.Remove:
                this._removeEvent();
                break;
            case BUT.Refresh:
                this._refreshAndReportPending(true, null);
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    protected _postEvent(event: JSONObject, callback: Fun00X = null): void {
        host$.postEvent_(event, ret => {
            toasters$.warn_(ret);
            this._refreshAndReportPending(true, callback);
        });
    }

    protected _removeEvent(): void {
        const selected = this._getSelectedAlarm();
        if (selected == null) {
            return;
        }
        _Util.confirmSmall_(MSG.format1_((RS.ConfirmRemove_Event), "1"), DEF.zindexConfirm, (yes: boolean) => {
            if (!yes) return;
            const ids = [selected.id$];
            host$.removeEvents_(ids, ret => {
                if (!toasters$.warn_(ret)) {
                    const count = ret[Key.result];
                    toasters$.info_(MSG.format1_(RS.removed_events, `${count}`));
                }
                this._refreshAndReportPending(true, null);
            });
        });
    }

    private _editEvent(): void {
        const event = this._getSelectedAlarm();
        if (event == null) return;
        this.promptAlarm_(event);
    }

    promptAlarm_(event: EventInfo, callback: Fun00X = null) {
        new PromptEvent(
            accessories$,
            cache$.ui$.buttonSize_(),
            settings$.dateFormat_(),
            settings$.timeFormat_(),
            native$.getIFrameUri_() ?? Uri.ROOT$,
            event)
            .titleKey_(RS.CreateEventTitle)
            .zindex_(DEF.zindexPrompt)
            .onOK_((event) => {
                this._postEvent(event, () => {
                    this.selectAndReveal_(event[EventKey.Id], callback);
                });
            })
            .onCancel_(() => {
                callback?.();
            })
            .show_();
    }

    /// @param cpath A context relatve path with leading /.
    private _openurl(url: string): void {
        sidePanel$.hideSidepanel_();
        const cpath = An.cpathOfFilepath2_(FS, url);
        if (cpath != null) {
            const lcsufix = Basepath.lcSuffix_(cpath);
            if (MimeUtil.isAudioLcSuffix_(lcsufix)) {
                _AudioPlayerDialog.createAndShow_(accessories$, cpath);
                return;
            }
            if (MimeUtil.isVideoLcSuffix_(lcsufix)) {
                host$.playVideo_(cpath, false, 0, (ret) => {
                    toasters$.warn_(ret);
                });
                return;
            }
        }
        _Util.onSaveOrDiscard_(() => {
            _Util.browse1_(An.parseUriSafe_(url, null));
        });
    }

    static _createAlarmForDate(date: DateTime, callback: JSONCallback): void {
        const id = _AlarmUtil.createId_();
        _EventsPanelBase._promptNewEvent(EventInfo.create_(
            id, date.millisecondsSinceEpoch$, "", "", ""
        ), callback).show_();
    }

    static _promptNewEvent(
        event: EventInfo,
        onok: JSONCallback,
    ): PromptEvent {
        const d = new PromptEvent(
            accessories$,
            cache$.ui$.buttonSize_(),
            settings$.dateFormat_(),
            settings$.timeFormat_(),
            native$.getIFrameUri_() ?? Uri.ROOT$,
            event);
        d.titleKey_(RS.CreateEventTitle);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_(onok);
        return d;
    }
}

////////////////////////////////////////////////////////////////////////

class _CalendarEventsPanel extends _EventsPanelBase {

    constructor(
        top: HTMLElement,
        private _calendarPanel: _CalendarPanel,
        private _date: DateTime
    ) {
        super(top);
        this._excludeDone = false;
        const style = this._eventsPanel.style;
        style.width = "-webkit-fit-content";
        style.minWidth = "100%";
    }

    protected _createEventsToolbars(b: DomBuilderEx): Toolbar {
        const tb = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.EditEvent,
            BUT.Remove,
            BUT.CreateEvent,
        ));
        tb.onAction_(action => this._toolbarActions(action));
        tb.onTooltips_(toasters$.onTooltipsKey_);
        return tb;
    }

    protected _refreshAndReportPending(refresh: boolean, callback: Fun00X = null): void {
        this._populated = false;
        host$.getEvents_(refresh, this._excludeDone, ret => {
            toasters$.warn_(ret);
            const alarms = (ret[Key.result] as JSONObject);
            this._calendarPanel.refreshCalendar1_(alarms);
            super._refresh(ret);
            host$.getPendingAlarmCount_(ret => {
                if (!toasters$.warn_(ret)) {
                    const count = ret[Key.result];
                    toasters$.info_(`${MSG.string_(RS.AlarmsPending_)}${count}`, { attop: false });
                }
                this._populated = true;
                callback?.();
            });
        });
    }

    protected _addEvent(): void {
        const now = DateTime.now_();
        const date = DateTime.local_(this._date.year$, this._date.month$, this._date.day$, now.hour$, now.minute$);
        _EventsPanelBase._createAlarmForDate(date, alarm => this._postEvent(alarm));
    }

    protected _includes(alarm: JSONObject): boolean {
        const ms = alarm[EventKey.Ms];
        const date = DateTime.fromMs_(ms);
        return An.isSameDay_(this._date, date);
    }

    /// Refresh alarms panel only, on date selected.
    setDate1(date: DateTime): void {
        this._date = date;
        host$.getEvents_(false, this._excludeDone, ret => {
            this._refresh(ret);
        });
    }

    /// Refresh alarms panel only, on refresh calendar.
    setDate(date: DateTime, alarms: JSONObject): void {
        this._date = date;
        this._sorted = [];
        this._selected = null;
        new DomBuilderEx(this._eventsPanel).empty_();
        this._refresh2(this._eventsPanel, alarms);
        this._updateToolbarState();
    }

    showContextmenu_(): void { }

    hideContextmenu_(): void { }

    onWindowSizeChanged_(): void { }
}

////////////////////////////////////////////////////////////////////////

class _EventsPanel extends _EventsPanelBase {
    private _editbar!: Toolbar;

    constructor(container: HTMLElement) {
        super(container);
        const padding = cache$.ui$.iwinPadding_();
        const style = this._eventsPanel.style;
        style.paddingBottom = `${padding}px`;
        style.width = "-webkit-fit-content";
        style.minWidth = "100%";
    }

    protected _createEventsToolbars(b: DomBuilderEx): Toolbar {
        const toolbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.EditEvent,
            BUT.Remove,
            BUT.CreateEvent,
            BUT.Toolbar,
        ));
        toolbar.onAction_(action => this._toolbarActions0(action));
        toolbar.onTooltips_(toasters$.onTooltipsKey_);
        this._editbar = new Toolbar(b.cursor_(), BUT.infos_(
            BUT.Refresh,
            BUT.ShowDoneEvents,
            BUT.ClearEvents,
            BUT.Toolbar1,
        ));
        this._editbar.onAction_(action => this._toolbarActions0(action));
        this._editbar.onTooltips_(toasters$.onTooltipsKey_);
        this._editbar.hide_();
        return toolbar;
    }

    protected _refreshAndReportPending(refresh: boolean, callback: Fun00X = null): void {
        this._populated = false;
        host$.getEvents_(refresh, this._excludeDone, ret => {
            this._refresh(ret);
            host$.getPendingAlarmCount_(ret => {
                if (!toasters$.warn_(ret)) {
                    const count = ret[Key.result];
                    toasters$.info_(`${MSG.string_(RS.AlarmsPending_)}${count}`, { attop: false });
                }
                this._populated = true;
                callback?.();
            });
        });
    }

    protected _addEvent(): void {
        _EventsPanelBase._createAlarmForDate(An.now00_(), (event) => this._postEvent(event));
    }

    protected _includes(_alarm: JSONObject): boolean {
        return true;
    }

    protected _updateToolbarState(): void {
        this._editbar.enableButton_(BUT.ClearEvents, true);
        super._updateToolbarState();
    }

    showContextmenu_(): void { }

    hideContextmenu_(): void { }

    onWindowSizeChanged_(): void { }

    show_(): void {
        host$.getSessionPreferences_(ret => {
            const result = ret[Key.result];
            if (result != null) {
                const showdone = result[SessionPreferencesKey.showDoneEvents];
                this._excludeDone = (true != showdone);
                const classes = this._editbar.button_(BUT.ShowDoneEvents).classList;
                if (this._excludeDone) {
                    classes.add(CSS.AnToggleOff);
                } else {
                    classes.remove(CSS.AnToggleOff);
                }
            }
            super.show_();
        });
    }

    onRefreshEvents_(): void {
        if (!this._shown) { return; }
        this._refreshAndReportPending(false);
    }

    private _toolbarActions0(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.Toolbar:
                this._toolbar.hide_();
                this._editbar.show_();
                break;
            case BUT.Toolbar1:
                this._editbar.hide_();
                this._toolbar.show_();
                break;
            case BUT.ShowDoneEvents:
                this._excludeDone = !this._excludeDone;
                this._editbar.button_(BUT.ShowDoneEvents).classList.toggle(CSS.AnToggleOff);
                host$.updateSessionPreferences_(
                    smap1_(SessionPreferencesKey.showDoneEvents, !this._excludeDone),
                    () => { });
                this._refreshAndReportPending(true);
                break;
            case BUT.ClearEvents:
                _Util.confirmKeySmall_(RS.ConfirmClearEvents, DEF.zindexConfirm, (yes: boolean) => {
                    if (!yes) return;
                    host$.clearEvents_(ret => {
                        toasters$.warn_(ret);
                        this._refreshAndReportPending(true);
                    });
                });
                break;
            default:
                super._toolbarActions(action);
        }
    }

}

////////////////////////////////////////////////////////////////////////

class _RecentsPanel extends UIPanelBase {
    private _toolbar: Toolbar;
    private _dirtreePanel: HTMLElement;
    private _filterbox: HTMLTextAreaElement;
    private _dirtree: FileInfo[] = [];
    private _recentsHandler: IRecentsHandler;
    private _sorted = false;

    constructor(private _container: HTMLElement) {
        super();
        this._recentsHandler = new RecentsHandler();
        const b = new DomBuilderEx(_container).push_();
        this._toolbar = new Toolbar(b.cursor_(), [
            INPUT.info_(INPUT.FilterBox),
            BUT.info_(BUT.Filter),
            BUT.info_(BUT.Sort),
            BUT.info_(BUT.ClearHistory),
            BUT.info_(BUT.RemoveBrokenEntries),
        ]);
        this._toolbar.onAction_(action => this._toolbarActions(action));
        this._toolbar.onTooltips_(toasters$.onTooltipsKey_);
        b.div1_(CSS.AnContentViewport).push_();
        this._dirtreePanel = b.peek_().div1_(CSS.AnViewportContent).cursor_();
        An.onContextmenu_(_container, e => {
            An.stopevent_(e);
        });
        An.onClickMatching_(this._dirtreePanel, `div.${CSS.AnRecents} > div`, (elm, e) => {
            An.stopevent_(e);
            const index = An.parseInt_(elm.getAttribute(ATTR.AnAction), null);
            if (index == null || index < 0 || index >= this._dirtree.length) return;
            const info = this._dirtree[index];
            
            const path = info.name$;
            const state = info.state$;
            this._openfile(path, state);
        });
        this._filterbox = this._toolbar.querySelector_(Conf.input$)! as AnInputElement;
        An.onInputFocusSelect_(this._filterbox);
        An.onKeypress_(this._filterbox, e => {
            if (e.key == "Enter") {
                An.stopevent_(e);
                this._actionFilter();
            }
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    private _showPanel(): void {
        An.showHidden_(this._container);
        this._setDirtreeHeight();
        An.setVisible_(this._container);
    }

    private _hidePanel(): void {
        this.hideContextmenu_();
        An.hide_(this._container);
    }

    resizeContent_(): void { }

    private _setDirtreeHeight(): void {
        const viewport = this._dirtreePanel.parentElement;
        if (viewport == null) { return; }
        const dirtreetop = An.documentOffset_(viewport).y;
        const winheight = window.innerHeight;
        const treeheight = winheight -
            dirtreetop -
            DEF.sidepanelMarginBottom /* margin-bottom */;
        const style = viewport.style;
        style.padding = "0";
        style.height = `${treeheight}px`;
        style.maxHeight = `${treeheight}px`;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            this._showPanel();
            this._refresh0();
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            this._hidePanel();
        }
    }

    private _refresh0(): void {
        if (this._sorted) {
            this._recentsHandler.sorted_(ret => {
                this._refresh(ret);
            });
        } else {
            this._recentsHandler.info_(ret => {
                this._refresh(ret);
            });
        }
    }

    private _refresh(ret: JSONObject): void {
        if (ret == null || toasters$.warn_(ret)) return;
        this._dirtree = FileInfo.arrayOf_(ret[Key.dirtree]) ?? [];
        this._refreshdirtree(this._dirtreePanel, this._dirtree);
    }

    private _refreshdirtree(panel: HTMLElement, fileinfos: FileInfo[]): void {
        new DomBuilderEx(panel).empty_();
        if (fileinfos.length == 0) return;
        const searchtext = this._filterbox.value.trim().toLowerCase();
        const b = DomBuilderEx.offline_(document, "div", {
            "class": `${CSS.AnRecents} ${CSS.AnTextList} ${CSS.AnZebra}`,
        }).push_();
        const len = fileinfos.length;
        for (let i = 0; i < len; ++i) {
            const fileinfo = fileinfos[i];
            const readable = fileinfo.readable$;
            const isredo = fileinfo.flag$;
            const url = fileinfo.name$;
            const y = fileinfo.state$?.["y"] ?? null;
            const aty = (y != null && y >= 0.5 ? ` @${Math.round(y)}` : "");
            if (searchtext.length > 0 && !url.toLowerCase().includes(searchtext)) {
                continue;
            }
            if (!readable) {
                b.peek_().div1_(isredo ? CSS.AnRedoItem : "").span_().text_(url);
            } else {
                b.peek_().div_(
                    [ATTR.AnAction, `${i}`],
                    ["class", isredo ? CSS.AnRedoItem : ""],
                ).a1_(CSS.AnFile).text_(url + aty);
            }
        }
        new DomBuilderEx(panel).appendNodes_(b.pop_().cursor_());
    }

    private _actionFilter() {
        this._refreshdirtree(this._dirtreePanel, this._dirtree);
    }

    private _toolbarActions(action: string): void {
        toasters$.hideAll_();
        switch (action) {
            case BUT.Filter:
                this._actionFilter();
                break;
            case BUT.RemoveBrokenEntries:
                this._recentsHandler.clean_(ret => {
                    toasters$.warn_(ret);
                    this._refresh(ret);
                });
                break;
            case BUT.Sort:
                this._sorted = An.toggleOnOffButton_(this._toolbar.button_(BUT.Sort));
                this._refresh0();
                break;
            case BUT.ClearHistory:
                _Util.confirmKeySmall_(RS.ActionClearHistoryMessage, DEF.zindexConfirm, (yes: boolean) => {
                    if (!yes) return;
                    this._recentsHandler.clear_(ret => {
                        toasters$.warn_(ret);
                        this._refresh(ret);
                    });
                });
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    /// @param cpath A context relatve path with leading /.
    private _openfile(cpath: string, state: JSONObjectX): void {
        sidePanel$.hideSidepanel_();
        _Util.onSaveOrDiscard_(() => {
            _Util.browseFile_(cpath, state);
        });
    }
}

////////////////////////////////////////////////////////////////////////

class _ExplorePanel extends TabPanel implements IUIPanel {
    _shown: boolean = false;

    constructor(container: HTMLElement) {
        super(container);
        const tab = this.addTab(RS.Tooltips_FilesPanel, `${CSS.Fa} ${CSS.FaFolder}`, (elm) => {
            return (new _FilesPanel(elm));
        });
        this.addTab(RS.Tooltips_CalendarPanel, `${CSS.Fa} ${CSS.FaCalendar}`, (elm) => {
            return (new _CalendarPanel(elm));
        });
        this.addTab(RS.Tooltips_EventsPanel, `${CSS.Fa} ${CSS.FaBellO}`, (elm) => {
            return (new _EventsPanel(elm));
        });
        this.addTab(RS.Tooltips_RecentsPanel, `${CSS.Fa} ${CSS.FaHistory}`, (elm) => {
            return (new _RecentsPanel(elm));
        });
        this.onTooltips(toasters$.onTooltipsKey_);
        this.activeTab(tab);
        native$.addCallback_(AjaxAction.refreshEvents, () => { return this._onRefreshEvents(); });
    }

    element_(): HTMLElement {
        return this._container;
    }

    private _onRefreshEvents(): stringX {
        if (!this._shown) {
            return null;
        }
        const active = this.activePanel();
        if (active instanceof _EventsPanel) {
            Timer.sleep0_(() => {
                active.onRefreshEvents_();
            });
        } else if (active instanceof _CalendarPanel) {
            Timer.sleep0_(() => {
                active.onRefreshEvents_();
            });
        }
        return null;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            
            An.showHidden_(this._container);
            this.resizeContent_(window.innerHeight);
            this.selectTab(this.activeTab());
            An.setVisible_(this._container);
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            
            An.hide_(this._container);
            const panel = this.activePanel();
            if (panel != null) {
                panel.hide_();
            }
        }
    }

    resizeContent_(containerheight: number): void {
        
        this._container.style.height = `${containerheight}px`;
        super.resizeContent1(containerheight, cache$.ui$.toolbarHeight_());
    }

    showContextmenu_(): void { }

    hideContextmenu_(): void {
        //// When hiding the sidepanel, hide any active contextmenu too.
        
        const panel = this.activePanel();
        if (panel != null) {
            panel.hideContextmenu_();
        }
    }

    onWindowSizeChanged_(): void {
        super.onWindowSizeChanged();
    }
}

////////////////////////////////////////////////////////////////////////

class _HtmlTemplatesPanel extends UIPanelBase {
    _container: HTMLElement;
    _viewport: HTMLElement;
    _content: HTMLElement;
    _shown: boolean = false;
    _populated: boolean = false;

    /// @param top The DOM element of an empty tab panel.
    constructor(container: HTMLElement) {
        super();
        this._container = container;
        const b = new DomBuilderEx(this._container).div_({
            "class": CSS.AnContentViewport,
        });
        this._viewport = b.cursor_();
        b.div1_(CSS.AnViewportContent, CSS.AnOverflowAuto);
        this._content = b.div_({
            "class": `${CSS.AnPanel} ${CSS.AnTemplateContainer}`,
            "style": `border-bottom:${DEF.themeBorder}`,
        }).cursor_();
        An.onClickMatching_(this._content, `div.${CSS.AnTemplateCell}`, (mtarget, e) => {
            An.stopevent_(e);
            const name = mtarget.getAttribute(ATTR.AnInfo);
            if (name != null && name.length > 0) {
                sidePanel$.hideSidepanel_();
                _Util.newPageFromTemplateName_(name);
            }
        });
        if (Conf.useFlash$) {
            new Flash(this._content, `div.${CSS.AnTemplateCell}`, CSS.AnFlashLowlight, DEFUtil.flashDuration);
        }
        An.onContextmenu_(this._container, e => {
            An.stopevent_(e);
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (this._shown) {
            return;
        }
        this._shown = true;
        if (!this._populated) {
            this._populate(settings$.htmlTemplates_());
            this._populated = true;
        }
        An.showVisible_(this._container);
    }

    resizeContent_(topheight: number): void {
        const h = topheight /* - _cache.ui.toolbarHeight() */ - DEF.sidepanelMarginBottom;
        this._viewport.style.height = `${h}px`;
    }

    private _populate(templates: Map<string, Array<TemplateInfo>>): void {
        const ret = new DocumentFragment();
        for (const [cat, infos] of templates.entries()) {
            const lccat = cat.toLowerCase();
            const b = DomBuilderEx.offline_(this._content.ownerDocument, "div", smap_(
                ["class", CSS.AnTemplateCategory],
                [ATTR.AnInfo, cat],
            ));
            ret.append(b.cursor_());
            b.div1_(CSS.AnTemplateHeader, `x-emoji-${lccat}`).text_(`\u00a0\u00a0${cat}`);
            b.up_().div1_(CSS.AnTemplateContent,).push_();
            for (const info of infos) {
                const name = info.name$;
                const tn = `assets/templates/${lccat}/${name}-tn.jpg`;
                b.peek_().div_(
                    ["class", CSS.AnTemplateCell],
                    [ATTR.AnInfo, name],
                ).img_(tn);
            }
        }
        new DomBuilderEx(this._content).empty_().appendNodes_(ret);
    }

}

////////////////////////////////////////////////////////////////////////

class _WidgetTemplates {
    static readonly _sidebarPalette0 = "rgba(160,160,160,0.5)";
    static readonly _colorYellow = "#fff000";
    static readonly _colorGreen = "#8c7";
    static readonly _colorBlue = "#9cf";
    static readonly _colorWhite = "#fff";
    static readonly _INFOS = [
        [
            RS.widgetAccordionTitle,
            `${CSS.Fa} ${CSS.FaChevronCircleUp}`,
        ],
        [
            RS.widgetAnnotationTitle,
            `${CSS.Fa} ${CSS.FaCommentO}`,
        ],
        [
            RS.widgetFlexboxTitle,
            `${CSS.Fa} ${CSS.FaColumns}`,
        ],
        [
            RS.widgetPictureFrameTitle,
            `${CSS.Fa} ${CSS.FaImage}`,
        ],
        [
            RS.widgetShoppingTitle,
            `${CSS.Fa} ${CSS.FaShoppingCart}`,
        ],
        [
            RS.widgetSidebarTabTitle,
            `${CSS.Fa} ${CSS.FaTag}`,
        ],
        [
            RS.widgetSidepanelTitle,
            `${CSS.Fa} ${CSS.FaSignOut}`,
        ],
        [
            RS.widgetSlideshowTitle,
            `${CSS.Fa} ${CSS.FaSlideshare}`,
        ],
        [
            RS.widgetStickerTitle,
            `${CSS.Fa} ${CSS.FaCertificate}`,
        ],
        [
            RS.widgetTocTitle,
            `${CSS.Fa} ${CSS.FaListUl}`,
        ],
        [
            RS.widgetTodoTitle,
            `${CSS.Fa} ${CSS.FaCheckSquareO}`,
        ],
    ];

    static create(action: string): void {
        sidePanel$.hideSidepanel_();
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) return;
        if (action == RS.widgetAccordionTitle) {
            const range = native$.getIFrameSelectionRange_();
            if (range != null) {
                _WidgetTemplates._accordion(range);
            }
        } else if (action == RS.widgetAnnotationTitle) {
            const range = _WidgetTemplates._getAnnotationTargetRange();
            if (range != null) {
                _WidgetTemplates._annotation(range, baseuri);
            }
        } else if (action == RS.widgetFlexboxTitle) {
            const range = native$.getIFrameSelectionRange_();
            if (range != null) {
                _FlexboxWidget._flexbox(range);
            }
        } else if (action == RS.widgetPictureFrameTitle) {
            const range = native$.getIFrameSelectionRange_();
            _WidgetTemplates._pictureframe(range, baseuri);
        } else if (action == RS.widgetShoppingTitle) {
            const idoc = native$.getIFrameDocument_();
            const range = native$.getIFrameSelectionRange_();
            if (idoc != null && range != null) {
                _ShoppingWidget.create_(idoc, range);
            }
        } else if (action == RS.widgetSidebarTabTitle) {
            _WidgetTemplates._sidebarTab(baseuri);
        } else if (action == RS.widgetSidepanelTitle) {
            _WidgetTemplates._sidepanel(baseuri);
        } else if (action == RS.widgetSlideshowTitle) {
            const range = native$.getValidIFrameSelectionRange_();
            if (range != null) {
                _WidgetTemplates._slideshow(range, baseuri);
            }
        } else if (action == RS.widgetStickerTitle) {
            _WidgetTemplates._sticker(baseuri);
        } else if (action == RS.widgetTocTitle) {
            const idoc = native$.getIFrameDocument_();
            const range = native$.getIFrameSelectionRange_();
            if (idoc != null && range != null) {
                _TocWidget.create_(idoc, range);
            }
        } else if (action == RS.widgetTodoTitle) {
            const idoc = native$.getIFrameDocument_();
            const range = native$.getIFrameSelectionRange_();
            if (idoc != null && range != null) {
                _TodoWidget.create_(idoc, range);
            }
        } else {
            throw Assert.notReach_(action);
        }
    }

    static promptStyle_(container: HTMLElement, callback: Fun10<string>): void {
        new _PromptWidgetStyle(container)
            .zindex_(DEF.zindexPrompt)
            .onOK_(callback)
            .show_();
    }

    static _getAnnotationTargetRange(): RangeX {
        const range = native$.getIFrameSelectionRange_();
        if (toasters$.warn_(JsUtil.actionWrapOK_(range))) {
            return null;
        }
        return range;
    }

    static _accordion(range: Range): void {
        history$.group_(RS.widgetAccordionTitle, "", () => {
            const collapsed = range.collapsed;
            if (collapsed) {
                const parent = JsUtil.ancestorOrSelfWithClasses_(range.startContainer, [CSS.xAccordionShow, CSS.xAccordionHide]);
                if (parent != null) {
                    _WidgetTemplates._accordionSibling(parent);
                } else {
                    _WidgetTemplates._accordionWrap(range, collapsed);
                }
            } else {
                const node = DomUt.asHTMLElement_(native$.getSingleSelectedNodeOfRange_(range));
                if (node != null && JsUtil.hasClasses_(node, [CSS.xAccordionShow, CSS.xAccordionHide])) {
                    _WidgetTemplates._accordionSibling(node);
                } else {
                    _WidgetTemplates._accordionWrap(range, collapsed);
                }
            }
        });
    }

    static _accordionSibling(sibling: Node): void {
        const parent = sibling.parentElement;
        if (parent == null) { return; }
        const b = new DomBuilderEx(parent);
        b
            .childBefore_(sibling.nextSibling, "article", {
                "class": CSS.xAccordionHide,
            })
            .push_()
            .child_("header", smap_(
                ["class", CSS.xAccordionButton],
                [ATTR.xButton, `r/${CSS.xAccordionShow} ${CSS.xAccordionHide}`],
            ))
            .text_("\u00a0\u00a0" + MSG.string_(RS.Subject))
            .pop_()
            .div1_(CSS.xAccordionContent)
            .text_(MSG.string_(RS.Content));
    }

    static _accordionWrap(range: Range, collapsed: boolean): void {
        const content = RangeUtil.wrapRange_("div", {
            "class": CSS.xAccordionContent,
        }, range);
        if (collapsed) {
            new DomBuilderEx(content).text_(MSG.string_(RS.Content));
        }
        const accordion = JsUtil.wrapNode_(content, "article", {
            "class": `${CSS.xAccordionShow}`,
        });
        const b = new DomBuilderEx(accordion);
        b.childBefore_(content, "header", smap_(
            ["class", CSS.xAccordionButton],
            [ATTR.xButton, `r/${CSS.xAccordionShow} ${CSS.xAccordionHide}`],
        )).text_("\u00a0\u00a0" + MSG.string_(RS.Subject));
    }

    static _destructAccordion(node: Node): void {
        _Util.confirmSmall_(MSG.formatArray1_(
            RS.destructWidgetAndContent,
            MSG.string_(RS.widgetAccordionTitle
            )), DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                JsUtil.remove_(node);
            });
    }

    /// @param titlekey The string resource key for the title.
    /// @param callback(HTMLElementX) The div.xAnnotationContent or null on error.
    static _annotation(range: Range, _baseuri: BaseUriX, callback: Fun10X<HTMLElementX> = null): void {
        function updatestyles(styles: Map<string, string>, options: _AnnotationOptions) {
            if (options.withBorder) {
                styles.set(PK.Border, DEF.themeBorder);
            }
            if (options.withCorners) {
                styles.set(PK.BorderRadius, DEF.themeBorderRadius);
            }
            if (options.withShadow) {
                styles.set(PK.BoxShadow, DEF.themeBoxShadow);
            }
            styles.set(PK.BackgroundColor, options.bgColor);
        }
        const buttonsize = cache$.ui$.buttonSize_();
        new _PromptAnnotationStyle(accessories$, buttonsize)
            .titleKey_(RS.PickStyle)
            .zindex_(DEF.zindexPrompt)
            .onOK_(options => {
                const text = range.collapsed ? XXX : "";
                const styles = map_<string, string>();
                updatestyles(styles, options);
                switch (options.style) {
                    case RS.widgetAnnotationStyleBasic:
                    case RS.widgetAnnotationStyleList:
                        this._annotationBasic(options.style, text, styles, range, callback);
                        break;
                    case RS.widgetAnnotationStyleImage:
                        this._annotationImage1(text, styles, range, callback);
                        break;
                }
            }).onCancel_(() => {
                callback?.(null);
            }).show_();
    }

    private static _annotationBasic(
        annotationstyle: stringX,
        text: string,
        styles: Map<string, string>,
        range: Range,
        callback: Fun10X<HTMLElementX>
    ): void {
        _WidgetTemplates._createAnnotation(
            range,
            RS.widgetAnnotationTitle,
            text,
            CSS.xAnnotationStyleText,
            styles,
            (content, annotation) => {
                const b = new DomBuilderEx(content);
                if (annotationstyle == RS.widgetAnnotationStyleList) {
                    b.empty_().ul1_(CSS.xNone).li1_(CSS.xList);
                    b.push_().span_({
                        "class": CSS.xBullet,
                        "style": `font-family:${DEF.FontAwesome}`,
                    }).text_("\uf0e5" + " ");
                    b.pop_().span1_(CSS.xListContent, CSS.xPlaceholder).text_(MSG.XXX$);
                } else {
                    b.addClass_(CSS.xPlaceholder);
                }
                _MainPanel._showAnnotation1(annotation);
                callback?.(content);
            });
    }

    static _destructAnnotation0(div: HTMLElement): HTMLElementX {
        const node = DomUt.asHTMLElement_(div.parentNode?.parentNode);
        if (node != null && native$.hasClass_(node, CSS.xAnnotation)) {
            _WidgetTemplates._destructAnnotation(node, true);
            return null;
        }
        return div;
    }

    /// @param callback(bool ok) ok is false on cancelled or error.
    static _annotationImage(range: Range, callback: Fun10X<boolean> = null): void {
        const styles = map_(
            [PK.Border, DEF.themeBorder],
            ["padding", "10px"],
        );
        this._annotationImage1(MSG.XXX$, styles, range, (content) => {
            callback?.(content != null);
        });
    }

    static _annotationImage1(
        text: string,
        styles: Map<string, string>,
        range: Range,
        callback: Fun10X<HTMLElementX> = null
    ): void {
        const baseuri = native$.getIFrameUri_();
        if (baseuri == null) {
            callback?.(null);
            return;
        }
        _Util.promptInsertImg1_(
            RS.InsertImageTitle,
            `class ${CSS.xImageholder} ${CSS.xImageDef}`,
            baseuri,
            Callbacks.onReadImageFolderButton_,
            result => {
                if (result == null) {
                    callback?.(null);
                    return;
                }
                _WidgetTemplates._createAnnotation(
                    range,
                    RS.widgetAnnotationImageTitle,
                    text,
                    CSS.xAnnotationStyleImage,
                    styles,
                    (content, annotation) => {
                        const path = An.cpathOfUri_(result.src);
                        if (content == null || path == null) {
                            callback?.(null);
                            return;
                        }
                        const r = native$.iSelectNode_(content.firstChild);
                        if (r != null) {
                            const img = _MainPanel._createimg(r, result.caption, result);
                            //// NOTE: This eliminate a gap at bottom of the IMG in case there is a border.
                            native$.replaceStyle_(img, "float", "left");
                        }
                        _MainPanel._showAnnotation1(annotation);
                        callback?.(content);
                    });
            }).onCancel_(() => {
                callback?.(null);
            }).showCaption_(false)
            .show_();
    }

    /**
         * @param callback(JsObject content) The div.xAnnotationContent element, null on cancelled or error.
         * NOTE that callback if given must be called outside of history group even if no cancel or error,
         * so that async iterator can proceed.
         */
    static _createAnnotation(
        range: Range,
        titlekey: StringId,
        text: stringX,
        classes: string,
        styles: Map<string, string>,
        callback: Fun20X<HTMLElement, HTMLElement>
    ): void {
        const [content, xannotation] = history$.group_(titlekey, "", () => {
            if (text != null && text.length > 0) {
                RangeUtil.replaceRange_(range, DomBuilderEx.createText_(text));
            }
            //// NOTE: Wrap the text in a span as sibling to x-smokescreen to avoid browser flashing the
            //// x-smokescreen on click.
            //// NOTE: Always wrap selection with span.xAnnotationTarget which is unwrapped on destruction.
            const span = RangeUtil.wrapRange_("span", {
                "class": CSS.xAnnotationTarget,
            }, range);
            const xannotation = JsUtil.wrapNode_(span, "div", {
                "class": CSS.xAnnotation,
            });
            const b = new DomBuilderEx(xannotation);
            b.div1_(CSS.xSmokescreen);
            const content = b.div_({
                "class": `${CSS.xAnnotationContent} ${classes}`,
                "style": CSSUtil.joinStyles_(styles),
            }).cursor_();
            b.text_(MSG.string_(RS.widgetSampleAnnotation));
            return [content, xannotation];
        });
        callback?.(content, xannotation);
    }

    static _destructAnnotation(xannotation: HTMLElement, force: boolean = false): void {
        for (const child of JsUtil.childElements_(xannotation)) {
            if ("DIV" == child.nodeName && native$.hasClass_(child, CSS.xSmokescreen)) {
                for (const content of JsUtil.childElements_(child)) {
                    if ("DIV" == content.nodeName && native$.hasClass_(content, CSS.xAnnotationContent)) {
                        if (force) {
                            _WidgetTemplates._destructAnnotation1(xannotation, child as HTMLElement);
                        } else {
                            _Util.confirmSmall_(
                                MSG.formatArray1_(RS.destructWidgetAndContent, MSG.string_(RS.widgetAnnotationTitle)),
                                DEF.zindexConfirm, (yes: boolean) => {
                                    if (!yes) return;
                                    _WidgetTemplates._destructAnnotation1(xannotation, child as HTMLElement);
                                });
                        }
                        return;
                    }
                }
            }
        }
        _WidgetTemplates._destructAnnotation1(xannotation, null);
    }

    static _destructAnnotation1(div: HTMLElement, sm: HTMLElementX) {
        history$.group_(RS.action_DestructAnnotation, "", () => {
            try {
                for (const child of JsUtil.childElements_(div)) {
                    if (native$.hasClass_(child, CSS.xAnnotationTarget)) {
                        new DomBuilderEx(child as HTMLElement).up_().unwrap_(child);
                        break;
                    }
                }
                const b = new DomBuilderEx(div);
                if (sm != null) {
                    b.removeChild_(sm);
                }
                b.up_().unwrap_(div);
            } catch (e) {
                
                toasters$.warnKey_(RS.ERROR);
                return;
            }
        });
    }

    static _sidepanel(baseuri: BaseUriX): void {
        const body = native$.getIFrameBody_();
        if (body == null) return;
        const leftexists = native$.iGetElementById_(ID.xLeftSidepanel) != null;
        const rightexists = native$.iGetElementById_(ID.xRightSidepanel) != null;
        if (leftexists && rightexists) {
            toasters$.warnKey_(RS.LeftAndRightSidepanelAlreadyExistsAbort);
            return;
        }
        const left = MSG.string_(RS.Left);
        const right = MSG.string_(RS.Right);
        const fontsize = `${cache$.ui$.toolbarFontSize_()}px`;
        const defbgcolor = _WidgetTemplates._colorGreen;
        const options = sarray_();
        if (!rightexists) { options.push(right); }
        if (!leftexists) { options.push(left); }
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld(
                "",
                "#side",
                (rightexists ? left : right),
                RS.LeftOrRight,
                options,
            ),
            new InputSelectField(
                "",
                "width",
                `${DEF.xSidepanelWidth}`,
                RS.Width,
                CSSLength.VW,
                CSSLengths
            ),
            new ColorField(
                "",
                PK.BackgroundColor,
                defbgcolor,
                cache$.ui$.buttonSize_(),
                RS.BGColor,
            ),
        ]);
        d.titleKey_(RS.widgetSidepanelTitle);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            const styles = d.getChanged_(new Map<string, string>());
            Sanitizers.onValidateStyles_(styles, baseuri, ret => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                const errors = sarray_();
                Sanitizers.onValidateNonEmptyValues_(errors, map1_("width", MSG.string_(RS.Width)), d, [
                    "width",
                ]);
                if (errors.length > 0) {
                    d.warn_(errors);
                    okcallback(false);
                    return;
                }
                const side = d.getValueAt_(0);
                okcallback(true);
                const sanitized = ret[Key.result] as SStringMap;
                const width = sanitized["width"];
                const bgcolor = sanitized[PK.BackgroundColor];
                const opaque = ColorUtil.getColorValue_(bgcolor, 1.0) ?? ColorValue.X_GREY;
                const c = ColorUtil.getAlphaColor_(opaque, 0.5);
                const color = c.toCSSString_();
                history$.group_(RS.widgetSidepanelTitle, "", () => {
                    const b = new DomBuilderEx(body);
                    if (side == "Left") {
                        _WidgetTemplates._createSidebarTab(
                            body,
                            ID.xOpenLeftSidepanel,
                            ["fa", "fa-toggle-down",],
                            color,
                            fontsize);
                        b.div_({
                            "id": ID.xLeftSidepanel,
                            "class": CSS.xSmokescreen,
                        }).div_({
                            "class": CSS.xLeftSidepanel,
                            "style": `background-color:${bgcolor}; width:${width};`,
                        }).cursor_();
                        b.div_().text_(MSG.string_(RS.widgetSidepanelSample));
                    } else {
                        _WidgetTemplates._createSidebarTab(
                            body,
                            ID.xOpenRightSidepanel,
                            ["fa", "fa-toggle-up",],
                            color,
                            fontsize);
                        b.div_({
                            "class": CSS.xSmokescreen,
                            "id": ID.xRightSidepanel,
                        }).div_({
                            "class": CSS.xRightSidepanel,
                            "style": `background-color:${bgcolor}; width:${width}; left:calc(100vw - ${width});`,
                        }).cursor_();
                        b.div_().text_(MSG.string_(RS.widgetSidepanelSample));
                    }
                });
            });
        });
        d.show_();
    }

    static _destructSidepanel(node: HTMLElement): void {
        _Util.confirmSmall_(
            MSG.formatArray1_(RS.destructWidgetAndContent, MSG.string_(RS.widgetSidepanelTitle)),
            DEF.zindexConfirm, yes => {
                if (!yes) return;
                history$.group_(RS.action_DestructSidepanel, "", () => {
                    const id = node.id;
                    let tab: HTMLElementX = null;
                    switch (id) {
                        case ID.xRightSidepanel:
                            tab = native$.iGetElementById_(ID.xOpenRightSidepanel);
                            break;
                        case ID.xLeftSidepanel:
                            tab = native$.iGetElementById_(ID.xOpenLeftSidepanel);
                            break;
                        default:
                            toasters$.warnKey_(RS.WidgetNotFound);
                            return;
                    }
                    JsUtil.remove_(node);
                    if (tab != null) {
                        JsUtil.remove_(tab);
                    }
                });
            });
    }

    static _sidebarTab(baseuri: BaseUri): void {
        _Util.promptValues_(RS.widgetSidebarTabTitle, [
            new UriField(
                "",
                "",
                HumanLink.Empty$,
                RS.URL,
                baseuri,
                [BUT.PathKind, BUT.Folder],
                Callbacks.onLinkFolderButton_,
            ),
            new InputField(
                "",
                "",
                "",
                RS.PlaceholderRequiredText,
            ),
            new ColorField(
                "",
                "",
                _WidgetTemplates._sidebarPalette0,
                cache$.ui$.buttonSize_(),
                RS.BGColor,
            ),
        ]).zindex_(DEF.zindexPrompt).onOK_((d, okcallback) => {
            const errors = sarray_();
            const text = d.getValueAt_(1);
            if (text.length == 0) errors.push(MSG.string1_(RS.inputMustNotBeEmpty_, MSG.string_(RS.Text)));
            const bgcolor = d.getValueAt_(2);
            const c = ColorUtil.getColorValue_(bgcolor);
            if (c == null) errors.push(MSG.string_(RS.InvalidColor_) + bgcolor);
            const url = d.getValueAt_(0);
            const uri = Sanitizers.checkOptionalHref_(url, baseuri).onFail_(msgs => {
                errors.push(...msgs);
            })?.result_();
            if (errors.length > 0 || c == null) {
                d.warn_(errors);
                okcallback(false);
                return;
            }
            okcallback(true);
            _WidgetTemplates._sidebarTab1(c, text, uri?.toString() ?? null);
        }).show_();
    }

    static _sidebarTab1(c: ColorValue, text: string, url: stringX): void {
        const body = native$.getIFrameBody_();
        if (body == null) return;
        const bgcolor = c.toCSSString_();
        history$.group_(RS.widgetSidebarTabTitle, text, () => {
            _WidgetTemplates._createSidebarTab(body, null, null, bgcolor, null, url).text_(text);
        });
    }

    /**
         * @param href An absolute context path or an iframe relative path.
         * @return JsDomBuilder with cursor at the tab element.
         */
    static _createSidebarTab(
        body: HTMLElement,
        id: stringX,
        classes: ArrayX<string>,
        bgcolor: string,
        fontsize: stringX,
        href: stringX = null
    ): DomBuilderEx {
        let sidebar = native$.iGetElementById_(ID.xRightSidebar);
        let b: DomBuilderEx;
        if (sidebar == null) {
            b = new DomBuilderEx(body);
            sidebar = b.div_({
                "id": ID.xRightSidebar,
            }).cursor_();
            b.div1_(CSS.xRightSidebarContent);
            b.div1_(CSS.xRightSidebarPadding);
        } else {
            const child = sidebar.firstElementChild;
            if (child == null || child.lastElementChild == null) {
                toasters$.warnKey_(RS.InvalidSidebarStructure);
                //// Create a new structure, instead of abort.
                b = new DomBuilderEx(sidebar);
                b.div1_(CSS.xRightSidebarContent);
                b.div1_(CSS.xRightSidebarPadding);
            } else {
                b = new DomBuilderEx(child.lastElementChild as HTMLElement);
            }
        }
        if (href != null && href.length > 0) {
            b.siblingBefore_("a", {
                "class": CSS.xRightSidebarTab,
                "href": href ?? "",
            });
        } else {
            b.siblingBefore_("div", {
                "class": CSS.xRightSidebarTab,
            });
        }
        if (id != null) {
            b.attr_("id", id);
        }
        if (classes != null) {
            b.addClasses_(classes);
        }
        const styles = ssmap_();
        if (bgcolor != null) {
            styles[PK.BackgroundColor] = bgcolor;
        }
        if (fontsize != null) {
            styles["font-size"] = fontsize;
        }
        b.addStyles_(styles);
        return b;
    }

    static _destructSidebarTab(node: HTMLElement): void {
        _Util.confirmSmall_(
            MSG.format1_(RS.destructWidget, MSG.string_(RS.widgetSidebarTabTitle)),
            DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                history$.group_(RS.action_DestructSidebarTab, "", () => {
                    let sidepanel: HTMLElementX = null;
                    const id = node.getAttribute("id");
                    if (ID.xOpenLeftSidepanel == id) {
                        sidepanel = native$.iGetElementById_(ID.xLeftSidepanel);
                    } else if (ID.xOpenRightSidepanel == id) {
                        sidepanel = native$.iGetElementById_(ID.xRightSidepanel);
                    }
                    if (sidepanel != null) {
                        JsUtil.remove_(sidepanel);
                    }
                    JsUtil.remove_(node);
                });
            });
    }

    static _slideshow(range: Range, baseuri: BaseUriX): void {
        const selection = native$.getSelectedNodesOfRange_(range);
        if (selection == null) {
            toasters$.warnKey_(RS.widgetSlideshowInvalidSelection);
            return;
        }
        let iwidth = 0;
        let iheight = 0;
        const images = new Array<HTMLImageElement>();
        for (const node of selection) {
            switch (node.nodeType) {
                case Node.ELEMENT_NODE: {
                    if (node.nodeName != "IMG") {
                        JsUtil.hide_(node as HTMLElement);
                        continue;
                    }
                    const elm = node as HTMLImageElement;
                    images.push(elm);
                    const w = elm.naturalWidth;
                    const h = elm.naturalHeight;
                    if (w != null && w > iwidth) {
                        iwidth = w;
                    }
                    if (h != null && h > iheight) {
                        iheight = h;
                    }
                    break;
                }
                case Node.TEXT_NODE:
                    if (!JsUtil.isWhitespaceNode_(node)) {
                        toasters$.warnKey_(RS.widgetSlideshowInvalidSelection);
                    }
                    break;
                case Node.COMMENT_NODE:
                    break;
                default:
                    toasters$.warnKey_(RS.widgetSlideshowInvalidSelection);
            }
        }
        if (images.length == 0) {
            toasters$.okKey_(RS.widgetSlideshowNoImageFound, { attop: true });
            return;
        }
        const w = iwidth > 0 ? iwidth : window.innerWidth / 2;
        const h = iheight > 0 ? iheight : window.innerHeight / 2;
        const defduration = 5;
        const XDURATION = "#XYP";
        const XCAPTION = "#X11";
        const d = new CompositeDialog(accessories$, [
            new InputSelectField(
                RS.Width,
                "width",
                `${w}`,
                RS.PlaceholderRequiredWidth,
                CSSLength.PX,
                CSSLengths,
            ),
            new InputSelectField(
                RS.Height,
                "height",
                `${h}`,
                RS.PlaceholderRequiredHeight,
                CSSLength.PX,
                CSSLengths
            ),
            new InputSelectField(
                RS.Duration,
                XDURATION,
                `${defduration}`,
                RS.PlaceholderRequiredDuration,
                MSG.string_(RS.sec),
                [
                    MSG.string_(RS.ms),
                    MSG.string_(RS.sec),
                    MSG.string_(RS.min),
                    MSG.string_(RS.hour),
                ]
            ),
            new InputField(
                RS.Caption,
                XCAPTION,
                "",
                RS.Caption
            ),
        ]);
        d.titleKey_(RS.widgetSlideshowTitle);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            const styles = map_(
                ["width", d.getValue_("width")],
                [PK.Height, d.getValue_(PK.Height)],
            );
            Sanitizers.onValidateStyles_(styles, baseuri, ret => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                const errors = sarray_();
                Sanitizers.onValidateNonEmptyValues_(errors, map_(
                    ["width", MSG.string_(RS.Width)],
                    [PK.Height, MSG.string_(RS.Height)],
                    [XDURATION, MSG.string_(RS.Duration)],
                ), d, ["width", "height", XDURATION]);
                if (errors.length > 0) {
                    d.warn_(errors);
                    okcallback(false);
                    return;
                }
                const caption = d.getValue_(XCAPTION);
                const duration = d.getValue_(XDURATION);
                okcallback(true);
                const sanitized = ret[Key.result] as JSONObject;
                const width = sanitized["width"];
                const height = sanitized["height"];
                const ms = An.msFromStringTimeUnit_(duration, defduration * 1000);
                history$.group_(RS.widgetSlideshowTitle, "", () => {
                    const hascaption = (caption != null && caption.length > 0);
                    if (hascaption) {
                        const div = RangeUtil.wrapRange_("div", {
                            "class": CSS.xSlideshowContent,
                            "style": `flex: 0 0 auto;width:${width};height:${height};animation-duration:${ms}ms;`,
                        }, range);
                        new DomBuilderEx(div)
                            .append_("div", {
                                "class": CSS.xSlideshowPlay,
                            })
                            .up_()
                            .childBefore_(div, "div", {
                                "class": CSS.xSlideshow
                            })
                            .appendNodes_(div)
                            .div_({
                                "style": `flex: 0 0 auto;box-sizing:border-box;width:${width};padding:5px 0;`,
                            })
                            .text_(caption);
                    } else {
                        const div = RangeUtil.wrapRange_("div", {
                            "class": CSS.xSlideshowContent,
                            "style": `flex: 0 0 auto;width:${width};height:${height};animation-duration:${ms}ms;`,
                        }, range);
                        JsUtil.wrapNode_(div, "div", {
                            "class": CSS.xSlideshow
                        });
                        new DomBuilderEx(div).append_("div", {
                            "class": CSS.xSlideshowPlay,
                        });
                    }
                    const add = [CSS.xSlideshowImage];
                    for (let i = 0; i < images.length; ++i) {
                        const img = images[i];
                        native$.removeAddClasses_(img, null, add);
                        const styleattr = img.getAttribute("style");
                        JsUtil.setAttribute0_(img, ATTR.AnSaved, styleattr);
                        const style = img.style;
                        if (i == 0) {
                            style.display = "inline";
                            style.opacity = "0.5";
                        }
                        style.width = width;
                        style.height = height;
                    }
                });
            });
        });
        d.show_();
    }

    static _destructSlideshow(node: HTMLElement): void {
        _Util.confirmSmall_(
            MSG.format1_(RS.destructWidget, MSG.string_(RS.widgetSlideshowTitle)),
            DEF.zindexConfirm, yes => {
                if (!yes) return;
                history$.group_(RS.action_DestructSlideshow, "", () => {
                    const content = JsUtil.childElementWithClass_(node, CSS.xSlideshowContent);
                    if (content == null) {
                        toasters$.warnKey_(RS.InvalidWidgetStructureForUndo);
                        return;
                    }
                    for (let c = node.firstChild, n = null; c != null; c = n) {
                        n = c.nextSibling;
                        if (native$.hasClass_(c, CSS.xSlideshowContent)) {
                            _WidgetTemplates._undoSlideshow1(content);
                            new DomBuilderEx(c as HTMLElement).up_().unwrap_(c);
                        } else {
                            node.removeChild(c);
                        }
                    }
                    new DomBuilderEx(node).up_().unwrap_(node);
                });
            });
    }

    static _undoSlideshow1(node: HTMLElement): void {
        for (let c = node.firstChild, n = null; c != null; c = n) {
            n = c.nextSibling;
            if (c.nodeType != Node.ELEMENT_NODE) {
                continue;
            }
            const nodename = c.nodeName;
            switch (nodename) {
                case "IMG": {
                    const elm = c as HTMLElement;
                    elm.classList.remove(CSS.xSlideshowImage);
                    const o = elm.getAttribute(ATTR.AnSaved);
                    elm.removeAttribute(ATTR.AnSaved);
                    JsUtil.setAttribute0_(elm, "style", o);
                    break;
                }
                case "DIV":
                    node.removeChild(c);
                    break;
            }
        }
    }

    static _pictureframe(range: RangeX, baseuri: BaseUriX): void {
        if (toasters$.warn_(JsUtil.actionWrapOK_(range)) || range == null /* dummy check */) {
            return;
        }
        const XKIND = "#XbV";
        const XSCROLLABLE = "#Xty";
        const XCAPTION = "#X9U";
        const XROTATION = "#XFO";
        const buttonsize = cache$.ui$.buttonSize_();
        const defkind = MSG.string_(RS.Static);
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld(
                RS.Positioning,
                XKIND,
                defkind,
                RS.Positioning,
                [MSG.string_(RS.Static), MSG.string_(RS.FloatLeft), MSG.string_(RS.FloatRight)],
            ),
            new SelectFIeld(
                RS.Clear,
                "clear",
                MSG.string_(RS.None),
                RS.Clear,
                [
                    MSG.string_(RS.None),
                    MSG.string_(RS.Left),
                    MSG.string_(RS.Right),
                    MSG.string_(RS.Both),
                ]
            ),
            new SelectFIeld(
                RS.Scrollable,
                XSCROLLABLE,
                MSG.string_(RS.True),
                RS.Scrollable,
                [MSG.string_(RS.True), MSG.string_(RS.False)],
            ),
            new InputSelectField(
                RS.Width,
                "width",
                "",
                RS.Width,
                CSSLength.PX,
                CSSLengths,
            ),
            new InputSelectField(
                RS.Height,
                "height",
                "",
                RS.Height,
                CSSLength.PX,
                CSSLengths
            ),
            new InputSelectField(
                RS.Padding,
                "padding",
                "10",
                RS.Padding,
                CSSLength.PX,
                CSSLengths
            ),
            new InputField(
                RS.Border,
                PK.Border,
                DEF.themeBorder,
                RS.Border,
            ),
            new InputSelectField(
                RS.Margin,
                "margin",
                "10",
                RS.Margin,
                CSSLength.PX,
                CSSLengths
            ),
            new ColorField(
                RS.BGColor,
                PK.BackgroundColor,
                "",
                buttonsize,
                RS.BGColor,
            ),
            new InputField(
                RS.Caption,
                XCAPTION,
                "",
                RS.Caption,
            ),
        ]);
        d.titleKey_(RS.widgetPictureFrameTitle);
        d.zindex_(DEF.zindexPrompt);
        d.setVisible_("clear", false);
        d.onChange_((field, input) => {
            if (field.spec$.key$ == XKIND) {
                const kind = (input as SelectOptions).getValue_(defkind);
                d.setVisible_("clear", (kind == MSG.string_(RS.FloatLeft) || kind == MSG.string_(RS.FloatRight)));
            }
        });
        d.onOK_((d, okcallback) => {
            Sanitizers.onValidateStyles_(d.getChanged_(new Map<string, string>()), baseuri, ret => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                const sanitized = ret[Key.result] as JSONObject;
                const kind = d.getValue_(XKIND);
                const clear = sanitized["clear"];
                sanitized["clear"] = undefined;
                const rotation = _Util.getRotation_(d.getValue_(XROTATION), 0);
                const scrollable = d.getValue_(XSCROLLABLE) == "True";
                const caption = d.getValue_(XCAPTION);
                okcallback(true);
                const hascaption = (caption != null && caption.trim().length > 0);
                const overflow = (scrollable ? "auto" : "hidden");
                sanitized["transform"] = "";
                sanitized["display"] = "inline-block";
                const iscollapsed = range.collapsed;
                history$.group_(RS.widgetPictureFrameTitle, "", () => {
                    let node: HTMLElement;
                    if (rotation == 0) {
                        sanitized["overflow"] = overflow;
                        if (hascaption) {
                            sanitized["flex"] = "0 0 auto";
                        }
                        sanitized["box-sizing"] = "content-box";
                        const style = CSSUtil.joinStyles1_(Object.entries(sanitized));
                        node = RangeUtil.wrapRange_("div", {
                            "style": style,
                        }, range) as HTMLElement;
                        if (iscollapsed) {
                            new DomBuilderEx(node).addClass_(CSS.xPlaceholder).text_(MSG.XXX$);
                        }
                    } else {
                        const styles = map_(
                            ["box-sizing", "border-box"],
                            ["width", sanitized["width"]],
                            ["height", sanitized["height"]],
                            ["overflow", overflow],
                        );
                        if (hascaption) {
                            styles.set("flex", "0 0 auto");
                        }
                        node = RangeUtil.wrapRange_("div", {
                            "style": CSSUtil.joinStyles_(styles),
                        }, range) as HTMLElement;
                        if (iscollapsed) {
                            new DomBuilderEx(node).addClass_(CSS.xPlaceholder).text_(MSG.XXX$);
                        }
                        const nodestyle = node.style;
                        const cstyle = native$.getComputedStylesOf_(node, null, [
                            "width",
                            "height",
                        ]);
                        const h = cstyle.get("height")!;
                        const w = cstyle.get("width")!;
                        switch (rotation) {
                            case 0:
                                nodestyle.transform = "";
                                nodestyle.transformOrigin = "";
                                break;
                            case 90:
                                //// Need to specify a width to get the correct height after transform.
                                nodestyle.width = w;
                                nodestyle.height = h;
                                nodestyle.transform = `translateX(${h}) rotate(${rotation}deg)`;
                                nodestyle.transformOrigin = "0 0";
                                break;
                            case 180:
                                nodestyle.transform = `rotate(${rotation}deg)`;
                                nodestyle.transformOrigin = "50% 50%";
                                break;
                            case 270:
                                //// Need to specify a width to get the correct height after transform.
                                nodestyle.width = w;
                                nodestyle.height = h;
                                nodestyle.transform = `translateY(${w}) rotate(${rotation}deg)`;
                                nodestyle.transformOrigin = "0 0";
                                break;
                        }
                        const m = map_(
                            ["display", "inline-block"],
                            ["box-sizing", "content-box"],
                            ["margin", sanitized["margin"]],
                            [PK.Border, sanitized[PK.Border]],
                            ["padding", sanitized["padding"]],
                            [PK.BackgroundColor, sanitized[PK.BackgroundColor]],
                        );
                        An.removeEmptyValues_(m);
                        const parent = new DomBuilderEx(node).wrap_("div", {
                            "class": `${CSS.xRotate} ${CSS.xPictureframeRotated}`,
                            "style": CSSUtil.joinStyles_(m),
                        }).cursor_();
                        if (rotation == 90 || rotation == 270) {
                            const parentstyle = parent.style;
                            parentstyle.width = `${h}`;
                            parentstyle.height = `${w}`;
                        } else {
                            const parentstyle = parent.style;
                            parentstyle.width = `${w}`;
                            parentstyle.height = `${h}`;
                        }
                        node = parent;
                    }
                    if (hascaption) {
                        if (kind == MSG.string_(RS.FloatRight)) {
                            native$.replaceStyle_(node, "align-self", "flex-end");
                        }
                        node = _WidgetTemplates._wrapWithCaption1(node, caption) as HTMLElement;
                    } else if (rotation == 0) {
                        /// NOTE Wrap an extra div to make it easier to find content on destruction.
                        node = JsUtil.wrapNode_(node, "div");
                    }
                    if (kind == MSG.string_(RS.FloatLeft)) {
                        native$.setStyles_(node, map_(
                            ["float", "left"],
                            ["clear", clear],
                        ));
                    } else if (kind == MSG.string_(RS.FloatRight)) {
                        native$.setStyles_(node, map_(
                            ["float", "right"],
                            ["clear", clear],
                        ));
                    }
                    node?.classList.add(CSS.xPictureframe);
                });
            });
        });
        d.show_();
    }

    static _destructPictureFrame(node: HTMLElement): void {
        const children = node.children;
        const len = children.length;
        switch (len) {
            case 1:
                _WidgetTemplates._destructPictureFrame1(node, children[0] as HTMLElement);
                return;
            case 2:
                const c1 = children[0];
                if (native$.hasClass_(c1, CSS.xPictureframeRotated)) {
                    const gc = c1.children;
                    if (gc.length == 1) {
                        _WidgetTemplates._destructPictureFrame1(node, gc[0] as HTMLElement);
                        return;
                    }
                } else {
                    _WidgetTemplates._destructPictureFrame1(node, c1 as HTMLElement);
                    return;
                }
                break;
            default:
        }
        toasters$.warnKey_(RS.InvalidWidgetStructureForUndo);
    }

    static _destructPictureFrame1(node: HTMLElement, content: HTMLElement): void {
        _Util.confirmSmall_(
            MSG.format1_(RS.destructWidget, MSG.string_(RS.widgetPictureFrameTitle)),
            DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                history$.group_(RS.action_DestructPictureFrame, "", () => {
                    new DomBuilderEx(node).up_().moveChildrenBefore_(node, content.firstChild, null).removeChild_(node);
                });
            });
    }

    static _sticker(baseuri: BaseUriX): void {
        const range = native$.getValidIFrameSelectionRange_();
        if (range == null) {
            toasters$.warnKey_(RS.ActionRequireAValidSelection);
            return;
        }
        const d = new _PromptStickerStyle(accessories$, cache$.ui$.buttonSize_());
        d.titleKey_(RS.PickStyle);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((options: _StickerOptions) => {
            _WidgetTemplates._sticker1(range, baseuri, options);
        });
        d.show_();
    }

    static _sticker1(range: Range, baseuri: BaseUriX, options: _StickerOptions): void {
        const body = native$.getIFrameBody_();
        if (body == null) return;
        const stickondocument = MSG.string_(RS.StickOnDocument);
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld(
                "",
                "",
                stickondocument,
                RS.Positioning,
                [stickondocument, MSG.string_(RS.StickOnScreen)],
            ),
            new InputSelectField(
                "",
                "width",
                "16",
                RS.PlaceholderRequiredWidth,
                CSSLength.REM,
                CSSLengths,
            ),
        ]);
        d.titleKey_(RS.widgetStickerTitle);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            Sanitizers.onValidateStyles_(d.getChanged_(), baseuri, ret => {
                if (d.warn_(ret)) {
                    okcallback(false);
                    return;
                }
                const errors = sarray_();
                Sanitizers.onValidateNonEmptyValues_(errors, map1_(
                    "width", MSG.string_(RS.Width),
                ), d, ["width"]);
                if (errors.length > 0) {
                    d.warn_(errors);
                    okcallback(false);
                    return;
                }
                const kind = d.getValueAt_(0);
                okcallback(true);
                const sanitized = ret[Key.result] as JSONObject;
                An.removeEmptyValues1_(sanitized);
                history$.group_(RS.widgetStickerTitle, "", () => {
                    sanitized["box-sizing"] = "border-box";
                    let x = 40;
                    let y = 40;
                    let start: NodeX = RangeUtil.rangeStart_(range);
                    if (start == null) {
                        start = range.startContainer;
                    }
                    while (start != null && start.nodeType != Node.ELEMENT_NODE) {
                        start = start.parentNode;
                    }
                    const elm = (start == null ? null : start as HTMLElement);
                    if (kind == stickondocument) {
                        if (elm != null) {
                            x = elm.offsetLeft;
                            y = elm.offsetTop;
                        }
                    } else {
                        if (elm != null) {
                            const bounds = native$.getBoundingClientRect_(elm);
                            if (bounds != null) {
                                x = Math.round(bounds.left);
                                y = Math.round(bounds.top);
                            }
                        }
                    }
                    sanitized["left"] = `${x}px`;
                    sanitized["top"] = `${y}px`;
                    const node = _WidgetTemplates._sticker2(options, body, sanitized);
                    if (kind == stickondocument) {
                        if (range.collapsed) {
                            RangeUtil.insertNode_(range, node);
                        } else {
                            let end = null;
                            let c: NodeX = range.endContainer;
                            if (c.nodeType == Node.ELEMENT_NODE) {
                                end = c.childNodes[range.endOffset];
                            } else {
                                end = c.nextSibling;
                                c = c.parentNode;
                            }
                            c?.insertBefore(node, end);
                        }
                        native$.removeAddClasses_(node, null, [CSS.xSticker, CSS.xStickOnDocument, CSS.xDraggable, CSS.xZTop]);
                    } else {
                        new DomBuilderEx(body).appendNodes_(node);
                        native$.removeAddClasses_(node, null, [CSS.xSticker, CSS.xStickOnScreen, CSS.xDraggable, CSS.xZTop]);
                    }
                });
            });
        });
        switch (options.style) {
            case RS.widgetStickerStyleBadge:
                d.setValue_("width", "8rem");
                break;
            case RS.widgetStickerStyleCanvas:
                const dim = DialogUt.defaultCanvasDimension_(cache$.ui$.toolbarHeight_());
                const fit = MediaUtil.fit_(dim.x, dim.y, 180, 240);
                d.setValue_("width", `${fit.x}px`);
                break;
            default:
        }
        d.show_();
    }

    static _sticker2(options: _StickerOptions, body: HTMLElement, styles: SStringMap): HTMLElement {
        const _xxx = MSG.XXX$;
        if (options.withBorder) {
            styles[PK.Border] = DEF.themeBorder;
        }
        if (options.withShadow) {
            styles[PK.BoxShadow] = DEF.themeBoxShadow;
        }
        if (options.withCorners && options.style != RS.widgetStickerStyleBadge) {
            styles[PK.BorderRadius] = DEF.themeBorderRadius;
        }
        styles["padding"] = "1.5ex 1em";
        styles[PK.BackgroundColor] = options.bgcolor;
        let actioncallback: Fun10<DomBuilderEx>;
        let contentcallback: Fun10<DomBuilderEx>;
        switch (options.style) {
            case RS.widgetStickerStyleBadge:
                return _WidgetTemplates._createStickerBadge(options, body, styles);
            case RS.widgetStickerStyleImage: {
                actioncallback = (b: DomBuilderEx) => {
                    _WidgetTemplates._stickerActionsCallback(b, options.withHeader);
                };
                contentcallback = (b: DomBuilderEx) => {
                    b.push_().div_().ahref_(PATH._assetsImagesSamplesLamp + `?${Param.view}`)
                        .img_(PATH._assetsImagesSamplesLamp, {
                            "class": CSS.xImageholder,
                            "style": "max-width:100%;float:left;",
                        }).up_().div_({
                            "style": "clear:both;padding-top:1ex;",
                        }).text_(_xxx).pop_();
                };
                break;
            }
            case RS.widgetStickerStyleCanvas: {
                actioncallback = (b: DomBuilderEx) => {
                    _WidgetTemplates._stickerActionsCallback(b, options.withHeader);
                };
                contentcallback = (b: DomBuilderEx) => {
                    const dim = DialogUt.defaultCanvasDimension_(cache$.ui$.toolbarHeight_());
                    const w = styles["width"];
                    delete styles["width"];
                    const node = b.push_().div_().img_(
                        ["class", CSS.xCanvas],
                        ["style", `max-width:${w};`],
                        [ATTR.xAnnotation, `{${ScribblerHistory.WIDTH}:${dim.x},${ScribblerHistory.HEIGHT}:${dim.y}`]
                    ).cursor_();
                    b.pop_();
                    Timer.sleep0_(() => {
                        const pair = An.parseIntUnit_(w);
                        const tnwidth = (pair == null ? 180 : pair[0]);
                        const tnheight = MediaUtil
                            .optionalDimension0_(tnwidth, null, dim.x, dim.y)
                            .y;
                        
                        mainPanel$.actionAnnotateCanvas1_(
                            node,
                            dim.x,
                            dim.y,
                            tnwidth,
                            tnheight,
                            ColorValue.X_TRANSPARENT,
                            null,
                            () => { }
                        );
                    });
                };
                break;
            }
            default:
                actioncallback = (b: DomBuilderEx) => {
                    _WidgetTemplates._stickerActionsCallback(b, options.withHeader);
                };
                contentcallback = (b: DomBuilderEx) => {
                    b.push_()
                        .div1_(CSS.xPlaceholder)
                        .text_(_xxx)
                        .pop_();
                };
        }
        if (options.withHeader) {
            return _WidgetTemplates._createStickerWithSubject1(body, styles, actioncallback, contentcallback);
        }
        return _WidgetTemplates._createSticker1(body, styles, actioncallback, contentcallback);
    }

    static _createStickerBadge(options: _StickerOptions, body: HTMLElement, styles: SStringMap): HTMLElement {
        styles[PK.BorderRadius] = "50%";
        styles[PK.Height] = styles["width"];
        styles["align-items"] = "center";
        styles["justify-content"] = "center";
        styles["display"] = "flex";
        styles["flex-direction"] = "column";
        styles["text-align"] = "center";
        const style = CSSUtil.joinStyles1_(Object.entries(styles));
        const b = DomBuilderEx.offline_(body.ownerDocument, "div", { "style": style });
        b.push_().div_({
            "class": CSS.xShowInEdit,
            "style": "margin-bottom:0.5ex",
        }).span_(
            ["class", "fa fa-arrows"],
            [ATTR.xButton, ClientAction.move],
        );
        if (options.withHeader) {
            b.peek_().div1_(CSS.xSubject)
                .div1_(CSS.xPlaceholder)
                .text_(MSG.string_(RS.Subject));
        }
        b.peek_()
            .div_({
                "class": CSS.xContent,
                "style": (options.withHeader ? "flex:unset;" : "flex:unset;padding:0;"),
            })
            .div1_(CSS.xPlaceholder)
            .text_(MSG.XXX$);
        return b.pop_().cursor_();
    }

    static _stickerActionsCallback(b: DomBuilderEx, withheader: boolean): void {
        const move = smap_(
            ["class", `${CSS.xFloatRightClearNone} ${CSS.xShowInEdit} fa fa-arrows`],
            [ATTR.xButton, ClientAction.move],
        );
        if (!withheader) move["style"] = "padding-bottom:10px";
        const cycle = smap_(
            ["class", `${CSS.xFloatRightClearNone}  ${CSS.xShowInEdit} fa fa-retweet`],
            [ATTR.xButton, `${ClientAction.cycle}${CSS.xZTop} ${CSS.xZUpper} ${CSS.xZMiddle} ${CSS.xZLower} ${CSS.xZBottom}/${CSS.xSticker}`],
        );
        const hide = smap_(
            ["class", `${CSS.xFloatRightClearNone}  ${CSS.xShowInEdit} fa fa-eye-slash`],
            [ATTR.xButton, `${ClientAction.hide}${CSS.xSticker}`],
        );
        if (!withheader) hide["style"] = "padding-bottom:10px;";
        b.push_().span_(move);
        b.peek_().span_(cycle);
        b.peek_().span_(hide);
        b.pop_();
    }

    static _createSticker1(
        body: HTMLElement,
        styles: SStringMap,
        actioncallback: Fun10<DomBuilderEx>,
        contentcallback: Fun10<DomBuilderEx>
    ): HTMLElement {
        const style = CSSUtil.joinStyles1_(Object.entries(styles));
        const b = DomBuilderEx.offline_(body.ownerDocument, "div", { "style": style });
        actioncallback(b);
        contentcallback(b);
        return b.cursor_();
    }

    static _createStickerWithSubject1(
        body: HTMLElement,
        styles: SStringMap,
        actioncallback: Fun10<DomBuilderEx>,
        contentcallback: Fun10<DomBuilderEx>
    ): HTMLElement {
        styles["display"] = "flex";
        styles["flex-direction"] = "column";
        const style = CSSUtil.joinStyles1_(Object.entries(styles));
        const b = DomBuilderEx.offline_(body.ownerDocument, "div", { "style": style });
        return b.indent_(
            b.push_().div1_(CSS.xSubject).indent_(
                b.push_(),
                actioncallback(b),
                b.pop_().div1_(CSS.xPlaceholder)
                    .text_(MSG.string_(RS.Subject))
            ),
            b.peek_().div1_(CSS.xContent),
            contentcallback(b),
            b.pop_()
        ).cursor_();
    }

    static _wrapWithCaption1(div: HTMLElement, caption: string): HTMLElement {
        const cstyle = native$.getComputedStylesOf_(div, null, ["width", "margin-left", "margin-right", "margin-bottom"]);
        const b = new DomBuilderEx(div)
            .addStyles_({ "margin-bottom": null })
            .up_()
            .childBefore_(div, "div")
            .push_();
        const ret = b.cursor_();
        b
            .up_()
            .removeChild_(div)
            .pop_()
            .child_(div)
            .up_()
            .div_({
                "style": CSSUtil.joinStyles1_(Object.entries({
                    "flex": "0 0 auto",
                    "box-sizing": "border-box",
                    "margin-top": "5px",
                    "margin-left": `${cstyle.get("margin-left")}`,
                    "margin-right": `${cstyle.get("margin-right")}`,
                    "margin-bottom": `${cstyle.get("margin-bottom")}`,
                })),
            }).text_(caption);
        return ret;
    }

    static _destructSticker(node: Node): void {
        _WidgetTemplates._destructSticker1(node);
    }

    static _destructSticker1(node: Node): void {
        _Util.confirmSmall_(
            MSG.formatArray1_(RS.destructWidgetAndContent, MSG.string_(RS.widgetStickerTitle)),
            DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                history$.group_(RS.action_DestructSticker, "", () => {
                    JsUtil.remove_(node);
                });
            });
    }

    static _actionDestructWidget(): boolean {
        const node = native$.getSingleSelectedNode_();
        if (node == null || node.nodeType != Node.ELEMENT_NODE) {
            toasters$.warnKey_(RS.ActionRequireASingleElementSelection);
            return false;
        }
        const elm = node as HTMLElement;
        const nodename = elm.nodeName;
        const classes = elm.classList;
        if (classes.contains(CSS.xAccordionShow) || classes.contains(CSS.xAccordionHide)) {
            _WidgetTemplates._destructAccordion(elm);
            return true;
        }
        if (classes.contains(CSS.xAccordionContent)) {
            const parent = JsUtil.ancestorWithClasses_(elm, [CSS.xAccordionShow, CSS.xAccordionHide]);
            if (parent != null) {
                _WidgetTemplates._destructAccordion(parent);
                return true;
            }
        }
        if (classes.contains(CSS.xAnnotationTarget)) {
            const parent = elm.parentElement;
            if (parent != null) {
                _WidgetTemplates._destructAnnotation(parent);
            }
            return true;

        }
        if (classes.contains(CSS.xRightSidebarTab)) {
            _WidgetTemplates._destructSidebarTab(elm);
            return true;
        }
        if ("DIV" == nodename) {
            if (classes.contains(CSS.xAnnotation)) {
                _WidgetTemplates._destructAnnotation(elm);
                return true;
            }
            if (classes.contains(CSS.xFlexbox)) {
                _FlexboxWidget._destructFlexbox(elm);
                return true;
            }
            if (classes.contains(CSS.xPictureframe)) {
                _WidgetTemplates._destructPictureFrame(elm);
                return true;
            }
            if (classes.contains(CSS.xSticker)) {
                _WidgetTemplates._destructSticker(elm);
                return true;
            }
            if (classes.contains(CSS.xSlideshow)) {
                _WidgetTemplates._destructSlideshow(elm);
                return true;
            }
        }
        if (classes.contains(CSS.xSlideshowImage)) {
            for (let parent = elm.parentElement; parent != null; parent = parent.parentElement) {
                if (parent.nodeName == "DIV" && native$.hasClass_(parent, CSS.xSlideshow)) {
                    _WidgetTemplates._destructSlideshow(parent);
                    return true;
                }
            }
        }
        const id = elm.id;
        if (id == ID.xRightSidepanel || id == ID.xLeftSidepanel) {
            _WidgetTemplates._destructSidepanel(elm);
            return true;
        }
        toasters$.warnKey_(RS.WidgetNotFound);
        return false;
    }
}

////////////////////////////////////////////////////////////////////////

class _GlobalSearchPanel extends UIPanelBase {
    _container: HTMLElement;
    _content: HTMLElement;
    _filterbar: Toolbar;
    _searchbar: Toolbar;
    _filefilter: HTMLTextAreaElement;
    _searchbox: HTMLTextAreaElement;
    _shown: boolean = false;
    _searchText: stringX = null;

    constructor(container: HTMLElement) {
        super();
        this._container = container;
        this._searchbar = new Toolbar(this._container, [
            INPUT.searchbox(RS.Tooltips_SearchRegex, "1"),
            BUT.info_(BUT.IgnoreCase),
            BUT.info_(BUT.RegexSearch),
        ]);
        this._searchbar.onAction_(action => this._toolbarActions(action));
        this._searchbar.onTooltips_(toasters$.onTooltipsKey_);
        this._filterbar = new Toolbar(this._container, [
            INPUT.searchbox(RS.Tooltips_FilepathFilter, "2"),
            BUT.info_(BUT.IgnoreCaseFilter),
            BUT.info_(BUT.ClearSearchText),
        ]);
        this._filterbar.onAction_(action => this._toolbarActions(action));
        this._filterbar.onTooltips_(toasters$.onTooltipsKey_);
        this._searchbar.element_().style.borderBottomColor = "transparent";
        const b = new DomBuilderEx(this._container).div1_(CSS.AnViewport);
        this._content = b.div_().cursor_();
        this._filefilter = this._filterbar.querySelector_(Conf.input$) as AnInputElement;
        this._searchbox = this._searchbar.querySelector_(Conf.input$) as AnInputElement;
        An.onInputFocusSelect_(this._filefilter);
        An.onInputEnterKeyStop_(this._filefilter);
        An.onInputFocusSelect_(this._searchbox);
        An.onInputEnterKey_(this._searchbox, () => {
            this._toolbarActions(BUT.RegexSearch);
        });
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (this._shown) { return; }
        this._shown = true;
        
        if (this._searchbox.value.length == 0) {
            const range = native$.getIFrameSelectionRange_();
            if (range != null && !range.collapsed) {
                const value = this._getsimpletext(range).trim();
                this._searchbox.value = value;
                An.select_(this._searchbox);
            }
        }
        An.showVisible_(this._container);
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            
            An.hide_(this._container);
        }
    }

    private _getsimpletext(range: Range): string {
        const start = RangeUtil.rangeStart_(range);
        const end = RangeUtil.rangeEnd_(range);
        if (end != start) {
            return "";
        }
        const type = start.nodeType;
        if (type == Node.TEXT_NODE) {
            return (start.nodeValue ?? "").substring(range.startOffset, range.endOffset);
        } else if (type != Node.ELEMENT_NODE) {
            return "";
        }
        const children = start.childNodes;
        if (children != null && children.length == 1 && children[0].nodeType == Node.TEXT_NODE) {
            return children[0].nodeValue ?? "";
        }
        return "";
    }

    resizeContent_(containerheight: number): void {
        
        const h = containerheight - cache$.ui$.toolbarHeight_() * 2 - DEF.sidepanelMarginBottom /* margin-bottom */;
        this._content.style.height = `${h}px`;
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.RegexSearch:
                this._search(true);
                break;
            case BUT.IgnoreCase:
                _Util.toggleIgnorecase_(this._searchbar.button_(BUT.IgnoreCase));
                break;
            case BUT.IgnoreCaseFilter:
                _Util.toggleIgnorecase_(this._filterbar.button_(BUT.IgnoreCaseFilter));
                break;
            case BUT.ClearSearchText:
                this._filefilter.value = "";
                this._searchbox.value = "";
                new DomBuilderEx(this._content).empty_();
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _search(isregex: boolean): void {
        const timer = new StepTimer();
        timer.debug_("# _GlobalSearchPanel.search(): start");
        const searchtext = this._searchbox.value;
        if (searchtext.length == 0) {
            toasters$.infoKey_(RS.PleaseSpecifySearchText, { attop: true });
            new DomBuilderEx(this._content).empty_();
            return;
        }
        const filefilter = this._filefilter.value;
        const filterignorecase = An.isButtonOn_(this._filterbar.button_(BUT.IgnoreCaseFilter));
        const searchignorecase = An.isButtonOn_(this._searchbar.button_(BUT.IgnoreCase));
        host$.globalSearch_(filterignorecase, filefilter, searchignorecase, searchtext, isregex, ret => {
            const id = ret[Key.result];
            const cb = (result: JSONObject) => {
                if (toasters$.warn_(result)) {
                    return;
                }
                if (!this._shown) {
                    //// Abandon ongoing search if panel is hidden.
                    return;
                }
                if (result[Key.busy] != null) {
                    toasters$.infoKey_(RS.PleaseWaitWhileIndexerIsBusy, { attop: true });
                    Timer.sleep_(250, () => {
                        host$.globalSearchResult_(id, isregex, cb);
                    });
                    return;
                }
                toasters$.hideInfo_();
                this._refresh(timer, searchignorecase, searchtext, isregex, result);
            };
            host$.globalSearchResult_(id, isregex, cb);
        });
    }

    refresh(): void {
        
    }

    private _refresh(timer: StepTimer, ignorecase: boolean, searchtext: string, isregex: boolean, ret: JSONObject): void {
        timer.debug_("# _GlobalSearchPanel.refresh(): start");
        this._populate(ignorecase, searchtext, isregex, ret);
        timer.debug_("# _GlobalSearchPanel.refresh(): end");
    }

    private _populate(ignorecase: boolean, searchtext: string, isregex: boolean, ret: JSONObject): void {
        const builder = new DomBuilderEx(this._content).empty_();
        const result: JSONObject = ret[Key.result] ?? json_();
        const keys = Object.keys(result);
        if (keys.length == 0) {
            toasters$.infoKey_(RS.SearchResultIsEmpty, { attop: true });
            new DomBuilderEx(this._content).empty_();
            return;
        }
        const sorted = keys.sort().map<[string, Array<Int>]>(k => [k, result[k]]);
        const b = DomBuilderEx.offline1_(document, "div", CSS.AnViewportContent).push_();
        b.div1_(CSS.AnTextList, CSS.AnZebra).push_();
        b.div1_(CSS.AnSec).text_(`${MSG.string_(RS.Result)}: ${sorted.length}`);
        for (const [path, hits] of sorted) {
            b.peek_().div2_(ATTR.AnAction, path).span1_(CSS.AnLnk).text_(path);
            if (hits != null) {
                b.up_().text_("\u00a0:\u00a0").span1_(CSS.AnTag).text_(`${hits.length}`);
            }
        }
        const elm = b.pop_(2).cursor_();
        builder.appendNodes_(elm);
        An.onClickMatching_(elm, `div.${CSS.AnTextList} > div`, (target, e) => {
            An.stopevent_(e);
            const path = target.getAttribute(ATTR.AnAction);
            if (path == null) return;
            this._openfile1(path, ignorecase, searchtext, isregex);
        });
    }

    /// @param path A context relative file path, with leading /.
    private _openfile1(filepath: string, ignorecase: boolean, searchtext: string, isregex: boolean): void {
        sidePanel$.hideSidepanel_();
        _Util.onSaveOrDiscard_(() => {
            _Util.browseFile_(filepath, null, false, ignorecase, searchtext, isregex);
        });
    }
}

////////////////////////////////////////////////////////////////////////

class _UISettingsPanel extends UIPanelBase {

    static readonly _readonlyInputAttributes = smap_(
        ["class", CSS.AnPromptSelect],
        ["style", "flex-basis:100%;white-space:nowrap"],
    );
    _container: HTMLElement;
    _viewport: HTMLElement;
    _content: HTMLElement;

    _inputButtonSize!: SelectOptions;
    _inputFontCategory!: SelectOptions;
    _inputFontName!: SelectOptions;
    _inputFontStyle!: SelectOptions;
    _inputFontSize!: SelectOptions;
    _inputFixedName!: SelectOptions;
    _inputFixedStyle!: SelectOptions;
    _inputDateFormat!: SelectOptions;
    _inputTimeFormat!: SelectOptions;
    _inputTimeZone!: SelectOptions;
    _inputImportImageDimension!: SelectOptions;

    _inputDialogBGColor!: HTMLElement;
    _dialogBGColorSample!: HTMLElement;
    _inputHeadingColor!: HTMLElement;
    _headingColorSample!: HTMLElement;
    _inputLinkColor!: HTMLElement;
    _linkColorSample!: HTMLElement;
    _inputAnnotationColor!: HTMLElement;
    _annotationColorSample!: HTMLElement;
    _inputHighlightColor!: HTMLElement;
    _highlightColorSample!: HTMLElement;
    _toolbarSample!: HTMLElement;
    _fontSample!: HTMLElement;
    _fixedSample!: HTMLElement;
    _toolbarButtons = new Map<string, HTMLElement>();
    _shown: boolean = false;

    constructor(container: HTMLElement) {
        super();
        this._container = container;
        const tb = new Toolbar(this._container, BUT.infos_(
            BUT.ResetUISettings,
            BUT.Apply,
            BUT.Cancel,
        ));
        tb.onAction_(action => this._toolbarActions(action));
        tb.onTooltips_(toasters$.onTooltipsKey_);
        const b = new DomBuilderEx(this._container).div1_(CSS.AnContentViewport,);
        this._viewport = b.cursor_();
        this._content = b.div_().cursor_();
    }

    element_(): HTMLElement {
        return this._container;
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            
            if (this._toolbarSample == null) {
                this._create();
            } else {
                this._reset(settings$.current_());
            }
            An.showVisible_(this._container);
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            
            this._reset(settings$.current_());
            An.hide_(this._container);
        }
    }

    resizeContent_(containerheight: number): void {
        if (this._viewport != null) {
            const h = containerheight - cache$.ui$.toolbarHeight_() - DEF.sidepanelMarginBottom /* margin-bottom */;
            this._viewport.style.height = `${h}px`;
        }
    }

    contextActions(): void { }

    ////////////////////////////////////////////////////////////////////////

    private _buttonsample(sample: HTMLElement, buttonsize: number): void {
        const px = `${buttonsize}px`;
        const half = `${buttonsize / 2}px`;
        sample.style.height = px;
        for (const e of Array.from(DomUt.queryAll_(sample, `div.${CSS.AnButton}`))) {
            const style = e.style;
            style.flexBasis = px;
            style.lineHeight = px;
            style.minHeight = px;
            style.height = px;
            style.fontSize = half;
        }
    }

    private _setuifont(name: string, style: string, size: number): void {
        this._inputFontName.setValue_(name);
        const selectedstyle = DialogUt.populateFontStyle_(
            this._inputFontStyle,
            [],
            settings$.fontInfo_(name),
            style);
        if (size > DEF.maxFontSize) {
            size = DEF.maxFontSize;
        }
        this._inputFontSize.setValue_(size.toString());
        this._fontSample.style.fontFamily = FontUtil.fontFamilyOf_(name, selectedstyle);
        this._fontSample.style.fontSize = `${size}px`;
    }

    private _setfixedfont(name: string, style: string, size: number): void {
        this._inputFixedName.setValue_(name);
        const selectedstyle = DialogUt.populateFontStyle_(
            this._inputFixedStyle,
            [],
            settings$.fontInfo_(name),
            style);
        this._fixedSample.style.fontFamily = FontUtil.fontFamilyOf_(name, selectedstyle);
        this._fixedSample.style.fontSize = `${size}px`;
    }

    private _reset(d: UISettings): void {
        DialogUt.populateFontName_(this._inputFontName, [], settings$.fontFamilies_(), FontCategories.All, d.uiFontName$);
        this._inputButtonSize.setValue_(d.buttonSize$.toString());
        this._buttonsample(this._toolbarSample, d.buttonSize$);
        this._inputFontCategory.setValue_(FontCategories.All);
        this._setuifont(d.uiFontName$, d.uiFontStyle$, d.uiFontSize$);
        this._setfixedfont(d.fixedFontName$, d.fixedFontStyle$, d.uiFontSize$);
        this._inputDialogBGColor.textContent = ColorUtil.validateColor_(d.dialogBGColor$, "red");
        this._dialogBGColorSample.style.backgroundColor = d.dialogBGColor$;
        this._inputHeadingColor.textContent = ColorUtil.validateColor_(d.headingColor$, "red");
        this._headingColorSample.style.backgroundColor = d.headingColor$;
        this._inputLinkColor.textContent = ColorUtil.validateColor_(d.linkColor$, "red");
        this._linkColorSample.style.backgroundColor = d.linkColor$;
        this._inputAnnotationColor.textContent = ColorUtil.validateColor_(d.annotationColor$, "red");
        this._annotationColorSample.style.backgroundColor = d.annotationColor$;
        this._inputHighlightColor.textContent = ColorUtil.validateColor_(d.highlightColor$, "red");
        this._highlightColorSample.style.backgroundColor = d.highlightColor$;
        this._inputDateFormat.setValue_(d.dateFormat$);
        this._inputTimeFormat.setValue_(d.timeFormat$);
        this._inputTimeZone.setValue_(d.timeZone$);
        this._inputImportImageDimension.setValue_(`${d.imageDimension$}`);
    }

    private _create(): void {
        const timer = new StepTimer();
        timer.debug_("# UiSettingsPanel.create(): start");
        const settings = settings$;
        const current = settings.current_();
        const b = DomBuilderEx.offline_(this._content.ownerDocument, "div", {
            "class": CSS.AnPanel,
            "style": `padding: 10px; border-bottom: ${DEF.themeBorder}; `,
        }).push_();
        const top = b.cursor_();
        this._inputButtonSize = DialogUt.textSelect_(accessories$, b, MSG.string_(RS.ButtonSize), RS.ButtonSize);
        this._toolbarSample = b
            .peek_()
            .div1_(CSS.AnMarginV5)
            .div_({
                "class": CSS.AnToolbar,
                "style": `overflow:hidden;border:${DEF.themeBorder};border-radius: 3px;`
            })
            .push_()
            .cursor_();
        b.peek_().div1_(CSS.AnButton, CSS.Fa, CSS.FaEdit);
        b.peek_().div1_(CSS.AnButton, CSS.Fa, CSS.FaPlusCircle);
        b.peek_().div1_(CSS.AnButton, CSS.Fa, CSS.FaArrowCircleLeft);
        b.peek_().div1_(CSS.AnButton, CSS.Fa, CSS.FaHome);
        b.pop_();
        this._inputFontCategory = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.Category), RS.Category);
        this._inputFontName = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.UIFont), RS.UIFont);
        this._inputFontStyle = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.Style), RS.Style);
        this._inputFontSize = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.Size), RS.Size);
        this._fontSample = this._fontsample(b.peek_());
        this._inputFixedName = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.Monospace), RS.Monospace);
        this._inputFixedStyle = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.Style), RS.Style);
        this._fixedSample = this._fontsample(b);
        [this._inputDialogBGColor, this._dialogBGColorSample] = this._createColorInput(b, RS.ColorDialogBG);
        [this._inputHeadingColor, this._headingColorSample] = this._createColorInput(b, RS.ColorHeading);
        [this._inputLinkColor, this._linkColorSample] = this._createColorInput(b, RS.ColorLink);
        [this._inputAnnotationColor, this._annotationColorSample] = this._createColorInput(b, RS.ColorAnnotation);
        [this._inputHighlightColor, this._highlightColorSample] = this._createColorInput(b, RS.HighlightColor);
        this._inputDateFormat = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.DateFormat), RS.DateFormat);
        this._inputTimeFormat = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.TimeFormat), RS.TimeFormat);
        this._inputTimeZone = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.TimeZone), RS.TimeZone);
        this._inputImportImageDimension = DialogUt.textSelect_(accessories$, b.peek_(), MSG.string_(RS.ImageDimension), RS.ImageDimension);
        b.pop_();
        this._inputImportImageDimension.setOptions_(
            ["256", "512", "1024", "1536", "2048", "2560", "3072", "3584", "4096", "4608", "5120"]);
        this._inputButtonSize.setOptions_(An.createStringList1_([
            [16, 32, 1],
            [32, 64, 2],
            [64, 129, 4],
        ]));
        this._inputFontCategory.setOptions_(settings.fontCategories_());
        this._inputFontSize.setOptions_(An.createStringList1_([
            [DEF.minFontSize, DEF.maxFontSize + 1, 1],
        ]));
        if (true) {
            const values = [];
            let selectedindex = 0;
            const fontname = current.fixedFontName$;
            for (const info of settings.fontFamilies_()) {
                const cat = info.category$;
                if (cat != null && FontCategories.Monospace == cat) {
                    const name = info.fontname$;
                    if (name == fontname) {
                        selectedindex = values.length;
                    }
                    values.push(name);
                }
            }
            this._inputFixedName.setOptions_(values, null, selectedindex);
        }
        this._inputDateFormat.setOptions_(DateFormat.SETTINGS_LIST);
        this._inputTimeFormat.setOptions_(TimeFormat.SETTINGS_LIST);
        this._inputTimeZone.setOptions_([settings$.timeZoneUTC$, settings$.timeZoneLocal$]);
        this._reset(current);
        this._inputButtonSize.onChange_((value: string) => {
            const buttonsize = An.parseInt_(value, current.buttonSize$);
            this._buttonsample(this._toolbarSample, buttonsize);
        });
        this._inputFontCategory.onChange_((cat: string) => {
            const fontname = this._inputFontName.getValue_("");
            DialogUt.populateFontName_(
                this._inputFontName,
                [],
                settings.fontFamilies_(),
                cat,
                fontname);
        });
        this._inputFontName.onChange_((fontname: string) => {
            const style = this._inputFontStyle.getValue_("");
            const selectedstyle = DialogUt.populateFontStyle_(
                this._inputFontStyle,
                [],
                settings.fontInfo_(fontname),
                style);
            this._fontSample.style.fontFamily = FontUtil.fontFamilyOf_(fontname, selectedstyle);
        });
        this._inputFontStyle.onChange_((style: string) => {
            const name = this._inputFontName.getValue_("");
            this._fontSample.style.fontFamily = FontUtil.fontFamilyOf_(name, style);
        });
        this._inputFontSize.onChange_((value: string) => {
            const size = An.parseInt_(value, current.uiFontSize$);
            const sizepx = `${size}px`;
            this._fontSample.style.fontSize = sizepx;
            this._fixedSample.style.fontSize = sizepx;
        });
        An.onClick_(this._fontSample, e => {
            An.stopevent_(e);
            const d = new PromptFont(
                accessories$,
                cache$.ui$.buttonSize_(),
                this._fontSample.style.fontFamily,
                DEFUtil.fontSamplerList,
                PATH._assetsFontsPng);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((familystyle: string) => {
                const namestyle = FontUtil.splitNameStyle_(familystyle);
                if (namestyle[0] != this._inputFontName.getValue_("")
                    || namestyle[1] != this._inputFontStyle.getValue_("")) {
                    this._inputFontName.setValue_(namestyle[0]);
                    DialogUt.populateFontStyle_(
                        this._inputFontStyle,
                        [],
                        settings.fontInfo_(namestyle[0]),
                        namestyle[1]);
                    this._fontSample.style.fontFamily = familystyle;
                }
            });
            d.show_();
        });
        this._inputFixedName.onChange_(name => {
            const style = this._inputFixedStyle.getValue_("");
            const selectedstyle = DialogUt.populateFontStyle_(
                this._inputFixedStyle,
                [],
                settings.fontInfo_(name),
                style);
            this._fixedSample.style.fontFamily = FontUtil.fontFamilyOf_(name, selectedstyle);
        });
        this._inputFixedStyle.onChange_((style: string) => {
            const name = this._inputFixedName.getValue_("");
            this._fixedSample.style.fontFamily = FontUtil.fontFamilyOf_(name, style);
        });
        An.onClick_(this._fixedSample, e => {
            An.stopevent_(e);
            const d = new PromptFont(
                accessories$,
                cache$.ui$.buttonSize_(),
                this._fixedSample.style.fontFamily,
                DEFUtil.monoSamplerList,
                PATH._assetsMonoPng);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((familystyle: string) => {
                const namestyle = FontUtil.splitNameStyle_(familystyle);
                if (namestyle[0] != this._inputFixedName.getValue_("")
                    || namestyle[1] != this._inputFixedStyle.getValue_("")) {
                    this._inputFixedName.setValue_(namestyle[0]);
                    DialogUt.populateFontStyle_(
                        this._inputFixedStyle,
                        [],
                        settings.fontInfo_(namestyle[0]),
                        namestyle[1]);
                    this._fixedSample.style.fontFamily = familystyle;
                }
            });
            d.show_();
        });
        for (const [input, sample] of [
            [this._inputDialogBGColor, this._dialogBGColorSample],
            [this._inputHeadingColor, this._headingColorSample],
            [this._inputLinkColor, this._linkColorSample],
            [this._inputAnnotationColor, this._annotationColorSample],
            [this._inputHighlightColor, this._highlightColorSample],
        ]) {
            An.onClick_(input, e => {
                An.stopevent_(e);
                this._promptcolor(input, sample);
            });
            An.onClick_(sample, e => {
                An.stopevent_(e);
                this._promptcolor(input, sample);
            });
        }
        const padding = cache$.ui$.iwinPadding_();
        this._content.style.paddingBottom = `${padding}px`;
        new DomBuilderEx(this._content).empty_().appendNodes_(top);
        An.stopAllInputEnterKey_(top);
        timer.debug_("# UiSettingsPanel.create(): end");
    }

    private _createColorInput(b: DomBuilderEx, stringid: string): [HTMLElement, HTMLElement] {
        b.peek_().textContainer_(DEF.BASIS_40, MSG.string_(stringid));
        const input = b.push_().div_(_UISettingsPanel._readonlyInputAttributes).cursor_();
        const sample = b.pop_().div1_(CSS.AnColorCell).cursor_();
        return [input, sample];
    }

    private _fontsample(b: DomBuilderEx): HTMLElement {
        const ret = b
            .peek_()
            .div1_(CSS.AnMarginV5)
            .div1_(CSS.AnSettingsSample,)
            .push_()
            .cursor_();
        b.peek_().span_().text_("ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789");
        b.pop_();
        return ret;
    }

    private _promptcolor(input: HTMLElement, sample: HTMLElement): void {
        const d = Callbacks.promptColor_(cache$.ui$.buttonSize_(), DEF.zindexPrompt, input.textContent ?? "", ColorValue.X_BLACK);
        d.onOK_((color, format) => {
            if (color != null) {
                input.textContent = ColorUtil.formatString_(format, color);
                sample.style.backgroundColor = ColorUtil.formatCSSString_(format, color);
            }
        });
        d.show_();
    }

    private _toolbarActions(action: string) {
        toasters$.hideAll_();
        switch (action) {
            case BUT.ResetUISettings:
                this._reset(settings$.defaults_());
                break;
            case BUT.Cancel:
                this._reset(settings$.current_());
                sidePanel$.hideSidepanel_();
                break;
            case BUT.Apply:
                const state = this._saveState(settings$.current_());
                _Util.onSaveOrDiscard_(() => {
                    this._apply(state);
                });
                break;
            default:
                throw Assert.notReach_(action);
        }
    }

    private _apply(state: JSONObject): void {
        this._updateState(settings$.current_(), state);
        host$.updateUISettings_(settings$.current_(), ret => {
            mainPanel$.addIFrameReadyOneshotCallback(() => {
                if (toasters$.warn_(ret)) {
                    
                }
            });
            native$.reloadHome_();
        });
    }

    private _getcsscolor(input: HTMLElement, sample: HTMLElement): string {
        const csscolor = ColorUtil.validateCSSColor_(input.textContent ?? "");
        return An.isempty_(csscolor) ? sample.style.backgroundColor : csscolor;
    }

    private _saveState(current: UISettings): JSONObject {
        return map_<string, any>(
            [SettingsKey.buttonSize, An.parseInt_(this._inputButtonSize.getValue_(""), current.buttonSize$)],
            [SettingsKey.uiFontName, this._inputFontName.getValue_("")],
            [SettingsKey.uiFontStyle, this._inputFontStyle.getValue_("")],
            [SettingsKey.uiFontSize, An.parseInt_(this._inputFontSize.getValue_(""), current.uiFontSize$)],
            [SettingsKey.fixedFontName, this._inputFixedName.getValue_("")],
            [SettingsKey.fixedFontStyle, this._inputFixedStyle.getValue_("")],
            [SettingsKey.dialogBGColor, this._getcsscolor(this._inputDialogBGColor, this._dialogBGColorSample)],
            [SettingsKey.headingColor, this._getcsscolor(this._inputHeadingColor, this._headingColorSample)],
            [SettingsKey.linkColor, this._getcsscolor(this._inputLinkColor, this._linkColorSample)],
            [SettingsKey.annotationColor, this._getcsscolor(this._inputAnnotationColor, this._annotationColorSample)],
            [SettingsKey.highlightColor, this._getcsscolor(this._inputHighlightColor, this._highlightColorSample)],
            [SettingsKey.dateFormat, this._inputDateFormat.getValue_("")],
            [SettingsKey.timeFormat, this._inputTimeFormat.getValue_("")],
            [SettingsKey.timeZone, this._inputTimeZone.getValue_(settings$.timeZoneUTC$)],
            [SettingsKey.imageDimension, An.parseInt_(this._inputImportImageDimension.getValue_(""), current.imageDimension$)],
        );
    }

    private _updateState(current: UISettings, state: JSONObject): void {
        for (const [key, value] of state.entries()) {
            current.set_(key, value);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _TemplatesPanel extends TabPanel implements IUIPanel {
    _container: HTMLElement;
    _shown: boolean = false;

    constructor(container: HTMLElement) {
        super(container);
        this._container = container;
        const tab = this.addTab(RS.Tooltips_PageTemplates, `${CSS.Fa} ${CSS.FaMagic}`, (elm) => {
            return new _HtmlTemplatesPanel(elm);
        });
        this.addTab(RS.Tooltips_GlobalSearchPanel, `${CSS.Fa} ${CSS.FaSearch}`, (elm) => {
            return (new _GlobalSearchPanel(elm));
        });
        this.addTab(RS.Tooltips_GlobalSettingsPanel, `${CSS.Fa} ${CSS.FaGear}`, (elm) => {
            return (new _UISettingsPanel(elm));
        });
        this.onTooltips(toasters$.onTooltipsKey_);
        this.activeTab(tab);
    }

    element_(): HTMLElement {
        return this._container;
    }

    destroy(): void {
        new DomBuilderEx(this._container).empty_();
    }

    show_(): void {
        if (!this._shown) {
            this._shown = true;
            An.showHidden_(this._container);
            this.resizeContent_(window.innerHeight);
            this.activePanel()?.show_();
            An.setVisible_(this._container);
        }
    }

    hide_(): void {
        if (this._shown) {
            this._shown = false;
            An.hide_(this._container);
            this.activePanel()?.hide_();
        }
    }

    resizeContent_(containerheight: number): void {
        super.resizeContent1(containerheight, cache$.ui$.toolbarHeight_());
    }

    showContextmenu_(): void { }

    hideContextmenu_(): void {
        //// When hiding the sidepanel, hide any active contextmenu too.
        const panel = this.activePanel();
        if (panel != null) {
            panel.hideContextmenu_();
        }
    }

    onWindowSizeChanged_(): void {
        super.onWindowSizeChanged();
    }
}

////////////////////////////////////////////////////////////////////////

class _AnnotationOptions {

    constructor(
        readonly style: stringX,
        readonly withBorder: boolean,
        readonly withCorners: boolean,
        readonly withShadow: boolean,
        readonly bgColor: string
    ) { }
}

type _PromptAnnotationStyleCallback = (options: _AnnotationOptions) => void;

class _PromptAnnotationStyle extends FixedSizeDialogBase {
    readonly _xxx: string = MSG.XXX$;
    _width: number;
    _okCallback: _PromptAnnotationStyleCallback | null = null;

    constructor(
        container: HTMLElement,
        buttonsize: number
    ) {
        super(container, buttonsize);
        this._width = (this._buttonSize * 4);
        this.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infosCancel,
            action => this._toolbarActions(action));
    }

    private _createContent(content: HTMLElement): void {
        const w = `width: ${this._width}px`;
        const style = CSSUtil.joinStyles1_(Object.entries({
            "border": DEF.themeBorder,
            "padding": "1.5ex 1em",
            "width": "100%",
            "height": `${this._width * 5 / 16}px`,
            "margin": "5px",
            "box-sizing": "border-box",
            "overflow": "hidden",
        }));
        const b = new DomBuilderEx(content);
        const top = b.div_({
            "style": `${w}; padding-top: 5px; border-top: ${DEF.themeBorder}; `,
        }).push_().cursor_();
        b.div_({
            "style": `${w}; box-sizing: border-box; margin: 10px 0; overflow: hidden; `
                + "display:flex;justify-content:center;",
        });
        const border = DialogUt.createBorderButton_(b.push_(), this._buttonSize, true);
        const corners = DialogUt.createRoundCornersButton_(b.peek_(), this._buttonSize, true);
        const shadow = DialogUt.createBoxShadowButton_(b.peek_(), this._buttonSize, false);
        const bgcolor = DialogUt.createColorButton_(b.pop_(), this._buttonSize, "");
        b.pop_().div_({
            "style": `${w}; font-size: 0.7rem; `
                + "box-sizing:border-box;padding:5px;"
                + "display:flex;flex-flow:row wrap;justify-content:center;align-items:center;",
        }).indent_(
            b.push_().div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners} ${CSS.AnAnnotationStyleText}`],
                ["style", style],
                [ATTR.xTooltips, RS.widgetAnnotationStyleBasic],
            ),
            _PromptAnnotationStyle._basicStyle(b, this._xxx),
            b.peek_().div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners} ${CSS.AnAnnotationStyleText}`],
                ["style", style],
                [ATTR.xTooltips, RS.widgetAnnotationStyleList],
            ),
            _PromptAnnotationStyle._listStyle(b, this._xxx),
            b.peek_().div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners} ${CSS.AnAnnotationStyleImage}`],
                ["style", style],
                [ATTR.xTooltips, RS.widgetAnnotationStyleImage],
            ),
            _PromptAnnotationStyle._imageStyle(b, this._width / 8),
        );
        An.onToggleToggle_(border, down => {
            for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                e.style.border = (down ? DEF.themeBorder : "");
            }
        });
        An.onToggleToggle_(corners, down => {
            for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                if (down) {
                    e.classList.add(CSS.AnRoundCorners);
                } else {
                    e.classList.remove(CSS.AnRoundCorners);
                }
            }
        });
        An.onToggleToggle_(shadow, down => {
            for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                if (down) {
                    e.classList.add(CSS.AnBoxShadow);
                } else {
                    e.classList.remove(CSS.AnBoxShadow);
                }
            }
        });
        An.onClick_(bgcolor, () => {
            const d = Callbacks.promptColor_(this._buttonSize, An.above_(this.element_()), bgcolor.style.backgroundColor, ColorValue.X_WHITE);
            d.onOK_((c, format) => {
                const formatted = ColorUtil.formatCSSString_(format, c);
                bgcolor.style.backgroundColor = formatted;
                for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                    e.style.backgroundColor = formatted;
                }
            });
            d.show_();
        });
        An.onClickMatching_(top, `div.${CSS.AnLink}`, (elm, e) => {
            An.stopevent_(e);
            const style = elm.getAttribute(ATTR.xTooltips);
            const border = corners.classList.contains(CSS.AnButtonDown);
            const rounded = corners.classList.contains(CSS.AnButtonDown);
            const withshadow = shadow.classList.contains(CSS.AnButtonDown);
            const color = bgcolor.style.backgroundColor;
            const callback = this._okCallback!;
            this.close_();
            callback(new _AnnotationOptions(style, border, rounded, withshadow, color));
        });
        An.onContextmenuMatching_(top, `div.${CSS.AnLink}`, toasters$.onTooltipsKey_);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: _PromptAnnotationStyleCallback): this {
        this._okCallback = callback;
        return this;
    }

    static _basicStyle(b: DomBuilderEx, text: string): void {
        b.text_(text);
    }

    static _listStyle(b: DomBuilderEx, text: string): void {
        b.ul1_(CSS.xNone).li1_(CSS.xList);
        b.push_().span_({
            "class": CSS.xBullet,
            "style": `font-family: ${DEF.FontAwesome}; width: 1.5em; margin-right: 0.5em; text-align: center; `,
        }).text_("\uf0e5 ");
        b.pop_().span1_(CSS.xListContent).text_(text);
    }

    static _imageStyle(b: DomBuilderEx, fontsize: Double): void {
        const elm = b.cursor_();
        elm.classList.add(CSS.Fa, CSS.FaImage);
        elm.style.display = "flex";
        elm.style.alignItems = "center";
        elm.style.justifyContent = "center";
        elm.style.fontSize = `${fontsize}px`;
    }

    static _photoStyle(b: DomBuilderEx, fontsize: Double): void {
        const elm = b.cursor_();
        elm.classList.add(CSS.Fa, CSS.FaCamera);
        elm.style.display = "flex";
        elm.style.alignItems = "center";
        elm.style.justifyContent = "center";
        elm.style.fontSize = `${fontsize}px`;
    }

    private _toolbarActions(action: string): void {
        switch (action) {
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _FlexboxOptions {

    constructor(
        readonly style: stringX,
        readonly vertical: boolean,
        readonly gutter: [number, string] | null
    ) { }

    hasGutter(): boolean {
        return this.gutter != null && this.gutter[0] != 0.0;
    }

    gutterString(): string {
        return this.gutter == null ? "0" : `${this.gutter[0]} ${this.gutter[1]}`;
    }
}

type _PromptFlexboxStyleCallback = (options: _FlexboxOptions) => void;

class _PromptFlexboxStyle extends FixedSizeDialogBase {
    readonly _xxx: string = MSG.XXX$;
    _width: number;
    _vertical: boolean = false;
    _gutter: [number, string] = [0.5, "em"];
    _okCallback: _PromptFlexboxStyleCallback | null = null;

    constructor(
        container: HTMLElement,
        buttonsize: number
    ) {
        super(container, buttonsize);
        this._width = (this._buttonSize * 4);
        this.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infosCancel,
            (action) => this._toolbarActions(action));
    }

    private _createContent(content: HTMLElement): void {
        const w = `width: ${this._width}px`;
        const b = new DomBuilderEx(content);
        const top = b.div_({
            "style": `${w}; padding-top: 5px; border-top: ${DEF.themeBorder}; `,
        }).push_().cursor_();
        b.div_({
            "style": `${w}; box-sizing: border-box; margin: 10px 0; overflow: hidden; `
                + "display:flex;justify-content:center;",
        });
        const orientation = DialogUt.createOrientationButton_(b, this._buttonSize, this._vertical);
        const gutter = DialogUt.createGutterButton_(b, this._buttonSize, this._vertical);
        const sample = b.pop_().div_({
            "style": `${w}; font-size: 0.7rem; `
                + "box-sizing:border-box;"
                + "display:flex;flex-flow:column wrap;justify-content:flex-start;align-items:stretch;",
        }).cursor_();
        this._basicStyle(b);
        this._imageStyle(b);
        orientation.addEventListener("click", () => {
            this._vertical = !this._vertical;
            this._refresh(orientation, gutter, sample);
        });
        gutter.addEventListener("click", () => {
            const d = new PromptDoubleUnit(accessories$, RS.Gutter, this._gutter);
            d.above_(this.element_());
            d.onOK_((d, sizeunit, okcallback) => {
                const pair = An.doubleSizeUnit_(sizeunit);
                if (pair == null) {
                    d.warn_(MSG.format2_(RS.invalidNameValue, MSG.string_(RS.Gutter), sizeunit));
                    okcallback(false);
                    return;
                }
                okcallback(true);
                this._gutter = pair;
                this._refresh(orientation, gutter, sample);
            });
            d.show_();
        });
        An.onClickMatching_(top, `div.${CSS.AnLink}`, (elm, e) => {
            An.stopevent_(e);
            const style = elm.getAttribute(ATTR.xTooltips);
            const callback = this._okCallback!;
            this.close_();
            callback(new _FlexboxOptions(style, this._vertical, this._gutter));
        });
        An.onContextmenuMatching_(top, `div.${CSS.AnLink}`, toasters$.onTooltipsKey_);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: _PromptFlexboxStyleCallback): this {
        this._okCallback = callback;
        return this;
    }

    private _refresh(orientation: HTMLElement, gutter: HTMLElement, sample: HTMLElement): void {
        DialogUt.updateOrientationButton_(new DomBuilderEx(orientation).empty_(), this._vertical);
        DialogUt.updateGutterButton_(new DomBuilderEx(gutter).empty_(), this._vertical);
        const b = new DomBuilderEx(sample).empty_();
        this._basicStyle(b);
        this._imageStyle(b);
    }

    private _basicStyle(b: DomBuilderEx): void {
        const sizeunit = this._gutter[0] + this._gutter[1];
        b.push_().div_(
            ["class", `${CSS.AnLink}`],
            ["style", "display:flex;"
                + `flex-flow: ${this._vertical ? "column nowrap" : "row nowrap"}; `
                + (this._vertical ? `flex:1 1 100%;height:${this._buttonSize * 3}px;` : `height:${this._buttonSize * 2}px;`)
                + "background-color:#eee;"
                + "margin:5px 0;"
                + "border:1px solid rgba(0,0,0,0.5);"
                + "box-sizing:border-box"],
            [ATTR.xTooltips, RS.widgetFlexboxStyleBasic],
        ).indent_(
            b.push_().div_(["style", "flex: 1 1 100%;padding:5px;"]).text_(this._xxx),
            b.peek_().div_(
                ["class", CSS.xGutter],
                ["style", `flex: 0 0 ${sizeunit}; ${this._vertical ? "max-height" : "max-width"}: ${this._buttonSize}px; `
                    + "background-color:rgba(0, 0, 0, 0.1);"],
            ),
            b.pop_().div_({
                "style": "flex: 1 1 100%;padding:5px;",
            }).text_(this._xxx),
        ).pop_();
    }

    private _imageStyle(b: DomBuilderEx): void {
        const sizeunit = this._gutter[0] + this._gutter[1];
        b.push_().div_(
            ["class", `${CSS.AnLink}`],
            ["style", `display: flex; flex-flow: ${this._vertical ? "column nowrap" : "row nowrap"}; `
                + "background-color:#eee;"
                + `${this._vertical ? "flex:1 1 100%;height:${this._buttonSize * 3};" : "height:${this._buttonSize * 2}px;"}`
                + "border:1px solid rgba(0,0,0,0.5);"
                + "margin:5px 0;"
                + "box-sizing:border-box"],
            [ATTR.xTooltips, RS.widgetFlexboxStyleImage],
        ).indent_(
            b.push_().div_({
                "style": "flex: 0 0 0%;",
            }).img_((this._vertical ? PATH._assetsImagesLandscapeSample : PATH._assetsImagesPortraitSample), {
                "style": (this._vertical ? "display:block;width:100%;" : `display: block; height: ${this._buttonSize * 2 - 2}px; `),
            }),
            b.peek_().div_({
                "class": CSS.xGutter,
                "style": `flex: 0 0 ${sizeunit}; ${this._vertical ? "max-height" : "max-width"}: ${this._buttonSize}px; `
                    + "background-color:rgba(0, 0, 0, 0.1);",
            }),
            b.pop_().div_({
                "style": "flex:1 1 100%;padding:5px;",
            }).text_(this._xxx),
        ).pop_();
    }

    private _toolbarActions(action: string): void {
        switch (action) {
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

////////////////////////////////////////////////////////////////////////

class _StickerOptions {

    constructor(
        readonly style: stringX,
        readonly withBorder: boolean,
        readonly withCorners: boolean,
        readonly withShadow: boolean,
        readonly withHeader: boolean,
        readonly bgcolor: string
    ) { }
}

type _PromptStickerStyleCallback = (options: _StickerOptions) => void;

class _PromptStickerStyle extends FixedSizeDialogBase {
    readonly _msgSubject: string = MSG.string_(RS.Subject);
    readonly _msgXXX: string = MSG.XXX$;
    _width: number;
    _okCallback: _PromptStickerStyleCallback | null = null;

    constructor(
        container: HTMLElement,
        buttonsize: number
    ) {
        super(container, buttonsize);
        this._width = (this._buttonSize * 6);
        this.init_(this.create_(container));
    }

    protected create_(container: HTMLElement): HTMLElement {
        return this._createDialogWithoutMessageStatus(
            container,
            (content) => this._createContent(content),
            BUT.infosCancel,
            (action) => this._toolbarActions(action));
    }

    private _createContent(content: HTMLElement): void {
        const w = `width: ${this._width}px`;
        const b = new DomBuilderEx(content);
        const top = b.div_({
            "style": `${w}; padding-top: 5px; border-top: ${DEF.themeBorder}; `,
        }).push_().cursor_();
        b
            .div_({
                "style": `${w}; box-sizing: border-box; margin: 10px 0; overflow: hidden; `
                    + "display:flex;justify-content:center;",
            }).cursor_();
        const border = DialogUt.createBorderButton_(b, this._buttonSize, true);
        const corners = DialogUt.createRoundCornersButton_(b, this._buttonSize, true);
        const shadow = DialogUt.createBoxShadowButton_(b, this._buttonSize, false);
        const header = DialogUt.createHeaderButton_(b, this._buttonSize, false);
        const bgcolor = DialogUt.createColorButton_(b, this._buttonSize, _WidgetTemplates._colorYellow);
        const style = CSSUtil.joinStyles1_(Object.entries({
            "border": DEF.themeBorder,
            "padding": "1.5ex 1em",
            "background-color": _WidgetTemplates._colorYellow,
            "width": "calc(50% - 10px)",
            "height": `${this._buttonSize * 3 - 15}px`,
            "margin": "5px",
            "box-sizing": "border-box",
            "overflow": "hidden",
        }));
        b.pop_().div_({
            "style": `${w}; font-size: 0.7rem; `
                + "box-sizing:border-box;padding:5px;"
                + "display:flex;flex-flow:row wrap;justify-content:center;align-items:center;",
        }).push_();
        this._basicStyle(b, style);
        this._badgeStyle(b, this._buttonSize);
        this._imageStyle(b, style);
        this._canvasStyle(b, style);
        An.onToggleToggle_(border, down => {
            for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                e.style.border = (down ? DEF.themeBorder : "");
            }
        });
        An.onToggleToggle_(corners, () => {
            for (const e of Array.from(top.querySelectorAll(`div.${CSS.AnLink}`))) {
                e.classList.toggle(CSS.AnRoundCorners);
            }
        });
        An.onToggleToggle_(shadow, () => {
            for (const e of Array.from(top.querySelectorAll(`div.${CSS.AnLink}`))) {
                e.classList.toggle(CSS.AnBoxShadow);
            }
        });
        An.onToggleToggle_(header, down => {
            for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                const subject = DomUt.query_(e, `div.${CSS.AnMarker}`);
                if (subject != null) {
                    subject.style.display = (down ? "block" : "none");
                }
                const marker = DomUt.query_(e, `span.${CSS.AnMarker}`);
                if (marker != null) {
                    if (down) {
                        marker.classList.remove(CSS.FaEyeSlash);
                        marker.style.display = "none";
                    } else {
                        marker.classList.add(CSS.FaEyeSlash);
                        marker.style.display = "inline-block";
                    }
                }
            }
        });
        An.onClick_(bgcolor, () => {
            const d = Callbacks.promptColor_(this._buttonSize, An.above_(this.element_()), bgcolor.style.backgroundColor, ColorValue.X_WHITE);
            d.onOK_((c, format) => {
                const formatted = ColorUtil.formatCSSString_(format, c);
                bgcolor.style.backgroundColor = formatted;
                for (const e of Array.from(DomUt.queryAll_(top, `div.${CSS.AnLink}`))) {
                    e.style.backgroundColor = formatted;
                }
            });
            d.show_();
        });
        An.onClickMatching_(top, `div.${CSS.AnLink}`, (elm, e) => {
            An.stopevent_(e);
            const options = new _StickerOptions(
                elm.getAttribute(ATTR.xTooltips),
                border.classList.contains(CSS.AnButtonDown),
                corners.classList.contains(CSS.AnButtonDown),
                shadow.classList.contains(CSS.AnButtonDown),
                header.classList.contains(CSS.AnButtonDown),
                bgcolor.style.backgroundColor);
            const callback = this._okCallback!;
            this.close_();
            callback(options);
        });
        An.onContextmenuMatching_(top, `div.${CSS.AnLink}`, toasters$.onTooltipsKey_);
    }

    close_() {
        this._okCallback = null;
        super.close_();
    }

    getContentWidth_(): number {
        return this._width;
    }

    onOK_(callback: _PromptStickerStyleCallback): this {
        this._okCallback = callback;
        return this;
    }

    private _basicStyle(b: DomBuilderEx, style: string): void {
        b
            .peek_().div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners}`],
                [ATTR.xTooltips, RS.widgetStickerStyleBasic],
                ["style", style],
            ).div_()
            .push_().span_({
                "class": `${CSS.xFloatRightClearNone} ${CSS.Fa} ${CSS.FaEyeSlash}`,
                "style": "margin-bottom:0.5ex;"
            })
            .peek_().div_({
                "class": CSS.AnMarker,
                "style": "display:none;"
                    + "font-weight:bold;"
                    + `border-bottom: ${DEF.themeBorder}; `
                    + "padding-bottom:0.75ex;"
                    + "margin-bottom:1ex;",
            }).text_(this._msgSubject)
            .peek_().div_()
            .text_(this._msgXXX)
            .pop_();
    }

    private _badgeStyle(b: DomBuilderEx, buttonsize: number): void {
        b.peek_().div_(
            ["class", `${CSS.AnLink} ${CSS.AnRoundCorners}`],
            [ATTR.xTooltips, RS.widgetStickerStyleBadge],
            ["style", `border: ${DEF.themeBorder}; `
                + `background-color: ${_WidgetTemplates._colorYellow}; `
                + "box-sizing:border-box;"
                + "width:calc(50% - 10px);"
                + `height: ${buttonsize * 3 - 10}px; `
                + "padding:1.5ex 1em;"
                + "margin:5px;"
                + "overflow:hidden;"
                + "display:flex;align-items:center;justify-content:center;"
                + "border-radius:50%;"],
        ).div_()
            .push_().div_({
                "class": CSS.AnMarker,
                "style": "display:none;"
                    + "font-weight:bold;"
                    + "text-align:center;"
                    + `border-bottom: ${DEF.themeBorder}; `
                    + "padding-bottom:0.75ex;"
                    + "margin-bottom:1ex;",
            }).text_(this._msgSubject)
            .span_({
                "class": `${CSS.xFloatRightClearNone} ${CSS.Fa} ${CSS.FaEyeSlash}`,
                "style": "margin-bottom:0.5ex;"
            }).pop_().div_({
                "style": "text-align:center",
            })
            .text_(this._msgXXX)
            .span_({
                "class": `${CSS.xFloatRightClearNone} ${CSS.Fa} ${CSS.FaEyeSlash} ${CSS.AnMarker}`,
                "style": "margin-bottom:0.5ex;"
            });
    }

    private _imageStyle(b: DomBuilderEx, style: string): void {
        b
            .peek_()
            .div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners}`],
                [ATTR.xTooltips, RS.widgetStickerStyleImage],
                ["style", `${style} display: flex; flex-flow: column; `],
            ).div_()
            .push_().span_({
                "class": `${CSS.xFloatRightClearNone} ${CSS.Fa} ${CSS.FaEyeSlash}`,
                "style": "margin-bottom:0.5ex;"
            })
            .peek_().div_({
                "class": CSS.AnMarker,
                "style": "display:none;"
                    + "font-weight:bold;"
                    + `border-bottom: ${DEF.themeBorder}; `
                    + "padding-bottom:0.75ex;"
                    + "margin-bottom:1ex;",
            }).text_(this._msgSubject)
            .pop_().up_().div_({
                "style": "overflow:hidden;"
                    + "flex:1 1 auto;"
                    + `background-image: url("${PATH._assetsImagesSamplesLamp}"); `
                    + "background-size:cover;"
                    + "overflow:hidden;",
            });
    }

    private _canvasStyle(b: DomBuilderEx, style: string): void {
        b
            .peek_()
            .div_(
                ["class", `${CSS.AnLink} ${CSS.AnRoundCorners}`],
                [ATTR.xTooltips, RS.widgetStickerStyleCanvas],
                ["style", `${style} display: flex; flex-flow: column; `],
            ).div_()
            .push_().span_({
                "class": `${CSS.xFloatRightClearNone} ${CSS.Fa} ${CSS.FaEyeSlash}`,
                "style": "margin-bottom:0.5ex;"
            })
            .peek_().div_({
                "class": CSS.AnMarker,
                "style": "display:none;"
                    + "font-weight:bold;"
                    + `border-bottom: ${DEF.themeBorder}; `
                    + "padding-bottom:0.75ex;"
                    + "margin-bottom:1ex;",
            }).text_(this._msgSubject)
            .pop_().up_().div_({
                "style": `background-image: url("${PATH._assetsImagesSig01Png}"); `
                    + "background-size:contain;"
                    + "background-position:center;"
                    + "background-repeat:no-repeat;"
                    + "flex:1 1 auto;"
                    + "overflow:hidden;",
            });
    }

    private _toolbarActions(action: string): void {
        switch (action) {
            case BUT.Cancel:
                this.actionCancel_();
                break;
            default:
                this.actionInvalid_(action);
        }
    }
}

abstract class _FlexboxWidget {

    static readonly XDIRECTION = "#X0D";
    static readonly XGUTTER = "#Xka";

    static _flexbox(range: Range): void {
        const idoc = native$.getIFrameDocument_();
        if (idoc == null) return;
        if (range.collapsed) {
            const d = new _PromptFlexboxStyle(accessories$, cache$.ui$.buttonSize_());
            d.titleKey_(RS.PickStyle);
            d.zindex_(DEF.zindexPrompt);
            d.onOK_((options: _FlexboxOptions) => {
                _FlexboxWidget._flexbox0(idoc, range, options);
            });
            d.show_();
        } else {
            _FlexboxWidget._flexbox1(idoc, range);
        }
    }

    static _flexbox0(idoc: Document, range: Range, options: _FlexboxOptions): void {
        _FlexboxWidget._flexbox3(idoc, options.vertical, b => {
            const isbasic = (options.style == RS.widgetFlexboxStyleBasic);
            b.push_();
            if (options.vertical) {
                if (isbasic) {
                    b.peek_().div_({
                        "style": "flex: 1 1 100%;",
                    }).text_(MSG.XXX$);
                } else {
                    b.div_({
                        "style": "flex: 0 0 auto",
                    }).ahref_(PATH._assetsImagesPortraitSample + `? ${Param.view}`)
                        .img_(PATH._assetsImagesLandscapeSample, {
                            "class": CSS.xImageholder,
                            "style": "display:block;width:100%;",
                        });
                }
                _FlexboxWidget._flexboxSecondBox(b, options);
            } else {
                if (isbasic) {
                    b.peek_().div_({
                        "style": "flex: 1 1 100%;",
                    }).text_(MSG.XXX$);
                } else {
                    b.div_({
                        "style": "flex: 0 0 auto;max-width:50%",
                    }).ahref_(PATH._assetsImagesPortraitSample + `? ${Param.view}`)
                        .img_(PATH._assetsImagesPortraitSample, {
                            "class": CSS.xImageholder,
                            "style": "display:block;width:100%;",
                        });
                }
                _FlexboxWidget._flexboxSecondBox(b, options);
            }
            RangeUtil.insertNode_(range, b.pop_().cursor_());
        });
    }

    /**
         * @param range A non-collapsed selection.
         */
    static _flexbox1(idoc: Document, range: Range): void {
        _FlexboxWidget._flexbox2(idoc, (b, options) => {
            const content = RangeUtil.extractContents_(range);
            const childcount = content.childElementCount;
            const hasgutter = options.hasGutter();
            let n = content.firstChild;
            let e = content.firstElementChild;
            b.push_();
            if (childcount == 0) {
                b.peek_().div_({
                    "style": "flex: 1 1 100%",
                });
            }
            for (let i = 0; i < childcount; ++i) {
                if (hasgutter && i > 0) {
                    b.peek_().div_({
                        "class": CSS.xGutter,
                        "style": `flex: 0 0 ${options.gutterString()}`
                    });
                }
                b.peek_().div_({
                    "style": "flex: 1 1 100%",
                });
                for (let next = null; n != null && n != e; n = next) {
                    next = n.nextSibling;
                    b.appendNodes_(n);
                }
                n = e!.nextSibling;
                const e1 = e!;
                e = e!.nextElementSibling;
                b.appendNodes_(e1);
            }
            for (let next; n != null; n = next) {
                next = n.nextSibling;
                b.appendNodes_(n);
            }
            if (childcount <= 1) {
                _FlexboxWidget._flexboxSecondBox(b, options);
            }
            RangeUtil.insertNode_(range, b.pop_().cursor_());
        });
    }

    static _flexboxSecondBox(b: DomBuilderEx, options: _FlexboxOptions): void {
        if (options.hasGutter()) {
            b.peek_().div_({
                "class": CSS.xGutter,
                "style": `flex: 0 0 ${options.gutterString()}`
            });
        }
        b.peek_().div_({
            "style": "flex:1 1 100%;",
        }).text_(MSG.XXX$);
    }

    static _flexbox2(idoc: Document, callback: (b: DomBuilderEx, options: _FlexboxOptions) => void): void {
        const d = new CompositeDialog(accessories$, [
            new SelectFIeld(
                RS.Direction,
                _FlexboxWidget.XDIRECTION,
                MSG.string_(RS.Horizontal),
                RS.Direction,
                [MSG.string_(RS.Horizontal), MSG.string_(RS.Vertical)]
            ),
            new InputSelectField(
                RS.Gutter,
                _FlexboxWidget.XGUTTER,
                "0.5",
                RS.Gutter,
                CSSLength.EM,
                CSSLengths
            ),
        ]);
        d.titleKey_(RS.widgetFlexboxTitle);
        d.messageKey_(RS.widgetFlexboxMessage);
        d.zindex_(DEF.zindexPrompt);
        d.onOK_((d, okcallback) => {
            const errors = sarray_();
            const gutter = d.getValue_(_FlexboxWidget.XGUTTER);
            if (!CSSUtil.validateOptionalCSSLength_(gutter)) {
                errors.push(MSG.format2_(RS.invalidNameValue, MSG.string_(RS.Gutter), gutter));
            }
            if (errors.length > 0) {
                d.warn_(errors);
                okcallback(false);
                return;
            }
            const vertical = (d.getValue_(_FlexboxWidget.XDIRECTION) == MSG.string_(RS.Vertical));
            okcallback(true);
            const sizeunit = An.doubleSizeUnit_(gutter);
            _FlexboxWidget._flexbox3(idoc, vertical, (b) => {
                callback(b, new _FlexboxOptions(null, vertical, sizeunit));
            });
        });
        d.show_();
    }

    static _flexbox3(idoc: Document, vertical: boolean, callback: (b: DomBuilderEx) => void): void {
        const direction = vertical ? "flex-direction:column;" : "";
        const style = `box-sizing: border-box; width: 100 %; ${direction}; align-items: stretch; `;
        history$.group_(RS.widgetFlexboxTitle, "", () => {
            const b = DomBuilderEx.offline_(idoc, "div", {
                "class": CSS.xFlexbox,
                "style": style,
            });
            callback(b);
        });
    }

    static _destructFlexbox(node: HTMLElement): void {
        _Util.confirmSmall_(
            MSG.format1_(RS.destructWidget, MSG.string_(RS.widgetFlexboxTitle)),
            DEF.zindexConfirm, (yes: boolean) => {
                if (!yes) return;
                history$.group_(RS.action_DestructFlexbox, "", () => {
                    const b = new DomBuilderEx(node);
                    for (let child = node.firstChild, next = null; child != null; child = next) {
                        next = child.nextSibling;
                        if (child.nodeType == Node.ELEMENT_NODE) {
                            if (native$.hasClass_(child, CSS.xGutter)) {
                                node.removeChild(child);
                            } else if ("DIV" == child.nodeName) {
                                b.unwrap_(child);
                            }
                        }
                    }
                    b.up_().unwrap_(node);
                });
            });
    }
}

abstract class _ShoppingWidget {
    static create_(idoc: Document, range: Range, callback: Fun10X<HTMLElement> = null): void {
        _WidgetTemplates.promptStyle_(accessories$, (style) => {
            const now = DateTime.now_();
            const b = DomBuilderEx.offline1_(idoc, "div", CSS.xWidgetShopping, style);
            const div = b.push_().table1_(CSS.xWidgetShopping).tbody_().indent_(
                b.push_().tr1_(CSS.xWidgetShoppingHeader).indent_(
                    b.push_().th_(
                        ["class", CSS.xWidgetShoppingDesc],
                        ["colspan", "2"],
                    ).text_(MSG.string_(RS.Description)),
                    b.peek_().th1_(CSS.xWidgetShoppingQuantity).text_("#"),
                    b.pop_().th1_(CSS.xWidgetShoppingPrice).text_("$")),
                b.peek_().tr1_(CSS.xWidgetShopping, CSS.xTodoItem).indent_(
                    b.push_().td1_(CSS.xTodoStatus),
                    b.peek_().td1_(CSS.xWidgetShoppingDesc).indent_(
                        b.push_().code_(
                            ["class", CSS.xDate],
                            ["style", "color:inherit;"],
                            [ATTR.xDateFormat, `${settings$.shortDateFormat_()};;${now.millisecondsSinceEpoch$}`],
                        ).text_(settings$.shortDateString_(now)),
                        b.pop_().text_("\u00a0").span1_(CSS.xPlaceholder).text_(MSG.XXX$)),
                    b.peek_().td1_(CSS.xCalcQuantity).text_("1"),
                    b.pop_().td1_(CSS.xCalcPrice).text_("0.00")),
                b.peek_().tr1_(CSS.xWidgetShopping, CSS.xTodoItem).indent_(
                    b.push_().td1_(CSS.xTodoStatus),
                    b.peek_().td1_(CSS.xWidgetShoppingDesc).indent_(
                        b.push_().code_(
                            ["class", CSS.xDate],
                            [ATTR.xDateFormat, `${settings$.shortDateFormat_()};;${now.millisecondsSinceEpoch$}`],
                        ).text_(settings$.shortDateString_(now)),
                        b.pop_().text_("\u00a0").span1_(CSS.xPlaceholder).text_(MSG.XXX$)),
                    b.peek_().td1_(CSS.xCalcQuantity).text_("1"),
                    b.pop_().td1_(CSS.xCalcPrice).text_("0.00")),
                b.pop_().tr1_(CSS.xWidgetShoppingTotal)
                    .td_(
                        ["class", CSS.xCalcTotal],
                        ["colspan", "4"],
                    ).text_("0.00")
            ).pop_().cursor_();
            history$.group_(RS.widgetShoppingTitle, RS.widgetShoppingDesc, () => {
                range.collapse(true);
                RangeUtil.replaceRange_(range, div);
            });
            callback?.(div);
        });
    }
}

abstract class _TocWidget {
    static create_(idoc: Document, range: Range, callback: Fun10X<HTMLElement> = null): void {
        _WidgetTemplates.promptStyle_(accessories$, (style) => {
            const b = DomBuilderEx.offline1_(idoc, "div", CSS.xWidgetToc, style);
            const div = b.push_().ul1_(CSS.xWidgetToc).indent_(
                b.push_().li1_(CSS.xWidgetToc1).text_("Subject"),
                b.peek_().li1_(CSS.xWidgetToc2).indent_(
                    b.push_().span1_(CSS.xWidgetTocBullet),
                    b.pop_().span1_(CSS.xPlaceholder).text_(MSG.XXX$),
                ),
                b.pop_().li1_(CSS.xWidgetToc4).indent_(
                    b.push_().span1_(CSS.xWidgetTocBullet),
                    b.pop_().span1_(CSS.xPlaceholder).text_(MSG.XXX$)
                ),
            ).pop_().cursor_();
            history$.group_(RS.widgetTocTitle, RS.widgetTocDesc, () => {
                range.collapse(true);
                RangeUtil.replaceRange_(range, div);
            });
            callback?.(div);
        });
    }
}

abstract class _TodoWidget {
    static create_(idoc: Document, range: Range, callback: Fun10X<HTMLElement> = null): void {
        _WidgetTemplates.promptStyle_(accessories$, (style) => {
            const now = DateTime.now_();
            const xxx = MSG.XXX$;
            const div = _TodoWidget.createTodo_(idoc, style, (b) => {
                b.code_(
                    ["class", `${CSS.xDate}`],
                    ["style", "color:inherit;"],
                    [ATTR.xDateFormat, `${settings$.shortDateFormat_()};;${now.millisecondsSinceEpoch$}`],
                ).text_(settings$.shortDateString_(now));
            }, (b) => {
                b.span1_(CSS.xWidgetTodoSubject, CSS.xPlaceholder).text_(xxx);
            }, (b) => {
                b.li1_(CSS.xList).indent_(
                    b.push_().span_(
                        ["class", CSS.xBullet],
                        ["style", "font-family: FontAwesome"],
                    ).text_(" "),
                    b.pop_().span1_(CSS.xListContent, CSS.xPlaceholder).text_(xxx),
                );
            });
            history$.group_(RS.widgetTodoTitle, RS.widgetTodoDesc, () => {
                range.collapse(true);
                RangeUtil.replaceRange_(range, div);
            });
            callback?.(div);
        });
    }

    /// @return b where b.cursor_() is UL for content and b.pop_().cursor_() is the top DIV.
    static createTodo_(
        idoc: Document,
        style: string,
        date: Fun10<DomBuilderEx>,
        subject: Fun10<DomBuilderEx>,
        content: Fun10<DomBuilderEx>
    ): HTMLElement {
        const b = DomBuilderEx.offline1_(idoc, "div", CSS.xWidgetTodo, style).push_();
        b.ul1_(CSS.xWidgetTodo).li1_(CSS.xWidgetTodo, CSS.xTodoItem).indent_(
            b.push_().div1_(CSS.xTodoStatus),
            b.pop_().div1_(CSS.xWidgetTodoContent).indent_(
                b.push_().div1_(CSS.xWidgetTodoSubject).indent_(
                    b.push_(),
                    date(b),
                    b.pop_().text_("\u00a0"),
                    subject(b)),
                b.pop_().div1_(CSS.xWidgetTodoBody).ul1_(CSS.xNone),
                content(b)));
        return b.pop_().cursor_();
    }
}

class _PromptWidgetStyle extends CompositeDialogBase {
    static readonly NONE = MSG.string_(RS.None);
    private _okCallback: Fun10X<string> = null;
    constructor(container: HTMLElement) {
        super(container, [
            new SelectFIeld(RS.Style, "", _PromptWidgetStyle.NONE, RS.Style, [
                _PromptWidgetStyle.NONE,
                MSG.string_(RS.Theme_Light),
                MSG.string_(RS.Theme_Dark),
            ]),
        ]);
        this.titleKey_(RS.PickStyle);
        this.getFieldAt_(0).element_().style.marginTop = "10px";
    }
    onOK_(callback: Fun10<string>): this {
        this._okCallback = callback;
        return this;
    }
    _onOK() {
        const value = this.getValueAt_(0);
        const style = value == _PromptWidgetStyle.NONE ? "" : `${CSS.xStyle}-${value.toLowerCase()}`;
        super.close_();
        this._okCallback?.(style);
        this._okCallback = null;
    }
}

////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////

class _SidePanel {
    private _sidebar!: HTMLElement;
    private _resizeTab!: HTMLElement;
    private _sidepanel!: HTMLElement;
    private _smokescreen: Smokescreen;
    private _shownPanel: IUIPanel | null = null;
    private _lastTabId: string;
    private _sidebarTabs = new Map<string, HTMLElement>();
    private _panels = new Map<string, IUIPanel & TabPanel>();
    private _sidebarTimer: Timer | null = null;
    private _isShowing: boolean = false;
    private _isHiding: boolean = false;
    private _isShown: boolean = false;
    private _isTransparent: boolean = false;
    private _sidepanelwidth: number = DEF.sidepanelWidth;
    private _iframeSelectionRange: RangeX = null;
    private _sidebarTabClickHandlers: StreamSubscription[] = [];

    /**
         * _SidePanel constructor.
         * @param container document.body.
         */
    constructor() {
        const timer = new StepTimer();
        this._createSidebar(timer);
        this._createSidepanel(timer);
        document.getElementById(ID.sidebar)!.replaceWith(this._sidebar);
        document.getElementById(ID.sidepanel)!.replaceWith(this._sidepanel);
        this._lastTabId = ID.sidebarDocument;
        this._smokescreen = new Smokescreen(accessories$, DEF.zindexSidebar - 1);
        this._constraintSidebarWidth();
        const max = bootPreferences$[SessionPreferencesKey.sidepanelWidth] ?? DEF.sidepanelWidth;
        this._sidepanelwidth = this._constraintSidepanelWidth(max);
        this._sidebar.style.transition = `left ${DEFUtil.sidepanelTransition$}ms`;
        this._sidepanel.style.transition = `left ${DEFUtil.sidepanelTransition$}ms`;
        An.setWidthLeft_(this._sidepanel, this._sidepanelwidth, -(this._sidepanelwidth + _DEF.SidepanelPaddingRight * 2));
        this._setupSidebarCollapsedHandlers();
        const dragger = this._createResizer();
        this.sidepanelWidthInit_();
        this.resizeContent_();
        dragger.bind_();
    }

    private _createSidebar(timer: StepTimer) {
        timer.debug_("# Created sidebar");
        const b = DomBuilderEx.offline_(document, "div", { "id": ID.sidebar }).push_();
        this._sidebar = b.cursor_();
        this._sidebarTabs.set(ID.sidebarTemplates, b.peek_().div_(
            ["id", ID.sidebarTemplates],
            ["class", `${CSS.AnSidebarTab} ${CSS.Fa} ${CSS.FaGlobe}`],
            [ATTR.xTooltips, RS.Tooltips_SidebarTemplates],
        ).cursor_());
        this._sidebarTabs.set(ID.sidebarExplore, b.peek_().div_(
            ["id", ID.sidebarExplore],
            ["class", `${CSS.AnSidebarTab} ${CSS.Fa} ${CSS.FaFolderO}`],
            [ATTR.xTooltips, RS.Tooltips_SidebarExplore],
        ).cursor_());
        this._sidebarTabs.set(ID.sidebarDocument, b.peek_().div_(
            ["id", ID.sidebarDocument],
            ["class", `${CSS.AnSidebarTab} ${CSS.Fa} ${CSS.FaFileTextO}`],
            [ATTR.xTooltips, RS.Tooltips_SidebarDocument],
        ).cursor_());
        this._resizeTab = b
            .peek_()
            .div_({
                "id": ID.sidebarResize,
                "style": "visibility: hidden;",
            })
            .hr_()
            .up_()
            .cursor_();
        An.onContextmenuMatching_(this._sidebar, `div[${ATTR.xTooltips}]`, toasters$.onTooltipsKey_);
        timer.debug_("# Created sidebar");
    }

    private _createSidepanel(timer: StepTimer): void {
        const b = DomBuilderEx.offline_(document, "div", { "id": ID.sidepanel }).push_();
        this._sidepanel = b.cursor_();
        this._panels.set(ID.sidebarTemplates, new _TemplatesPanel(b.peek_().div_({
            "class": `${CSS.AnSidepanel} ${CSS.AnSidepanelTemplates}`,
            "style": "visibility: hidden;"
        }).cursor_()));
        timer.debug_("# Created templates panel");
        this._panels.set(ID.sidebarExplore, new _ExplorePanel(b.peek_().div_({
            "class": `${CSS.AnSidepanel} ${CSS.AnSidepanelExplore}`,
            "style": "visibility: hidden;"
        }).cursor_()));
        timer.debug_("# Created explore panel");
        this._panels.set(ID.sidebarDocument, new _DocumentPanel(b.peek_().div_({
            "class": `${CSS.AnSidepanel} ${CSS.AnSidepanelDocument}`,
            "style": "visibility: hidden;"
        }).cursor_()));
        timer.debug_("# Created sidepanel");
    }

    get sidepanelWidth$(): Int {
        return this._sidepanelwidth;
    }

    get sidepanel$(): HTMLElement {
        return this._sidepanel;
    }

    get sidebar$(): HTMLElement {
        return this._sidebar;
    }

    get resizebar$(): HTMLElement {
        return this._resizeTab;
    }

    get activePanel$(): IUIPanel | null {
        return this._shownPanel;
    }

    get lastTabId$(): string {
        return this._lastTabId;
    }

    get sidebarTabs$() {
        return this._sidebarTabs.entries();
    }

    getPanel_(id: string) {
        return this._panels.get(id);
    }

    resizeContent_(): void {
        const height = window.innerHeight;
        
        this._sidepanel.style.height = `${height}px`;
        if (this._shownPanel != null) {
            this._shownPanel.resizeContent_(height);
        }
        for (const panel of this._panels.values()) {
            if (panel !== this._shownPanel) {
                panel.resizeContent_(height);
            }
        }
    }

    onIFrameLoad_(): void {
        if (this._isShown && (this._shownPanel instanceof DocumentPanelBase)) {
            this._shownPanel.refresh();
        }
    }

    /**
         * @param tabid The tabid for the panel.
         */
    showPanel_(tabid: string): void {
        const panel = this._panels.get(tabid);
        if (panel === undefined) { return; }
        if (this._shownPanel != null && this._shownPanel !== panel) {
            this._shownPanel.hide_();
        }
        this._shownPanel = panel;
        this._lastTabId = tabid;
        panel.show_();
    }

    toggleShowBackground_(): void {
        const opacity = (this._isTransparent ? DEF.opacityOpaque : DEF.opacityShowBackground).toString();
        sidePanel$
            .sidebar$
            .style
            .opacity = opacity;
        sidePanel$
            .sidepanel$
            .style
            .opacity = opacity;
        this._isTransparent = !this._isTransparent;
    }

    sidepanelWidthInit_(): void {
        host$.sidepanelChanged_(smap1_("sidebarHeight", cache$.ui$.sidebarHeight_()));
    }

    /// Setup event handlers for the sidebar that is in collapsed state.
    private _setupSidebarCollapsedHandlers(): void {
        
        An.cancelSubscriptions_(this._sidebarTabClickHandlers);
        if (!Conf.useTouch$) {
            for (const tab of this._sidebarTabs.values()) {
                this._sidebarTabClickHandlers.push(An.subscriptEvent_(tab, "click", e => {
                    An.stopevent_(e);
                    this.showSidepanel_((e.target as HTMLElement).id, false);
                }));
            }
        }
    }

    /// Setup event handlers for the sidebar that is in expanded state.
    private _setupSidebarExpandedHandlers(): void {
        
        An.cancelSubscriptions_(this._sidebarTabClickHandlers);
        for (const tab of this._sidebarTabs.values()) {
            this._sidebarTabClickHandlers.push(An.subscriptEvent_(tab, "click", e => {
                An.stopevent_(e);
                this._deselectAllTabs();
                this.selectTab_(tab);
                this.showPanel_(tab.id);
            }));
        }
    }

    public sidebarAnimate(x: number): void {
        this._sidebarTransform(x);
    }

    private _sidebarTransform(x: number): void {
        return An.setTransform_(this._sidebar, `translateX(${x}px) rotate(90deg)`);
    }

    private _sidepanelAnimate(x: number, callback: Fun00): void {
        if (An.documentOffset_(this._sidepanel).x != x) {
            const listener = An.subscriptEvent_(this._sidepanel, "transitionend", () => {
                listener.cancel_();
                callback();
            });
            this._sidepanel.style.left = `${x}px`;
        } else {
            if (callback != null) {
                callback();
            }
        }
    }

    deselectTab_(tab: HTMLElement): void {
        tab.style.marginTop = "0px";
    }

    selectTab_(tab: HTMLElement): void {
        this._deselectAllTabs();
        tab.style.marginTop = `${-_DEF.SidebarActive}px`;
    }

    private _deselectAllTabs(): void {
        for (const tab of this._sidebarTabs.values()) {
            this.deselectTab_(tab);
        }
    }

    /**
         * Resize sidepanel for device orientation or size changes.
         */
    onWindowSizeChanged_(): void {
        this.hideSidepanel_();
        this._constraintSidebarWidth();
        this._deselectAllTabs();
        const width = this._constraintSidepanelWidth(this._sidepanelwidth);
        if (width != this._sidepanelwidth) {
            this._sidepanel.style.width = `${width}px`;
            this._sidepanelwidth = width;
            An.setWidthLeft_(this._sidepanel, this._sidepanelwidth, -(this._sidepanelwidth + _DEF.SidepanelPaddingRight * 2));
            this._sidebarTransform(_DEF.SidebarTop);
        }
        for (const panel of this._panels.values()) {
            panel.onWindowSizeChanged_();
        }
        this.resizeContent_();
    }

    private _constraintSidebarWidth(): void {
        const winheight = window.innerHeight;
        const min = (winheight > 800) ? (winheight / 2) : ((winheight * 2) / 3);
        
        this._sidebar.style.width = `${min}px`;
    }

    private _constraintSidepanelWidth(width: number): number {
        const min = DEFUtil.sidepanelWidth_(cache$.ui$.buttonSize_());
        const winwidth = window.innerWidth;
        const max = winwidth - cache$.ui$.sidebarHeight_() * 2;
        if (width < min) {
            width = min;
        }
        if (width > max) {
            width = max;
        }
        
        return width;
    }

    /**
         * Reside sidepanel for resizer bar, to the given width.
         */
    resize_(width: number): void {
        
        width = this._constraintSidepanelWidth(width);
        this._resize1(width);
    }

    private _resize1(width: number): void {
        this._sidepanel.style.width = `${width}px`;
        this._sidepanelwidth = width;
        this._sidebarTransform(this._sidepanelwidth + cache$.ui$.sidebarHeight_() /* + _DEF.SidebarTop - 1 */);
        this.resizeContent_();
    }

    selectSidebarTab_(tabid: string): void {
        const tab = this._sidebarTabs.get(tabid);
        if (tab == null) { return; }
        this._deselectAllTabs();
        this.selectTab_(tab);
        Timer.sleep1_(() => {
            this.showPanel_(tabid);
        });
    }

    showSidepanel_(tabid: string, _forcehidekeyboard: boolean, callback: Fun00X = null): void {
        if (this._isShown || this._isShowing) { return; }
        this._isShowing = true;
        native$.blurIFrame_();
        this._iframeSelectionRange = native$.getIFrameSelectionRange_();
        host$.hideCaret_(tabid, () => {
            this.showSidepanelCallback_(tabid, () => {
                host$.hideKeyboard0_();
                if (this._iframeSelectionRange != null) {
                    native$.iSelectRange_(this._iframeSelectionRange);
                    this._iframeSelectionRange = null;
                }
                native$.blurIFrame_();
                callback?.();
            });
        });
    }

    showSidepanelCallback_(tabid: string, callback: Fun00X = null): void {
        
        if (tabid == null) {
            callback?.();
            return;
        }
        const tab = this._sidebarTabs.get(tabid);
        if (tab === undefined) { return; }
        An.showVisible_(this._sidepanel);
        this.selectTab_(tab);
        const onsidebarcomplete = () => {
            this._setupSidebarExpandedHandlers();
            this.showPanel_(tabid);
            this.selectTab_(tab);
            An.setVisible_(this._resizeTab);
            this._smokescreen.show_((sm) => {
                this._sidepanel.style.borderRight = "1px solid #888";
                const elm = sm.element_()!;
                _Util.createContentScroller_(elm, () => {
                    this.hideSidepanel_();
                    native$.focusIFrame_();
                });
                this._isShown = true;
                this._isShowing = false;
                callback?.();
            });
        };
        const left = this._sidepanelwidth + cache$.ui$.sidebarHeight_() /* + _DEF.SidebarTop - 1 */;
        this._sidepanelAnimate(0, () => {
            this.sidebarAnimate(left);
            onsidebarcomplete();
        });
    }

    showEventsPanel_(callback: Fun10X<_EventsPanel | null> = null) {
        this.showSidepanel_(ID.sidebarExplore, true, () => {
            const panel = sidePanel$.activePanel$ as _ExplorePanel;
            callback?.((panel?.selectTabAt(2) ?? null) as _EventsPanel);
        });
    }

    showFilesPanel_(callback: Fun10X<_FilesPanel | null> = null) {
        this.showSidepanel_(ID.sidebarExplore, true, () => {
            const panel = sidePanel$.activePanel$ as _ExplorePanel;
            callback?.((panel?.selectTabAt(0) ?? null) as _FilesPanel);
        });
    }

    hideSidepanel_(sidebartop: Int = _DEF.SidebarTop, done: Fun00X = null): void {
        if (!this._isShown || this._isHiding) {
            return;
        }
        this._isHiding = true;
        if (this._shownPanel != null) {
            this._shownPanel.hideContextmenu_();
        }
        this.hideSidepanel1_(sidebartop, done);
    }

    hideSidepanel1_(sidebartop: number, done: Fun00X) {
        toasters$.hideModal_();
        const onsidepanelcomplete = () => {
            
            if (this._shownPanel != null) {
                this._shownPanel.hide_();
                this._shownPanel = null;
            }
            const opaque = DEF.opacityOpaque.toString();
            this._sidepanel.style.opacity = opaque;
            this._sidebar.style.opacity = opaque;
            this._isTransparent = false;
            this._setupSidebarCollapsedHandlers();
            this._isHiding = false;
            this._isShown = false;
            done?.();
        };
        this._smokescreen.hide_();
        this._deselectAllTabs();
        An.setHidden_(this._resizeTab);
        if (this._sidebarTimer != null) {
            this._sidebarTimer.cancel_();
            this._sidebarTimer = null;
        }
        this._sidepanel.style.borderRight = "";
        this._deselectAllTabs();
        this.sidebarAnimate(sidebartop);
        this._sidepanelAnimate(-this._sidepanelwidth, () => {
            onsidepanelcomplete();
        });
    }

    isShown_(): boolean {
        return this._isShown;
    }

    private _createResizer(): Dragger {
        return new Dragger(this._resizeTab, new _SidepanelResizeHandler())
            .rateLimit_(new FrameLimiter(2));
    }

    static _handleGesture = (event: string, data: JSONObject): boolean => {
        Timer.sleep1_(() => {
            const y = data[GestureKey.y];
            if (GestureEvent.leftInward == event && sidePanel$ != null && !sidePanel$.isShown_()) {
                const sms = Smokescreen.liveCount();
                if (sms > 0) {
                    
                    return;
                }
                let tab: stringX = null;
                if (y > cache$.ui$.documentBottom_()) {
                    if (mainPanel$.isEditing()) {
                        sidePanel$.showSidepanel_(ID.sidebarDocument, true, () => {
                            const panel = sidePanel$.activePanel$ as _DocumentPanel;
                            if (panel == null) return;
                            panel.selectTabAt(0);
                        });
                    } else {
                        sidePanel$.showSidepanel_(ID.sidebarExplore, true, () => {
                            const panel = sidePanel$.activePanel$ as _ExplorePanel;
                            if (panel == null) return;
                            panel.selectTabAt(0);
                        });
                    }
                    return;
                }
                if (y > cache$.ui$.exploreBottom_()) {
                    tab = ID.sidebarDocument;
                } else if (y > cache$.ui$.templatesBottom_()) {
                    tab = ID.sidebarExplore;
                } else if (y > 0) {
                    tab = ID.sidebarTemplates;
                }
                if (tab != null) {
                    
                    sidePanel$.showSidepanel_(tab, true);
                }
            }
        });
        return true;
    };
}

class _SidepanelResizeHandler implements IDraggerHandler {
    private static _sidepanelWidthUpdater = new RateLimiter(1000);
    private _x: number = 0;

    onDragstart_(_dragger: Dragger, _target: EventTarget, _x: number, _y: number): boolean {
        this._x = sidePanel$.sidepanelWidth$ ?? 0;
        return true;
    }

    onDragmove_(dragger: Dragger): void {
        sidePanel$.resize_(this._x + dragger
            .state_()
            .cx);
    }

    onDragend_(_dragger: Dragger, _e: UIEvent): void {
        
        _SidepanelResizeHandler._sidepanelWidthUpdater.queue_(() => {
            host$.updateSessionPreferences_(json1_(SessionPreferencesKey.sidepanelWidth, sidePanel$.sidepanelWidth$), An.noop_);
        }, DateTime.ms_());
    }
}

const sidePanel$ = new _SidePanel();

////////////////////////////////////////////////////////////////////////

abstract class XX {
    static readonly xxAudio = "xx-audio";
    static readonly xxAudios = "xx-audios";
    static readonly xxBackground = "xx-background";
    static readonly xxBelow = "xx-below";
    static readonly xxAbove = "xx-above";
    static readonly xxBlog = "xx-blog";
    static readonly xxBlue = "xx-blue";
    static readonly xxBody = "xx-body";
    static readonly xxBullet = "xx-bullet";
    static readonly xxCalendar = "xx-calendar";
    static readonly xxCanvas = "xx-canvas";
    static readonly xxCaption = "xx-caption";
    static readonly xxCaptionContent = "xx-caption-content";
    static readonly xxCard = "xx-card";
    static readonly xxCards = "xx-cards";
    static readonly xxCenter = "xx-center";
    static readonly xxColumn = "xx-column";
    static readonly xxColumns = "xx-columns";
    static readonly xxComment = "xx-comment";
    static readonly xxContent = "xx-content";
    static readonly xxDate = "xx-date";
    static readonly xxDatetime = "xx-datetime";
    static readonly xxDesc = "xx-desc";
    static readonly xxDetails = "xx-details";
    static readonly xxDone = "xx-done";
    static readonly xxDrawing = "xx-drawing";
    static readonly xxFooter = "xx-footer";
    static readonly xxGreen = "xx-green";
    static readonly xxHead = "xx-head";
    static readonly xxHeader = "xx-header";
    static readonly xxHide = "xx-hide";
    static readonly xxHigh = "xx-high";
    static readonly xxHigher = "xx-higher";
    static readonly xxHighest = "xx-highest";
    static readonly xxHighlight = "xx-highlight";
    static readonly xxItem = "xx-item";
    static readonly xxItems = "xx-items";
    static readonly xxLeft = "xx-left";
    static readonly xxLink = "xx-link";
    static readonly xxLow = "xx-low";
    static readonly xxMedia = "xx-media";
    static readonly xxMedias = "xx-medias";
    static readonly xxName = "xx-name";
    static readonly xxNote = "xx-note";
    static readonly xxPhoto = "xx-photo";
    static readonly xxPhotos = "xx-photos";
    static readonly xxPrice = "xx-price";
    static readonly xxQuantity = "xx-quantity";
    static readonly xxRed = "xx-red";
    static readonly xxRight = "xx-right";
    static readonly xxSection = "xx-section";
    static readonly xxSections = "xx-sections";
    static readonly xxStatus = "xx-status";
    static readonly xxSticker = "xx-sticker";
    static readonly xxStyle = "xx-style";
    static readonly xxStyle00 = "xx-style00";
    static readonly xxStyle01 = "xx-style01";
    static readonly xxStyle02 = "xx-style02";
    static readonly xxStyle03 = "xx-style03";
    static readonly xxStyle04 = "xx-style04";
    static readonly xxStyle05 = "xx-style05";
    static readonly xxStyle06 = "xx-style06";
    static readonly xxStyle07 = "xx-style07";
    static readonly xxStyle08 = "xx-style08";
    static readonly xxStyle09 = "xx-style09";
    static readonly xxStyle10 = "xx-style10";
    static readonly xxStyle11 = "xx-style11";
    static readonly xxStyle12 = "xx-style12";
    static readonly xxStyle13 = "xx-style13";
    static readonly xxStyle14 = "xx-style14";
    static readonly xxStyle15 = "xx-style15";
    static readonly xxStyle16 = "xx-style16";
    static readonly xxStyle17 = "xx-style17";
    static readonly xxStyle18 = "xx-style18";
    static readonly xxStyle19 = "xx-style19";
    static readonly xxStyle20 = "xx-style20";
    static readonly xxStyle21 = "xx-style21";
    static readonly xxStyle22 = "xx-style22";
    static readonly xxStyle23 = "xx-style23";
    static readonly xxStyle24 = "xx-style24";
    static readonly xxStyle25 = "xx-style25";
    static readonly xxStyle26 = "xx-style26";
    static readonly xxStyle27 = "xx-style27";
    static readonly xxStyle28 = "xx-style28";
    static readonly xxStyle29 = "xx-style29";
    static readonly xxSubject = "xx-subject";
    static readonly xxSubheader = "xx-subheader";
    static readonly xxSubtitle = "xx-subtitle";
    static readonly xxSubtotal = "xx-subtotal";
    static readonly xxTime = "xx-time";
    static readonly xxTitle = "xx-title";
    static readonly xxTocs = "xx-tocs";
    static readonly xxToc0 = "xx-toc0";
    static readonly xxToc1 = "xx-toc1";
    static readonly xxToc2 = "xx-toc2";
    static readonly xxToc3 = "xx-toc3";
    static readonly xxToc4 = "xx-toc4";
    static readonly xxTodo = "xx-todo";
    static readonly xxTodos = "xx-todos";
    static readonly xxTop = "xx-top";
    static readonly xxTotal = "xx-total";
    static readonly xxVerticalToolbar = "xx-vertical-toolbar";
    static readonly xxVideo = "xx-video";
    static readonly xxWelcome = "xx-welcome";
    static readonly xxWhite = "xx-white";
}

//////////////////////////////////////////////////////////////////////
